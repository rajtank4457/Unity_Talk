"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/livekit-client";
exports.ids = ["vendor-chunks/livekit-client"];
exports.modules = {

/***/ "(ssr)/./node_modules/livekit-client/dist/livekit-client.esm.mjs":
/*!*****************************************************************!*\
  !*** ./node_modules/livekit-client/dist/livekit-client.esm.mjs ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AudioPresets: () => (/* binding */ AudioPresets),\n/* harmony export */   BaseKeyProvider: () => (/* binding */ BaseKeyProvider),\n/* harmony export */   ConnectionCheck: () => (/* binding */ ConnectionCheck),\n/* harmony export */   ConnectionError: () => (/* binding */ ConnectionError),\n/* harmony export */   ConnectionQuality: () => (/* binding */ ConnectionQuality),\n/* harmony export */   ConnectionState: () => (/* binding */ ConnectionState),\n/* harmony export */   CriticalTimers: () => (/* binding */ CriticalTimers),\n/* harmony export */   CryptorEvent: () => (/* binding */ CryptorEvent),\n/* harmony export */   DataPacket_Kind: () => (/* binding */ DataPacket_Kind),\n/* harmony export */   DefaultReconnectPolicy: () => (/* binding */ DefaultReconnectPolicy),\n/* harmony export */   DeviceUnsupportedError: () => (/* binding */ DeviceUnsupportedError),\n/* harmony export */   DisconnectReason: () => (/* binding */ DisconnectReason),\n/* harmony export */   EncryptionEvent: () => (/* binding */ EncryptionEvent),\n/* harmony export */   EngineEvent: () => (/* binding */ EngineEvent),\n/* harmony export */   ExternalE2EEKeyProvider: () => (/* binding */ ExternalE2EEKeyProvider),\n/* harmony export */   KeyHandlerEvent: () => (/* binding */ KeyHandlerEvent),\n/* harmony export */   KeyProviderEvent: () => (/* binding */ KeyProviderEvent),\n/* harmony export */   LivekitError: () => (/* binding */ LivekitError),\n/* harmony export */   LocalAudioTrack: () => (/* binding */ LocalAudioTrack),\n/* harmony export */   LocalParticipant: () => (/* binding */ LocalParticipant),\n/* harmony export */   LocalTrack: () => (/* binding */ LocalTrack),\n/* harmony export */   LocalTrackPublication: () => (/* binding */ LocalTrackPublication),\n/* harmony export */   LocalVideoTrack: () => (/* binding */ LocalVideoTrack),\n/* harmony export */   LogLevel: () => (/* binding */ LogLevel),\n/* harmony export */   MediaDeviceFailure: () => (/* binding */ MediaDeviceFailure),\n/* harmony export */   NegotiationError: () => (/* binding */ NegotiationError),\n/* harmony export */   Participant: () => (/* binding */ Participant),\n/* harmony export */   ParticipantEvent: () => (/* binding */ ParticipantEvent),\n/* harmony export */   PublishDataError: () => (/* binding */ PublishDataError),\n/* harmony export */   RemoteAudioTrack: () => (/* binding */ RemoteAudioTrack),\n/* harmony export */   RemoteParticipant: () => (/* binding */ RemoteParticipant),\n/* harmony export */   RemoteTrack: () => (/* binding */ RemoteTrack),\n/* harmony export */   RemoteTrackPublication: () => (/* binding */ RemoteTrackPublication),\n/* harmony export */   RemoteVideoTrack: () => (/* binding */ RemoteVideoTrack),\n/* harmony export */   Room: () => (/* binding */ Room),\n/* harmony export */   RoomEvent: () => (/* binding */ RoomEvent),\n/* harmony export */   RoomState: () => (/* binding */ RoomState),\n/* harmony export */   ScreenSharePresets: () => (/* binding */ ScreenSharePresets),\n/* harmony export */   Track: () => (/* binding */ Track),\n/* harmony export */   TrackEvent: () => (/* binding */ TrackEvent),\n/* harmony export */   TrackInvalidError: () => (/* binding */ TrackInvalidError),\n/* harmony export */   TrackPublication: () => (/* binding */ TrackPublication),\n/* harmony export */   UnexpectedConnectionState: () => (/* binding */ UnexpectedConnectionState),\n/* harmony export */   UnsupportedServer: () => (/* binding */ UnsupportedServer),\n/* harmony export */   VideoPreset: () => (/* binding */ VideoPreset),\n/* harmony export */   VideoPresets: () => (/* binding */ VideoPresets),\n/* harmony export */   VideoPresets43: () => (/* binding */ VideoPresets43),\n/* harmony export */   VideoQuality: () => (/* binding */ VideoQuality),\n/* harmony export */   attachToElement: () => (/* binding */ attachToElement),\n/* harmony export */   createAudioAnalyser: () => (/* binding */ createAudioAnalyser),\n/* harmony export */   createE2EEKey: () => (/* binding */ createE2EEKey),\n/* harmony export */   createKeyMaterialFromBuffer: () => (/* binding */ createKeyMaterialFromBuffer),\n/* harmony export */   createKeyMaterialFromString: () => (/* binding */ createKeyMaterialFromString),\n/* harmony export */   createLocalAudioTrack: () => (/* binding */ createLocalAudioTrack),\n/* harmony export */   createLocalScreenTracks: () => (/* binding */ createLocalScreenTracks),\n/* harmony export */   createLocalTracks: () => (/* binding */ createLocalTracks),\n/* harmony export */   createLocalVideoTrack: () => (/* binding */ createLocalVideoTrack),\n/* harmony export */   deriveKeys: () => (/* binding */ deriveKeys),\n/* harmony export */   detachTrack: () => (/* binding */ detachTrack),\n/* harmony export */   facingModeFromDeviceLabel: () => (/* binding */ facingModeFromDeviceLabel),\n/* harmony export */   facingModeFromLocalTrack: () => (/* binding */ facingModeFromLocalTrack),\n/* harmony export */   getEmptyAudioStreamTrack: () => (/* binding */ getEmptyAudioStreamTrack),\n/* harmony export */   getEmptyVideoStreamTrack: () => (/* binding */ getEmptyVideoStreamTrack),\n/* harmony export */   getLogger: () => (/* binding */ getLogger),\n/* harmony export */   importKey: () => (/* binding */ importKey),\n/* harmony export */   isBackupCodec: () => (/* binding */ isBackupCodec),\n/* harmony export */   isBrowserSupported: () => (/* binding */ isBrowserSupported),\n/* harmony export */   isE2EESupported: () => (/* binding */ isE2EESupported),\n/* harmony export */   isInsertableStreamSupported: () => (/* binding */ isInsertableStreamSupported),\n/* harmony export */   isScriptTransformSupported: () => (/* binding */ isScriptTransformSupported),\n/* harmony export */   isVideoFrame: () => (/* binding */ isVideoFrame),\n/* harmony export */   needsRbspUnescaping: () => (/* binding */ needsRbspUnescaping),\n/* harmony export */   parseRbsp: () => (/* binding */ parseRbsp),\n/* harmony export */   protocolVersion: () => (/* binding */ protocolVersion),\n/* harmony export */   ratchet: () => (/* binding */ ratchet),\n/* harmony export */   setLogExtension: () => (/* binding */ setLogExtension),\n/* harmony export */   setLogLevel: () => (/* binding */ setLogLevel),\n/* harmony export */   supportsAV1: () => (/* binding */ supportsAV1),\n/* harmony export */   supportsAdaptiveStream: () => (/* binding */ supportsAdaptiveStream),\n/* harmony export */   supportsDynacast: () => (/* binding */ supportsDynacast),\n/* harmony export */   supportsVP9: () => (/* binding */ supportsVP9),\n/* harmony export */   version: () => (/* binding */ version),\n/* harmony export */   videoCodecs: () => (/* binding */ videoCodecs),\n/* harmony export */   writeRbsp: () => (/* binding */ writeRbsp)\n/* harmony export */ });\nfunction _mergeNamespaces(n, m) {\n    m.forEach(function(e) {\n        e && typeof e !== 'string' && !Array.isArray(e) && Object.keys(e).forEach(function(k) {\n            if (k !== 'default' && !(k in n)) {\n                var d = Object.getOwnPropertyDescriptor(e, k);\n                Object.defineProperty(n, k, d.get ? d : {\n                    enumerable: true,\n                    get: function() {\n                        return e[k];\n                    }\n                });\n            }\n        });\n    });\n    return Object.freeze(n);\n}\nvar commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis :  false ? 0 : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\nfunction getDefaultExportFromCjs(x) {\n    return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;\n}\nvar loglevel = {\n    exports: {}\n};\n/*\n* loglevel - https://github.com/pimterry/loglevel\n*\n* Copyright (c) 2013 Tim Perry\n* Licensed under the MIT license.\n*/ (function(module) {\n    (function(root, definition) {\n        if (module.exports) {\n            module.exports = definition();\n        } else {\n            root.log = definition();\n        }\n    })(commonjsGlobal, function() {\n        // Slightly dubious tricks to cut down minimized file size\n        var noop = function() {};\n        var undefinedType = \"undefined\";\n        var isIE = \"undefined\" !== undefinedType && typeof window.navigator !== undefinedType && /Trident\\/|MSIE /.test(window.navigator.userAgent);\n        var logMethods = [\n            \"trace\",\n            \"debug\",\n            \"info\",\n            \"warn\",\n            \"error\"\n        ];\n        // Cross-browser bind equivalent that works at least back to IE6\n        function bindMethod(obj, methodName) {\n            var method = obj[methodName];\n            if (typeof method.bind === 'function') {\n                return method.bind(obj);\n            } else {\n                try {\n                    return Function.prototype.bind.call(method, obj);\n                } catch (e) {\n                    // Missing bind shim or IE8 + Modernizr, fallback to wrapping\n                    return function() {\n                        return Function.prototype.apply.apply(method, [\n                            obj,\n                            arguments\n                        ]);\n                    };\n                }\n            }\n        }\n        // Trace() doesn't print the message in IE, so for that case we need to wrap it\n        function traceForIE() {\n            if (console.log) {\n                if (console.log.apply) {\n                    console.log.apply(console, arguments);\n                } else {\n                    // In old IE, native console methods themselves don't have apply().\n                    Function.prototype.apply.apply(console.log, [\n                        console,\n                        arguments\n                    ]);\n                }\n            }\n            if (console.trace) console.trace();\n        }\n        // Build the best logging method possible for this env\n        // Wherever possible we want to bind, not wrap, to preserve stack traces\n        function realMethod(methodName) {\n            if (methodName === 'debug') {\n                methodName = 'log';\n            }\n            if (typeof console === undefinedType) {\n                return false; // No method possible, for now - fixed later by enableLoggingWhenConsoleArrives\n            } else if (methodName === 'trace' && isIE) {\n                return traceForIE;\n            } else if (console[methodName] !== undefined) {\n                return bindMethod(console, methodName);\n            } else if (console.log !== undefined) {\n                return bindMethod(console, 'log');\n            } else {\n                return noop;\n            }\n        }\n        // These private functions always need `this` to be set properly\n        function replaceLoggingMethods(level, loggerName) {\n            /*jshint validthis:true */ for(var i = 0; i < logMethods.length; i++){\n                var methodName = logMethods[i];\n                this[methodName] = i < level ? noop : this.methodFactory(methodName, level, loggerName);\n            }\n            // Define log.log as an alias for log.debug\n            this.log = this.debug;\n        }\n        // In old IE versions, the console isn't present until you first open it.\n        // We build realMethod() replacements here that regenerate logging methods\n        function enableLoggingWhenConsoleArrives(methodName, level, loggerName) {\n            return function() {\n                if (typeof console !== undefinedType) {\n                    replaceLoggingMethods.call(this, level, loggerName);\n                    this[methodName].apply(this, arguments);\n                }\n            };\n        }\n        // By default, we use closely bound real methods wherever possible, and\n        // otherwise we wait for a console to appear, and then try again.\n        function defaultMethodFactory(methodName, level, loggerName) {\n            /*jshint validthis:true */ return realMethod(methodName) || enableLoggingWhenConsoleArrives.apply(this, arguments);\n        }\n        function Logger(name, defaultLevel, factory) {\n            var self1 = this;\n            var currentLevel;\n            defaultLevel = defaultLevel == null ? \"WARN\" : defaultLevel;\n            var storageKey = \"loglevel\";\n            if (typeof name === \"string\") {\n                storageKey += \":\" + name;\n            } else if (typeof name === \"symbol\") {\n                storageKey = undefined;\n            }\n            function persistLevelIfPossible(levelNum) {\n                var levelName = (logMethods[levelNum] || 'silent').toUpperCase();\n                if (\"undefined\" === undefinedType || !storageKey) return;\n                // Use localStorage if available\n                try {\n                    window.localStorage[storageKey] = levelName;\n                    return;\n                } catch (ignore) {}\n                // Use session cookie as fallback\n                try {\n                    window.document.cookie = encodeURIComponent(storageKey) + \"=\" + levelName + \";\";\n                } catch (ignore) {}\n            }\n            function getPersistedLevel() {\n                var storedLevel;\n                if (\"undefined\" === undefinedType || !storageKey) return;\n                try {\n                    storedLevel = window.localStorage[storageKey];\n                } catch (ignore) {}\n                // Fallback to cookies if local storage gives us nothing\n                if (typeof storedLevel === undefinedType) {\n                    try {\n                        var cookie = window.document.cookie;\n                        var location = cookie.indexOf(encodeURIComponent(storageKey) + \"=\");\n                        if (location !== -1) {\n                            storedLevel = /^([^;]+)/.exec(cookie.slice(location))[1];\n                        }\n                    } catch (ignore) {}\n                }\n                // If the stored level is not valid, treat it as if nothing was stored.\n                if (self1.levels[storedLevel] === undefined) {\n                    storedLevel = undefined;\n                }\n                return storedLevel;\n            }\n            function clearPersistedLevel() {\n                if (\"undefined\" === undefinedType || !storageKey) return;\n                // Use localStorage if available\n                try {\n                    window.localStorage.removeItem(storageKey);\n                    return;\n                } catch (ignore) {}\n                // Use session cookie as fallback\n                try {\n                    window.document.cookie = encodeURIComponent(storageKey) + \"=; expires=Thu, 01 Jan 1970 00:00:00 UTC\";\n                } catch (ignore) {}\n            }\n            /*\n       *\n       * Public logger API - see https://github.com/pimterry/loglevel for details\n       *\n       */ self1.name = name;\n            self1.levels = {\n                \"TRACE\": 0,\n                \"DEBUG\": 1,\n                \"INFO\": 2,\n                \"WARN\": 3,\n                \"ERROR\": 4,\n                \"SILENT\": 5\n            };\n            self1.methodFactory = factory || defaultMethodFactory;\n            self1.getLevel = function() {\n                return currentLevel;\n            };\n            self1.setLevel = function(level, persist) {\n                if (typeof level === \"string\" && self1.levels[level.toUpperCase()] !== undefined) {\n                    level = self1.levels[level.toUpperCase()];\n                }\n                if (typeof level === \"number\" && level >= 0 && level <= self1.levels.SILENT) {\n                    currentLevel = level;\n                    if (persist !== false) {\n                        // defaults to true\n                        persistLevelIfPossible(level);\n                    }\n                    replaceLoggingMethods.call(self1, level, name);\n                    if (typeof console === undefinedType && level < self1.levels.SILENT) {\n                        return \"No console available for logging\";\n                    }\n                } else {\n                    throw \"log.setLevel() called with invalid level: \" + level;\n                }\n            };\n            self1.setDefaultLevel = function(level) {\n                defaultLevel = level;\n                if (!getPersistedLevel()) {\n                    self1.setLevel(level, false);\n                }\n            };\n            self1.resetLevel = function() {\n                self1.setLevel(defaultLevel, false);\n                clearPersistedLevel();\n            };\n            self1.enableAll = function(persist) {\n                self1.setLevel(self1.levels.TRACE, persist);\n            };\n            self1.disableAll = function(persist) {\n                self1.setLevel(self1.levels.SILENT, persist);\n            };\n            // Initialize with the right level\n            var initialLevel = getPersistedLevel();\n            if (initialLevel == null) {\n                initialLevel = defaultLevel;\n            }\n            self1.setLevel(initialLevel, false);\n        }\n        /*\n     *\n     * Top-level API\n     *\n     */ var defaultLogger = new Logger();\n        var _loggersByName = {};\n        defaultLogger.getLogger = function getLogger(name) {\n            if (typeof name !== \"symbol\" && typeof name !== \"string\" || name === \"\") {\n                throw new TypeError(\"You must supply a name when creating a logger.\");\n            }\n            var logger = _loggersByName[name];\n            if (!logger) {\n                logger = _loggersByName[name] = new Logger(name, defaultLogger.getLevel(), defaultLogger.methodFactory);\n            }\n            return logger;\n        };\n        // Grab the current global log variable in case of overwrite\n        var _log = \"undefined\" !== undefinedType ? window.log : undefined;\n        defaultLogger.noConflict = function() {\n            if (\"undefined\" !== undefinedType && window.log === defaultLogger) {\n                window.log = _log;\n            }\n            return defaultLogger;\n        };\n        defaultLogger.getLoggers = function getLoggers() {\n            return _loggersByName;\n        };\n        // ES6 default export, for compatibility\n        defaultLogger['default'] = defaultLogger;\n        return defaultLogger;\n    });\n})(loglevel);\nvar loglevelExports = loglevel.exports;\nvar LogLevel;\n(function(LogLevel) {\n    LogLevel[LogLevel[\"trace\"] = 0] = \"trace\";\n    LogLevel[LogLevel[\"debug\"] = 1] = \"debug\";\n    LogLevel[LogLevel[\"info\"] = 2] = \"info\";\n    LogLevel[LogLevel[\"warn\"] = 3] = \"warn\";\n    LogLevel[LogLevel[\"error\"] = 4] = \"error\";\n    LogLevel[LogLevel[\"silent\"] = 5] = \"silent\";\n})(LogLevel || (LogLevel = {}));\nvar LoggerNames;\n(function(LoggerNames) {\n    LoggerNames[\"Default\"] = \"livekit\";\n    LoggerNames[\"Room\"] = \"livekit-room\";\n    LoggerNames[\"Participant\"] = \"livekit-participant\";\n    LoggerNames[\"Track\"] = \"livekit-track\";\n    LoggerNames[\"Publication\"] = \"livekit-track-publication\";\n    LoggerNames[\"Engine\"] = \"livekit-engine\";\n    LoggerNames[\"Signal\"] = \"livekit-signal\";\n    LoggerNames[\"PCManager\"] = \"livekit-pc-manager\";\n    LoggerNames[\"PCTransport\"] = \"livekit-pc-transport\";\n    LoggerNames[\"E2EE\"] = \"lk-e2ee\";\n})(LoggerNames || (LoggerNames = {}));\nlet livekitLogger = loglevelExports.getLogger('livekit');\nlivekitLogger.setDefaultLevel(LogLevel.info);\n/**\n * @internal\n */ function getLogger(name) {\n    const logger = loglevelExports.getLogger(name);\n    logger.setDefaultLevel(livekitLogger.getLevel());\n    return logger;\n}\nfunction setLogLevel(level, loggerName) {\n    if (loggerName) {\n        loglevelExports.getLogger(loggerName).setLevel(level);\n    }\n    for (const logger of Object.entries(loglevelExports.getLoggers()).filter((_ref)=>{\n        let [logrName] = _ref;\n        return logrName.startsWith('livekit');\n    }).map((_ref2)=>{\n        let [, logr] = _ref2;\n        return logr;\n    })){\n        logger.setLevel(level);\n    }\n}\n/**\n * use this to hook into the logging function to allow sending internal livekit logs to third party services\n * if set, the browser logs will lose their stacktrace information (see https://github.com/pimterry/loglevel#writing-plugins)\n */ function setLogExtension(extension) {\n    let logger = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : livekitLogger;\n    const originalFactory = logger.methodFactory;\n    logger.methodFactory = (methodName, configLevel, loggerName)=>{\n        const rawMethod = originalFactory(methodName, configLevel, loggerName);\n        const logLevel = LogLevel[methodName];\n        const needLog = logLevel >= configLevel && logLevel < LogLevel.silent;\n        return (msg, context)=>{\n            if (context) rawMethod(msg, context);\n            else rawMethod(msg);\n            if (needLog) {\n                extension(logLevel, msg, context);\n            }\n        };\n    };\n    logger.setLevel(logger.getLevel()); // Be sure to call setLevel method in order to apply plugin\n}\nloglevelExports.getLogger('lk-e2ee');\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Assert that condition is truthy or throw error (with message)\n */ function assert(condition, msg) {\n    // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions -- we want the implicit conversion to boolean\n    if (!condition) {\n        throw new Error(msg);\n    }\n}\nconst FLOAT32_MAX = 3.4028234663852886e38, FLOAT32_MIN = -3.4028234663852886e38, UINT32_MAX = 0xffffffff, INT32_MAX = 0x7fffffff, INT32_MIN = -0x80000000;\n/**\n * Assert a valid signed protobuf 32-bit integer.\n */ function assertInt32(arg) {\n    if (typeof arg !== \"number\") throw new Error(\"invalid int 32: \" + typeof arg);\n    if (!Number.isInteger(arg) || arg > INT32_MAX || arg < INT32_MIN) throw new Error(\"invalid int 32: \" + arg); // eslint-disable-line @typescript-eslint/restrict-plus-operands -- we want the implicit conversion to string\n}\n/**\n * Assert a valid unsigned protobuf 32-bit integer.\n */ function assertUInt32(arg) {\n    if (typeof arg !== \"number\") throw new Error(\"invalid uint 32: \" + typeof arg);\n    if (!Number.isInteger(arg) || arg > UINT32_MAX || arg < 0) throw new Error(\"invalid uint 32: \" + arg); // eslint-disable-line @typescript-eslint/restrict-plus-operands -- we want the implicit conversion to string\n}\n/**\n * Assert a valid protobuf float value.\n */ function assertFloat32(arg) {\n    if (typeof arg !== \"number\") throw new Error(\"invalid float 32: \" + typeof arg);\n    if (!Number.isFinite(arg)) return;\n    if (arg > FLOAT32_MAX || arg < FLOAT32_MIN) throw new Error(\"invalid float 32: \" + arg); // eslint-disable-line @typescript-eslint/restrict-plus-operands -- we want the implicit conversion to string\n}\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nconst enumTypeSymbol = Symbol(\"@bufbuild/protobuf/enum-type\");\n/**\n * Get reflection information from a generated enum.\n * If this function is called on something other than a generated\n * enum, it raises an error.\n */ function getEnumType(enumObject) {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-explicit-any\n    const t = enumObject[enumTypeSymbol];\n    assert(t, \"missing enum type on enum object\");\n    return t; // eslint-disable-line @typescript-eslint/no-unsafe-return\n}\n/**\n * Sets reflection information on a generated enum.\n */ function setEnumType(enumObject, typeName, values, opt) {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-explicit-any\n    enumObject[enumTypeSymbol] = makeEnumType(typeName, values.map((v)=>({\n            no: v.no,\n            name: v.name,\n            localName: enumObject[v.no]\n        })));\n}\n/**\n * Create a new EnumType with the given values.\n */ function makeEnumType(typeName, values, // eslint-disable-next-line @typescript-eslint/no-unused-vars\n_opt) {\n    const names = Object.create(null);\n    const numbers = Object.create(null);\n    const normalValues = [];\n    for (const value of values){\n        // We do not surface options at this time\n        // const value: EnumValueInfo = {...v, options: v.options ?? emptyReadonlyObject};\n        const n = normalizeEnumValue(value);\n        normalValues.push(n);\n        names[value.name] = n;\n        numbers[value.no] = n;\n    }\n    return {\n        typeName,\n        values: normalValues,\n        // We do not surface options at this time\n        // options: opt?.options ?? Object.create(null),\n        findName (name) {\n            return names[name];\n        },\n        findNumber (no) {\n            return numbers[no];\n        }\n    };\n}\n/**\n * Create a new enum object with the given values.\n * Sets reflection information.\n */ function makeEnum(typeName, values, opt) {\n    const enumObject = {};\n    for (const value of values){\n        const n = normalizeEnumValue(value);\n        enumObject[n.localName] = n.no;\n        enumObject[n.no] = n.localName;\n    }\n    setEnumType(enumObject, typeName, values);\n    return enumObject;\n}\nfunction normalizeEnumValue(value) {\n    if (\"localName\" in value) {\n        return value;\n    }\n    return Object.assign(Object.assign({}, value), {\n        localName: value.name\n    });\n}\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Message is the base class of every message, generated, or created at\n * runtime.\n *\n * It is _not_ safe to extend this class. If you want to create a message at\n * run time, use proto3.makeMessageType().\n */ class Message {\n    /**\n   * Compare with a message of the same type.\n   */ equals(other) {\n        return this.getType().runtime.util.equals(this.getType(), this, other);\n    }\n    /**\n   * Create a deep copy.\n   */ clone() {\n        return this.getType().runtime.util.clone(this);\n    }\n    /**\n   * Parse from binary data, merging fields.\n   *\n   * Repeated fields are appended. Map entries are added, overwriting\n   * existing keys.\n   *\n   * If a message field is already present, it will be merged with the\n   * new data.\n   */ fromBinary(bytes, options) {\n        const type = this.getType(), format = type.runtime.bin, opt = format.makeReadOptions(options);\n        format.readMessage(this, opt.readerFactory(bytes), bytes.byteLength, opt);\n        return this;\n    }\n    /**\n   * Parse a message from a JSON value.\n   */ fromJson(jsonValue, options) {\n        const type = this.getType(), format = type.runtime.json, opt = format.makeReadOptions(options);\n        format.readMessage(type, jsonValue, opt, this);\n        return this;\n    }\n    /**\n   * Parse a message from a JSON string.\n   */ fromJsonString(jsonString, options) {\n        let json;\n        try {\n            json = JSON.parse(jsonString);\n        } catch (e) {\n            throw new Error(\"cannot decode \".concat(this.getType().typeName, \" from JSON: \").concat(e instanceof Error ? e.message : String(e)));\n        }\n        return this.fromJson(json, options);\n    }\n    /**\n   * Serialize the message to binary data.\n   */ toBinary(options) {\n        const type = this.getType(), bin = type.runtime.bin, opt = bin.makeWriteOptions(options), writer = opt.writerFactory();\n        bin.writeMessage(this, writer, opt);\n        return writer.finish();\n    }\n    /**\n   * Serialize the message to a JSON value, a JavaScript value that can be\n   * passed to JSON.stringify().\n   */ toJson(options) {\n        const type = this.getType(), json = type.runtime.json, opt = json.makeWriteOptions(options);\n        return json.writeMessage(this, opt);\n    }\n    /**\n   * Serialize the message to a JSON string.\n   */ toJsonString(options) {\n        var _a;\n        const value = this.toJson(options);\n        return JSON.stringify(value, null, (_a = options === null || options === void 0 ? void 0 : options.prettySpaces) !== null && _a !== void 0 ? _a : 0);\n    }\n    /**\n   * Override for serialization behavior. This will be invoked when calling\n   * JSON.stringify on this message (i.e. JSON.stringify(msg)).\n   *\n   * Note that this will not serialize google.protobuf.Any with a packed\n   * message because the protobuf JSON format specifies that it needs to be\n   * unpacked, and this is only possible with a type registry to look up the\n   * message type.  As a result, attempting to serialize a message with this\n   * type will throw an Error.\n   *\n   * This method is protected because you should not need to invoke it\n   * directly -- instead use JSON.stringify or toJsonString for\n   * stringified JSON.  Alternatively, if actual JSON is desired, you should\n   * use toJson.\n   */ toJSON() {\n        return this.toJson({\n            emitDefaultValues: true\n        });\n    }\n    /**\n   * Retrieve the MessageType of this message - a singleton that represents\n   * the protobuf message declaration and provides metadata for reflection-\n   * based operations.\n   */ getType() {\n        // Any class that extends Message _must_ provide a complete static\n        // implementation of MessageType.\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-return\n        return Object.getPrototypeOf(this).constructor;\n    }\n}\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Create a new message type using the given runtime.\n */ function makeMessageType(runtime, typeName, fields, opt) {\n    var _a;\n    const localName = (_a = opt === null || opt === void 0 ? void 0 : opt.localName) !== null && _a !== void 0 ? _a : typeName.substring(typeName.lastIndexOf(\".\") + 1);\n    const type = {\n        [localName]: function(data) {\n            runtime.util.initFields(this);\n            runtime.util.initPartial(data, this);\n        }\n    }[localName];\n    Object.setPrototypeOf(type.prototype, new Message());\n    Object.assign(type, {\n        runtime,\n        typeName,\n        fields: runtime.util.newFieldList(fields),\n        fromBinary (bytes, options) {\n            return new type().fromBinary(bytes, options);\n        },\n        fromJson (jsonValue, options) {\n            return new type().fromJson(jsonValue, options);\n        },\n        fromJsonString (jsonString, options) {\n            return new type().fromJsonString(jsonString, options);\n        },\n        equals (a, b) {\n            return runtime.util.equals(type, a, b);\n        }\n    });\n    return type;\n}\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nfunction makeProtoRuntime(syntax, json, bin, util) {\n    return {\n        syntax,\n        json,\n        bin,\n        util,\n        makeMessageType (typeName, fields, opt) {\n            return makeMessageType(this, typeName, fields, opt);\n        },\n        makeEnum,\n        makeEnumType,\n        getEnumType\n    };\n}\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Scalar value types. This is a subset of field types declared by protobuf\n * enum google.protobuf.FieldDescriptorProto.Type The types GROUP and MESSAGE\n * are omitted, but the numerical values are identical.\n */ var ScalarType;\n(function(ScalarType) {\n    // 0 is reserved for errors.\n    // Order is weird for historical reasons.\n    ScalarType[ScalarType[\"DOUBLE\"] = 1] = \"DOUBLE\";\n    ScalarType[ScalarType[\"FLOAT\"] = 2] = \"FLOAT\";\n    // Not ZigZag encoded.  Negative numbers take 10 bytes.  Use TYPE_SINT64 if\n    // negative values are likely.\n    ScalarType[ScalarType[\"INT64\"] = 3] = \"INT64\";\n    ScalarType[ScalarType[\"UINT64\"] = 4] = \"UINT64\";\n    // Not ZigZag encoded.  Negative numbers take 10 bytes.  Use TYPE_SINT32 if\n    // negative values are likely.\n    ScalarType[ScalarType[\"INT32\"] = 5] = \"INT32\";\n    ScalarType[ScalarType[\"FIXED64\"] = 6] = \"FIXED64\";\n    ScalarType[ScalarType[\"FIXED32\"] = 7] = \"FIXED32\";\n    ScalarType[ScalarType[\"BOOL\"] = 8] = \"BOOL\";\n    ScalarType[ScalarType[\"STRING\"] = 9] = \"STRING\";\n    // Tag-delimited aggregate.\n    // Group type is deprecated and not supported in proto3. However, Proto3\n    // implementations should still be able to parse the group wire format and\n    // treat group fields as unknown fields.\n    // TYPE_GROUP = 10,\n    // TYPE_MESSAGE = 11,  // Length-delimited aggregate.\n    // New in version 2.\n    ScalarType[ScalarType[\"BYTES\"] = 12] = \"BYTES\";\n    ScalarType[ScalarType[\"UINT32\"] = 13] = \"UINT32\";\n    // TYPE_ENUM = 14,\n    ScalarType[ScalarType[\"SFIXED32\"] = 15] = \"SFIXED32\";\n    ScalarType[ScalarType[\"SFIXED64\"] = 16] = \"SFIXED64\";\n    ScalarType[ScalarType[\"SINT32\"] = 17] = \"SINT32\";\n    ScalarType[ScalarType[\"SINT64\"] = 18] = \"SINT64\";\n})(ScalarType || (ScalarType = {}));\n/**\n * JavaScript representation of fields with 64 bit integral types (int64, uint64,\n * sint64, fixed64, sfixed64).\n *\n * This is a subset of google.protobuf.FieldOptions.JSType, which defines JS_NORMAL,\n * JS_STRING, and JS_NUMBER. Protobuf-ES uses BigInt by default, but will use\n * String if `[jstype = JS_STRING]` is specified.\n *\n * ```protobuf\n * uint64 field_a = 1; // BigInt\n * uint64 field_b = 2 [jstype = JS_NORMAL]; // BigInt\n * uint64 field_b = 2 [jstype = JS_NUMBER]; // BigInt\n * uint64 field_b = 2 [jstype = JS_STRING]; // String\n * ```\n */ var LongType;\n(function(LongType) {\n    /**\n   * Use JavaScript BigInt.\n   */ LongType[LongType[\"BIGINT\"] = 0] = \"BIGINT\";\n    /**\n   * Use JavaScript String.\n   *\n   * Field option `[jstype = JS_STRING]`.\n   */ LongType[LongType[\"STRING\"] = 1] = \"STRING\";\n})(LongType || (LongType = {}));\n// Copyright 2008 Google Inc.  All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n// * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n// * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n// * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n// Code generated by the Protocol Buffer compiler is owned by the owner\n// of the input file used when generating it.  This code is not\n// standalone and requires a support library to be linked with it.  This\n// support library is itself covered by the above license.\n/* eslint-disable prefer-const,@typescript-eslint/restrict-plus-operands */ /**\n * Read a 64 bit varint as two JS numbers.\n *\n * Returns tuple:\n * [0]: low bits\n * [1]: high bits\n *\n * Copyright 2008 Google Inc.  All rights reserved.\n *\n * See https://github.com/protocolbuffers/protobuf/blob/8a71927d74a4ce34efe2d8769fda198f52d20d12/js/experimental/runtime/kernel/buffer_decoder.js#L175\n */ function varint64read() {\n    let lowBits = 0;\n    let highBits = 0;\n    for(let shift = 0; shift < 28; shift += 7){\n        let b = this.buf[this.pos++];\n        lowBits |= (b & 0x7f) << shift;\n        if ((b & 0x80) == 0) {\n            this.assertBounds();\n            return [\n                lowBits,\n                highBits\n            ];\n        }\n    }\n    let middleByte = this.buf[this.pos++];\n    // last four bits of the first 32 bit number\n    lowBits |= (middleByte & 0x0f) << 28;\n    // 3 upper bits are part of the next 32 bit number\n    highBits = (middleByte & 0x70) >> 4;\n    if ((middleByte & 0x80) == 0) {\n        this.assertBounds();\n        return [\n            lowBits,\n            highBits\n        ];\n    }\n    for(let shift = 3; shift <= 31; shift += 7){\n        let b = this.buf[this.pos++];\n        highBits |= (b & 0x7f) << shift;\n        if ((b & 0x80) == 0) {\n            this.assertBounds();\n            return [\n                lowBits,\n                highBits\n            ];\n        }\n    }\n    throw new Error(\"invalid varint\");\n}\n/**\n * Write a 64 bit varint, given as two JS numbers, to the given bytes array.\n *\n * Copyright 2008 Google Inc.  All rights reserved.\n *\n * See https://github.com/protocolbuffers/protobuf/blob/8a71927d74a4ce34efe2d8769fda198f52d20d12/js/experimental/runtime/kernel/writer.js#L344\n */ function varint64write(lo, hi, bytes) {\n    for(let i = 0; i < 28; i = i + 7){\n        const shift = lo >>> i;\n        const hasNext = !(shift >>> 7 == 0 && hi == 0);\n        const byte = (hasNext ? shift | 0x80 : shift) & 0xff;\n        bytes.push(byte);\n        if (!hasNext) {\n            return;\n        }\n    }\n    const splitBits = lo >>> 28 & 0x0f | (hi & 0x07) << 4;\n    const hasMoreBits = !(hi >> 3 == 0);\n    bytes.push((hasMoreBits ? splitBits | 0x80 : splitBits) & 0xff);\n    if (!hasMoreBits) {\n        return;\n    }\n    for(let i = 3; i < 31; i = i + 7){\n        const shift = hi >>> i;\n        const hasNext = !(shift >>> 7 == 0);\n        const byte = (hasNext ? shift | 0x80 : shift) & 0xff;\n        bytes.push(byte);\n        if (!hasNext) {\n            return;\n        }\n    }\n    bytes.push(hi >>> 31 & 0x01);\n}\n// constants for binary math\nconst TWO_PWR_32_DBL = 0x100000000;\n/**\n * Parse decimal string of 64 bit integer value as two JS numbers.\n *\n * Copyright 2008 Google Inc.  All rights reserved.\n *\n * See https://github.com/protocolbuffers/protobuf-javascript/blob/a428c58273abad07c66071d9753bc4d1289de426/experimental/runtime/int64.js#L10\n */ function int64FromString(dec) {\n    // Check for minus sign.\n    const minus = dec[0] === \"-\";\n    if (minus) {\n        dec = dec.slice(1);\n    }\n    // Work 6 decimal digits at a time, acting like we're converting base 1e6\n    // digits to binary. This is safe to do with floating point math because\n    // Number.isSafeInteger(ALL_32_BITS * 1e6) == true.\n    const base = 1e6;\n    let lowBits = 0;\n    let highBits = 0;\n    function add1e6digit(begin, end) {\n        // Note: Number('') is 0.\n        const digit1e6 = Number(dec.slice(begin, end));\n        highBits *= base;\n        lowBits = lowBits * base + digit1e6;\n        // Carry bits from lowBits to\n        if (lowBits >= TWO_PWR_32_DBL) {\n            highBits = highBits + (lowBits / TWO_PWR_32_DBL | 0);\n            lowBits = lowBits % TWO_PWR_32_DBL;\n        }\n    }\n    add1e6digit(-24, -18);\n    add1e6digit(-18, -12);\n    add1e6digit(-12, -6);\n    add1e6digit(-6);\n    return minus ? negate(lowBits, highBits) : newBits(lowBits, highBits);\n}\n/**\n * Losslessly converts a 64-bit signed integer in 32:32 split representation\n * into a decimal string.\n *\n * Copyright 2008 Google Inc.  All rights reserved.\n *\n * See https://github.com/protocolbuffers/protobuf-javascript/blob/a428c58273abad07c66071d9753bc4d1289de426/experimental/runtime/int64.js#L10\n */ function int64ToString(lo, hi) {\n    let bits = newBits(lo, hi);\n    // If we're treating the input as a signed value and the high bit is set, do\n    // a manual two's complement conversion before the decimal conversion.\n    const negative = bits.hi & 0x80000000;\n    if (negative) {\n        bits = negate(bits.lo, bits.hi);\n    }\n    const result = uInt64ToString(bits.lo, bits.hi);\n    return negative ? \"-\" + result : result;\n}\n/**\n * Losslessly converts a 64-bit unsigned integer in 32:32 split representation\n * into a decimal string.\n *\n * Copyright 2008 Google Inc.  All rights reserved.\n *\n * See https://github.com/protocolbuffers/protobuf-javascript/blob/a428c58273abad07c66071d9753bc4d1289de426/experimental/runtime/int64.js#L10\n */ function uInt64ToString(lo, hi) {\n    ({ lo, hi } = toUnsigned(lo, hi));\n    // Skip the expensive conversion if the number is small enough to use the\n    // built-in conversions.\n    // Number.MAX_SAFE_INTEGER = 0x001FFFFF FFFFFFFF, thus any number with\n    // highBits <= 0x1FFFFF can be safely expressed with a double and retain\n    // integer precision.\n    // Proven by: Number.isSafeInteger(0x1FFFFF * 2**32 + 0xFFFFFFFF) == true.\n    if (hi <= 0x1FFFFF) {\n        return String(TWO_PWR_32_DBL * hi + lo);\n    }\n    // What this code is doing is essentially converting the input number from\n    // base-2 to base-1e7, which allows us to represent the 64-bit range with\n    // only 3 (very large) digits. Those digits are then trivial to convert to\n    // a base-10 string.\n    // The magic numbers used here are -\n    // 2^24 = 16777216 = (1,6777216) in base-1e7.\n    // 2^48 = 281474976710656 = (2,8147497,6710656) in base-1e7.\n    // Split 32:32 representation into 16:24:24 representation so our\n    // intermediate digits don't overflow.\n    const low = lo & 0xFFFFFF;\n    const mid = (lo >>> 24 | hi << 8) & 0xFFFFFF;\n    const high = hi >> 16 & 0xFFFF;\n    // Assemble our three base-1e7 digits, ignoring carries. The maximum\n    // value in a digit at this step is representable as a 48-bit integer, which\n    // can be stored in a 64-bit floating point number.\n    let digitA = low + mid * 6777216 + high * 6710656;\n    let digitB = mid + high * 8147497;\n    let digitC = high * 2;\n    // Apply carries from A to B and from B to C.\n    const base = 10000000;\n    if (digitA >= base) {\n        digitB += Math.floor(digitA / base);\n        digitA %= base;\n    }\n    if (digitB >= base) {\n        digitC += Math.floor(digitB / base);\n        digitB %= base;\n    }\n    // If digitC is 0, then we should have returned in the trivial code path\n    // at the top for non-safe integers. Given this, we can assume both digitB\n    // and digitA need leading zeros.\n    return digitC.toString() + decimalFrom1e7WithLeadingZeros(digitB) + decimalFrom1e7WithLeadingZeros(digitA);\n}\nfunction toUnsigned(lo, hi) {\n    return {\n        lo: lo >>> 0,\n        hi: hi >>> 0\n    };\n}\nfunction newBits(lo, hi) {\n    return {\n        lo: lo | 0,\n        hi: hi | 0\n    };\n}\n/**\n * Returns two's compliment negation of input.\n * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators#Signed_32-bit_integers\n */ function negate(lowBits, highBits) {\n    highBits = ~highBits;\n    if (lowBits) {\n        lowBits = ~lowBits + 1;\n    } else {\n        // If lowBits is 0, then bitwise-not is 0xFFFFFFFF,\n        // adding 1 to that, results in 0x100000000, which leaves\n        // the low bits 0x0 and simply adds one to the high bits.\n        highBits += 1;\n    }\n    return newBits(lowBits, highBits);\n}\n/**\n * Returns decimal representation of digit1e7 with leading zeros.\n */ const decimalFrom1e7WithLeadingZeros = (digit1e7)=>{\n    const partial = String(digit1e7);\n    return \"0000000\".slice(partial.length) + partial;\n};\n/**\n * Write a 32 bit varint, signed or unsigned. Same as `varint64write(0, value, bytes)`\n *\n * Copyright 2008 Google Inc.  All rights reserved.\n *\n * See https://github.com/protocolbuffers/protobuf/blob/1b18833f4f2a2f681f4e4a25cdf3b0a43115ec26/js/binary/encoder.js#L144\n */ function varint32write(value, bytes) {\n    if (value >= 0) {\n        // write value as varint 32\n        while(value > 0x7f){\n            bytes.push(value & 0x7f | 0x80);\n            value = value >>> 7;\n        }\n        bytes.push(value);\n    } else {\n        for(let i = 0; i < 9; i++){\n            bytes.push(value & 127 | 128);\n            value = value >> 7;\n        }\n        bytes.push(1);\n    }\n}\n/**\n * Read an unsigned 32 bit varint.\n *\n * See https://github.com/protocolbuffers/protobuf/blob/8a71927d74a4ce34efe2d8769fda198f52d20d12/js/experimental/runtime/kernel/buffer_decoder.js#L220\n */ function varint32read() {\n    let b = this.buf[this.pos++];\n    let result = b & 0x7f;\n    if ((b & 0x80) == 0) {\n        this.assertBounds();\n        return result;\n    }\n    b = this.buf[this.pos++];\n    result |= (b & 0x7f) << 7;\n    if ((b & 0x80) == 0) {\n        this.assertBounds();\n        return result;\n    }\n    b = this.buf[this.pos++];\n    result |= (b & 0x7f) << 14;\n    if ((b & 0x80) == 0) {\n        this.assertBounds();\n        return result;\n    }\n    b = this.buf[this.pos++];\n    result |= (b & 0x7f) << 21;\n    if ((b & 0x80) == 0) {\n        this.assertBounds();\n        return result;\n    }\n    // Extract only last 4 bits\n    b = this.buf[this.pos++];\n    result |= (b & 0x0f) << 28;\n    for(let readBytes = 5; (b & 0x80) !== 0 && readBytes < 10; readBytes++)b = this.buf[this.pos++];\n    if ((b & 0x80) != 0) throw new Error(\"invalid varint\");\n    this.assertBounds();\n    // Result can have 32 bits, convert it to unsigned\n    return result >>> 0;\n}\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nfunction makeInt64Support() {\n    const dv = new DataView(new ArrayBuffer(8));\n    // note that Safari 14 implements BigInt, but not the DataView methods\n    const ok = typeof BigInt === \"function\" && typeof dv.getBigInt64 === \"function\" && typeof dv.getBigUint64 === \"function\" && typeof dv.setBigInt64 === \"function\" && typeof dv.setBigUint64 === \"function\" && (typeof process != \"object\" || typeof process.env != \"object\" || process.env.BUF_BIGINT_DISABLE !== \"1\");\n    if (ok) {\n        const MIN = BigInt(\"-9223372036854775808\"), MAX = BigInt(\"9223372036854775807\"), UMIN = BigInt(\"0\"), UMAX = BigInt(\"18446744073709551615\");\n        return {\n            zero: BigInt(0),\n            supported: true,\n            parse (value) {\n                const bi = typeof value == \"bigint\" ? value : BigInt(value);\n                if (bi > MAX || bi < MIN) {\n                    throw new Error(\"int64 invalid: \".concat(value));\n                }\n                return bi;\n            },\n            uParse (value) {\n                const bi = typeof value == \"bigint\" ? value : BigInt(value);\n                if (bi > UMAX || bi < UMIN) {\n                    throw new Error(\"uint64 invalid: \".concat(value));\n                }\n                return bi;\n            },\n            enc (value) {\n                dv.setBigInt64(0, this.parse(value), true);\n                return {\n                    lo: dv.getInt32(0, true),\n                    hi: dv.getInt32(4, true)\n                };\n            },\n            uEnc (value) {\n                dv.setBigInt64(0, this.uParse(value), true);\n                return {\n                    lo: dv.getInt32(0, true),\n                    hi: dv.getInt32(4, true)\n                };\n            },\n            dec (lo, hi) {\n                dv.setInt32(0, lo, true);\n                dv.setInt32(4, hi, true);\n                return dv.getBigInt64(0, true);\n            },\n            uDec (lo, hi) {\n                dv.setInt32(0, lo, true);\n                dv.setInt32(4, hi, true);\n                return dv.getBigUint64(0, true);\n            }\n        };\n    }\n    const assertInt64String = (value)=>assert(/^-?[0-9]+$/.test(value), \"int64 invalid: \".concat(value));\n    const assertUInt64String = (value)=>assert(/^[0-9]+$/.test(value), \"uint64 invalid: \".concat(value));\n    return {\n        zero: \"0\",\n        supported: false,\n        parse (value) {\n            if (typeof value != \"string\") {\n                value = value.toString();\n            }\n            assertInt64String(value);\n            return value;\n        },\n        uParse (value) {\n            if (typeof value != \"string\") {\n                value = value.toString();\n            }\n            assertUInt64String(value);\n            return value;\n        },\n        enc (value) {\n            if (typeof value != \"string\") {\n                value = value.toString();\n            }\n            assertInt64String(value);\n            return int64FromString(value);\n        },\n        uEnc (value) {\n            if (typeof value != \"string\") {\n                value = value.toString();\n            }\n            assertUInt64String(value);\n            return int64FromString(value);\n        },\n        dec (lo, hi) {\n            return int64ToString(lo, hi);\n        },\n        uDec (lo, hi) {\n            return uInt64ToString(lo, hi);\n        }\n    };\n}\nconst protoInt64 = makeInt64Support();\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/* eslint-disable prefer-const,no-case-declarations,@typescript-eslint/restrict-plus-operands */ /**\n * Protobuf binary format wire types.\n *\n * A wire type provides just enough information to find the length of the\n * following value.\n *\n * See https://developers.google.com/protocol-buffers/docs/encoding#structure\n */ var WireType;\n(function(WireType) {\n    /**\n   * Used for int32, int64, uint32, uint64, sint32, sint64, bool, enum\n   */ WireType[WireType[\"Varint\"] = 0] = \"Varint\";\n    /**\n   * Used for fixed64, sfixed64, double.\n   * Always 8 bytes with little-endian byte order.\n   */ WireType[WireType[\"Bit64\"] = 1] = \"Bit64\";\n    /**\n   * Used for string, bytes, embedded messages, packed repeated fields\n   *\n   * Only repeated numeric types (types which use the varint, 32-bit,\n   * or 64-bit wire types) can be packed. In proto3, such fields are\n   * packed by default.\n   */ WireType[WireType[\"LengthDelimited\"] = 2] = \"LengthDelimited\";\n    /**\n   * Used for groups\n   * @deprecated\n   */ WireType[WireType[\"StartGroup\"] = 3] = \"StartGroup\";\n    /**\n   * Used for groups\n   * @deprecated\n   */ WireType[WireType[\"EndGroup\"] = 4] = \"EndGroup\";\n    /**\n   * Used for fixed32, sfixed32, float.\n   * Always 4 bytes with little-endian byte order.\n   */ WireType[WireType[\"Bit32\"] = 5] = \"Bit32\";\n})(WireType || (WireType = {}));\nclass BinaryWriter {\n    constructor(textEncoder){\n        /**\n     * Previous fork states.\n     */ this.stack = [];\n        this.textEncoder = textEncoder !== null && textEncoder !== void 0 ? textEncoder : new TextEncoder();\n        this.chunks = [];\n        this.buf = [];\n    }\n    /**\n   * Return all bytes written and reset this writer.\n   */ finish() {\n        this.chunks.push(new Uint8Array(this.buf)); // flush the buffer\n        let len = 0;\n        for(let i = 0; i < this.chunks.length; i++)len += this.chunks[i].length;\n        let bytes = new Uint8Array(len);\n        let offset = 0;\n        for(let i = 0; i < this.chunks.length; i++){\n            bytes.set(this.chunks[i], offset);\n            offset += this.chunks[i].length;\n        }\n        this.chunks = [];\n        return bytes;\n    }\n    /**\n   * Start a new fork for length-delimited data like a message\n   * or a packed repeated field.\n   *\n   * Must be joined later with `join()`.\n   */ fork() {\n        this.stack.push({\n            chunks: this.chunks,\n            buf: this.buf\n        });\n        this.chunks = [];\n        this.buf = [];\n        return this;\n    }\n    /**\n   * Join the last fork. Write its length and bytes, then\n   * return to the previous state.\n   */ join() {\n        // get chunk of fork\n        let chunk = this.finish();\n        // restore previous state\n        let prev = this.stack.pop();\n        if (!prev) throw new Error(\"invalid state, fork stack empty\");\n        this.chunks = prev.chunks;\n        this.buf = prev.buf;\n        // write length of chunk as varint\n        this.uint32(chunk.byteLength);\n        return this.raw(chunk);\n    }\n    /**\n   * Writes a tag (field number and wire type).\n   *\n   * Equivalent to `uint32( (fieldNo << 3 | type) >>> 0 )`.\n   *\n   * Generated code should compute the tag ahead of time and call `uint32()`.\n   */ tag(fieldNo, type) {\n        return this.uint32((fieldNo << 3 | type) >>> 0);\n    }\n    /**\n   * Write a chunk of raw bytes.\n   */ raw(chunk) {\n        if (this.buf.length) {\n            this.chunks.push(new Uint8Array(this.buf));\n            this.buf = [];\n        }\n        this.chunks.push(chunk);\n        return this;\n    }\n    /**\n   * Write a `uint32` value, an unsigned 32 bit varint.\n   */ uint32(value) {\n        assertUInt32(value);\n        // write value as varint 32, inlined for speed\n        while(value > 0x7f){\n            this.buf.push(value & 0x7f | 0x80);\n            value = value >>> 7;\n        }\n        this.buf.push(value);\n        return this;\n    }\n    /**\n   * Write a `int32` value, a signed 32 bit varint.\n   */ int32(value) {\n        assertInt32(value);\n        varint32write(value, this.buf);\n        return this;\n    }\n    /**\n   * Write a `bool` value, a variant.\n   */ bool(value) {\n        this.buf.push(value ? 1 : 0);\n        return this;\n    }\n    /**\n   * Write a `bytes` value, length-delimited arbitrary data.\n   */ bytes(value) {\n        this.uint32(value.byteLength); // write length of chunk as varint\n        return this.raw(value);\n    }\n    /**\n   * Write a `string` value, length-delimited data converted to UTF-8 text.\n   */ string(value) {\n        let chunk = this.textEncoder.encode(value);\n        this.uint32(chunk.byteLength); // write length of chunk as varint\n        return this.raw(chunk);\n    }\n    /**\n   * Write a `float` value, 32-bit floating point number.\n   */ float(value) {\n        assertFloat32(value);\n        let chunk = new Uint8Array(4);\n        new DataView(chunk.buffer).setFloat32(0, value, true);\n        return this.raw(chunk);\n    }\n    /**\n   * Write a `double` value, a 64-bit floating point number.\n   */ double(value) {\n        let chunk = new Uint8Array(8);\n        new DataView(chunk.buffer).setFloat64(0, value, true);\n        return this.raw(chunk);\n    }\n    /**\n   * Write a `fixed32` value, an unsigned, fixed-length 32-bit integer.\n   */ fixed32(value) {\n        assertUInt32(value);\n        let chunk = new Uint8Array(4);\n        new DataView(chunk.buffer).setUint32(0, value, true);\n        return this.raw(chunk);\n    }\n    /**\n   * Write a `sfixed32` value, a signed, fixed-length 32-bit integer.\n   */ sfixed32(value) {\n        assertInt32(value);\n        let chunk = new Uint8Array(4);\n        new DataView(chunk.buffer).setInt32(0, value, true);\n        return this.raw(chunk);\n    }\n    /**\n   * Write a `sint32` value, a signed, zigzag-encoded 32-bit varint.\n   */ sint32(value) {\n        assertInt32(value);\n        // zigzag encode\n        value = (value << 1 ^ value >> 31) >>> 0;\n        varint32write(value, this.buf);\n        return this;\n    }\n    /**\n   * Write a `fixed64` value, a signed, fixed-length 64-bit integer.\n   */ sfixed64(value) {\n        let chunk = new Uint8Array(8), view = new DataView(chunk.buffer), tc = protoInt64.enc(value);\n        view.setInt32(0, tc.lo, true);\n        view.setInt32(4, tc.hi, true);\n        return this.raw(chunk);\n    }\n    /**\n   * Write a `fixed64` value, an unsigned, fixed-length 64 bit integer.\n   */ fixed64(value) {\n        let chunk = new Uint8Array(8), view = new DataView(chunk.buffer), tc = protoInt64.uEnc(value);\n        view.setInt32(0, tc.lo, true);\n        view.setInt32(4, tc.hi, true);\n        return this.raw(chunk);\n    }\n    /**\n   * Write a `int64` value, a signed 64-bit varint.\n   */ int64(value) {\n        let tc = protoInt64.enc(value);\n        varint64write(tc.lo, tc.hi, this.buf);\n        return this;\n    }\n    /**\n   * Write a `sint64` value, a signed, zig-zag-encoded 64-bit varint.\n   */ sint64(value) {\n        let tc = protoInt64.enc(value), // zigzag encode\n        sign = tc.hi >> 31, lo = tc.lo << 1 ^ sign, hi = (tc.hi << 1 | tc.lo >>> 31) ^ sign;\n        varint64write(lo, hi, this.buf);\n        return this;\n    }\n    /**\n   * Write a `uint64` value, an unsigned 64-bit varint.\n   */ uint64(value) {\n        let tc = protoInt64.uEnc(value);\n        varint64write(tc.lo, tc.hi, this.buf);\n        return this;\n    }\n}\nclass BinaryReader {\n    constructor(buf, textDecoder){\n        this.varint64 = varint64read; // dirty cast for `this`\n        /**\n     * Read a `uint32` field, an unsigned 32 bit varint.\n     */ this.uint32 = varint32read; // dirty cast for `this` and access to protected `buf`\n        this.buf = buf;\n        this.len = buf.length;\n        this.pos = 0;\n        this.view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n        this.textDecoder = textDecoder !== null && textDecoder !== void 0 ? textDecoder : new TextDecoder();\n    }\n    /**\n   * Reads a tag - field number and wire type.\n   */ tag() {\n        let tag = this.uint32(), fieldNo = tag >>> 3, wireType = tag & 7;\n        if (fieldNo <= 0 || wireType < 0 || wireType > 5) throw new Error(\"illegal tag: field no \" + fieldNo + \" wire type \" + wireType);\n        return [\n            fieldNo,\n            wireType\n        ];\n    }\n    /**\n   * Skip one element on the wire and return the skipped data.\n   * Supports WireType.StartGroup since v2.0.0-alpha.23.\n   */ skip(wireType) {\n        let start = this.pos;\n        switch(wireType){\n            case WireType.Varint:\n                while(this.buf[this.pos++] & 0x80){\n                // ignore\n                }\n                break;\n            // eslint-disable-next-line\n            // @ts-ignore TS7029: Fallthrough case in switch\n            case WireType.Bit64:\n                this.pos += 4;\n            // eslint-disable-next-line\n            // @ts-ignore TS7029: Fallthrough case in switch\n            case WireType.Bit32:\n                this.pos += 4;\n                break;\n            case WireType.LengthDelimited:\n                let len = this.uint32();\n                this.pos += len;\n                break;\n            case WireType.StartGroup:\n                // From descriptor.proto: Group type is deprecated, not supported in proto3.\n                // But we must still be able to parse and treat as unknown.\n                let t;\n                while((t = this.tag()[1]) !== WireType.EndGroup){\n                    this.skip(t);\n                }\n                break;\n            default:\n                throw new Error(\"cant skip wire type \" + wireType);\n        }\n        this.assertBounds();\n        return this.buf.subarray(start, this.pos);\n    }\n    /**\n   * Throws error if position in byte array is out of range.\n   */ assertBounds() {\n        if (this.pos > this.len) throw new RangeError(\"premature EOF\");\n    }\n    /**\n   * Read a `int32` field, a signed 32 bit varint.\n   */ int32() {\n        return this.uint32() | 0;\n    }\n    /**\n   * Read a `sint32` field, a signed, zigzag-encoded 32-bit varint.\n   */ sint32() {\n        let zze = this.uint32();\n        // decode zigzag\n        return zze >>> 1 ^ -(zze & 1);\n    }\n    /**\n   * Read a `int64` field, a signed 64-bit varint.\n   */ int64() {\n        return protoInt64.dec(...this.varint64());\n    }\n    /**\n   * Read a `uint64` field, an unsigned 64-bit varint.\n   */ uint64() {\n        return protoInt64.uDec(...this.varint64());\n    }\n    /**\n   * Read a `sint64` field, a signed, zig-zag-encoded 64-bit varint.\n   */ sint64() {\n        let [lo, hi] = this.varint64();\n        // decode zig zag\n        let s = -(lo & 1);\n        lo = (lo >>> 1 | (hi & 1) << 31) ^ s;\n        hi = hi >>> 1 ^ s;\n        return protoInt64.dec(lo, hi);\n    }\n    /**\n   * Read a `bool` field, a variant.\n   */ bool() {\n        let [lo, hi] = this.varint64();\n        return lo !== 0 || hi !== 0;\n    }\n    /**\n   * Read a `fixed32` field, an unsigned, fixed-length 32-bit integer.\n   */ fixed32() {\n        return this.view.getUint32((this.pos += 4) - 4, true);\n    }\n    /**\n   * Read a `sfixed32` field, a signed, fixed-length 32-bit integer.\n   */ sfixed32() {\n        return this.view.getInt32((this.pos += 4) - 4, true);\n    }\n    /**\n   * Read a `fixed64` field, an unsigned, fixed-length 64 bit integer.\n   */ fixed64() {\n        return protoInt64.uDec(this.sfixed32(), this.sfixed32());\n    }\n    /**\n   * Read a `fixed64` field, a signed, fixed-length 64-bit integer.\n   */ sfixed64() {\n        return protoInt64.dec(this.sfixed32(), this.sfixed32());\n    }\n    /**\n   * Read a `float` field, 32-bit floating point number.\n   */ float() {\n        return this.view.getFloat32((this.pos += 4) - 4, true);\n    }\n    /**\n   * Read a `double` field, a 64-bit floating point number.\n   */ double() {\n        return this.view.getFloat64((this.pos += 8) - 8, true);\n    }\n    /**\n   * Read a `bytes` field, length-delimited arbitrary data.\n   */ bytes() {\n        let len = this.uint32(), start = this.pos;\n        this.pos += len;\n        this.assertBounds();\n        return this.buf.subarray(start, start + len);\n    }\n    /**\n   * Read a `string` field, length-delimited data converted to UTF-8 text.\n   */ string() {\n        return this.textDecoder.decode(this.bytes());\n    }\n}\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Wrap a primitive message field value in its corresponding wrapper\n * message. This function is idempotent.\n */ function wrapField(type, value) {\n    if (value instanceof Message || !type.fieldWrapper) {\n        return value;\n    }\n    return type.fieldWrapper.wrapField(value);\n}\n({\n    \"google.protobuf.DoubleValue\": ScalarType.DOUBLE,\n    \"google.protobuf.FloatValue\": ScalarType.FLOAT,\n    \"google.protobuf.Int64Value\": ScalarType.INT64,\n    \"google.protobuf.UInt64Value\": ScalarType.UINT64,\n    \"google.protobuf.Int32Value\": ScalarType.INT32,\n    \"google.protobuf.UInt32Value\": ScalarType.UINT32,\n    \"google.protobuf.BoolValue\": ScalarType.BOOL,\n    \"google.protobuf.StringValue\": ScalarType.STRING,\n    \"google.protobuf.BytesValue\": ScalarType.BYTES\n});\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/* eslint-disable @typescript-eslint/no-explicit-any */ /**\n * Returns true if both scalar values are equal.\n */ function scalarEquals(type, a, b) {\n    if (a === b) {\n        // This correctly matches equal values except BYTES and (possibly) 64-bit integers.\n        return true;\n    }\n    // Special case BYTES - we need to compare each byte individually\n    if (type == ScalarType.BYTES) {\n        if (!(a instanceof Uint8Array) || !(b instanceof Uint8Array)) {\n            return false;\n        }\n        if (a.length !== b.length) {\n            return false;\n        }\n        for(let i = 0; i < a.length; i++){\n            if (a[i] !== b[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    // Special case 64-bit integers - we support number, string and bigint representation.\n    // eslint-disable-next-line @typescript-eslint/switch-exhaustiveness-check\n    switch(type){\n        case ScalarType.UINT64:\n        case ScalarType.FIXED64:\n        case ScalarType.INT64:\n        case ScalarType.SFIXED64:\n        case ScalarType.SINT64:\n            // Loose comparison will match between 0n, 0 and \"0\".\n            return a == b;\n    }\n    // Anything that hasn't been caught by strict comparison or special cased\n    // BYTES and 64-bit integers is not equal.\n    return false;\n}\n/**\n * Returns the default value for the given scalar type, following\n * proto3 semantics.\n */ function scalarDefaultValue(type, longType) {\n    switch(type){\n        case ScalarType.BOOL:\n            return false;\n        case ScalarType.UINT64:\n        case ScalarType.FIXED64:\n        case ScalarType.INT64:\n        case ScalarType.SFIXED64:\n        case ScalarType.SINT64:\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-enum-comparison -- acceptable since it's covered by tests\n            return longType == 0 ? protoInt64.zero : \"0\";\n        case ScalarType.DOUBLE:\n        case ScalarType.FLOAT:\n            return 0.0;\n        case ScalarType.BYTES:\n            return new Uint8Array(0);\n        case ScalarType.STRING:\n            return \"\";\n        default:\n            // Handles INT32, UINT32, SINT32, FIXED32, SFIXED32.\n            // We do not use individual cases to save a few bytes code size.\n            return 0;\n    }\n}\n/**\n * Get information for writing a scalar value.\n *\n * Returns tuple:\n * [0]: appropriate WireType\n * [1]: name of the appropriate method of IBinaryWriter\n * [2]: whether the given value is a default value for proto3 semantics\n *\n * If argument `value` is omitted, [2] is always false.\n */ function scalarTypeInfo(type, value) {\n    const isUndefined = value === undefined;\n    let wireType = WireType.Varint;\n    let isIntrinsicDefault = value === 0;\n    // eslint-disable-next-line @typescript-eslint/switch-exhaustiveness-check -- INT32, UINT32, SINT32 are covered by the defaults\n    switch(type){\n        case ScalarType.STRING:\n            isIntrinsicDefault = isUndefined || !value.length;\n            wireType = WireType.LengthDelimited;\n            break;\n        case ScalarType.BOOL:\n            isIntrinsicDefault = value === false;\n            break;\n        case ScalarType.DOUBLE:\n            wireType = WireType.Bit64;\n            break;\n        case ScalarType.FLOAT:\n            wireType = WireType.Bit32;\n            break;\n        case ScalarType.INT64:\n            isIntrinsicDefault = isUndefined || value == 0; // Loose comparison matches 0n, 0 and \"0\"\n            break;\n        case ScalarType.UINT64:\n            isIntrinsicDefault = isUndefined || value == 0; // Loose comparison matches 0n, 0 and \"0\"\n            break;\n        case ScalarType.FIXED64:\n            isIntrinsicDefault = isUndefined || value == 0; // Loose comparison matches 0n, 0 and \"0\"\n            wireType = WireType.Bit64;\n            break;\n        case ScalarType.BYTES:\n            isIntrinsicDefault = isUndefined || !value.byteLength;\n            wireType = WireType.LengthDelimited;\n            break;\n        case ScalarType.FIXED32:\n            wireType = WireType.Bit32;\n            break;\n        case ScalarType.SFIXED32:\n            wireType = WireType.Bit32;\n            break;\n        case ScalarType.SFIXED64:\n            isIntrinsicDefault = isUndefined || value == 0;\n            wireType = WireType.Bit64;\n            break;\n        case ScalarType.SINT64:\n            isIntrinsicDefault = isUndefined || value == 0;\n            break;\n    }\n    const method = ScalarType[type].toLowerCase();\n    return [\n        wireType,\n        method,\n        isUndefined || isIntrinsicDefault\n    ];\n}\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/* eslint-disable @typescript-eslint/no-unsafe-return, @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-argument, @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-call, @typescript-eslint/no-unnecessary-condition, no-case-declarations, prefer-const */ const unknownFieldsSymbol = Symbol(\"@bufbuild/protobuf/unknown-fields\");\n// Default options for parsing binary data.\nconst readDefaults = {\n    readUnknownFields: true,\n    readerFactory: (bytes)=>new BinaryReader(bytes)\n};\n// Default options for serializing binary data.\nconst writeDefaults = {\n    writeUnknownFields: true,\n    writerFactory: ()=>new BinaryWriter()\n};\nfunction makeReadOptions$1(options) {\n    return options ? Object.assign(Object.assign({}, readDefaults), options) : readDefaults;\n}\nfunction makeWriteOptions$1(options) {\n    return options ? Object.assign(Object.assign({}, writeDefaults), options) : writeDefaults;\n}\nfunction makeBinaryFormatCommon() {\n    return {\n        makeReadOptions: makeReadOptions$1,\n        makeWriteOptions: makeWriteOptions$1,\n        listUnknownFields (message) {\n            var _a;\n            return (_a = message[unknownFieldsSymbol]) !== null && _a !== void 0 ? _a : [];\n        },\n        discardUnknownFields (message) {\n            delete message[unknownFieldsSymbol];\n        },\n        writeUnknownFields (message, writer) {\n            const m = message;\n            const c = m[unknownFieldsSymbol];\n            if (c) {\n                for (const f of c){\n                    writer.tag(f.no, f.wireType).raw(f.data);\n                }\n            }\n        },\n        onUnknownField (message, no, wireType, data) {\n            const m = message;\n            if (!Array.isArray(m[unknownFieldsSymbol])) {\n                m[unknownFieldsSymbol] = [];\n            }\n            m[unknownFieldsSymbol].push({\n                no,\n                wireType,\n                data\n            });\n        },\n        readMessage (message, reader, length, options) {\n            const type = message.getType();\n            const end = length === undefined ? reader.len : reader.pos + length;\n            while(reader.pos < end){\n                const [fieldNo, wireType] = reader.tag(), field = type.fields.find(fieldNo);\n                if (!field) {\n                    const data = reader.skip(wireType);\n                    if (options.readUnknownFields) {\n                        this.onUnknownField(message, fieldNo, wireType, data);\n                    }\n                    continue;\n                }\n                let target = message, repeated = field.repeated, localName = field.localName;\n                if (field.oneof) {\n                    target = target[field.oneof.localName];\n                    if (target.case != localName) {\n                        delete target.value;\n                    }\n                    target.case = localName;\n                    localName = \"value\";\n                }\n                switch(field.kind){\n                    case \"scalar\":\n                    case \"enum\":\n                        const scalarType = field.kind == \"enum\" ? ScalarType.INT32 : field.T;\n                        let read = readScalar$1;\n                        // eslint-disable-next-line @typescript-eslint/no-unsafe-enum-comparison -- acceptable since it's covered by tests\n                        if (field.kind == \"scalar\" && field.L > 0) {\n                            read = readScalarLTString;\n                        }\n                        if (repeated) {\n                            let arr = target[localName]; // safe to assume presence of array, oneof cannot contain repeated values\n                            if (wireType == WireType.LengthDelimited && scalarType != ScalarType.STRING && scalarType != ScalarType.BYTES) {\n                                let e = reader.uint32() + reader.pos;\n                                while(reader.pos < e){\n                                    arr.push(read(reader, scalarType));\n                                }\n                            } else {\n                                arr.push(read(reader, scalarType));\n                            }\n                        } else {\n                            target[localName] = read(reader, scalarType);\n                        }\n                        break;\n                    case \"message\":\n                        const messageType = field.T;\n                        if (repeated) {\n                            // safe to assume presence of array, oneof cannot contain repeated values\n                            target[localName].push(readMessageField(reader, new messageType(), options));\n                        } else {\n                            if (target[localName] instanceof Message) {\n                                readMessageField(reader, target[localName], options);\n                            } else {\n                                target[localName] = readMessageField(reader, new messageType(), options);\n                                if (messageType.fieldWrapper && !field.oneof && !field.repeated) {\n                                    target[localName] = messageType.fieldWrapper.unwrapField(target[localName]);\n                                }\n                            }\n                        }\n                        break;\n                    case \"map\":\n                        let [mapKey, mapVal] = readMapEntry(field, reader, options);\n                        // safe to assume presence of map object, oneof cannot contain repeated values\n                        target[localName][mapKey] = mapVal;\n                        break;\n                }\n            }\n        }\n    };\n}\n// Read a message, avoiding MessageType.fromBinary() to re-use the\n// BinaryReadOptions and the IBinaryReader.\nfunction readMessageField(reader, message, options) {\n    const format = message.getType().runtime.bin;\n    format.readMessage(message, reader, reader.uint32(), options);\n    return message;\n}\n// Read a map field, expecting key field = 1, value field = 2\nfunction readMapEntry(field, reader, options) {\n    const length = reader.uint32(), end = reader.pos + length;\n    let key, val;\n    while(reader.pos < end){\n        let [fieldNo] = reader.tag();\n        switch(fieldNo){\n            case 1:\n                key = readScalar$1(reader, field.K);\n                break;\n            case 2:\n                switch(field.V.kind){\n                    case \"scalar\":\n                        val = readScalar$1(reader, field.V.T);\n                        break;\n                    case \"enum\":\n                        val = reader.int32();\n                        break;\n                    case \"message\":\n                        val = readMessageField(reader, new field.V.T(), options);\n                        break;\n                }\n                break;\n        }\n    }\n    if (key === undefined) {\n        let keyRaw = scalarDefaultValue(field.K, LongType.BIGINT);\n        key = field.K == ScalarType.BOOL ? keyRaw.toString() : keyRaw;\n    }\n    if (typeof key != \"string\" && typeof key != \"number\") {\n        key = key.toString();\n    }\n    if (val === undefined) {\n        switch(field.V.kind){\n            case \"scalar\":\n                val = scalarDefaultValue(field.V.T, LongType.BIGINT);\n                break;\n            case \"enum\":\n                val = 0;\n                break;\n            case \"message\":\n                val = new field.V.T();\n                break;\n        }\n    }\n    return [\n        key,\n        val\n    ];\n}\n// Read a scalar value, but return 64 bit integral types (int64, uint64,\n// sint64, fixed64, sfixed64) as string instead of bigint.\nfunction readScalarLTString(reader, type) {\n    const v = readScalar$1(reader, type);\n    return typeof v == \"bigint\" ? v.toString() : v;\n}\n// Does not use scalarTypeInfo() for better performance.\nfunction readScalar$1(reader, type) {\n    switch(type){\n        case ScalarType.STRING:\n            return reader.string();\n        case ScalarType.BOOL:\n            return reader.bool();\n        case ScalarType.DOUBLE:\n            return reader.double();\n        case ScalarType.FLOAT:\n            return reader.float();\n        case ScalarType.INT32:\n            return reader.int32();\n        case ScalarType.INT64:\n            return reader.int64();\n        case ScalarType.UINT64:\n            return reader.uint64();\n        case ScalarType.FIXED64:\n            return reader.fixed64();\n        case ScalarType.BYTES:\n            return reader.bytes();\n        case ScalarType.FIXED32:\n            return reader.fixed32();\n        case ScalarType.SFIXED32:\n            return reader.sfixed32();\n        case ScalarType.SFIXED64:\n            return reader.sfixed64();\n        case ScalarType.SINT64:\n            return reader.sint64();\n        case ScalarType.UINT32:\n            return reader.uint32();\n        case ScalarType.SINT32:\n            return reader.sint32();\n    }\n}\nfunction writeMapEntry(writer, options, field, key, value) {\n    writer.tag(field.no, WireType.LengthDelimited);\n    writer.fork();\n    // javascript only allows number or string for object properties\n    // we convert from our representation to the protobuf type\n    let keyValue = key;\n    // eslint-disable-next-line @typescript-eslint/switch-exhaustiveness-check -- we deliberately handle just the special cases for map keys\n    switch(field.K){\n        case ScalarType.INT32:\n        case ScalarType.FIXED32:\n        case ScalarType.UINT32:\n        case ScalarType.SFIXED32:\n        case ScalarType.SINT32:\n            keyValue = Number.parseInt(key);\n            break;\n        case ScalarType.BOOL:\n            assert(key == \"true\" || key == \"false\");\n            keyValue = key == \"true\";\n            break;\n    }\n    // write key, expecting key field number = 1\n    writeScalar$1(writer, field.K, 1, keyValue, true);\n    // write value, expecting value field number = 2\n    switch(field.V.kind){\n        case \"scalar\":\n            writeScalar$1(writer, field.V.T, 2, value, true);\n            break;\n        case \"enum\":\n            writeScalar$1(writer, ScalarType.INT32, 2, value, true);\n            break;\n        case \"message\":\n            writeMessageField(writer, options, field.V.T, 2, value);\n            break;\n    }\n    writer.join();\n}\nfunction writeMessageField(writer, options, type, fieldNo, value) {\n    if (value !== undefined) {\n        const message = wrapField(type, value);\n        writer.tag(fieldNo, WireType.LengthDelimited).bytes(message.toBinary(options));\n    }\n}\nfunction writeScalar$1(writer, type, fieldNo, value, emitIntrinsicDefault) {\n    let [wireType, method, isIntrinsicDefault] = scalarTypeInfo(type, value);\n    if (!isIntrinsicDefault || emitIntrinsicDefault) {\n        writer.tag(fieldNo, wireType)[method](value);\n    }\n}\nfunction writePacked(writer, type, fieldNo, value) {\n    if (!value.length) {\n        return;\n    }\n    writer.tag(fieldNo, WireType.LengthDelimited).fork();\n    let [, method] = scalarTypeInfo(type);\n    for(let i = 0; i < value.length; i++){\n        writer[method](value[i]);\n    }\n    writer.join();\n}\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/* eslint-disable @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-argument, @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unnecessary-condition, @typescript-eslint/strict-boolean-expressions, prefer-const, no-case-declarations */ function makeBinaryFormatProto3() {\n    return Object.assign(Object.assign({}, makeBinaryFormatCommon()), {\n        writeMessage (message, writer, options) {\n            const type = message.getType();\n            for (const field of type.fields.byNumber()){\n                let value, // this will be our field value, whether it is member of a oneof or regular field\n                repeated = field.repeated, localName = field.localName;\n                if (field.oneof) {\n                    const oneof = message[field.oneof.localName];\n                    if (oneof.case !== localName) {\n                        continue; // field is not selected, skip\n                    }\n                    value = oneof.value;\n                } else {\n                    value = message[localName];\n                }\n                switch(field.kind){\n                    case \"scalar\":\n                    case \"enum\":\n                        let scalarType = field.kind == \"enum\" ? ScalarType.INT32 : field.T;\n                        if (repeated) {\n                            if (field.packed) {\n                                writePacked(writer, scalarType, field.no, value);\n                            } else {\n                                for (const item of value){\n                                    writeScalar$1(writer, scalarType, field.no, item, true);\n                                }\n                            }\n                        } else {\n                            if (value !== undefined) {\n                                writeScalar$1(writer, scalarType, field.no, value, !!field.oneof || field.opt);\n                            }\n                        }\n                        break;\n                    case \"message\":\n                        if (repeated) {\n                            for (const item of value){\n                                writeMessageField(writer, options, field.T, field.no, item);\n                            }\n                        } else {\n                            writeMessageField(writer, options, field.T, field.no, value);\n                        }\n                        break;\n                    case \"map\":\n                        for (const [key, val] of Object.entries(value)){\n                            writeMapEntry(writer, options, field, key, val);\n                        }\n                        break;\n                }\n            }\n            if (options.writeUnknownFields) {\n                this.writeUnknownFields(message, writer);\n            }\n            return writer;\n        }\n    });\n}\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/* eslint-disable @typescript-eslint/ban-ts-comment, @typescript-eslint/no-unnecessary-condition, prefer-const */ // lookup table from base64 character to byte\nlet encTable = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\".split(\"\");\n// lookup table from base64 character *code* to byte because lookup by number is fast\nlet decTable = [];\nfor(let i = 0; i < encTable.length; i++)decTable[encTable[i].charCodeAt(0)] = i;\n// support base64url variants\ndecTable[\"-\".charCodeAt(0)] = encTable.indexOf(\"+\");\ndecTable[\"_\".charCodeAt(0)] = encTable.indexOf(\"/\");\nconst protoBase64 = {\n    /**\n   * Decodes a base64 string to a byte array.\n   *\n   * - ignores white-space, including line breaks and tabs\n   * - allows inner padding (can decode concatenated base64 strings)\n   * - does not require padding\n   * - understands base64url encoding:\n   *   \"-\" instead of \"+\",\n   *   \"_\" instead of \"/\",\n   *   no padding\n   */ dec (base64Str) {\n        // estimate byte size, not accounting for inner padding and whitespace\n        let es = base64Str.length * 3 / 4;\n        if (base64Str[base64Str.length - 2] == \"=\") es -= 2;\n        else if (base64Str[base64Str.length - 1] == \"=\") es -= 1;\n        let bytes = new Uint8Array(es), bytePos = 0, // position in byte array\n        groupPos = 0, // position in base64 group\n        b, // current byte\n        p = 0; // previous byte\n        for(let i = 0; i < base64Str.length; i++){\n            b = decTable[base64Str.charCodeAt(i)];\n            if (b === undefined) {\n                switch(base64Str[i]){\n                    // @ts-ignore TS7029: Fallthrough case in switch\n                    case \"=\":\n                        groupPos = 0;\n                    // reset state when padding found\n                    // @ts-ignore TS7029: Fallthrough case in switch\n                    case \"\\n\":\n                    case \"\\r\":\n                    case \"\\t\":\n                    case \" \":\n                        continue;\n                    // skip white-space, and padding\n                    default:\n                        throw Error(\"invalid base64 string.\");\n                }\n            }\n            switch(groupPos){\n                case 0:\n                    p = b;\n                    groupPos = 1;\n                    break;\n                case 1:\n                    bytes[bytePos++] = p << 2 | (b & 48) >> 4;\n                    p = b;\n                    groupPos = 2;\n                    break;\n                case 2:\n                    bytes[bytePos++] = (p & 15) << 4 | (b & 60) >> 2;\n                    p = b;\n                    groupPos = 3;\n                    break;\n                case 3:\n                    bytes[bytePos++] = (p & 3) << 6 | b;\n                    groupPos = 0;\n                    break;\n            }\n        }\n        if (groupPos == 1) throw Error(\"invalid base64 string.\");\n        return bytes.subarray(0, bytePos);\n    },\n    /**\n   * Encode a byte array to a base64 string.\n   */ enc (bytes) {\n        let base64 = \"\", groupPos = 0, // position in base64 group\n        b, // current byte\n        p = 0; // carry over from previous byte\n        for(let i = 0; i < bytes.length; i++){\n            b = bytes[i];\n            switch(groupPos){\n                case 0:\n                    base64 += encTable[b >> 2];\n                    p = (b & 3) << 4;\n                    groupPos = 1;\n                    break;\n                case 1:\n                    base64 += encTable[p | b >> 4];\n                    p = (b & 15) << 2;\n                    groupPos = 2;\n                    break;\n                case 2:\n                    base64 += encTable[p | b >> 6];\n                    base64 += encTable[b & 63];\n                    groupPos = 0;\n                    break;\n            }\n        }\n        // add output padding\n        if (groupPos) {\n            base64 += encTable[p];\n            base64 += \"=\";\n            if (groupPos == 1) base64 += \"=\";\n        }\n        return base64;\n    }\n};\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/* eslint-disable no-case-declarations, @typescript-eslint/restrict-plus-operands,@typescript-eslint/no-explicit-any,@typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-unsafe-call,@typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-argument */ // Default options for parsing JSON.\nconst jsonReadDefaults = {\n    ignoreUnknownFields: false\n};\n// Default options for serializing to JSON.\nconst jsonWriteDefaults = {\n    emitDefaultValues: false,\n    enumAsInteger: false,\n    useProtoFieldName: false,\n    prettySpaces: 0\n};\nfunction makeReadOptions(options) {\n    return options ? Object.assign(Object.assign({}, jsonReadDefaults), options) : jsonReadDefaults;\n}\nfunction makeWriteOptions(options) {\n    return options ? Object.assign(Object.assign({}, jsonWriteDefaults), options) : jsonWriteDefaults;\n}\nfunction makeJsonFormatCommon(makeWriteField) {\n    const writeField = makeWriteField(writeEnum, writeScalar);\n    return {\n        makeReadOptions,\n        makeWriteOptions,\n        readMessage (type, json, options, message) {\n            if (json == null || Array.isArray(json) || typeof json != \"object\") {\n                throw new Error(\"cannot decode message \".concat(type.typeName, \" from JSON: \").concat(this.debug(json)));\n            }\n            message = message !== null && message !== void 0 ? message : new type();\n            const oneofSeen = {};\n            for (const [jsonKey, jsonValue] of Object.entries(json)){\n                const field = type.fields.findJsonName(jsonKey);\n                if (!field) {\n                    if (!options.ignoreUnknownFields) {\n                        throw new Error(\"cannot decode message \".concat(type.typeName, \" from JSON: key \\\"\").concat(jsonKey, \"\\\" is unknown\"));\n                    }\n                    continue;\n                }\n                let localName = field.localName;\n                let target = message;\n                if (field.oneof) {\n                    if (jsonValue === null && field.kind == \"scalar\") {\n                        continue;\n                    }\n                    const seen = oneofSeen[field.oneof.localName];\n                    if (seen) {\n                        throw new Error(\"cannot decode message \".concat(type.typeName, \" from JSON: multiple keys for oneof \\\"\").concat(field.oneof.name, \"\\\" present: \\\"\").concat(seen, \"\\\", \\\"\").concat(jsonKey, \"\\\"\"));\n                    }\n                    oneofSeen[field.oneof.localName] = jsonKey;\n                    target = target[field.oneof.localName] = {\n                        case: localName\n                    };\n                    localName = \"value\";\n                }\n                if (field.repeated) {\n                    if (jsonValue === null) {\n                        continue;\n                    }\n                    if (!Array.isArray(jsonValue)) {\n                        throw new Error(\"cannot decode field \".concat(type.typeName, \".\").concat(field.name, \" from JSON: \").concat(this.debug(jsonValue)));\n                    }\n                    const targetArray = target[localName];\n                    for (const jsonItem of jsonValue){\n                        if (jsonItem === null) {\n                            throw new Error(\"cannot decode field \".concat(type.typeName, \".\").concat(field.name, \" from JSON: \").concat(this.debug(jsonItem)));\n                        }\n                        let val;\n                        // eslint-disable-next-line @typescript-eslint/switch-exhaustiveness-check -- \"map\" is invalid for repeated fields\n                        switch(field.kind){\n                            case \"message\":\n                                val = field.T.fromJson(jsonItem, options);\n                                break;\n                            case \"enum\":\n                                val = readEnum(field.T, jsonItem, options.ignoreUnknownFields);\n                                if (val === undefined) continue;\n                                break;\n                            case \"scalar\":\n                                try {\n                                    val = readScalar(field.T, jsonItem, field.L);\n                                } catch (e) {\n                                    let m = \"cannot decode field \".concat(type.typeName, \".\").concat(field.name, \" from JSON: \").concat(this.debug(jsonItem));\n                                    if (e instanceof Error && e.message.length > 0) {\n                                        m += \": \".concat(e.message);\n                                    }\n                                    throw new Error(m);\n                                }\n                                break;\n                        }\n                        targetArray.push(val);\n                    }\n                } else if (field.kind == \"map\") {\n                    if (jsonValue === null) {\n                        continue;\n                    }\n                    if (Array.isArray(jsonValue) || typeof jsonValue != \"object\") {\n                        throw new Error(\"cannot decode field \".concat(type.typeName, \".\").concat(field.name, \" from JSON: \").concat(this.debug(jsonValue)));\n                    }\n                    const targetMap = target[localName];\n                    for (const [jsonMapKey, jsonMapValue] of Object.entries(jsonValue)){\n                        if (jsonMapValue === null) {\n                            throw new Error(\"cannot decode field \".concat(type.typeName, \".\").concat(field.name, \" from JSON: map value null\"));\n                        }\n                        let val;\n                        switch(field.V.kind){\n                            case \"message\":\n                                val = field.V.T.fromJson(jsonMapValue, options);\n                                break;\n                            case \"enum\":\n                                val = readEnum(field.V.T, jsonMapValue, options.ignoreUnknownFields);\n                                if (val === undefined) continue;\n                                break;\n                            case \"scalar\":\n                                try {\n                                    val = readScalar(field.V.T, jsonMapValue, LongType.BIGINT);\n                                } catch (e) {\n                                    let m = \"cannot decode map value for field \".concat(type.typeName, \".\").concat(field.name, \" from JSON: \").concat(this.debug(jsonValue));\n                                    if (e instanceof Error && e.message.length > 0) {\n                                        m += \": \".concat(e.message);\n                                    }\n                                    throw new Error(m);\n                                }\n                                break;\n                        }\n                        try {\n                            targetMap[readScalar(field.K, field.K == ScalarType.BOOL ? jsonMapKey == \"true\" ? true : jsonMapKey == \"false\" ? false : jsonMapKey : jsonMapKey, LongType.BIGINT).toString()] = val;\n                        } catch (e) {\n                            let m = \"cannot decode map key for field \".concat(type.typeName, \".\").concat(field.name, \" from JSON: \").concat(this.debug(jsonValue));\n                            if (e instanceof Error && e.message.length > 0) {\n                                m += \": \".concat(e.message);\n                            }\n                            throw new Error(m);\n                        }\n                    }\n                } else {\n                    switch(field.kind){\n                        case \"message\":\n                            const messageType = field.T;\n                            if (jsonValue === null && messageType.typeName != \"google.protobuf.Value\") {\n                                if (field.oneof) {\n                                    throw new Error(\"cannot decode field \".concat(type.typeName, \".\").concat(field.name, \" from JSON: null is invalid for oneof field \\\"\").concat(jsonKey, \"\\\"\"));\n                                }\n                                continue;\n                            }\n                            if (target[localName] instanceof Message) {\n                                target[localName].fromJson(jsonValue, options);\n                            } else {\n                                target[localName] = messageType.fromJson(jsonValue, options);\n                                if (messageType.fieldWrapper && !field.oneof) {\n                                    target[localName] = messageType.fieldWrapper.unwrapField(target[localName]);\n                                }\n                            }\n                            break;\n                        case \"enum\":\n                            const enumValue = readEnum(field.T, jsonValue, options.ignoreUnknownFields);\n                            if (enumValue !== undefined) {\n                                target[localName] = enumValue;\n                            }\n                            break;\n                        case \"scalar\":\n                            try {\n                                target[localName] = readScalar(field.T, jsonValue, field.L);\n                            } catch (e) {\n                                let m = \"cannot decode field \".concat(type.typeName, \".\").concat(field.name, \" from JSON: \").concat(this.debug(jsonValue));\n                                if (e instanceof Error && e.message.length > 0) {\n                                    m += \": \".concat(e.message);\n                                }\n                                throw new Error(m);\n                            }\n                            break;\n                    }\n                }\n            }\n            return message;\n        },\n        writeMessage (message, options) {\n            const type = message.getType();\n            const json = {};\n            let field;\n            try {\n                for (const member of type.fields.byMember()){\n                    let jsonValue;\n                    if (member.kind == \"oneof\") {\n                        const oneof = message[member.localName];\n                        if (oneof.value === undefined) {\n                            continue;\n                        }\n                        field = member.findField(oneof.case);\n                        if (!field) {\n                            throw \"oneof case not found: \" + oneof.case;\n                        }\n                        jsonValue = writeField(field, oneof.value, options);\n                    } else {\n                        field = member;\n                        jsonValue = writeField(field, message[field.localName], options);\n                    }\n                    if (jsonValue !== undefined) {\n                        json[options.useProtoFieldName ? field.name : field.jsonName] = jsonValue;\n                    }\n                }\n            } catch (e) {\n                const m = field ? \"cannot encode field \".concat(type.typeName, \".\").concat(field.name, \" to JSON\") : \"cannot encode message \".concat(type.typeName, \" to JSON\");\n                const r = e instanceof Error ? e.message : String(e);\n                throw new Error(m + (r.length > 0 ? \": \".concat(r) : \"\"));\n            }\n            return json;\n        },\n        readScalar,\n        writeScalar,\n        debug: debugJsonValue\n    };\n}\nfunction debugJsonValue(json) {\n    if (json === null) {\n        return \"null\";\n    }\n    switch(typeof json){\n        case \"object\":\n            return Array.isArray(json) ? \"array\" : \"object\";\n        case \"string\":\n            return json.length > 100 ? \"string\" : \"\\\"\".concat(json.split('\"').join('\\\\\"'), \"\\\"\");\n        default:\n            return String(json);\n    }\n}\n// May throw an error. If the error message is non-blank, it should be shown.\n// It is up to the caller to provide context.\nfunction readScalar(type, json, longType) {\n    // every valid case in the switch below returns, and every fall\n    // through is regarded as a failure.\n    switch(type){\n        // float, double: JSON value will be a number or one of the special string values \"NaN\", \"Infinity\", and \"-Infinity\".\n        // Either numbers or strings are accepted. Exponent notation is also accepted.\n        case ScalarType.DOUBLE:\n        case ScalarType.FLOAT:\n            if (json === null) return 0.0;\n            if (json === \"NaN\") return Number.NaN;\n            if (json === \"Infinity\") return Number.POSITIVE_INFINITY;\n            if (json === \"-Infinity\") return Number.NEGATIVE_INFINITY;\n            if (json === \"\") {\n                break;\n            }\n            if (typeof json == \"string\" && json.trim().length !== json.length) {\n                break;\n            }\n            if (typeof json != \"string\" && typeof json != \"number\") {\n                break;\n            }\n            const float = Number(json);\n            if (Number.isNaN(float)) {\n                break;\n            }\n            if (!Number.isFinite(float)) {\n                break;\n            }\n            if (type == ScalarType.FLOAT) assertFloat32(float);\n            return float;\n        // int32, fixed32, uint32: JSON value will be a decimal number. Either numbers or strings are accepted.\n        case ScalarType.INT32:\n        case ScalarType.FIXED32:\n        case ScalarType.SFIXED32:\n        case ScalarType.SINT32:\n        case ScalarType.UINT32:\n            if (json === null) return 0;\n            let int32;\n            if (typeof json == \"number\") int32 = json;\n            else if (typeof json == \"string\" && json.length > 0) {\n                if (json.trim().length === json.length) int32 = Number(json);\n            }\n            if (int32 === undefined) break;\n            if (type == ScalarType.UINT32) assertUInt32(int32);\n            else assertInt32(int32);\n            return int32;\n        // int64, fixed64, uint64: JSON value will be a decimal string. Either numbers or strings are accepted.\n        case ScalarType.INT64:\n        case ScalarType.SFIXED64:\n        case ScalarType.SINT64:\n            if (json === null) return protoInt64.zero;\n            if (typeof json != \"number\" && typeof json != \"string\") break;\n            const long = protoInt64.parse(json);\n            // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n            return longType ? long.toString() : long;\n        case ScalarType.FIXED64:\n        case ScalarType.UINT64:\n            if (json === null) return protoInt64.zero;\n            if (typeof json != \"number\" && typeof json != \"string\") break;\n            const uLong = protoInt64.uParse(json);\n            // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n            return longType ? uLong.toString() : uLong;\n        // bool:\n        case ScalarType.BOOL:\n            if (json === null) return false;\n            if (typeof json !== \"boolean\") break;\n            return json;\n        // string:\n        case ScalarType.STRING:\n            if (json === null) return \"\";\n            if (typeof json !== \"string\") {\n                break;\n            }\n            // A string must always contain UTF-8 encoded or 7-bit ASCII.\n            // We validate with encodeURIComponent, which appears to be the fastest widely available option.\n            try {\n                encodeURIComponent(json);\n            } catch (e) {\n                throw new Error(\"invalid UTF8\");\n            }\n            return json;\n        // bytes: JSON value will be the data encoded as a string using standard base64 encoding with paddings.\n        // Either standard or URL-safe base64 encoding with/without paddings are accepted.\n        case ScalarType.BYTES:\n            if (json === null || json === \"\") return new Uint8Array(0);\n            if (typeof json !== \"string\") break;\n            return protoBase64.dec(json);\n    }\n    throw new Error();\n}\nfunction readEnum(type, json, ignoreUnknownFields) {\n    if (json === null) {\n        // proto3 requires 0 to be default value for all enums\n        return 0;\n    }\n    // eslint-disable-next-line @typescript-eslint/switch-exhaustiveness-check\n    switch(typeof json){\n        case \"number\":\n            if (Number.isInteger(json)) {\n                return json;\n            }\n            break;\n        case \"string\":\n            const value = type.findName(json);\n            // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing\n            if (value || ignoreUnknownFields) {\n                return value === null || value === void 0 ? void 0 : value.no;\n            }\n            break;\n    }\n    throw new Error(\"cannot decode enum \".concat(type.typeName, \" from JSON: \").concat(debugJsonValue(json)));\n}\nfunction writeEnum(type, value, emitIntrinsicDefault, enumAsInteger) {\n    var _a;\n    if (value === undefined) {\n        return value;\n    }\n    if (value === 0 && !emitIntrinsicDefault) {\n        // proto3 requires 0 to be default value for all enums\n        return undefined;\n    }\n    if (enumAsInteger) {\n        return value;\n    }\n    if (type.typeName == \"google.protobuf.NullValue\") {\n        return null;\n    }\n    const val = type.findNumber(value);\n    return (_a = val === null || val === void 0 ? void 0 : val.name) !== null && _a !== void 0 ? _a : value; // if we don't know the enum value, just return the number\n}\nfunction writeScalar(type, value, emitIntrinsicDefault) {\n    if (value === undefined) {\n        return undefined;\n    }\n    switch(type){\n        // int32, fixed32, uint32: JSON value will be a decimal number. Either numbers or strings are accepted.\n        case ScalarType.INT32:\n        case ScalarType.SFIXED32:\n        case ScalarType.SINT32:\n        case ScalarType.FIXED32:\n        case ScalarType.UINT32:\n            assert(typeof value == \"number\");\n            return value != 0 || emitIntrinsicDefault ? value : undefined;\n        // float, double: JSON value will be a number or one of the special string values \"NaN\", \"Infinity\", and \"-Infinity\".\n        // Either numbers or strings are accepted. Exponent notation is also accepted.\n        case ScalarType.FLOAT:\n        // assertFloat32(value);\n        case ScalarType.DOUBLE:\n            // eslint-disable-line no-fallthrough\n            assert(typeof value == \"number\");\n            if (Number.isNaN(value)) return \"NaN\";\n            if (value === Number.POSITIVE_INFINITY) return \"Infinity\";\n            if (value === Number.NEGATIVE_INFINITY) return \"-Infinity\";\n            return value !== 0 || emitIntrinsicDefault ? value : undefined;\n        // string:\n        case ScalarType.STRING:\n            assert(typeof value == \"string\");\n            return value.length > 0 || emitIntrinsicDefault ? value : undefined;\n        // bool:\n        case ScalarType.BOOL:\n            assert(typeof value == \"boolean\");\n            return value || emitIntrinsicDefault ? value : undefined;\n        // JSON value will be a decimal string. Either numbers or strings are accepted.\n        case ScalarType.UINT64:\n        case ScalarType.FIXED64:\n        case ScalarType.INT64:\n        case ScalarType.SFIXED64:\n        case ScalarType.SINT64:\n            assert(typeof value == \"bigint\" || typeof value == \"string\" || typeof value == \"number\");\n            // We use implicit conversion with `value != 0` to catch both 0n and \"0\"\n            // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n            // @ts-ignore\n            return emitIntrinsicDefault || value != 0 ? value.toString(10) : undefined;\n        // bytes: JSON value will be the data encoded as a string using standard base64 encoding with paddings.\n        // Either standard or URL-safe base64 encoding with/without paddings are accepted.\n        case ScalarType.BYTES:\n            assert(value instanceof Uint8Array);\n            return emitIntrinsicDefault || value.byteLength > 0 ? protoBase64.enc(value) : undefined;\n    }\n}\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/* eslint-disable no-case-declarations, @typescript-eslint/restrict-plus-operands,@typescript-eslint/no-explicit-any,@typescript-eslint/no-unsafe-return,@typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-unsafe-call,@typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-argument */ function makeJsonFormatProto3() {\n    return makeJsonFormatCommon((writeEnum, writeScalar)=>{\n        return function writeField(field, value, options) {\n            if (field.kind == \"map\") {\n                const jsonObj = {};\n                switch(field.V.kind){\n                    case \"scalar\":\n                        for (const [entryKey, entryValue] of Object.entries(value)){\n                            const val = writeScalar(field.V.T, entryValue, true);\n                            assert(val !== undefined);\n                            jsonObj[entryKey.toString()] = val; // JSON standard allows only (double quoted) string as property key\n                        }\n                        break;\n                    case \"message\":\n                        for (const [entryKey, entryValue] of Object.entries(value)){\n                            // JSON standard allows only (double quoted) string as property key\n                            jsonObj[entryKey.toString()] = entryValue.toJson(options);\n                        }\n                        break;\n                    case \"enum\":\n                        const enumType = field.V.T;\n                        for (const [entryKey, entryValue] of Object.entries(value)){\n                            assert(entryValue === undefined || typeof entryValue == \"number\");\n                            const val = writeEnum(enumType, entryValue, true, options.enumAsInteger);\n                            assert(val !== undefined);\n                            jsonObj[entryKey.toString()] = val; // JSON standard allows only (double quoted) string as property key\n                        }\n                        break;\n                }\n                return options.emitDefaultValues || Object.keys(jsonObj).length > 0 ? jsonObj : undefined;\n            } else if (field.repeated) {\n                const jsonArr = [];\n                switch(field.kind){\n                    case \"scalar\":\n                        for(let i = 0; i < value.length; i++){\n                            jsonArr.push(writeScalar(field.T, value[i], true));\n                        }\n                        break;\n                    case \"enum\":\n                        for(let i = 0; i < value.length; i++){\n                            jsonArr.push(writeEnum(field.T, value[i], true, options.enumAsInteger));\n                        }\n                        break;\n                    case \"message\":\n                        for(let i = 0; i < value.length; i++){\n                            jsonArr.push(wrapField(field.T, value[i]).toJson(options));\n                        }\n                        break;\n                }\n                return options.emitDefaultValues || jsonArr.length > 0 ? jsonArr : undefined;\n            } else {\n                switch(field.kind){\n                    case \"scalar\":\n                        return writeScalar(field.T, value, !!field.oneof || field.opt || options.emitDefaultValues);\n                    case \"enum\":\n                        return writeEnum(field.T, value, !!field.oneof || field.opt || options.emitDefaultValues, options.enumAsInteger);\n                    case \"message\":\n                        return value !== undefined ? wrapField(field.T, value).toJson(options) : undefined;\n                }\n            }\n        };\n    });\n}\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/* eslint-disable @typescript-eslint/no-explicit-any,@typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-return,@typescript-eslint/no-unsafe-argument,no-case-declarations */ function makeUtilCommon() {\n    return {\n        setEnumType,\n        initPartial (source, target) {\n            if (source === undefined) {\n                return;\n            }\n            const type = target.getType();\n            for (const member of type.fields.byMember()){\n                const localName = member.localName, t = target, s = source;\n                if (s[localName] === undefined) {\n                    continue;\n                }\n                switch(member.kind){\n                    case \"oneof\":\n                        const sk = s[localName].case;\n                        if (sk === undefined) {\n                            continue;\n                        }\n                        const sourceField = member.findField(sk);\n                        let val = s[localName].value;\n                        if (sourceField && sourceField.kind == \"message\" && !(val instanceof sourceField.T)) {\n                            val = new sourceField.T(val);\n                        } else if (sourceField && sourceField.kind === \"scalar\" && sourceField.T === ScalarType.BYTES) {\n                            val = toU8Arr(val);\n                        }\n                        t[localName] = {\n                            case: sk,\n                            value: val\n                        };\n                        break;\n                    case \"scalar\":\n                    case \"enum\":\n                        let copy = s[localName];\n                        if (member.T === ScalarType.BYTES) {\n                            copy = member.repeated ? copy.map(toU8Arr) : toU8Arr(copy);\n                        }\n                        t[localName] = copy;\n                        break;\n                    case \"map\":\n                        switch(member.V.kind){\n                            case \"scalar\":\n                            case \"enum\":\n                                if (member.V.T === ScalarType.BYTES) {\n                                    for (const [k, v] of Object.entries(s[localName])){\n                                        t[localName][k] = toU8Arr(v);\n                                    }\n                                } else {\n                                    Object.assign(t[localName], s[localName]);\n                                }\n                                break;\n                            case \"message\":\n                                const messageType = member.V.T;\n                                for (const k of Object.keys(s[localName])){\n                                    let val = s[localName][k];\n                                    if (!messageType.fieldWrapper) {\n                                        // We only take partial input for messages that are not a wrapper type.\n                                        // For those messages, we recursively normalize the partial input.\n                                        val = new messageType(val);\n                                    }\n                                    t[localName][k] = val;\n                                }\n                                break;\n                        }\n                        break;\n                    case \"message\":\n                        const mt = member.T;\n                        if (member.repeated) {\n                            t[localName] = s[localName].map((val)=>val instanceof mt ? val : new mt(val));\n                        } else if (s[localName] !== undefined) {\n                            const val = s[localName];\n                            if (mt.fieldWrapper) {\n                                if (// We can't use BytesValue.typeName as that will create a circular import\n                                mt.typeName === \"google.protobuf.BytesValue\") {\n                                    t[localName] = toU8Arr(val);\n                                } else {\n                                    t[localName] = val;\n                                }\n                            } else {\n                                t[localName] = val instanceof mt ? val : new mt(val);\n                            }\n                        }\n                        break;\n                }\n            }\n        },\n        equals (type, a, b) {\n            if (a === b) {\n                return true;\n            }\n            if (!a || !b) {\n                return false;\n            }\n            return type.fields.byMember().every((m)=>{\n                const va = a[m.localName];\n                const vb = b[m.localName];\n                if (m.repeated) {\n                    if (va.length !== vb.length) {\n                        return false;\n                    }\n                    // eslint-disable-next-line @typescript-eslint/switch-exhaustiveness-check -- repeated fields are never \"map\"\n                    switch(m.kind){\n                        case \"message\":\n                            return va.every((a, i)=>m.T.equals(a, vb[i]));\n                        case \"scalar\":\n                            return va.every((a, i)=>scalarEquals(m.T, a, vb[i]));\n                        case \"enum\":\n                            return va.every((a, i)=>scalarEquals(ScalarType.INT32, a, vb[i]));\n                    }\n                    throw new Error(\"repeated cannot contain \".concat(m.kind));\n                }\n                switch(m.kind){\n                    case \"message\":\n                        return m.T.equals(va, vb);\n                    case \"enum\":\n                        return scalarEquals(ScalarType.INT32, va, vb);\n                    case \"scalar\":\n                        return scalarEquals(m.T, va, vb);\n                    case \"oneof\":\n                        if (va.case !== vb.case) {\n                            return false;\n                        }\n                        const s = m.findField(va.case);\n                        if (s === undefined) {\n                            return true;\n                        }\n                        // eslint-disable-next-line @typescript-eslint/switch-exhaustiveness-check -- oneof fields are never \"map\"\n                        switch(s.kind){\n                            case \"message\":\n                                return s.T.equals(va.value, vb.value);\n                            case \"enum\":\n                                return scalarEquals(ScalarType.INT32, va.value, vb.value);\n                            case \"scalar\":\n                                return scalarEquals(s.T, va.value, vb.value);\n                        }\n                        throw new Error(\"oneof cannot contain \".concat(s.kind));\n                    case \"map\":\n                        const keys = Object.keys(va).concat(Object.keys(vb));\n                        switch(m.V.kind){\n                            case \"message\":\n                                const messageType = m.V.T;\n                                return keys.every((k)=>messageType.equals(va[k], vb[k]));\n                            case \"enum\":\n                                return keys.every((k)=>scalarEquals(ScalarType.INT32, va[k], vb[k]));\n                            case \"scalar\":\n                                const scalarType = m.V.T;\n                                return keys.every((k)=>scalarEquals(scalarType, va[k], vb[k]));\n                        }\n                        break;\n                }\n            });\n        },\n        clone (message) {\n            const type = message.getType(), target = new type(), any = target;\n            for (const member of type.fields.byMember()){\n                const source = message[member.localName];\n                let copy;\n                if (member.repeated) {\n                    copy = source.map(cloneSingularField);\n                } else if (member.kind == \"map\") {\n                    copy = any[member.localName];\n                    for (const [key, v] of Object.entries(source)){\n                        copy[key] = cloneSingularField(v);\n                    }\n                } else if (member.kind == \"oneof\") {\n                    const f = member.findField(source.case);\n                    copy = f ? {\n                        case: source.case,\n                        value: cloneSingularField(source.value)\n                    } : {\n                        case: undefined\n                    };\n                } else {\n                    copy = cloneSingularField(source);\n                }\n                any[member.localName] = copy;\n            }\n            return target;\n        }\n    };\n}\n// clone a single field value - i.e. the element type of repeated fields, the value type of maps\nfunction cloneSingularField(value) {\n    if (value === undefined) {\n        return value;\n    }\n    if (value instanceof Message) {\n        return value.clone();\n    }\n    if (value instanceof Uint8Array) {\n        const c = new Uint8Array(value.byteLength);\n        c.set(value);\n        return c;\n    }\n    return value;\n}\n// converts any ArrayLike<number> to Uint8Array if necessary.\nfunction toU8Arr(input) {\n    return input instanceof Uint8Array ? input : new Uint8Array(input);\n}\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nclass InternalFieldList {\n    constructor(fields, normalizer){\n        this._fields = fields;\n        this._normalizer = normalizer;\n    }\n    findJsonName(jsonName) {\n        if (!this.jsonNames) {\n            const t = {};\n            for (const f of this.list()){\n                t[f.jsonName] = t[f.name] = f;\n            }\n            this.jsonNames = t;\n        }\n        return this.jsonNames[jsonName];\n    }\n    find(fieldNo) {\n        if (!this.numbers) {\n            const t = {};\n            for (const f of this.list()){\n                t[f.no] = f;\n            }\n            this.numbers = t;\n        }\n        return this.numbers[fieldNo];\n    }\n    list() {\n        if (!this.all) {\n            this.all = this._normalizer(this._fields);\n        }\n        return this.all;\n    }\n    byNumber() {\n        if (!this.numbersAsc) {\n            this.numbersAsc = this.list().concat().sort((a, b)=>a.no - b.no);\n        }\n        return this.numbersAsc;\n    }\n    byMember() {\n        if (!this.members) {\n            this.members = [];\n            const a = this.members;\n            let o;\n            for (const f of this.list()){\n                if (f.oneof) {\n                    if (f.oneof !== o) {\n                        o = f.oneof;\n                        a.push(o);\n                    }\n                } else {\n                    a.push(f);\n                }\n            }\n        }\n        return this.members;\n    }\n}\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Returns the name of a protobuf element in generated code.\n *\n * Field names - including oneofs - are converted to lowerCamelCase. For\n * messages, enumerations and services, the package name is stripped from\n * the type name. For nested messages and enumerations, the names are joined\n * with an underscore. For methods, the first character is made lowercase.\n */ /**\n * Returns the name of a field in generated code.\n */ function localFieldName(protoName, inOneof) {\n    const name = protoCamelCase(protoName);\n    if (inOneof) {\n        // oneof member names are not properties, but values of the `case` property.\n        return name;\n    }\n    return safeObjectProperty(safeMessageProperty(name));\n}\n/**\n * Returns the name of a oneof group in generated code.\n */ function localOneofName(protoName) {\n    return localFieldName(protoName, false);\n}\n/**\n * Returns the JSON name for a protobuf field, exactly like protoc does.\n */ const fieldJsonName = protoCamelCase;\n/**\n * Converts snake_case to protoCamelCase according to the convention\n * used by protoc to convert a field name to a JSON name.\n */ function protoCamelCase(snakeCase) {\n    let capNext = false;\n    const b = [];\n    for(let i = 0; i < snakeCase.length; i++){\n        let c = snakeCase.charAt(i);\n        switch(c){\n            case \"_\":\n                capNext = true;\n                break;\n            case \"0\":\n            case \"1\":\n            case \"2\":\n            case \"3\":\n            case \"4\":\n            case \"5\":\n            case \"6\":\n            case \"7\":\n            case \"8\":\n            case \"9\":\n                b.push(c);\n                capNext = false;\n                break;\n            default:\n                if (capNext) {\n                    capNext = false;\n                    c = c.toUpperCase();\n                }\n                b.push(c);\n                break;\n        }\n    }\n    return b.join(\"\");\n}\n/**\n * Names that cannot be used for object properties because they are reserved\n * by built-in JavaScript properties.\n */ const reservedObjectProperties = new Set([\n    // names reserved by JavaScript\n    \"constructor\",\n    \"toString\",\n    \"toJSON\",\n    \"valueOf\"\n]);\n/**\n * Names that cannot be used for object properties because they are reserved\n * by the runtime.\n */ const reservedMessageProperties = new Set([\n    // names reserved by the runtime\n    \"getType\",\n    \"clone\",\n    \"equals\",\n    \"fromBinary\",\n    \"fromJson\",\n    \"fromJsonString\",\n    \"toBinary\",\n    \"toJson\",\n    \"toJsonString\",\n    // names reserved by the runtime for the future\n    \"toObject\"\n]);\nconst fallback = (name)=>\"\".concat(name, \"$\");\n/**\n * Will wrap names that are Object prototype properties or names reserved\n * for `Message`s.\n */ const safeMessageProperty = (name)=>{\n    if (reservedMessageProperties.has(name)) {\n        return fallback(name);\n    }\n    return name;\n};\n/**\n * Names that cannot be used for object properties because they are reserved\n * by built-in JavaScript properties.\n */ const safeObjectProperty = (name)=>{\n    if (reservedObjectProperties.has(name)) {\n        return fallback(name);\n    }\n    return name;\n};\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nclass InternalOneofInfo {\n    constructor(name){\n        this.kind = \"oneof\";\n        this.repeated = false;\n        this.packed = false;\n        this.opt = false;\n        this.default = undefined;\n        this.fields = [];\n        this.name = name;\n        this.localName = localOneofName(name);\n    }\n    addField(field) {\n        assert(field.oneof === this, \"field \".concat(field.name, \" not one of \").concat(this.name));\n        this.fields.push(field);\n    }\n    findField(localName) {\n        if (!this._lookup) {\n            this._lookup = Object.create(null);\n            for(let i = 0; i < this.fields.length; i++){\n                this._lookup[this.fields[i].localName] = this.fields[i];\n            }\n        }\n        return this._lookup[localName];\n    }\n}\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Provides functionality for messages defined with the proto3 syntax.\n */ const proto3 = makeProtoRuntime(\"proto3\", makeJsonFormatProto3(), makeBinaryFormatProto3(), Object.assign(Object.assign({}, makeUtilCommon()), {\n    newFieldList (fields) {\n        return new InternalFieldList(fields, normalizeFieldInfosProto3);\n    },\n    initFields (target) {\n        for (const member of target.getType().fields.byMember()){\n            if (member.opt) {\n                continue;\n            }\n            const name = member.localName, t = target;\n            if (member.repeated) {\n                t[name] = [];\n                continue;\n            }\n            switch(member.kind){\n                case \"oneof\":\n                    t[name] = {\n                        case: undefined\n                    };\n                    break;\n                case \"enum\":\n                    t[name] = 0;\n                    break;\n                case \"map\":\n                    t[name] = {};\n                    break;\n                case \"scalar\":\n                    t[name] = scalarDefaultValue(member.T, member.L); // eslint-disable-line @typescript-eslint/no-unsafe-assignment\n                    break;\n            }\n        }\n    }\n}));\n/* eslint-disable @typescript-eslint/no-explicit-any,@typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-argument */ function normalizeFieldInfosProto3(fieldInfos) {\n    var _a, _b, _c, _d;\n    const r = [];\n    let o;\n    for (const field of typeof fieldInfos == \"function\" ? fieldInfos() : fieldInfos){\n        const f = field;\n        f.localName = localFieldName(field.name, field.oneof !== undefined);\n        f.jsonName = (_a = field.jsonName) !== null && _a !== void 0 ? _a : fieldJsonName(field.name);\n        f.repeated = (_b = field.repeated) !== null && _b !== void 0 ? _b : false;\n        if (field.kind == \"scalar\") {\n            f.L = (_c = field.L) !== null && _c !== void 0 ? _c : LongType.BIGINT;\n        }\n        // From the proto3 language guide:\n        // > In proto3, repeated fields of scalar numeric types are packed by default.\n        // This information is incomplete - according to the conformance tests, BOOL\n        // and ENUM are packed by default as well. This means only STRING and BYTES\n        // are not packed by default, which makes sense because they are length-delimited.\n        f.packed = (_d = field.packed) !== null && _d !== void 0 ? _d : field.kind == \"enum\" || field.kind == \"scalar\" && field.T != ScalarType.BYTES && field.T != ScalarType.STRING;\n        // We do not surface options at this time\n        // f.options = field.options ?? emptyReadonlyObject;\n        if (field.oneof !== undefined) {\n            const ooname = typeof field.oneof == \"string\" ? field.oneof : field.oneof.name;\n            if (!o || o.name != ooname) {\n                o = new InternalOneofInfo(ooname);\n            }\n            f.oneof = o;\n            o.addField(f);\n        }\n        r.push(f);\n    }\n    return r;\n}\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * A Timestamp represents a point in time independent of any time zone or local\n * calendar, encoded as a count of seconds and fractions of seconds at\n * nanosecond resolution. The count is relative to an epoch at UTC midnight on\n * January 1, 1970, in the proleptic Gregorian calendar which extends the\n * Gregorian calendar backwards to year one.\n *\n * All minutes are 60 seconds long. Leap seconds are \"smeared\" so that no leap\n * second table is needed for interpretation, using a [24-hour linear\n * smear](https://developers.google.com/time/smear).\n *\n * The range is from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59.999999999Z. By\n * restricting to that range, we ensure that we can convert to and from [RFC\n * 3339](https://www.ietf.org/rfc/rfc3339.txt) date strings.\n *\n * # Examples\n *\n * Example 1: Compute Timestamp from POSIX `time()`.\n *\n *     Timestamp timestamp;\n *     timestamp.set_seconds(time(NULL));\n *     timestamp.set_nanos(0);\n *\n * Example 2: Compute Timestamp from POSIX `gettimeofday()`.\n *\n *     struct timeval tv;\n *     gettimeofday(&tv, NULL);\n *\n *     Timestamp timestamp;\n *     timestamp.set_seconds(tv.tv_sec);\n *     timestamp.set_nanos(tv.tv_usec * 1000);\n *\n * Example 3: Compute Timestamp from Win32 `GetSystemTimeAsFileTime()`.\n *\n *     FILETIME ft;\n *     GetSystemTimeAsFileTime(&ft);\n *     UINT64 ticks = (((UINT64)ft.dwHighDateTime) << 32) | ft.dwLowDateTime;\n *\n *     // A Windows tick is 100 nanoseconds. Windows epoch 1601-01-01T00:00:00Z\n *     // is 11644473600 seconds before Unix epoch 1970-01-01T00:00:00Z.\n *     Timestamp timestamp;\n *     timestamp.set_seconds((INT64) ((ticks / 10000000) - 11644473600LL));\n *     timestamp.set_nanos((INT32) ((ticks % 10000000) * 100));\n *\n * Example 4: Compute Timestamp from Java `System.currentTimeMillis()`.\n *\n *     long millis = System.currentTimeMillis();\n *\n *     Timestamp timestamp = Timestamp.newBuilder().setSeconds(millis / 1000)\n *         .setNanos((int) ((millis % 1000) * 1000000)).build();\n *\n * Example 5: Compute Timestamp from Java `Instant.now()`.\n *\n *     Instant now = Instant.now();\n *\n *     Timestamp timestamp =\n *         Timestamp.newBuilder().setSeconds(now.getEpochSecond())\n *             .setNanos(now.getNano()).build();\n *\n * Example 6: Compute Timestamp from current time in Python.\n *\n *     timestamp = Timestamp()\n *     timestamp.GetCurrentTime()\n *\n * # JSON Mapping\n *\n * In JSON format, the Timestamp type is encoded as a string in the\n * [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) format. That is, the\n * format is \"{year}-{month}-{day}T{hour}:{min}:{sec}[.{frac_sec}]Z\"\n * where {year} is always expressed using four digits while {month}, {day},\n * {hour}, {min}, and {sec} are zero-padded to two digits each. The fractional\n * seconds, which can go up to 9 digits (i.e. up to 1 nanosecond resolution),\n * are optional. The \"Z\" suffix indicates the timezone (\"UTC\"); the timezone\n * is required. A proto3 JSON serializer should always use UTC (as indicated by\n * \"Z\") when printing the Timestamp type and a proto3 JSON parser should be\n * able to accept both UTC and other timezones (as indicated by an offset).\n *\n * For example, \"2017-01-15T01:30:15.01Z\" encodes 15.01 seconds past\n * 01:30 UTC on January 15, 2017.\n *\n * In JavaScript, one can convert a Date object to this format using the\n * standard\n * [toISOString()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toISOString)\n * method. In Python, a standard `datetime.datetime` object can be converted\n * to this format using\n * [`strftime`](https://docs.python.org/2/library/time.html#time.strftime) with\n * the time format spec '%Y-%m-%dT%H:%M:%S.%fZ'. Likewise, in Java, one can use\n * the Joda Time's [`ISODateTimeFormat.dateTime()`](\n * http://joda-time.sourceforge.net/apidocs/org/joda/time/format/ISODateTimeFormat.html#dateTime()\n * ) to obtain a formatter capable of generating timestamps in this format.\n *\n *\n * @generated from message google.protobuf.Timestamp\n */ class Timestamp extends Message {\n    constructor(data){\n        super();\n        /**\n     * Represents seconds of UTC time since Unix epoch\n     * 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to\n     * 9999-12-31T23:59:59Z inclusive.\n     *\n     * @generated from field: int64 seconds = 1;\n     */ this.seconds = protoInt64.zero;\n        /**\n     * Non-negative fractions of a second at nanosecond resolution. Negative\n     * second values with fractions must still have non-negative nanos values\n     * that count forward in time. Must be from 0 to 999,999,999\n     * inclusive.\n     *\n     * @generated from field: int32 nanos = 2;\n     */ this.nanos = 0;\n        proto3.util.initPartial(data, this);\n    }\n    fromJson(json, options) {\n        if (typeof json !== \"string\") {\n            throw new Error(\"cannot decode google.protobuf.Timestamp from JSON: \".concat(proto3.json.debug(json)));\n        }\n        const matches = json.match(/^([0-9]{4})-([0-9]{2})-([0-9]{2})T([0-9]{2}):([0-9]{2}):([0-9]{2})(?:Z|\\.([0-9]{3,9})Z|([+-][0-9][0-9]:[0-9][0-9]))$/);\n        if (!matches) {\n            throw new Error(\"cannot decode google.protobuf.Timestamp from JSON: invalid RFC 3339 string\");\n        }\n        const ms = Date.parse(matches[1] + \"-\" + matches[2] + \"-\" + matches[3] + \"T\" + matches[4] + \":\" + matches[5] + \":\" + matches[6] + (matches[8] ? matches[8] : \"Z\"));\n        if (Number.isNaN(ms)) {\n            throw new Error(\"cannot decode google.protobuf.Timestamp from JSON: invalid RFC 3339 string\");\n        }\n        if (ms < Date.parse(\"0001-01-01T00:00:00Z\") || ms > Date.parse(\"9999-12-31T23:59:59Z\")) {\n            throw new Error(\"cannot decode message google.protobuf.Timestamp from JSON: must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive\");\n        }\n        this.seconds = protoInt64.parse(ms / 1000);\n        this.nanos = 0;\n        if (matches[7]) {\n            this.nanos = parseInt(\"1\" + matches[7] + \"0\".repeat(9 - matches[7].length)) - 1000000000;\n        }\n        return this;\n    }\n    toJson(options) {\n        const ms = Number(this.seconds) * 1000;\n        if (ms < Date.parse(\"0001-01-01T00:00:00Z\") || ms > Date.parse(\"9999-12-31T23:59:59Z\")) {\n            throw new Error(\"cannot encode google.protobuf.Timestamp to JSON: must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive\");\n        }\n        if (this.nanos < 0) {\n            throw new Error(\"cannot encode google.protobuf.Timestamp to JSON: nanos must not be negative\");\n        }\n        let z = \"Z\";\n        if (this.nanos > 0) {\n            const nanosStr = (this.nanos + 1000000000).toString().substring(1);\n            if (nanosStr.substring(3) === \"000000\") {\n                z = \".\" + nanosStr.substring(0, 3) + \"Z\";\n            } else if (nanosStr.substring(6) === \"000\") {\n                z = \".\" + nanosStr.substring(0, 6) + \"Z\";\n            } else {\n                z = \".\" + nanosStr + \"Z\";\n            }\n        }\n        return new Date(ms).toISOString().replace(\".000Z\", z);\n    }\n    toDate() {\n        return new Date(Number(this.seconds) * 1000 + Math.ceil(this.nanos / 1000000));\n    }\n    static now() {\n        return Timestamp.fromDate(new Date());\n    }\n    static fromDate(date) {\n        const ms = date.getTime();\n        return new Timestamp({\n            seconds: protoInt64.parse(Math.floor(ms / 1000)),\n            nanos: ms % 1000 * 1000000\n        });\n    }\n    static fromBinary(bytes, options) {\n        return new Timestamp().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new Timestamp().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new Timestamp().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(Timestamp, a, b);\n    }\n}\nTimestamp.runtime = proto3;\nTimestamp.typeName = \"google.protobuf.Timestamp\";\nTimestamp.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"seconds\",\n            kind: \"scalar\",\n            T: 3 /* ScalarType.INT64 */ \n        },\n        {\n            no: 2,\n            name: \"nanos\",\n            kind: \"scalar\",\n            T: 5 /* ScalarType.INT32 */ \n        }\n    ]);\n// Copyright 2023 LiveKit, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * @generated from enum livekit.AudioCodec\n */ var AudioCodec;\n(function(AudioCodec) {\n    /**\n   * @generated from enum value: DEFAULT_AC = 0;\n   */ AudioCodec[AudioCodec[\"DEFAULT_AC\"] = 0] = \"DEFAULT_AC\";\n    /**\n   * @generated from enum value: OPUS = 1;\n   */ AudioCodec[AudioCodec[\"OPUS\"] = 1] = \"OPUS\";\n    /**\n   * @generated from enum value: AAC = 2;\n   */ AudioCodec[AudioCodec[\"AAC\"] = 2] = \"AAC\";\n})(AudioCodec || (AudioCodec = {}));\n// Retrieve enum metadata with: proto3.getEnumType(AudioCodec)\nproto3.util.setEnumType(AudioCodec, \"livekit.AudioCodec\", [\n    {\n        no: 0,\n        name: \"DEFAULT_AC\"\n    },\n    {\n        no: 1,\n        name: \"OPUS\"\n    },\n    {\n        no: 2,\n        name: \"AAC\"\n    }\n]);\n/**\n * @generated from enum livekit.VideoCodec\n */ var VideoCodec;\n(function(VideoCodec) {\n    /**\n   * @generated from enum value: DEFAULT_VC = 0;\n   */ VideoCodec[VideoCodec[\"DEFAULT_VC\"] = 0] = \"DEFAULT_VC\";\n    /**\n   * @generated from enum value: H264_BASELINE = 1;\n   */ VideoCodec[VideoCodec[\"H264_BASELINE\"] = 1] = \"H264_BASELINE\";\n    /**\n   * @generated from enum value: H264_MAIN = 2;\n   */ VideoCodec[VideoCodec[\"H264_MAIN\"] = 2] = \"H264_MAIN\";\n    /**\n   * @generated from enum value: H264_HIGH = 3;\n   */ VideoCodec[VideoCodec[\"H264_HIGH\"] = 3] = \"H264_HIGH\";\n    /**\n   * @generated from enum value: VP8 = 4;\n   */ VideoCodec[VideoCodec[\"VP8\"] = 4] = \"VP8\";\n})(VideoCodec || (VideoCodec = {}));\n// Retrieve enum metadata with: proto3.getEnumType(VideoCodec)\nproto3.util.setEnumType(VideoCodec, \"livekit.VideoCodec\", [\n    {\n        no: 0,\n        name: \"DEFAULT_VC\"\n    },\n    {\n        no: 1,\n        name: \"H264_BASELINE\"\n    },\n    {\n        no: 2,\n        name: \"H264_MAIN\"\n    },\n    {\n        no: 3,\n        name: \"H264_HIGH\"\n    },\n    {\n        no: 4,\n        name: \"VP8\"\n    }\n]);\n/**\n * @generated from enum livekit.ImageCodec\n */ var ImageCodec;\n(function(ImageCodec) {\n    /**\n   * @generated from enum value: IC_DEFAULT = 0;\n   */ ImageCodec[ImageCodec[\"IC_DEFAULT\"] = 0] = \"IC_DEFAULT\";\n    /**\n   * @generated from enum value: IC_JPEG = 1;\n   */ ImageCodec[ImageCodec[\"IC_JPEG\"] = 1] = \"IC_JPEG\";\n})(ImageCodec || (ImageCodec = {}));\n// Retrieve enum metadata with: proto3.getEnumType(ImageCodec)\nproto3.util.setEnumType(ImageCodec, \"livekit.ImageCodec\", [\n    {\n        no: 0,\n        name: \"IC_DEFAULT\"\n    },\n    {\n        no: 1,\n        name: \"IC_JPEG\"\n    }\n]);\n/**\n * @generated from enum livekit.TrackType\n */ var TrackType;\n(function(TrackType) {\n    /**\n   * @generated from enum value: AUDIO = 0;\n   */ TrackType[TrackType[\"AUDIO\"] = 0] = \"AUDIO\";\n    /**\n   * @generated from enum value: VIDEO = 1;\n   */ TrackType[TrackType[\"VIDEO\"] = 1] = \"VIDEO\";\n    /**\n   * @generated from enum value: DATA = 2;\n   */ TrackType[TrackType[\"DATA\"] = 2] = \"DATA\";\n})(TrackType || (TrackType = {}));\n// Retrieve enum metadata with: proto3.getEnumType(TrackType)\nproto3.util.setEnumType(TrackType, \"livekit.TrackType\", [\n    {\n        no: 0,\n        name: \"AUDIO\"\n    },\n    {\n        no: 1,\n        name: \"VIDEO\"\n    },\n    {\n        no: 2,\n        name: \"DATA\"\n    }\n]);\n/**\n * @generated from enum livekit.TrackSource\n */ var TrackSource;\n(function(TrackSource) {\n    /**\n   * @generated from enum value: UNKNOWN = 0;\n   */ TrackSource[TrackSource[\"UNKNOWN\"] = 0] = \"UNKNOWN\";\n    /**\n   * @generated from enum value: CAMERA = 1;\n   */ TrackSource[TrackSource[\"CAMERA\"] = 1] = \"CAMERA\";\n    /**\n   * @generated from enum value: MICROPHONE = 2;\n   */ TrackSource[TrackSource[\"MICROPHONE\"] = 2] = \"MICROPHONE\";\n    /**\n   * @generated from enum value: SCREEN_SHARE = 3;\n   */ TrackSource[TrackSource[\"SCREEN_SHARE\"] = 3] = \"SCREEN_SHARE\";\n    /**\n   * @generated from enum value: SCREEN_SHARE_AUDIO = 4;\n   */ TrackSource[TrackSource[\"SCREEN_SHARE_AUDIO\"] = 4] = \"SCREEN_SHARE_AUDIO\";\n})(TrackSource || (TrackSource = {}));\n// Retrieve enum metadata with: proto3.getEnumType(TrackSource)\nproto3.util.setEnumType(TrackSource, \"livekit.TrackSource\", [\n    {\n        no: 0,\n        name: \"UNKNOWN\"\n    },\n    {\n        no: 1,\n        name: \"CAMERA\"\n    },\n    {\n        no: 2,\n        name: \"MICROPHONE\"\n    },\n    {\n        no: 3,\n        name: \"SCREEN_SHARE\"\n    },\n    {\n        no: 4,\n        name: \"SCREEN_SHARE_AUDIO\"\n    }\n]);\n/**\n * @generated from enum livekit.VideoQuality\n */ var VideoQuality;\n(function(VideoQuality) {\n    /**\n   * @generated from enum value: LOW = 0;\n   */ VideoQuality[VideoQuality[\"LOW\"] = 0] = \"LOW\";\n    /**\n   * @generated from enum value: MEDIUM = 1;\n   */ VideoQuality[VideoQuality[\"MEDIUM\"] = 1] = \"MEDIUM\";\n    /**\n   * @generated from enum value: HIGH = 2;\n   */ VideoQuality[VideoQuality[\"HIGH\"] = 2] = \"HIGH\";\n    /**\n   * @generated from enum value: OFF = 3;\n   */ VideoQuality[VideoQuality[\"OFF\"] = 3] = \"OFF\";\n})(VideoQuality || (VideoQuality = {}));\n// Retrieve enum metadata with: proto3.getEnumType(VideoQuality)\nproto3.util.setEnumType(VideoQuality, \"livekit.VideoQuality\", [\n    {\n        no: 0,\n        name: \"LOW\"\n    },\n    {\n        no: 1,\n        name: \"MEDIUM\"\n    },\n    {\n        no: 2,\n        name: \"HIGH\"\n    },\n    {\n        no: 3,\n        name: \"OFF\"\n    }\n]);\n/**\n * @generated from enum livekit.ConnectionQuality\n */ var ConnectionQuality$1;\n(function(ConnectionQuality) {\n    /**\n   * @generated from enum value: POOR = 0;\n   */ ConnectionQuality[ConnectionQuality[\"POOR\"] = 0] = \"POOR\";\n    /**\n   * @generated from enum value: GOOD = 1;\n   */ ConnectionQuality[ConnectionQuality[\"GOOD\"] = 1] = \"GOOD\";\n    /**\n   * @generated from enum value: EXCELLENT = 2;\n   */ ConnectionQuality[ConnectionQuality[\"EXCELLENT\"] = 2] = \"EXCELLENT\";\n    /**\n   * @generated from enum value: LOST = 3;\n   */ ConnectionQuality[ConnectionQuality[\"LOST\"] = 3] = \"LOST\";\n})(ConnectionQuality$1 || (ConnectionQuality$1 = {}));\n// Retrieve enum metadata with: proto3.getEnumType(ConnectionQuality)\nproto3.util.setEnumType(ConnectionQuality$1, \"livekit.ConnectionQuality\", [\n    {\n        no: 0,\n        name: \"POOR\"\n    },\n    {\n        no: 1,\n        name: \"GOOD\"\n    },\n    {\n        no: 2,\n        name: \"EXCELLENT\"\n    },\n    {\n        no: 3,\n        name: \"LOST\"\n    }\n]);\n/**\n * @generated from enum livekit.ClientConfigSetting\n */ var ClientConfigSetting;\n(function(ClientConfigSetting) {\n    /**\n   * @generated from enum value: UNSET = 0;\n   */ ClientConfigSetting[ClientConfigSetting[\"UNSET\"] = 0] = \"UNSET\";\n    /**\n   * @generated from enum value: DISABLED = 1;\n   */ ClientConfigSetting[ClientConfigSetting[\"DISABLED\"] = 1] = \"DISABLED\";\n    /**\n   * @generated from enum value: ENABLED = 2;\n   */ ClientConfigSetting[ClientConfigSetting[\"ENABLED\"] = 2] = \"ENABLED\";\n})(ClientConfigSetting || (ClientConfigSetting = {}));\n// Retrieve enum metadata with: proto3.getEnumType(ClientConfigSetting)\nproto3.util.setEnumType(ClientConfigSetting, \"livekit.ClientConfigSetting\", [\n    {\n        no: 0,\n        name: \"UNSET\"\n    },\n    {\n        no: 1,\n        name: \"DISABLED\"\n    },\n    {\n        no: 2,\n        name: \"ENABLED\"\n    }\n]);\n/**\n * @generated from enum livekit.DisconnectReason\n */ var DisconnectReason;\n(function(DisconnectReason) {\n    /**\n   * @generated from enum value: UNKNOWN_REASON = 0;\n   */ DisconnectReason[DisconnectReason[\"UNKNOWN_REASON\"] = 0] = \"UNKNOWN_REASON\";\n    /**\n   * @generated from enum value: CLIENT_INITIATED = 1;\n   */ DisconnectReason[DisconnectReason[\"CLIENT_INITIATED\"] = 1] = \"CLIENT_INITIATED\";\n    /**\n   * @generated from enum value: DUPLICATE_IDENTITY = 2;\n   */ DisconnectReason[DisconnectReason[\"DUPLICATE_IDENTITY\"] = 2] = \"DUPLICATE_IDENTITY\";\n    /**\n   * @generated from enum value: SERVER_SHUTDOWN = 3;\n   */ DisconnectReason[DisconnectReason[\"SERVER_SHUTDOWN\"] = 3] = \"SERVER_SHUTDOWN\";\n    /**\n   * @generated from enum value: PARTICIPANT_REMOVED = 4;\n   */ DisconnectReason[DisconnectReason[\"PARTICIPANT_REMOVED\"] = 4] = \"PARTICIPANT_REMOVED\";\n    /**\n   * @generated from enum value: ROOM_DELETED = 5;\n   */ DisconnectReason[DisconnectReason[\"ROOM_DELETED\"] = 5] = \"ROOM_DELETED\";\n    /**\n   * @generated from enum value: STATE_MISMATCH = 6;\n   */ DisconnectReason[DisconnectReason[\"STATE_MISMATCH\"] = 6] = \"STATE_MISMATCH\";\n    /**\n   * @generated from enum value: JOIN_FAILURE = 7;\n   */ DisconnectReason[DisconnectReason[\"JOIN_FAILURE\"] = 7] = \"JOIN_FAILURE\";\n})(DisconnectReason || (DisconnectReason = {}));\n// Retrieve enum metadata with: proto3.getEnumType(DisconnectReason)\nproto3.util.setEnumType(DisconnectReason, \"livekit.DisconnectReason\", [\n    {\n        no: 0,\n        name: \"UNKNOWN_REASON\"\n    },\n    {\n        no: 1,\n        name: \"CLIENT_INITIATED\"\n    },\n    {\n        no: 2,\n        name: \"DUPLICATE_IDENTITY\"\n    },\n    {\n        no: 3,\n        name: \"SERVER_SHUTDOWN\"\n    },\n    {\n        no: 4,\n        name: \"PARTICIPANT_REMOVED\"\n    },\n    {\n        no: 5,\n        name: \"ROOM_DELETED\"\n    },\n    {\n        no: 6,\n        name: \"STATE_MISMATCH\"\n    },\n    {\n        no: 7,\n        name: \"JOIN_FAILURE\"\n    }\n]);\n/**\n * @generated from enum livekit.ReconnectReason\n */ var ReconnectReason;\n(function(ReconnectReason) {\n    /**\n   * @generated from enum value: RR_UNKNOWN = 0;\n   */ ReconnectReason[ReconnectReason[\"RR_UNKNOWN\"] = 0] = \"RR_UNKNOWN\";\n    /**\n   * @generated from enum value: RR_SIGNAL_DISCONNECTED = 1;\n   */ ReconnectReason[ReconnectReason[\"RR_SIGNAL_DISCONNECTED\"] = 1] = \"RR_SIGNAL_DISCONNECTED\";\n    /**\n   * @generated from enum value: RR_PUBLISHER_FAILED = 2;\n   */ ReconnectReason[ReconnectReason[\"RR_PUBLISHER_FAILED\"] = 2] = \"RR_PUBLISHER_FAILED\";\n    /**\n   * @generated from enum value: RR_SUBSCRIBER_FAILED = 3;\n   */ ReconnectReason[ReconnectReason[\"RR_SUBSCRIBER_FAILED\"] = 3] = \"RR_SUBSCRIBER_FAILED\";\n    /**\n   * @generated from enum value: RR_SWITCH_CANDIDATE = 4;\n   */ ReconnectReason[ReconnectReason[\"RR_SWITCH_CANDIDATE\"] = 4] = \"RR_SWITCH_CANDIDATE\";\n})(ReconnectReason || (ReconnectReason = {}));\n// Retrieve enum metadata with: proto3.getEnumType(ReconnectReason)\nproto3.util.setEnumType(ReconnectReason, \"livekit.ReconnectReason\", [\n    {\n        no: 0,\n        name: \"RR_UNKNOWN\"\n    },\n    {\n        no: 1,\n        name: \"RR_SIGNAL_DISCONNECTED\"\n    },\n    {\n        no: 2,\n        name: \"RR_PUBLISHER_FAILED\"\n    },\n    {\n        no: 3,\n        name: \"RR_SUBSCRIBER_FAILED\"\n    },\n    {\n        no: 4,\n        name: \"RR_SWITCH_CANDIDATE\"\n    }\n]);\n/**\n * @generated from enum livekit.SubscriptionError\n */ var SubscriptionError;\n(function(SubscriptionError) {\n    /**\n   * @generated from enum value: SE_UNKNOWN = 0;\n   */ SubscriptionError[SubscriptionError[\"SE_UNKNOWN\"] = 0] = \"SE_UNKNOWN\";\n    /**\n   * @generated from enum value: SE_CODEC_UNSUPPORTED = 1;\n   */ SubscriptionError[SubscriptionError[\"SE_CODEC_UNSUPPORTED\"] = 1] = \"SE_CODEC_UNSUPPORTED\";\n    /**\n   * @generated from enum value: SE_TRACK_NOTFOUND = 2;\n   */ SubscriptionError[SubscriptionError[\"SE_TRACK_NOTFOUND\"] = 2] = \"SE_TRACK_NOTFOUND\";\n})(SubscriptionError || (SubscriptionError = {}));\n// Retrieve enum metadata with: proto3.getEnumType(SubscriptionError)\nproto3.util.setEnumType(SubscriptionError, \"livekit.SubscriptionError\", [\n    {\n        no: 0,\n        name: \"SE_UNKNOWN\"\n    },\n    {\n        no: 1,\n        name: \"SE_CODEC_UNSUPPORTED\"\n    },\n    {\n        no: 2,\n        name: \"SE_TRACK_NOTFOUND\"\n    }\n]);\n/**\n * @generated from message livekit.Room\n */ let Room$1 = class Room extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: string sid = 1;\n     */ this.sid = \"\";\n        /**\n     * @generated from field: string name = 2;\n     */ this.name = \"\";\n        /**\n     * @generated from field: uint32 empty_timeout = 3;\n     */ this.emptyTimeout = 0;\n        /**\n     * @generated from field: uint32 max_participants = 4;\n     */ this.maxParticipants = 0;\n        /**\n     * @generated from field: int64 creation_time = 5;\n     */ this.creationTime = protoInt64.zero;\n        /**\n     * @generated from field: string turn_password = 6;\n     */ this.turnPassword = \"\";\n        /**\n     * @generated from field: repeated livekit.Codec enabled_codecs = 7;\n     */ this.enabledCodecs = [];\n        /**\n     * @generated from field: string metadata = 8;\n     */ this.metadata = \"\";\n        /**\n     * @generated from field: uint32 num_participants = 9;\n     */ this.numParticipants = 0;\n        /**\n     * @generated from field: uint32 num_publishers = 11;\n     */ this.numPublishers = 0;\n        /**\n     * @generated from field: bool active_recording = 10;\n     */ this.activeRecording = false;\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new Room().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new Room().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new Room().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(Room, a, b);\n    }\n};\nRoom$1.runtime = proto3;\nRoom$1.typeName = \"livekit.Room\";\nRoom$1.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"sid\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 2,\n            name: \"name\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 3,\n            name: \"empty_timeout\",\n            kind: \"scalar\",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 4,\n            name: \"max_participants\",\n            kind: \"scalar\",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 5,\n            name: \"creation_time\",\n            kind: \"scalar\",\n            T: 3 /* ScalarType.INT64 */ \n        },\n        {\n            no: 6,\n            name: \"turn_password\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 7,\n            name: \"enabled_codecs\",\n            kind: \"message\",\n            T: Codec,\n            repeated: true\n        },\n        {\n            no: 8,\n            name: \"metadata\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 9,\n            name: \"num_participants\",\n            kind: \"scalar\",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 11,\n            name: \"num_publishers\",\n            kind: \"scalar\",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 10,\n            name: \"active_recording\",\n            kind: \"scalar\",\n            T: 8 /* ScalarType.BOOL */ \n        }\n    ]);\n/**\n * @generated from message livekit.Codec\n */ class Codec extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: string mime = 1;\n     */ this.mime = \"\";\n        /**\n     * @generated from field: string fmtp_line = 2;\n     */ this.fmtpLine = \"\";\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new Codec().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new Codec().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new Codec().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(Codec, a, b);\n    }\n}\nCodec.runtime = proto3;\nCodec.typeName = \"livekit.Codec\";\nCodec.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"mime\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 2,\n            name: \"fmtp_line\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        }\n    ]);\n/**\n * @generated from message livekit.PlayoutDelay\n */ class PlayoutDelay extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: bool enabled = 1;\n     */ this.enabled = false;\n        /**\n     * @generated from field: uint32 min = 2;\n     */ this.min = 0;\n        /**\n     * @generated from field: uint32 max = 3;\n     */ this.max = 0;\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new PlayoutDelay().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new PlayoutDelay().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new PlayoutDelay().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(PlayoutDelay, a, b);\n    }\n}\nPlayoutDelay.runtime = proto3;\nPlayoutDelay.typeName = \"livekit.PlayoutDelay\";\nPlayoutDelay.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"enabled\",\n            kind: \"scalar\",\n            T: 8 /* ScalarType.BOOL */ \n        },\n        {\n            no: 2,\n            name: \"min\",\n            kind: \"scalar\",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 3,\n            name: \"max\",\n            kind: \"scalar\",\n            T: 13 /* ScalarType.UINT32 */ \n        }\n    ]);\n/**\n * @generated from message livekit.ParticipantPermission\n */ class ParticipantPermission extends Message {\n    constructor(data){\n        super();\n        /**\n     * allow participant to subscribe to other tracks in the room\n     *\n     * @generated from field: bool can_subscribe = 1;\n     */ this.canSubscribe = false;\n        /**\n     * allow participant to publish new tracks to room\n     *\n     * @generated from field: bool can_publish = 2;\n     */ this.canPublish = false;\n        /**\n     * allow participant to publish data\n     *\n     * @generated from field: bool can_publish_data = 3;\n     */ this.canPublishData = false;\n        /**\n     * sources that are allowed to be published\n     *\n     * @generated from field: repeated livekit.TrackSource can_publish_sources = 9;\n     */ this.canPublishSources = [];\n        /**\n     * indicates that it's hidden to others\n     *\n     * @generated from field: bool hidden = 7;\n     */ this.hidden = false;\n        /**\n     * indicates it's a recorder instance\n     *\n     * @generated from field: bool recorder = 8;\n     */ this.recorder = false;\n        /**\n     * indicates that participant can update own metadata\n     *\n     * @generated from field: bool can_update_metadata = 10;\n     */ this.canUpdateMetadata = false;\n        /**\n     * indicates that participant is an agent\n     *\n     * @generated from field: bool agent = 11;\n     */ this.agent = false;\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new ParticipantPermission().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new ParticipantPermission().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new ParticipantPermission().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(ParticipantPermission, a, b);\n    }\n}\nParticipantPermission.runtime = proto3;\nParticipantPermission.typeName = \"livekit.ParticipantPermission\";\nParticipantPermission.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"can_subscribe\",\n            kind: \"scalar\",\n            T: 8 /* ScalarType.BOOL */ \n        },\n        {\n            no: 2,\n            name: \"can_publish\",\n            kind: \"scalar\",\n            T: 8 /* ScalarType.BOOL */ \n        },\n        {\n            no: 3,\n            name: \"can_publish_data\",\n            kind: \"scalar\",\n            T: 8 /* ScalarType.BOOL */ \n        },\n        {\n            no: 9,\n            name: \"can_publish_sources\",\n            kind: \"enum\",\n            T: proto3.getEnumType(TrackSource),\n            repeated: true\n        },\n        {\n            no: 7,\n            name: \"hidden\",\n            kind: \"scalar\",\n            T: 8 /* ScalarType.BOOL */ \n        },\n        {\n            no: 8,\n            name: \"recorder\",\n            kind: \"scalar\",\n            T: 8 /* ScalarType.BOOL */ \n        },\n        {\n            no: 10,\n            name: \"can_update_metadata\",\n            kind: \"scalar\",\n            T: 8 /* ScalarType.BOOL */ \n        },\n        {\n            no: 11,\n            name: \"agent\",\n            kind: \"scalar\",\n            T: 8 /* ScalarType.BOOL */ \n        }\n    ]);\n/**\n * @generated from message livekit.ParticipantInfo\n */ class ParticipantInfo extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: string sid = 1;\n     */ this.sid = \"\";\n        /**\n     * @generated from field: string identity = 2;\n     */ this.identity = \"\";\n        /**\n     * @generated from field: livekit.ParticipantInfo.State state = 3;\n     */ this.state = ParticipantInfo_State.JOINING;\n        /**\n     * @generated from field: repeated livekit.TrackInfo tracks = 4;\n     */ this.tracks = [];\n        /**\n     * @generated from field: string metadata = 5;\n     */ this.metadata = \"\";\n        /**\n     * timestamp when participant joined room, in seconds\n     *\n     * @generated from field: int64 joined_at = 6;\n     */ this.joinedAt = protoInt64.zero;\n        /**\n     * @generated from field: string name = 9;\n     */ this.name = \"\";\n        /**\n     * @generated from field: uint32 version = 10;\n     */ this.version = 0;\n        /**\n     * @generated from field: string region = 12;\n     */ this.region = \"\";\n        /**\n     * indicates the participant has an active publisher connection\n     * and can publish to the server\n     *\n     * @generated from field: bool is_publisher = 13;\n     */ this.isPublisher = false;\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new ParticipantInfo().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new ParticipantInfo().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new ParticipantInfo().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(ParticipantInfo, a, b);\n    }\n}\nParticipantInfo.runtime = proto3;\nParticipantInfo.typeName = \"livekit.ParticipantInfo\";\nParticipantInfo.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"sid\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 2,\n            name: \"identity\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 3,\n            name: \"state\",\n            kind: \"enum\",\n            T: proto3.getEnumType(ParticipantInfo_State)\n        },\n        {\n            no: 4,\n            name: \"tracks\",\n            kind: \"message\",\n            T: TrackInfo,\n            repeated: true\n        },\n        {\n            no: 5,\n            name: \"metadata\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 6,\n            name: \"joined_at\",\n            kind: \"scalar\",\n            T: 3 /* ScalarType.INT64 */ \n        },\n        {\n            no: 9,\n            name: \"name\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 10,\n            name: \"version\",\n            kind: \"scalar\",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 11,\n            name: \"permission\",\n            kind: \"message\",\n            T: ParticipantPermission\n        },\n        {\n            no: 12,\n            name: \"region\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 13,\n            name: \"is_publisher\",\n            kind: \"scalar\",\n            T: 8 /* ScalarType.BOOL */ \n        }\n    ]);\n/**\n * @generated from enum livekit.ParticipantInfo.State\n */ var ParticipantInfo_State;\n(function(ParticipantInfo_State) {\n    /**\n   * websocket' connected, but not offered yet\n   *\n   * @generated from enum value: JOINING = 0;\n   */ ParticipantInfo_State[ParticipantInfo_State[\"JOINING\"] = 0] = \"JOINING\";\n    /**\n   * server received client offer\n   *\n   * @generated from enum value: JOINED = 1;\n   */ ParticipantInfo_State[ParticipantInfo_State[\"JOINED\"] = 1] = \"JOINED\";\n    /**\n   * ICE connectivity established\n   *\n   * @generated from enum value: ACTIVE = 2;\n   */ ParticipantInfo_State[ParticipantInfo_State[\"ACTIVE\"] = 2] = \"ACTIVE\";\n    /**\n   * WS disconnected\n   *\n   * @generated from enum value: DISCONNECTED = 3;\n   */ ParticipantInfo_State[ParticipantInfo_State[\"DISCONNECTED\"] = 3] = \"DISCONNECTED\";\n})(ParticipantInfo_State || (ParticipantInfo_State = {}));\n// Retrieve enum metadata with: proto3.getEnumType(ParticipantInfo_State)\nproto3.util.setEnumType(ParticipantInfo_State, \"livekit.ParticipantInfo.State\", [\n    {\n        no: 0,\n        name: \"JOINING\"\n    },\n    {\n        no: 1,\n        name: \"JOINED\"\n    },\n    {\n        no: 2,\n        name: \"ACTIVE\"\n    },\n    {\n        no: 3,\n        name: \"DISCONNECTED\"\n    }\n]);\n/**\n * @generated from message livekit.Encryption\n */ class Encryption extends Message {\n    constructor(data){\n        super();\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new Encryption().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new Encryption().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new Encryption().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(Encryption, a, b);\n    }\n}\nEncryption.runtime = proto3;\nEncryption.typeName = \"livekit.Encryption\";\nEncryption.fields = proto3.util.newFieldList(()=>[]);\n/**\n * @generated from enum livekit.Encryption.Type\n */ var Encryption_Type;\n(function(Encryption_Type) {\n    /**\n   * @generated from enum value: NONE = 0;\n   */ Encryption_Type[Encryption_Type[\"NONE\"] = 0] = \"NONE\";\n    /**\n   * @generated from enum value: GCM = 1;\n   */ Encryption_Type[Encryption_Type[\"GCM\"] = 1] = \"GCM\";\n    /**\n   * @generated from enum value: CUSTOM = 2;\n   */ Encryption_Type[Encryption_Type[\"CUSTOM\"] = 2] = \"CUSTOM\";\n})(Encryption_Type || (Encryption_Type = {}));\n// Retrieve enum metadata with: proto3.getEnumType(Encryption_Type)\nproto3.util.setEnumType(Encryption_Type, \"livekit.Encryption.Type\", [\n    {\n        no: 0,\n        name: \"NONE\"\n    },\n    {\n        no: 1,\n        name: \"GCM\"\n    },\n    {\n        no: 2,\n        name: \"CUSTOM\"\n    }\n]);\n/**\n * @generated from message livekit.SimulcastCodecInfo\n */ class SimulcastCodecInfo extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: string mime_type = 1;\n     */ this.mimeType = \"\";\n        /**\n     * @generated from field: string mid = 2;\n     */ this.mid = \"\";\n        /**\n     * @generated from field: string cid = 3;\n     */ this.cid = \"\";\n        /**\n     * @generated from field: repeated livekit.VideoLayer layers = 4;\n     */ this.layers = [];\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new SimulcastCodecInfo().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new SimulcastCodecInfo().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new SimulcastCodecInfo().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(SimulcastCodecInfo, a, b);\n    }\n}\nSimulcastCodecInfo.runtime = proto3;\nSimulcastCodecInfo.typeName = \"livekit.SimulcastCodecInfo\";\nSimulcastCodecInfo.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"mime_type\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 2,\n            name: \"mid\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 3,\n            name: \"cid\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 4,\n            name: \"layers\",\n            kind: \"message\",\n            T: VideoLayer,\n            repeated: true\n        }\n    ]);\n/**\n * @generated from message livekit.TrackInfo\n */ class TrackInfo extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: string sid = 1;\n     */ this.sid = \"\";\n        /**\n     * @generated from field: livekit.TrackType type = 2;\n     */ this.type = TrackType.AUDIO;\n        /**\n     * @generated from field: string name = 3;\n     */ this.name = \"\";\n        /**\n     * @generated from field: bool muted = 4;\n     */ this.muted = false;\n        /**\n     * original width of video (unset for audio)\n     * clients may receive a lower resolution version with simulcast\n     *\n     * @generated from field: uint32 width = 5;\n     */ this.width = 0;\n        /**\n     * original height of video (unset for audio)\n     *\n     * @generated from field: uint32 height = 6;\n     */ this.height = 0;\n        /**\n     * true if track is simulcasted\n     *\n     * @generated from field: bool simulcast = 7;\n     */ this.simulcast = false;\n        /**\n     * true if DTX (Discontinuous Transmission) is disabled for audio\n     *\n     * @generated from field: bool disable_dtx = 8;\n     */ this.disableDtx = false;\n        /**\n     * source of media\n     *\n     * @generated from field: livekit.TrackSource source = 9;\n     */ this.source = TrackSource.UNKNOWN;\n        /**\n     * @generated from field: repeated livekit.VideoLayer layers = 10;\n     */ this.layers = [];\n        /**\n     * mime type of codec\n     *\n     * @generated from field: string mime_type = 11;\n     */ this.mimeType = \"\";\n        /**\n     * @generated from field: string mid = 12;\n     */ this.mid = \"\";\n        /**\n     * @generated from field: repeated livekit.SimulcastCodecInfo codecs = 13;\n     */ this.codecs = [];\n        /**\n     * @generated from field: bool stereo = 14;\n     */ this.stereo = false;\n        /**\n     * true if RED (Redundant Encoding) is disabled for audio\n     *\n     * @generated from field: bool disable_red = 15;\n     */ this.disableRed = false;\n        /**\n     * @generated from field: livekit.Encryption.Type encryption = 16;\n     */ this.encryption = Encryption_Type.NONE;\n        /**\n     * @generated from field: string stream = 17;\n     */ this.stream = \"\";\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new TrackInfo().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new TrackInfo().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new TrackInfo().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(TrackInfo, a, b);\n    }\n}\nTrackInfo.runtime = proto3;\nTrackInfo.typeName = \"livekit.TrackInfo\";\nTrackInfo.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"sid\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 2,\n            name: \"type\",\n            kind: \"enum\",\n            T: proto3.getEnumType(TrackType)\n        },\n        {\n            no: 3,\n            name: \"name\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 4,\n            name: \"muted\",\n            kind: \"scalar\",\n            T: 8 /* ScalarType.BOOL */ \n        },\n        {\n            no: 5,\n            name: \"width\",\n            kind: \"scalar\",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 6,\n            name: \"height\",\n            kind: \"scalar\",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 7,\n            name: \"simulcast\",\n            kind: \"scalar\",\n            T: 8 /* ScalarType.BOOL */ \n        },\n        {\n            no: 8,\n            name: \"disable_dtx\",\n            kind: \"scalar\",\n            T: 8 /* ScalarType.BOOL */ \n        },\n        {\n            no: 9,\n            name: \"source\",\n            kind: \"enum\",\n            T: proto3.getEnumType(TrackSource)\n        },\n        {\n            no: 10,\n            name: \"layers\",\n            kind: \"message\",\n            T: VideoLayer,\n            repeated: true\n        },\n        {\n            no: 11,\n            name: \"mime_type\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 12,\n            name: \"mid\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 13,\n            name: \"codecs\",\n            kind: \"message\",\n            T: SimulcastCodecInfo,\n            repeated: true\n        },\n        {\n            no: 14,\n            name: \"stereo\",\n            kind: \"scalar\",\n            T: 8 /* ScalarType.BOOL */ \n        },\n        {\n            no: 15,\n            name: \"disable_red\",\n            kind: \"scalar\",\n            T: 8 /* ScalarType.BOOL */ \n        },\n        {\n            no: 16,\n            name: \"encryption\",\n            kind: \"enum\",\n            T: proto3.getEnumType(Encryption_Type)\n        },\n        {\n            no: 17,\n            name: \"stream\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        }\n    ]);\n/**\n * provide information about available spatial layers\n *\n * @generated from message livekit.VideoLayer\n */ class VideoLayer extends Message {\n    constructor(data){\n        super();\n        /**\n     * for tracks with a single layer, this should be HIGH\n     *\n     * @generated from field: livekit.VideoQuality quality = 1;\n     */ this.quality = VideoQuality.LOW;\n        /**\n     * @generated from field: uint32 width = 2;\n     */ this.width = 0;\n        /**\n     * @generated from field: uint32 height = 3;\n     */ this.height = 0;\n        /**\n     * target bitrate in bit per second (bps), server will measure actual\n     *\n     * @generated from field: uint32 bitrate = 4;\n     */ this.bitrate = 0;\n        /**\n     * @generated from field: uint32 ssrc = 5;\n     */ this.ssrc = 0;\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new VideoLayer().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new VideoLayer().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new VideoLayer().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(VideoLayer, a, b);\n    }\n}\nVideoLayer.runtime = proto3;\nVideoLayer.typeName = \"livekit.VideoLayer\";\nVideoLayer.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"quality\",\n            kind: \"enum\",\n            T: proto3.getEnumType(VideoQuality)\n        },\n        {\n            no: 2,\n            name: \"width\",\n            kind: \"scalar\",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 3,\n            name: \"height\",\n            kind: \"scalar\",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 4,\n            name: \"bitrate\",\n            kind: \"scalar\",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 5,\n            name: \"ssrc\",\n            kind: \"scalar\",\n            T: 13 /* ScalarType.UINT32 */ \n        }\n    ]);\n/**\n * new DataPacket API\n *\n * @generated from message livekit.DataPacket\n */ class DataPacket extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: livekit.DataPacket.Kind kind = 1;\n     */ this.kind = DataPacket_Kind.RELIABLE;\n        /**\n     * @generated from oneof livekit.DataPacket.value\n     */ this.value = {\n            case: undefined\n        };\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new DataPacket().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new DataPacket().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new DataPacket().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(DataPacket, a, b);\n    }\n}\nDataPacket.runtime = proto3;\nDataPacket.typeName = \"livekit.DataPacket\";\nDataPacket.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"kind\",\n            kind: \"enum\",\n            T: proto3.getEnumType(DataPacket_Kind)\n        },\n        {\n            no: 2,\n            name: \"user\",\n            kind: \"message\",\n            T: UserPacket,\n            oneof: \"value\"\n        },\n        {\n            no: 3,\n            name: \"speaker\",\n            kind: \"message\",\n            T: ActiveSpeakerUpdate,\n            oneof: \"value\"\n        }\n    ]);\n/**\n * @generated from enum livekit.DataPacket.Kind\n */ var DataPacket_Kind;\n(function(DataPacket_Kind) {\n    /**\n   * @generated from enum value: RELIABLE = 0;\n   */ DataPacket_Kind[DataPacket_Kind[\"RELIABLE\"] = 0] = \"RELIABLE\";\n    /**\n   * @generated from enum value: LOSSY = 1;\n   */ DataPacket_Kind[DataPacket_Kind[\"LOSSY\"] = 1] = \"LOSSY\";\n})(DataPacket_Kind || (DataPacket_Kind = {}));\n// Retrieve enum metadata with: proto3.getEnumType(DataPacket_Kind)\nproto3.util.setEnumType(DataPacket_Kind, \"livekit.DataPacket.Kind\", [\n    {\n        no: 0,\n        name: \"RELIABLE\"\n    },\n    {\n        no: 1,\n        name: \"LOSSY\"\n    }\n]);\n/**\n * @generated from message livekit.ActiveSpeakerUpdate\n */ class ActiveSpeakerUpdate extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: repeated livekit.SpeakerInfo speakers = 1;\n     */ this.speakers = [];\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new ActiveSpeakerUpdate().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new ActiveSpeakerUpdate().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new ActiveSpeakerUpdate().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(ActiveSpeakerUpdate, a, b);\n    }\n}\nActiveSpeakerUpdate.runtime = proto3;\nActiveSpeakerUpdate.typeName = \"livekit.ActiveSpeakerUpdate\";\nActiveSpeakerUpdate.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"speakers\",\n            kind: \"message\",\n            T: SpeakerInfo,\n            repeated: true\n        }\n    ]);\n/**\n * @generated from message livekit.SpeakerInfo\n */ class SpeakerInfo extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: string sid = 1;\n     */ this.sid = \"\";\n        /**\n     * audio level, 0-1.0, 1 is loudest\n     *\n     * @generated from field: float level = 2;\n     */ this.level = 0;\n        /**\n     * true if speaker is currently active\n     *\n     * @generated from field: bool active = 3;\n     */ this.active = false;\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new SpeakerInfo().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new SpeakerInfo().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new SpeakerInfo().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(SpeakerInfo, a, b);\n    }\n}\nSpeakerInfo.runtime = proto3;\nSpeakerInfo.typeName = \"livekit.SpeakerInfo\";\nSpeakerInfo.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"sid\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 2,\n            name: \"level\",\n            kind: \"scalar\",\n            T: 2 /* ScalarType.FLOAT */ \n        },\n        {\n            no: 3,\n            name: \"active\",\n            kind: \"scalar\",\n            T: 8 /* ScalarType.BOOL */ \n        }\n    ]);\n/**\n * @generated from message livekit.UserPacket\n */ class UserPacket extends Message {\n    constructor(data){\n        super();\n        /**\n     * participant ID of user that sent the message\n     *\n     * @generated from field: string participant_sid = 1;\n     */ this.participantSid = \"\";\n        /**\n     * @generated from field: string participant_identity = 5;\n     */ this.participantIdentity = \"\";\n        /**\n     * user defined payload\n     *\n     * @generated from field: bytes payload = 2;\n     */ this.payload = new Uint8Array(0);\n        /**\n     * the ID of the participants who will receive the message (sent to all by default)\n     *\n     * @generated from field: repeated string destination_sids = 3;\n     */ this.destinationSids = [];\n        /**\n     * identities of participants who will receive the message (sent to all by default)\n     *\n     * @generated from field: repeated string destination_identities = 6;\n     */ this.destinationIdentities = [];\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new UserPacket().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new UserPacket().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new UserPacket().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(UserPacket, a, b);\n    }\n}\nUserPacket.runtime = proto3;\nUserPacket.typeName = \"livekit.UserPacket\";\nUserPacket.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"participant_sid\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 5,\n            name: \"participant_identity\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 2,\n            name: \"payload\",\n            kind: \"scalar\",\n            T: 12 /* ScalarType.BYTES */ \n        },\n        {\n            no: 3,\n            name: \"destination_sids\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ ,\n            repeated: true\n        },\n        {\n            no: 6,\n            name: \"destination_identities\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ ,\n            repeated: true\n        },\n        {\n            no: 4,\n            name: \"topic\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ ,\n            opt: true\n        }\n    ]);\n/**\n * @generated from message livekit.ParticipantTracks\n */ class ParticipantTracks extends Message {\n    constructor(data){\n        super();\n        /**\n     * participant ID of participant to whom the tracks belong\n     *\n     * @generated from field: string participant_sid = 1;\n     */ this.participantSid = \"\";\n        /**\n     * @generated from field: repeated string track_sids = 2;\n     */ this.trackSids = [];\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new ParticipantTracks().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new ParticipantTracks().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new ParticipantTracks().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(ParticipantTracks, a, b);\n    }\n}\nParticipantTracks.runtime = proto3;\nParticipantTracks.typeName = \"livekit.ParticipantTracks\";\nParticipantTracks.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"participant_sid\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 2,\n            name: \"track_sids\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ ,\n            repeated: true\n        }\n    ]);\n/**\n * details about the server\n *\n * @generated from message livekit.ServerInfo\n */ class ServerInfo extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: livekit.ServerInfo.Edition edition = 1;\n     */ this.edition = ServerInfo_Edition.Standard;\n        /**\n     * @generated from field: string version = 2;\n     */ this.version = \"\";\n        /**\n     * @generated from field: int32 protocol = 3;\n     */ this.protocol = 0;\n        /**\n     * @generated from field: string region = 4;\n     */ this.region = \"\";\n        /**\n     * @generated from field: string node_id = 5;\n     */ this.nodeId = \"\";\n        /**\n     * additional debugging information. sent only if server is in development mode\n     *\n     * @generated from field: string debug_info = 6;\n     */ this.debugInfo = \"\";\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new ServerInfo().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new ServerInfo().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new ServerInfo().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(ServerInfo, a, b);\n    }\n}\nServerInfo.runtime = proto3;\nServerInfo.typeName = \"livekit.ServerInfo\";\nServerInfo.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"edition\",\n            kind: \"enum\",\n            T: proto3.getEnumType(ServerInfo_Edition)\n        },\n        {\n            no: 2,\n            name: \"version\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 3,\n            name: \"protocol\",\n            kind: \"scalar\",\n            T: 5 /* ScalarType.INT32 */ \n        },\n        {\n            no: 4,\n            name: \"region\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 5,\n            name: \"node_id\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 6,\n            name: \"debug_info\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        }\n    ]);\n/**\n * @generated from enum livekit.ServerInfo.Edition\n */ var ServerInfo_Edition;\n(function(ServerInfo_Edition) {\n    /**\n   * @generated from enum value: Standard = 0;\n   */ ServerInfo_Edition[ServerInfo_Edition[\"Standard\"] = 0] = \"Standard\";\n    /**\n   * @generated from enum value: Cloud = 1;\n   */ ServerInfo_Edition[ServerInfo_Edition[\"Cloud\"] = 1] = \"Cloud\";\n})(ServerInfo_Edition || (ServerInfo_Edition = {}));\n// Retrieve enum metadata with: proto3.getEnumType(ServerInfo_Edition)\nproto3.util.setEnumType(ServerInfo_Edition, \"livekit.ServerInfo.Edition\", [\n    {\n        no: 0,\n        name: \"Standard\"\n    },\n    {\n        no: 1,\n        name: \"Cloud\"\n    }\n]);\n/**\n * details about the client\n *\n * @generated from message livekit.ClientInfo\n */ class ClientInfo extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: livekit.ClientInfo.SDK sdk = 1;\n     */ this.sdk = ClientInfo_SDK.UNKNOWN;\n        /**\n     * @generated from field: string version = 2;\n     */ this.version = \"\";\n        /**\n     * @generated from field: int32 protocol = 3;\n     */ this.protocol = 0;\n        /**\n     * @generated from field: string os = 4;\n     */ this.os = \"\";\n        /**\n     * @generated from field: string os_version = 5;\n     */ this.osVersion = \"\";\n        /**\n     * @generated from field: string device_model = 6;\n     */ this.deviceModel = \"\";\n        /**\n     * @generated from field: string browser = 7;\n     */ this.browser = \"\";\n        /**\n     * @generated from field: string browser_version = 8;\n     */ this.browserVersion = \"\";\n        /**\n     * @generated from field: string address = 9;\n     */ this.address = \"\";\n        /**\n     * wifi, wired, cellular, vpn, empty if not known\n     *\n     * @generated from field: string network = 10;\n     */ this.network = \"\";\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new ClientInfo().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new ClientInfo().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new ClientInfo().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(ClientInfo, a, b);\n    }\n}\nClientInfo.runtime = proto3;\nClientInfo.typeName = \"livekit.ClientInfo\";\nClientInfo.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"sdk\",\n            kind: \"enum\",\n            T: proto3.getEnumType(ClientInfo_SDK)\n        },\n        {\n            no: 2,\n            name: \"version\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 3,\n            name: \"protocol\",\n            kind: \"scalar\",\n            T: 5 /* ScalarType.INT32 */ \n        },\n        {\n            no: 4,\n            name: \"os\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 5,\n            name: \"os_version\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 6,\n            name: \"device_model\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 7,\n            name: \"browser\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 8,\n            name: \"browser_version\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 9,\n            name: \"address\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 10,\n            name: \"network\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        }\n    ]);\n/**\n * @generated from enum livekit.ClientInfo.SDK\n */ var ClientInfo_SDK;\n(function(ClientInfo_SDK) {\n    /**\n   * @generated from enum value: UNKNOWN = 0;\n   */ ClientInfo_SDK[ClientInfo_SDK[\"UNKNOWN\"] = 0] = \"UNKNOWN\";\n    /**\n   * @generated from enum value: JS = 1;\n   */ ClientInfo_SDK[ClientInfo_SDK[\"JS\"] = 1] = \"JS\";\n    /**\n   * @generated from enum value: SWIFT = 2;\n   */ ClientInfo_SDK[ClientInfo_SDK[\"SWIFT\"] = 2] = \"SWIFT\";\n    /**\n   * @generated from enum value: ANDROID = 3;\n   */ ClientInfo_SDK[ClientInfo_SDK[\"ANDROID\"] = 3] = \"ANDROID\";\n    /**\n   * @generated from enum value: FLUTTER = 4;\n   */ ClientInfo_SDK[ClientInfo_SDK[\"FLUTTER\"] = 4] = \"FLUTTER\";\n    /**\n   * @generated from enum value: GO = 5;\n   */ ClientInfo_SDK[ClientInfo_SDK[\"GO\"] = 5] = \"GO\";\n    /**\n   * @generated from enum value: UNITY = 6;\n   */ ClientInfo_SDK[ClientInfo_SDK[\"UNITY\"] = 6] = \"UNITY\";\n    /**\n   * @generated from enum value: REACT_NATIVE = 7;\n   */ ClientInfo_SDK[ClientInfo_SDK[\"REACT_NATIVE\"] = 7] = \"REACT_NATIVE\";\n    /**\n   * @generated from enum value: RUST = 8;\n   */ ClientInfo_SDK[ClientInfo_SDK[\"RUST\"] = 8] = \"RUST\";\n    /**\n   * @generated from enum value: PYTHON = 9;\n   */ ClientInfo_SDK[ClientInfo_SDK[\"PYTHON\"] = 9] = \"PYTHON\";\n    /**\n   * @generated from enum value: CPP = 10;\n   */ ClientInfo_SDK[ClientInfo_SDK[\"CPP\"] = 10] = \"CPP\";\n})(ClientInfo_SDK || (ClientInfo_SDK = {}));\n// Retrieve enum metadata with: proto3.getEnumType(ClientInfo_SDK)\nproto3.util.setEnumType(ClientInfo_SDK, \"livekit.ClientInfo.SDK\", [\n    {\n        no: 0,\n        name: \"UNKNOWN\"\n    },\n    {\n        no: 1,\n        name: \"JS\"\n    },\n    {\n        no: 2,\n        name: \"SWIFT\"\n    },\n    {\n        no: 3,\n        name: \"ANDROID\"\n    },\n    {\n        no: 4,\n        name: \"FLUTTER\"\n    },\n    {\n        no: 5,\n        name: \"GO\"\n    },\n    {\n        no: 6,\n        name: \"UNITY\"\n    },\n    {\n        no: 7,\n        name: \"REACT_NATIVE\"\n    },\n    {\n        no: 8,\n        name: \"RUST\"\n    },\n    {\n        no: 9,\n        name: \"PYTHON\"\n    },\n    {\n        no: 10,\n        name: \"CPP\"\n    }\n]);\n/**\n * server provided client configuration\n *\n * @generated from message livekit.ClientConfiguration\n */ class ClientConfiguration extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: livekit.ClientConfigSetting resume_connection = 3;\n     */ this.resumeConnection = ClientConfigSetting.UNSET;\n        /**\n     * @generated from field: livekit.ClientConfigSetting force_relay = 5;\n     */ this.forceRelay = ClientConfigSetting.UNSET;\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new ClientConfiguration().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new ClientConfiguration().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new ClientConfiguration().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(ClientConfiguration, a, b);\n    }\n}\nClientConfiguration.runtime = proto3;\nClientConfiguration.typeName = \"livekit.ClientConfiguration\";\nClientConfiguration.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"video\",\n            kind: \"message\",\n            T: VideoConfiguration\n        },\n        {\n            no: 2,\n            name: \"screen\",\n            kind: \"message\",\n            T: VideoConfiguration\n        },\n        {\n            no: 3,\n            name: \"resume_connection\",\n            kind: \"enum\",\n            T: proto3.getEnumType(ClientConfigSetting)\n        },\n        {\n            no: 4,\n            name: \"disabled_codecs\",\n            kind: \"message\",\n            T: DisabledCodecs\n        },\n        {\n            no: 5,\n            name: \"force_relay\",\n            kind: \"enum\",\n            T: proto3.getEnumType(ClientConfigSetting)\n        }\n    ]);\n/**\n * @generated from message livekit.VideoConfiguration\n */ class VideoConfiguration extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: livekit.ClientConfigSetting hardware_encoder = 1;\n     */ this.hardwareEncoder = ClientConfigSetting.UNSET;\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new VideoConfiguration().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new VideoConfiguration().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new VideoConfiguration().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(VideoConfiguration, a, b);\n    }\n}\nVideoConfiguration.runtime = proto3;\nVideoConfiguration.typeName = \"livekit.VideoConfiguration\";\nVideoConfiguration.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"hardware_encoder\",\n            kind: \"enum\",\n            T: proto3.getEnumType(ClientConfigSetting)\n        }\n    ]);\n/**\n * @generated from message livekit.DisabledCodecs\n */ class DisabledCodecs extends Message {\n    constructor(data){\n        super();\n        /**\n     * disabled for both publish and subscribe\n     *\n     * @generated from field: repeated livekit.Codec codecs = 1;\n     */ this.codecs = [];\n        /**\n     * only disable for publish\n     *\n     * @generated from field: repeated livekit.Codec publish = 2;\n     */ this.publish = [];\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new DisabledCodecs().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new DisabledCodecs().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new DisabledCodecs().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(DisabledCodecs, a, b);\n    }\n}\nDisabledCodecs.runtime = proto3;\nDisabledCodecs.typeName = \"livekit.DisabledCodecs\";\nDisabledCodecs.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"codecs\",\n            kind: \"message\",\n            T: Codec,\n            repeated: true\n        },\n        {\n            no: 2,\n            name: \"publish\",\n            kind: \"message\",\n            T: Codec,\n            repeated: true\n        }\n    ]);\n/**\n * @generated from message livekit.RTPDrift\n */ class RTPDrift extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: double duration = 3;\n     */ this.duration = 0;\n        /**\n     * @generated from field: uint64 start_timestamp = 4;\n     */ this.startTimestamp = protoInt64.zero;\n        /**\n     * @generated from field: uint64 end_timestamp = 5;\n     */ this.endTimestamp = protoInt64.zero;\n        /**\n     * @generated from field: uint64 rtp_clock_ticks = 6;\n     */ this.rtpClockTicks = protoInt64.zero;\n        /**\n     * @generated from field: int64 drift_samples = 7;\n     */ this.driftSamples = protoInt64.zero;\n        /**\n     * @generated from field: double drift_ms = 8;\n     */ this.driftMs = 0;\n        /**\n     * @generated from field: double clock_rate = 9;\n     */ this.clockRate = 0;\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new RTPDrift().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new RTPDrift().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new RTPDrift().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(RTPDrift, a, b);\n    }\n}\nRTPDrift.runtime = proto3;\nRTPDrift.typeName = \"livekit.RTPDrift\";\nRTPDrift.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"start_time\",\n            kind: \"message\",\n            T: Timestamp\n        },\n        {\n            no: 2,\n            name: \"end_time\",\n            kind: \"message\",\n            T: Timestamp\n        },\n        {\n            no: 3,\n            name: \"duration\",\n            kind: \"scalar\",\n            T: 1 /* ScalarType.DOUBLE */ \n        },\n        {\n            no: 4,\n            name: \"start_timestamp\",\n            kind: \"scalar\",\n            T: 4 /* ScalarType.UINT64 */ \n        },\n        {\n            no: 5,\n            name: \"end_timestamp\",\n            kind: \"scalar\",\n            T: 4 /* ScalarType.UINT64 */ \n        },\n        {\n            no: 6,\n            name: \"rtp_clock_ticks\",\n            kind: \"scalar\",\n            T: 4 /* ScalarType.UINT64 */ \n        },\n        {\n            no: 7,\n            name: \"drift_samples\",\n            kind: \"scalar\",\n            T: 3 /* ScalarType.INT64 */ \n        },\n        {\n            no: 8,\n            name: \"drift_ms\",\n            kind: \"scalar\",\n            T: 1 /* ScalarType.DOUBLE */ \n        },\n        {\n            no: 9,\n            name: \"clock_rate\",\n            kind: \"scalar\",\n            T: 1 /* ScalarType.DOUBLE */ \n        }\n    ]);\n/**\n * @generated from message livekit.RTPStats\n */ class RTPStats extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: double duration = 3;\n     */ this.duration = 0;\n        /**\n     * @generated from field: uint32 packets = 4;\n     */ this.packets = 0;\n        /**\n     * @generated from field: double packet_rate = 5;\n     */ this.packetRate = 0;\n        /**\n     * @generated from field: uint64 bytes = 6;\n     */ this.bytes = protoInt64.zero;\n        /**\n     * @generated from field: uint64 header_bytes = 39;\n     */ this.headerBytes = protoInt64.zero;\n        /**\n     * @generated from field: double bitrate = 7;\n     */ this.bitrate = 0;\n        /**\n     * @generated from field: uint32 packets_lost = 8;\n     */ this.packetsLost = 0;\n        /**\n     * @generated from field: double packet_loss_rate = 9;\n     */ this.packetLossRate = 0;\n        /**\n     * @generated from field: float packet_loss_percentage = 10;\n     */ this.packetLossPercentage = 0;\n        /**\n     * @generated from field: uint32 packets_duplicate = 11;\n     */ this.packetsDuplicate = 0;\n        /**\n     * @generated from field: double packet_duplicate_rate = 12;\n     */ this.packetDuplicateRate = 0;\n        /**\n     * @generated from field: uint64 bytes_duplicate = 13;\n     */ this.bytesDuplicate = protoInt64.zero;\n        /**\n     * @generated from field: uint64 header_bytes_duplicate = 40;\n     */ this.headerBytesDuplicate = protoInt64.zero;\n        /**\n     * @generated from field: double bitrate_duplicate = 14;\n     */ this.bitrateDuplicate = 0;\n        /**\n     * @generated from field: uint32 packets_padding = 15;\n     */ this.packetsPadding = 0;\n        /**\n     * @generated from field: double packet_padding_rate = 16;\n     */ this.packetPaddingRate = 0;\n        /**\n     * @generated from field: uint64 bytes_padding = 17;\n     */ this.bytesPadding = protoInt64.zero;\n        /**\n     * @generated from field: uint64 header_bytes_padding = 41;\n     */ this.headerBytesPadding = protoInt64.zero;\n        /**\n     * @generated from field: double bitrate_padding = 18;\n     */ this.bitratePadding = 0;\n        /**\n     * @generated from field: uint32 packets_out_of_order = 19;\n     */ this.packetsOutOfOrder = 0;\n        /**\n     * @generated from field: uint32 frames = 20;\n     */ this.frames = 0;\n        /**\n     * @generated from field: double frame_rate = 21;\n     */ this.frameRate = 0;\n        /**\n     * @generated from field: double jitter_current = 22;\n     */ this.jitterCurrent = 0;\n        /**\n     * @generated from field: double jitter_max = 23;\n     */ this.jitterMax = 0;\n        /**\n     * @generated from field: map<int32, uint32> gap_histogram = 24;\n     */ this.gapHistogram = {};\n        /**\n     * @generated from field: uint32 nacks = 25;\n     */ this.nacks = 0;\n        /**\n     * @generated from field: uint32 nack_acks = 37;\n     */ this.nackAcks = 0;\n        /**\n     * @generated from field: uint32 nack_misses = 26;\n     */ this.nackMisses = 0;\n        /**\n     * @generated from field: uint32 nack_repeated = 38;\n     */ this.nackRepeated = 0;\n        /**\n     * @generated from field: uint32 plis = 27;\n     */ this.plis = 0;\n        /**\n     * @generated from field: uint32 firs = 29;\n     */ this.firs = 0;\n        /**\n     * @generated from field: uint32 rtt_current = 31;\n     */ this.rttCurrent = 0;\n        /**\n     * @generated from field: uint32 rtt_max = 32;\n     */ this.rttMax = 0;\n        /**\n     * @generated from field: uint32 key_frames = 33;\n     */ this.keyFrames = 0;\n        /**\n     * @generated from field: uint32 layer_lock_plis = 35;\n     */ this.layerLockPlis = 0;\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new RTPStats().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new RTPStats().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new RTPStats().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(RTPStats, a, b);\n    }\n}\nRTPStats.runtime = proto3;\nRTPStats.typeName = \"livekit.RTPStats\";\nRTPStats.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"start_time\",\n            kind: \"message\",\n            T: Timestamp\n        },\n        {\n            no: 2,\n            name: \"end_time\",\n            kind: \"message\",\n            T: Timestamp\n        },\n        {\n            no: 3,\n            name: \"duration\",\n            kind: \"scalar\",\n            T: 1 /* ScalarType.DOUBLE */ \n        },\n        {\n            no: 4,\n            name: \"packets\",\n            kind: \"scalar\",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 5,\n            name: \"packet_rate\",\n            kind: \"scalar\",\n            T: 1 /* ScalarType.DOUBLE */ \n        },\n        {\n            no: 6,\n            name: \"bytes\",\n            kind: \"scalar\",\n            T: 4 /* ScalarType.UINT64 */ \n        },\n        {\n            no: 39,\n            name: \"header_bytes\",\n            kind: \"scalar\",\n            T: 4 /* ScalarType.UINT64 */ \n        },\n        {\n            no: 7,\n            name: \"bitrate\",\n            kind: \"scalar\",\n            T: 1 /* ScalarType.DOUBLE */ \n        },\n        {\n            no: 8,\n            name: \"packets_lost\",\n            kind: \"scalar\",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 9,\n            name: \"packet_loss_rate\",\n            kind: \"scalar\",\n            T: 1 /* ScalarType.DOUBLE */ \n        },\n        {\n            no: 10,\n            name: \"packet_loss_percentage\",\n            kind: \"scalar\",\n            T: 2 /* ScalarType.FLOAT */ \n        },\n        {\n            no: 11,\n            name: \"packets_duplicate\",\n            kind: \"scalar\",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 12,\n            name: \"packet_duplicate_rate\",\n            kind: \"scalar\",\n            T: 1 /* ScalarType.DOUBLE */ \n        },\n        {\n            no: 13,\n            name: \"bytes_duplicate\",\n            kind: \"scalar\",\n            T: 4 /* ScalarType.UINT64 */ \n        },\n        {\n            no: 40,\n            name: \"header_bytes_duplicate\",\n            kind: \"scalar\",\n            T: 4 /* ScalarType.UINT64 */ \n        },\n        {\n            no: 14,\n            name: \"bitrate_duplicate\",\n            kind: \"scalar\",\n            T: 1 /* ScalarType.DOUBLE */ \n        },\n        {\n            no: 15,\n            name: \"packets_padding\",\n            kind: \"scalar\",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 16,\n            name: \"packet_padding_rate\",\n            kind: \"scalar\",\n            T: 1 /* ScalarType.DOUBLE */ \n        },\n        {\n            no: 17,\n            name: \"bytes_padding\",\n            kind: \"scalar\",\n            T: 4 /* ScalarType.UINT64 */ \n        },\n        {\n            no: 41,\n            name: \"header_bytes_padding\",\n            kind: \"scalar\",\n            T: 4 /* ScalarType.UINT64 */ \n        },\n        {\n            no: 18,\n            name: \"bitrate_padding\",\n            kind: \"scalar\",\n            T: 1 /* ScalarType.DOUBLE */ \n        },\n        {\n            no: 19,\n            name: \"packets_out_of_order\",\n            kind: \"scalar\",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 20,\n            name: \"frames\",\n            kind: \"scalar\",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 21,\n            name: \"frame_rate\",\n            kind: \"scalar\",\n            T: 1 /* ScalarType.DOUBLE */ \n        },\n        {\n            no: 22,\n            name: \"jitter_current\",\n            kind: \"scalar\",\n            T: 1 /* ScalarType.DOUBLE */ \n        },\n        {\n            no: 23,\n            name: \"jitter_max\",\n            kind: \"scalar\",\n            T: 1 /* ScalarType.DOUBLE */ \n        },\n        {\n            no: 24,\n            name: \"gap_histogram\",\n            kind: \"map\",\n            K: 5 /* ScalarType.INT32 */ ,\n            V: {\n                kind: \"scalar\",\n                T: 13 /* ScalarType.UINT32 */ \n            }\n        },\n        {\n            no: 25,\n            name: \"nacks\",\n            kind: \"scalar\",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 37,\n            name: \"nack_acks\",\n            kind: \"scalar\",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 26,\n            name: \"nack_misses\",\n            kind: \"scalar\",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 38,\n            name: \"nack_repeated\",\n            kind: \"scalar\",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 27,\n            name: \"plis\",\n            kind: \"scalar\",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 28,\n            name: \"last_pli\",\n            kind: \"message\",\n            T: Timestamp\n        },\n        {\n            no: 29,\n            name: \"firs\",\n            kind: \"scalar\",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 30,\n            name: \"last_fir\",\n            kind: \"message\",\n            T: Timestamp\n        },\n        {\n            no: 31,\n            name: \"rtt_current\",\n            kind: \"scalar\",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 32,\n            name: \"rtt_max\",\n            kind: \"scalar\",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 33,\n            name: \"key_frames\",\n            kind: \"scalar\",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 34,\n            name: \"last_key_frame\",\n            kind: \"message\",\n            T: Timestamp\n        },\n        {\n            no: 35,\n            name: \"layer_lock_plis\",\n            kind: \"scalar\",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 36,\n            name: \"last_layer_lock_pli\",\n            kind: \"message\",\n            T: Timestamp\n        },\n        {\n            no: 44,\n            name: \"packet_drift\",\n            kind: \"message\",\n            T: RTPDrift\n        },\n        {\n            no: 45,\n            name: \"report_drift\",\n            kind: \"message\",\n            T: RTPDrift\n        }\n    ]);\n/**\n * @generated from message livekit.TimedVersion\n */ class TimedVersion extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: int64 unix_micro = 1;\n     */ this.unixMicro = protoInt64.zero;\n        /**\n     * @generated from field: int32 ticks = 2;\n     */ this.ticks = 0;\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new TimedVersion().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new TimedVersion().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new TimedVersion().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(TimedVersion, a, b);\n    }\n}\nTimedVersion.runtime = proto3;\nTimedVersion.typeName = \"livekit.TimedVersion\";\nTimedVersion.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"unix_micro\",\n            kind: \"scalar\",\n            T: 3 /* ScalarType.INT64 */ \n        },\n        {\n            no: 2,\n            name: \"ticks\",\n            kind: \"scalar\",\n            T: 5 /* ScalarType.INT32 */ \n        }\n    ]);\nconst maxRetryDelay = 7000;\nconst DEFAULT_RETRY_DELAYS_IN_MS = [\n    0,\n    300,\n    2 * 2 * 300,\n    3 * 3 * 300,\n    4 * 4 * 300,\n    maxRetryDelay,\n    maxRetryDelay,\n    maxRetryDelay,\n    maxRetryDelay,\n    maxRetryDelay\n];\nclass DefaultReconnectPolicy {\n    constructor(retryDelays){\n        this._retryDelays = retryDelays !== undefined ? [\n            ...retryDelays\n        ] : DEFAULT_RETRY_DELAYS_IN_MS;\n    }\n    nextRetryDelayInMs(context) {\n        if (context.retryCount >= this._retryDelays.length) return null;\n        const retryDelay = this._retryDelays[context.retryCount];\n        if (context.retryCount <= 1) return retryDelay;\n        return retryDelay + Math.random() * 1000;\n    }\n}\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */ /* global Reflect, Promise, SuppressedError, Symbol */ function __awaiter(thisArg, _arguments, P, generator) {\n    function adopt(value) {\n        return value instanceof P ? value : new P(function(resolve) {\n            resolve(value);\n        });\n    }\n    return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function rejected(value) {\n            try {\n                step(generator[\"throw\"](value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n}\nfunction __values(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function() {\n            if (o && i >= o.length) o = void 0;\n            return {\n                value: o && o[i++],\n                done: !o\n            };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n}\nfunction __asyncValues(o) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var m = o[Symbol.asyncIterator], i;\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function() {\n        return this;\n    }, i);\n    function verb(n) {\n        i[n] = o[n] && function(v) {\n            return new Promise(function(resolve, reject) {\n                v = o[n](v), settle(resolve, reject, v.done, v.value);\n            });\n        };\n    }\n    function settle(resolve, reject, d, v) {\n        Promise.resolve(v).then(function(v) {\n            resolve({\n                value: v,\n                done: d\n            });\n        }, reject);\n    }\n}\ntypeof SuppressedError === \"function\" ? SuppressedError : function(error, suppressed, message) {\n    var e = new Error(message);\n    return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\n};\nvar events = {\n    exports: {}\n};\nvar R = typeof Reflect === 'object' ? Reflect : null;\nvar ReflectApply = R && typeof R.apply === 'function' ? R.apply : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n};\nvar ReflectOwnKeys;\nif (R && typeof R.ownKeys === 'function') {\n    ReflectOwnKeys = R.ownKeys;\n} else if (Object.getOwnPropertySymbols) {\n    ReflectOwnKeys = function ReflectOwnKeys(target) {\n        return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));\n    };\n} else {\n    ReflectOwnKeys = function ReflectOwnKeys(target) {\n        return Object.getOwnPropertyNames(target);\n    };\n}\nfunction ProcessEmitWarning(warning) {\n    if (console && console.warn) console.warn(warning);\n}\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n    return value !== value;\n};\nfunction EventEmitter() {\n    EventEmitter.init.call(this);\n}\nevents.exports = EventEmitter;\nevents.exports.once = once;\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\nfunction checkListener(listener) {\n    if (typeof listener !== 'function') {\n        throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n    }\n}\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n    enumerable: true,\n    get: function() {\n        return defaultMaxListeners;\n    },\n    set: function(arg) {\n        if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n            throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n        }\n        defaultMaxListeners = arg;\n    }\n});\nEventEmitter.init = function() {\n    if (this._events === undefined || this._events === Object.getPrototypeOf(this)._events) {\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n    }\n    this._maxListeners = this._maxListeners || undefined;\n};\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n    if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n        throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n    }\n    this._maxListeners = n;\n    return this;\n};\nfunction _getMaxListeners(that) {\n    if (that._maxListeners === undefined) return EventEmitter.defaultMaxListeners;\n    return that._maxListeners;\n}\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n    return _getMaxListeners(this);\n};\nEventEmitter.prototype.emit = function emit(type) {\n    var args = [];\n    for(var i = 1; i < arguments.length; i++)args.push(arguments[i]);\n    var doError = type === 'error';\n    var events = this._events;\n    if (events !== undefined) doError = doError && events.error === undefined;\n    else if (!doError) return false;\n    // If there is no 'error' event listener then throw.\n    if (doError) {\n        var er;\n        if (args.length > 0) er = args[0];\n        if (er instanceof Error) {\n            // Note: The comments on the `throw` lines are intentional, they show\n            // up in Node's output if this results in an unhandled exception.\n            throw er; // Unhandled 'error' event\n        }\n        // At least give some kind of context to the user\n        var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n        err.context = er;\n        throw err; // Unhandled 'error' event\n    }\n    var handler = events[type];\n    if (handler === undefined) return false;\n    if (typeof handler === 'function') {\n        ReflectApply(handler, this, args);\n    } else {\n        var len = handler.length;\n        var listeners = arrayClone(handler, len);\n        for(var i = 0; i < len; ++i)ReflectApply(listeners[i], this, args);\n    }\n    return true;\n};\nfunction _addListener(target, type, listener, prepend) {\n    var m;\n    var events;\n    var existing;\n    checkListener(listener);\n    events = target._events;\n    if (events === undefined) {\n        events = target._events = Object.create(null);\n        target._eventsCount = 0;\n    } else {\n        // To avoid recursion in the case that type === \"newListener\"! Before\n        // adding it to the listeners, first emit \"newListener\".\n        if (events.newListener !== undefined) {\n            target.emit('newListener', type, listener.listener ? listener.listener : listener);\n            // Re-assign `events` because a newListener handler could have caused the\n            // this._events to be assigned to a new object\n            events = target._events;\n        }\n        existing = events[type];\n    }\n    if (existing === undefined) {\n        // Optimize the case of one listener. Don't need the extra array object.\n        existing = events[type] = listener;\n        ++target._eventsCount;\n    } else {\n        if (typeof existing === 'function') {\n            // Adding the second element, need to change to array.\n            existing = events[type] = prepend ? [\n                listener,\n                existing\n            ] : [\n                existing,\n                listener\n            ];\n        // If we've already got an array, just append.\n        } else if (prepend) {\n            existing.unshift(listener);\n        } else {\n            existing.push(listener);\n        }\n        // Check for listener leak\n        m = _getMaxListeners(target);\n        if (m > 0 && existing.length > m && !existing.warned) {\n            existing.warned = true;\n            // No error code for this since it is a Warning\n            // eslint-disable-next-line no-restricted-syntax\n            var w = new Error('Possible EventEmitter memory leak detected. ' + existing.length + ' ' + String(type) + ' listeners ' + 'added. Use emitter.setMaxListeners() to ' + 'increase limit');\n            w.name = 'MaxListenersExceededWarning';\n            w.emitter = target;\n            w.type = type;\n            w.count = existing.length;\n            ProcessEmitWarning(w);\n        }\n    }\n    return target;\n}\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n    return _addListener(this, type, listener, false);\n};\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\nEventEmitter.prototype.prependListener = function prependListener(type, listener) {\n    return _addListener(this, type, listener, true);\n};\nfunction onceWrapper() {\n    if (!this.fired) {\n        this.target.removeListener(this.type, this.wrapFn);\n        this.fired = true;\n        if (arguments.length === 0) return this.listener.call(this.target);\n        return this.listener.apply(this.target, arguments);\n    }\n}\nfunction _onceWrap(target, type, listener) {\n    var state = {\n        fired: false,\n        wrapFn: undefined,\n        target: target,\n        type: type,\n        listener: listener\n    };\n    var wrapped = onceWrapper.bind(state);\n    wrapped.listener = listener;\n    state.wrapFn = wrapped;\n    return wrapped;\n}\nEventEmitter.prototype.once = function once(type, listener) {\n    checkListener(listener);\n    this.on(type, _onceWrap(this, type, listener));\n    return this;\n};\nEventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {\n    checkListener(listener);\n    this.prependListener(type, _onceWrap(this, type, listener));\n    return this;\n};\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener = function removeListener(type, listener) {\n    var list, events, position, i, originalListener;\n    checkListener(listener);\n    events = this._events;\n    if (events === undefined) return this;\n    list = events[type];\n    if (list === undefined) return this;\n    if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0) this._events = Object.create(null);\n        else {\n            delete events[type];\n            if (events.removeListener) this.emit('removeListener', type, list.listener || listener);\n        }\n    } else if (typeof list !== 'function') {\n        position = -1;\n        for(i = list.length - 1; i >= 0; i--){\n            if (list[i] === listener || list[i].listener === listener) {\n                originalListener = list[i].listener;\n                position = i;\n                break;\n            }\n        }\n        if (position < 0) return this;\n        if (position === 0) list.shift();\n        else {\n            spliceOne(list, position);\n        }\n        if (list.length === 1) events[type] = list[0];\n        if (events.removeListener !== undefined) this.emit('removeListener', type, originalListener || listener);\n    }\n    return this;\n};\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {\n    var listeners, events, i;\n    events = this._events;\n    if (events === undefined) return this;\n    // not listening for removeListener, no need to emit\n    if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n            this._events = Object.create(null);\n            this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n            if (--this._eventsCount === 0) this._events = Object.create(null);\n            else delete events[type];\n        }\n        return this;\n    }\n    // emit removeListener for all listeners on all events\n    if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for(i = 0; i < keys.length; ++i){\n            key = keys[i];\n            if (key === 'removeListener') continue;\n            this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n    }\n    listeners = events[type];\n    if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n    } else if (listeners !== undefined) {\n        // LIFO order\n        for(i = listeners.length - 1; i >= 0; i--){\n            this.removeListener(type, listeners[i]);\n        }\n    }\n    return this;\n};\nfunction _listeners(target, type, unwrap) {\n    var events = target._events;\n    if (events === undefined) return [];\n    var evlistener = events[type];\n    if (evlistener === undefined) return [];\n    if (typeof evlistener === 'function') return unwrap ? [\n        evlistener.listener || evlistener\n    ] : [\n        evlistener\n    ];\n    return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\nEventEmitter.prototype.listeners = function listeners(type) {\n    return _listeners(this, type, true);\n};\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n    return _listeners(this, type, false);\n};\nEventEmitter.listenerCount = function(emitter, type) {\n    if (typeof emitter.listenerCount === 'function') {\n        return emitter.listenerCount(type);\n    } else {\n        return listenerCount.call(emitter, type);\n    }\n};\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n    var events = this._events;\n    if (events !== undefined) {\n        var evlistener = events[type];\n        if (typeof evlistener === 'function') {\n            return 1;\n        } else if (evlistener !== undefined) {\n            return evlistener.length;\n        }\n    }\n    return 0;\n}\nEventEmitter.prototype.eventNames = function eventNames() {\n    return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\nfunction arrayClone(arr, n) {\n    var copy = new Array(n);\n    for(var i = 0; i < n; ++i)copy[i] = arr[i];\n    return copy;\n}\nfunction spliceOne(list, index) {\n    for(; index + 1 < list.length; index++)list[index] = list[index + 1];\n    list.pop();\n}\nfunction unwrapListeners(arr) {\n    var ret = new Array(arr.length);\n    for(var i = 0; i < ret.length; ++i){\n        ret[i] = arr[i].listener || arr[i];\n    }\n    return ret;\n}\nfunction once(emitter, name) {\n    return new Promise(function(resolve, reject) {\n        function errorListener(err) {\n            emitter.removeListener(name, resolver);\n            reject(err);\n        }\n        function resolver() {\n            if (typeof emitter.removeListener === 'function') {\n                emitter.removeListener('error', errorListener);\n            }\n            resolve([].slice.call(arguments));\n        }\n        eventTargetAgnosticAddListener(emitter, name, resolver, {\n            once: true\n        });\n        if (name !== 'error') {\n            addErrorHandlerIfEventEmitter(emitter, errorListener, {\n                once: true\n            });\n        }\n    });\n}\nfunction addErrorHandlerIfEventEmitter(emitter, handler, flags) {\n    if (typeof emitter.on === 'function') {\n        eventTargetAgnosticAddListener(emitter, 'error', handler, flags);\n    }\n}\nfunction eventTargetAgnosticAddListener(emitter, name, listener, flags) {\n    if (typeof emitter.on === 'function') {\n        if (flags.once) {\n            emitter.once(name, listener);\n        } else {\n            emitter.on(name, listener);\n        }\n    } else if (typeof emitter.addEventListener === 'function') {\n        // EventTarget does not have `error` event semantics like Node\n        // EventEmitters, we do not listen for `error` events here.\n        emitter.addEventListener(name, function wrapListener(arg) {\n            // IE does not have builtin `{ once: true }` support so we\n            // have to do it manually.\n            if (flags.once) {\n                emitter.removeEventListener(name, wrapListener);\n            }\n            listener(arg);\n        });\n    } else {\n        throw new TypeError('The \"emitter\" argument must be of type EventEmitter. Received type ' + typeof emitter);\n    }\n}\nvar eventsExports = events.exports;\n/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */ /* eslint-env node */ let logDisabled_ = true;\nlet deprecationWarnings_ = true;\n/**\n * Extract browser version out of the provided user agent string.\n *\n * @param {!string} uastring userAgent string.\n * @param {!string} expr Regular expression used as match criteria.\n * @param {!number} pos position in the version string to be returned.\n * @return {!number} browser version.\n */ function extractVersion(uastring, expr, pos) {\n    const match = uastring.match(expr);\n    return match && match.length >= pos && parseInt(match[pos], 10);\n}\n// Wraps the peerconnection event eventNameToWrap in a function\n// which returns the modified event object (or false to prevent\n// the event).\nfunction wrapPeerConnectionEvent(window1, eventNameToWrap, wrapper) {\n    if (!window1.RTCPeerConnection) {\n        return;\n    }\n    const proto = window1.RTCPeerConnection.prototype;\n    const nativeAddEventListener = proto.addEventListener;\n    proto.addEventListener = function(nativeEventName, cb) {\n        if (nativeEventName !== eventNameToWrap) {\n            return nativeAddEventListener.apply(this, arguments);\n        }\n        const wrappedCallback = (e)=>{\n            const modifiedEvent = wrapper(e);\n            if (modifiedEvent) {\n                if (cb.handleEvent) {\n                    cb.handleEvent(modifiedEvent);\n                } else {\n                    cb(modifiedEvent);\n                }\n            }\n        };\n        this._eventMap = this._eventMap || {};\n        if (!this._eventMap[eventNameToWrap]) {\n            this._eventMap[eventNameToWrap] = new Map();\n        }\n        this._eventMap[eventNameToWrap].set(cb, wrappedCallback);\n        return nativeAddEventListener.apply(this, [\n            nativeEventName,\n            wrappedCallback\n        ]);\n    };\n    const nativeRemoveEventListener = proto.removeEventListener;\n    proto.removeEventListener = function(nativeEventName, cb) {\n        if (nativeEventName !== eventNameToWrap || !this._eventMap || !this._eventMap[eventNameToWrap]) {\n            return nativeRemoveEventListener.apply(this, arguments);\n        }\n        if (!this._eventMap[eventNameToWrap].has(cb)) {\n            return nativeRemoveEventListener.apply(this, arguments);\n        }\n        const unwrappedCb = this._eventMap[eventNameToWrap].get(cb);\n        this._eventMap[eventNameToWrap].delete(cb);\n        if (this._eventMap[eventNameToWrap].size === 0) {\n            delete this._eventMap[eventNameToWrap];\n        }\n        if (Object.keys(this._eventMap).length === 0) {\n            delete this._eventMap;\n        }\n        return nativeRemoveEventListener.apply(this, [\n            nativeEventName,\n            unwrappedCb\n        ]);\n    };\n    Object.defineProperty(proto, 'on' + eventNameToWrap, {\n        get () {\n            return this['_on' + eventNameToWrap];\n        },\n        set (cb) {\n            if (this['_on' + eventNameToWrap]) {\n                this.removeEventListener(eventNameToWrap, this['_on' + eventNameToWrap]);\n                delete this['_on' + eventNameToWrap];\n            }\n            if (cb) {\n                this.addEventListener(eventNameToWrap, this['_on' + eventNameToWrap] = cb);\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n}\nfunction disableLog(bool) {\n    if (typeof bool !== 'boolean') {\n        return new Error('Argument type: ' + typeof bool + '. Please use a boolean.');\n    }\n    logDisabled_ = bool;\n    return bool ? 'adapter.js logging disabled' : 'adapter.js logging enabled';\n}\n/**\n * Disable or enable deprecation warnings\n * @param {!boolean} bool set to true to disable warnings.\n */ function disableWarnings(bool) {\n    if (typeof bool !== 'boolean') {\n        return new Error('Argument type: ' + typeof bool + '. Please use a boolean.');\n    }\n    deprecationWarnings_ = !bool;\n    return 'adapter.js deprecation warnings ' + (bool ? 'disabled' : 'enabled');\n}\nfunction log() {\n    if (false) {}\n}\n/**\n * Shows a deprecation warning suggesting the modern and spec-compatible API.\n */ function deprecated(oldMethod, newMethod) {\n    if (!deprecationWarnings_) {\n        return;\n    }\n    console.warn(oldMethod + ' is deprecated, please use ' + newMethod + ' instead.');\n}\n/**\n * Browser detector.\n *\n * @return {object} result containing browser and version\n *     properties.\n */ function detectBrowser(window1) {\n    // Returned result object.\n    const result = {\n        browser: null,\n        version: null\n    };\n    // Fail early if it's not a browser\n    if (typeof window1 === 'undefined' || !window1.navigator || !window1.navigator.userAgent) {\n        result.browser = 'Not a browser.';\n        return result;\n    }\n    const { navigator: navigator1 } = window1;\n    if (navigator1.mozGetUserMedia) {\n        // Firefox.\n        result.browser = 'firefox';\n        result.version = extractVersion(navigator1.userAgent, /Firefox\\/(\\d+)\\./, 1);\n    } else if (navigator1.webkitGetUserMedia || window1.isSecureContext === false && window1.webkitRTCPeerConnection) {\n        // Chrome, Chromium, Webview, Opera.\n        // Version matches Chrome/WebRTC version.\n        // Chrome 74 removed webkitGetUserMedia on http as well so we need the\n        // more complicated fallback to webkitRTCPeerConnection.\n        result.browser = 'chrome';\n        result.version = extractVersion(navigator1.userAgent, /Chrom(e|ium)\\/(\\d+)\\./, 2);\n    } else if (window1.RTCPeerConnection && navigator1.userAgent.match(/AppleWebKit\\/(\\d+)\\./)) {\n        // Safari.\n        result.browser = 'safari';\n        result.version = extractVersion(navigator1.userAgent, /AppleWebKit\\/(\\d+)\\./, 1);\n        result.supportsUnifiedPlan = window1.RTCRtpTransceiver && 'currentDirection' in window1.RTCRtpTransceiver.prototype;\n    } else {\n        // Default fallthrough: not supported.\n        result.browser = 'Not a supported browser.';\n        return result;\n    }\n    return result;\n}\n/**\n * Checks if something is an object.\n *\n * @param {*} val The something you want to check.\n * @return true if val is an object, false otherwise.\n */ function isObject(val) {\n    return Object.prototype.toString.call(val) === '[object Object]';\n}\n/**\n * Remove all empty objects and undefined values\n * from a nested object -- an enhanced and vanilla version\n * of Lodash's `compact`.\n */ function compactObject(data) {\n    if (!isObject(data)) {\n        return data;\n    }\n    return Object.keys(data).reduce(function(accumulator, key) {\n        const isObj = isObject(data[key]);\n        const value = isObj ? compactObject(data[key]) : data[key];\n        const isEmptyObject = isObj && !Object.keys(value).length;\n        if (value === undefined || isEmptyObject) {\n            return accumulator;\n        }\n        return Object.assign(accumulator, {\n            [key]: value\n        });\n    }, {});\n}\n/* iterates the stats graph recursively. */ function walkStats(stats, base, resultSet) {\n    if (!base || resultSet.has(base.id)) {\n        return;\n    }\n    resultSet.set(base.id, base);\n    Object.keys(base).forEach((name)=>{\n        if (name.endsWith('Id')) {\n            walkStats(stats, stats.get(base[name]), resultSet);\n        } else if (name.endsWith('Ids')) {\n            base[name].forEach((id)=>{\n                walkStats(stats, stats.get(id), resultSet);\n            });\n        }\n    });\n}\n/* filter getStats for a sender/receiver track. */ function filterStats(result, track, outbound) {\n    const streamStatsType = outbound ? 'outbound-rtp' : 'inbound-rtp';\n    const filteredResult = new Map();\n    if (track === null) {\n        return filteredResult;\n    }\n    const trackStats = [];\n    result.forEach((value)=>{\n        if (value.type === 'track' && value.trackIdentifier === track.id) {\n            trackStats.push(value);\n        }\n    });\n    trackStats.forEach((trackStat)=>{\n        result.forEach((stats)=>{\n            if (stats.type === streamStatsType && stats.trackId === trackStat.id) {\n                walkStats(result, stats, filteredResult);\n            }\n        });\n    });\n    return filteredResult;\n}\n/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */ /* eslint-env node */ const logging = log;\nfunction shimGetUserMedia$2(window1, browserDetails) {\n    const navigator1 = window1 && window1.navigator;\n    if (!navigator1.mediaDevices) {\n        return;\n    }\n    const constraintsToChrome_ = function(c) {\n        if (typeof c !== 'object' || c.mandatory || c.optional) {\n            return c;\n        }\n        const cc = {};\n        Object.keys(c).forEach((key)=>{\n            if (key === 'require' || key === 'advanced' || key === 'mediaSource') {\n                return;\n            }\n            const r = typeof c[key] === 'object' ? c[key] : {\n                ideal: c[key]\n            };\n            if (r.exact !== undefined && typeof r.exact === 'number') {\n                r.min = r.max = r.exact;\n            }\n            const oldname_ = function(prefix, name) {\n                if (prefix) {\n                    return prefix + name.charAt(0).toUpperCase() + name.slice(1);\n                }\n                return name === 'deviceId' ? 'sourceId' : name;\n            };\n            if (r.ideal !== undefined) {\n                cc.optional = cc.optional || [];\n                let oc = {};\n                if (typeof r.ideal === 'number') {\n                    oc[oldname_('min', key)] = r.ideal;\n                    cc.optional.push(oc);\n                    oc = {};\n                    oc[oldname_('max', key)] = r.ideal;\n                    cc.optional.push(oc);\n                } else {\n                    oc[oldname_('', key)] = r.ideal;\n                    cc.optional.push(oc);\n                }\n            }\n            if (r.exact !== undefined && typeof r.exact !== 'number') {\n                cc.mandatory = cc.mandatory || {};\n                cc.mandatory[oldname_('', key)] = r.exact;\n            } else {\n                [\n                    'min',\n                    'max'\n                ].forEach((mix)=>{\n                    if (r[mix] !== undefined) {\n                        cc.mandatory = cc.mandatory || {};\n                        cc.mandatory[oldname_(mix, key)] = r[mix];\n                    }\n                });\n            }\n        });\n        if (c.advanced) {\n            cc.optional = (cc.optional || []).concat(c.advanced);\n        }\n        return cc;\n    };\n    const shimConstraints_ = function(constraints, func) {\n        if (browserDetails.version >= 61) {\n            return func(constraints);\n        }\n        constraints = JSON.parse(JSON.stringify(constraints));\n        if (constraints && typeof constraints.audio === 'object') {\n            const remap = function(obj, a, b) {\n                if (a in obj && !(b in obj)) {\n                    obj[b] = obj[a];\n                    delete obj[a];\n                }\n            };\n            constraints = JSON.parse(JSON.stringify(constraints));\n            remap(constraints.audio, 'autoGainControl', 'googAutoGainControl');\n            remap(constraints.audio, 'noiseSuppression', 'googNoiseSuppression');\n            constraints.audio = constraintsToChrome_(constraints.audio);\n        }\n        if (constraints && typeof constraints.video === 'object') {\n            // Shim facingMode for mobile & surface pro.\n            let face = constraints.video.facingMode;\n            face = face && (typeof face === 'object' ? face : {\n                ideal: face\n            });\n            const getSupportedFacingModeLies = browserDetails.version < 66;\n            if (face && (face.exact === 'user' || face.exact === 'environment' || face.ideal === 'user' || face.ideal === 'environment') && !(navigator1.mediaDevices.getSupportedConstraints && navigator1.mediaDevices.getSupportedConstraints().facingMode && !getSupportedFacingModeLies)) {\n                delete constraints.video.facingMode;\n                let matches;\n                if (face.exact === 'environment' || face.ideal === 'environment') {\n                    matches = [\n                        'back',\n                        'rear'\n                    ];\n                } else if (face.exact === 'user' || face.ideal === 'user') {\n                    matches = [\n                        'front'\n                    ];\n                }\n                if (matches) {\n                    // Look for matches in label, or use last cam for back (typical).\n                    return navigator1.mediaDevices.enumerateDevices().then((devices)=>{\n                        devices = devices.filter((d)=>d.kind === 'videoinput');\n                        let dev = devices.find((d)=>matches.some((match)=>d.label.toLowerCase().includes(match)));\n                        if (!dev && devices.length && matches.includes('back')) {\n                            dev = devices[devices.length - 1]; // more likely the back cam\n                        }\n                        if (dev) {\n                            constraints.video.deviceId = face.exact ? {\n                                exact: dev.deviceId\n                            } : {\n                                ideal: dev.deviceId\n                            };\n                        }\n                        constraints.video = constraintsToChrome_(constraints.video);\n                        logging('chrome: ' + JSON.stringify(constraints));\n                        return func(constraints);\n                    });\n                }\n            }\n            constraints.video = constraintsToChrome_(constraints.video);\n        }\n        logging('chrome: ' + JSON.stringify(constraints));\n        return func(constraints);\n    };\n    const shimError_ = function(e) {\n        if (browserDetails.version >= 64) {\n            return e;\n        }\n        return {\n            name: ({\n                PermissionDeniedError: 'NotAllowedError',\n                PermissionDismissedError: 'NotAllowedError',\n                InvalidStateError: 'NotAllowedError',\n                DevicesNotFoundError: 'NotFoundError',\n                ConstraintNotSatisfiedError: 'OverconstrainedError',\n                TrackStartError: 'NotReadableError',\n                MediaDeviceFailedDueToShutdown: 'NotAllowedError',\n                MediaDeviceKillSwitchOn: 'NotAllowedError',\n                TabCaptureError: 'AbortError',\n                ScreenCaptureError: 'AbortError',\n                DeviceCaptureError: 'AbortError'\n            })[e.name] || e.name,\n            message: e.message,\n            constraint: e.constraint || e.constraintName,\n            toString () {\n                return this.name + (this.message && ': ') + this.message;\n            }\n        };\n    };\n    const getUserMedia_ = function(constraints, onSuccess, onError) {\n        shimConstraints_(constraints, (c)=>{\n            navigator1.webkitGetUserMedia(c, onSuccess, (e)=>{\n                if (onError) {\n                    onError(shimError_(e));\n                }\n            });\n        });\n    };\n    navigator1.getUserMedia = getUserMedia_.bind(navigator1);\n    // Even though Chrome 45 has navigator.mediaDevices and a getUserMedia\n    // function which returns a Promise, it does not accept spec-style\n    // constraints.\n    if (navigator1.mediaDevices.getUserMedia) {\n        const origGetUserMedia = navigator1.mediaDevices.getUserMedia.bind(navigator1.mediaDevices);\n        navigator1.mediaDevices.getUserMedia = function(cs) {\n            return shimConstraints_(cs, (c)=>origGetUserMedia(c).then((stream)=>{\n                    if (c.audio && !stream.getAudioTracks().length || c.video && !stream.getVideoTracks().length) {\n                        stream.getTracks().forEach((track)=>{\n                            track.stop();\n                        });\n                        throw new DOMException('', 'NotFoundError');\n                    }\n                    return stream;\n                }, (e)=>Promise.reject(shimError_(e))));\n        };\n    }\n}\n/*\n *  Copyright (c) 2018 The adapter.js project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */ /* eslint-env node */ function shimGetDisplayMedia$1(window1, getSourceId) {\n    if (window1.navigator.mediaDevices && 'getDisplayMedia' in window1.navigator.mediaDevices) {\n        return;\n    }\n    if (!window1.navigator.mediaDevices) {\n        return;\n    }\n    // getSourceId is a function that returns a promise resolving with\n    // the sourceId of the screen/window/tab to be shared.\n    if (typeof getSourceId !== 'function') {\n        console.error('shimGetDisplayMedia: getSourceId argument is not ' + 'a function');\n        return;\n    }\n    window1.navigator.mediaDevices.getDisplayMedia = function getDisplayMedia(constraints) {\n        return getSourceId(constraints).then((sourceId)=>{\n            const widthSpecified = constraints.video && constraints.video.width;\n            const heightSpecified = constraints.video && constraints.video.height;\n            const frameRateSpecified = constraints.video && constraints.video.frameRate;\n            constraints.video = {\n                mandatory: {\n                    chromeMediaSource: 'desktop',\n                    chromeMediaSourceId: sourceId,\n                    maxFrameRate: frameRateSpecified || 3\n                }\n            };\n            if (widthSpecified) {\n                constraints.video.mandatory.maxWidth = widthSpecified;\n            }\n            if (heightSpecified) {\n                constraints.video.mandatory.maxHeight = heightSpecified;\n            }\n            return window1.navigator.mediaDevices.getUserMedia(constraints);\n        });\n    };\n}\n/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */ /* eslint-env node */ function shimMediaStream(window1) {\n    window1.MediaStream = window1.MediaStream || window1.webkitMediaStream;\n}\nfunction shimOnTrack$1(window1) {\n    if (typeof window1 === 'object' && window1.RTCPeerConnection && !('ontrack' in window1.RTCPeerConnection.prototype)) {\n        Object.defineProperty(window1.RTCPeerConnection.prototype, 'ontrack', {\n            get () {\n                return this._ontrack;\n            },\n            set (f) {\n                if (this._ontrack) {\n                    this.removeEventListener('track', this._ontrack);\n                }\n                this.addEventListener('track', this._ontrack = f);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        const origSetRemoteDescription = window1.RTCPeerConnection.prototype.setRemoteDescription;\n        window1.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription() {\n            if (!this._ontrackpoly) {\n                this._ontrackpoly = (e)=>{\n                    // onaddstream does not fire when a track is added to an existing\n                    // stream. But stream.onaddtrack is implemented so we use that.\n                    e.stream.addEventListener('addtrack', (te)=>{\n                        let receiver;\n                        if (window1.RTCPeerConnection.prototype.getReceivers) {\n                            receiver = this.getReceivers().find((r)=>r.track && r.track.id === te.track.id);\n                        } else {\n                            receiver = {\n                                track: te.track\n                            };\n                        }\n                        const event = new Event('track');\n                        event.track = te.track;\n                        event.receiver = receiver;\n                        event.transceiver = {\n                            receiver\n                        };\n                        event.streams = [\n                            e.stream\n                        ];\n                        this.dispatchEvent(event);\n                    });\n                    e.stream.getTracks().forEach((track)=>{\n                        let receiver;\n                        if (window1.RTCPeerConnection.prototype.getReceivers) {\n                            receiver = this.getReceivers().find((r)=>r.track && r.track.id === track.id);\n                        } else {\n                            receiver = {\n                                track\n                            };\n                        }\n                        const event = new Event('track');\n                        event.track = track;\n                        event.receiver = receiver;\n                        event.transceiver = {\n                            receiver\n                        };\n                        event.streams = [\n                            e.stream\n                        ];\n                        this.dispatchEvent(event);\n                    });\n                };\n                this.addEventListener('addstream', this._ontrackpoly);\n            }\n            return origSetRemoteDescription.apply(this, arguments);\n        };\n    } else {\n        // even if RTCRtpTransceiver is in window, it is only used and\n        // emitted in unified-plan. Unfortunately this means we need\n        // to unconditionally wrap the event.\n        wrapPeerConnectionEvent(window1, 'track', (e)=>{\n            if (!e.transceiver) {\n                Object.defineProperty(e, 'transceiver', {\n                    value: {\n                        receiver: e.receiver\n                    }\n                });\n            }\n            return e;\n        });\n    }\n}\nfunction shimGetSendersWithDtmf(window1) {\n    // Overrides addTrack/removeTrack, depends on shimAddTrackRemoveTrack.\n    if (typeof window1 === 'object' && window1.RTCPeerConnection && !('getSenders' in window1.RTCPeerConnection.prototype) && 'createDTMFSender' in window1.RTCPeerConnection.prototype) {\n        const shimSenderWithDtmf = function(pc, track) {\n            return {\n                track,\n                get dtmf () {\n                    if (this._dtmf === undefined) {\n                        if (track.kind === 'audio') {\n                            this._dtmf = pc.createDTMFSender(track);\n                        } else {\n                            this._dtmf = null;\n                        }\n                    }\n                    return this._dtmf;\n                },\n                _pc: pc\n            };\n        };\n        // augment addTrack when getSenders is not available.\n        if (!window1.RTCPeerConnection.prototype.getSenders) {\n            window1.RTCPeerConnection.prototype.getSenders = function getSenders() {\n                this._senders = this._senders || [];\n                return this._senders.slice(); // return a copy of the internal state.\n            };\n            const origAddTrack = window1.RTCPeerConnection.prototype.addTrack;\n            window1.RTCPeerConnection.prototype.addTrack = function addTrack(track, stream) {\n                let sender = origAddTrack.apply(this, arguments);\n                if (!sender) {\n                    sender = shimSenderWithDtmf(this, track);\n                    this._senders.push(sender);\n                }\n                return sender;\n            };\n            const origRemoveTrack = window1.RTCPeerConnection.prototype.removeTrack;\n            window1.RTCPeerConnection.prototype.removeTrack = function removeTrack(sender) {\n                origRemoveTrack.apply(this, arguments);\n                const idx = this._senders.indexOf(sender);\n                if (idx !== -1) {\n                    this._senders.splice(idx, 1);\n                }\n            };\n        }\n        const origAddStream = window1.RTCPeerConnection.prototype.addStream;\n        window1.RTCPeerConnection.prototype.addStream = function addStream(stream) {\n            this._senders = this._senders || [];\n            origAddStream.apply(this, [\n                stream\n            ]);\n            stream.getTracks().forEach((track)=>{\n                this._senders.push(shimSenderWithDtmf(this, track));\n            });\n        };\n        const origRemoveStream = window1.RTCPeerConnection.prototype.removeStream;\n        window1.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {\n            this._senders = this._senders || [];\n            origRemoveStream.apply(this, [\n                stream\n            ]);\n            stream.getTracks().forEach((track)=>{\n                const sender = this._senders.find((s)=>s.track === track);\n                if (sender) {\n                    // remove sender\n                    this._senders.splice(this._senders.indexOf(sender), 1);\n                }\n            });\n        };\n    } else if (typeof window1 === 'object' && window1.RTCPeerConnection && 'getSenders' in window1.RTCPeerConnection.prototype && 'createDTMFSender' in window1.RTCPeerConnection.prototype && window1.RTCRtpSender && !('dtmf' in window1.RTCRtpSender.prototype)) {\n        const origGetSenders = window1.RTCPeerConnection.prototype.getSenders;\n        window1.RTCPeerConnection.prototype.getSenders = function getSenders() {\n            const senders = origGetSenders.apply(this, []);\n            senders.forEach((sender)=>sender._pc = this);\n            return senders;\n        };\n        Object.defineProperty(window1.RTCRtpSender.prototype, 'dtmf', {\n            get () {\n                if (this._dtmf === undefined) {\n                    if (this.track.kind === 'audio') {\n                        this._dtmf = this._pc.createDTMFSender(this.track);\n                    } else {\n                        this._dtmf = null;\n                    }\n                }\n                return this._dtmf;\n            }\n        });\n    }\n}\nfunction shimGetStats(window1) {\n    if (!window1.RTCPeerConnection) {\n        return;\n    }\n    const origGetStats = window1.RTCPeerConnection.prototype.getStats;\n    window1.RTCPeerConnection.prototype.getStats = function getStats() {\n        const [selector, onSucc, onErr] = arguments;\n        // If selector is a function then we are in the old style stats so just\n        // pass back the original getStats format to avoid breaking old users.\n        if (arguments.length > 0 && typeof selector === 'function') {\n            return origGetStats.apply(this, arguments);\n        }\n        // When spec-style getStats is supported, return those when called with\n        // either no arguments or the selector argument is null.\n        if (origGetStats.length === 0 && (arguments.length === 0 || typeof selector !== 'function')) {\n            return origGetStats.apply(this, []);\n        }\n        const fixChromeStats_ = function(response) {\n            const standardReport = {};\n            const reports = response.result();\n            reports.forEach((report)=>{\n                const standardStats = {\n                    id: report.id,\n                    timestamp: report.timestamp,\n                    type: {\n                        localcandidate: 'local-candidate',\n                        remotecandidate: 'remote-candidate'\n                    }[report.type] || report.type\n                };\n                report.names().forEach((name)=>{\n                    standardStats[name] = report.stat(name);\n                });\n                standardReport[standardStats.id] = standardStats;\n            });\n            return standardReport;\n        };\n        // shim getStats with maplike support\n        const makeMapStats = function(stats) {\n            return new Map(Object.keys(stats).map((key)=>[\n                    key,\n                    stats[key]\n                ]));\n        };\n        if (arguments.length >= 2) {\n            const successCallbackWrapper_ = function(response) {\n                onSucc(makeMapStats(fixChromeStats_(response)));\n            };\n            return origGetStats.apply(this, [\n                successCallbackWrapper_,\n                selector\n            ]);\n        }\n        // promise-support\n        return new Promise((resolve, reject)=>{\n            origGetStats.apply(this, [\n                function(response) {\n                    resolve(makeMapStats(fixChromeStats_(response)));\n                },\n                reject\n            ]);\n        }).then(onSucc, onErr);\n    };\n}\nfunction shimSenderReceiverGetStats(window1) {\n    if (!(typeof window1 === 'object' && window1.RTCPeerConnection && window1.RTCRtpSender && window1.RTCRtpReceiver)) {\n        return;\n    }\n    // shim sender stats.\n    if (!('getStats' in window1.RTCRtpSender.prototype)) {\n        const origGetSenders = window1.RTCPeerConnection.prototype.getSenders;\n        if (origGetSenders) {\n            window1.RTCPeerConnection.prototype.getSenders = function getSenders() {\n                const senders = origGetSenders.apply(this, []);\n                senders.forEach((sender)=>sender._pc = this);\n                return senders;\n            };\n        }\n        const origAddTrack = window1.RTCPeerConnection.prototype.addTrack;\n        if (origAddTrack) {\n            window1.RTCPeerConnection.prototype.addTrack = function addTrack() {\n                const sender = origAddTrack.apply(this, arguments);\n                sender._pc = this;\n                return sender;\n            };\n        }\n        window1.RTCRtpSender.prototype.getStats = function getStats() {\n            const sender = this;\n            return this._pc.getStats().then((result)=>/* Note: this will include stats of all senders that\n       *   send a track with the same id as sender.track as\n       *   it is not possible to identify the RTCRtpSender.\n       */ filterStats(result, sender.track, true));\n        };\n    }\n    // shim receiver stats.\n    if (!('getStats' in window1.RTCRtpReceiver.prototype)) {\n        const origGetReceivers = window1.RTCPeerConnection.prototype.getReceivers;\n        if (origGetReceivers) {\n            window1.RTCPeerConnection.prototype.getReceivers = function getReceivers() {\n                const receivers = origGetReceivers.apply(this, []);\n                receivers.forEach((receiver)=>receiver._pc = this);\n                return receivers;\n            };\n        }\n        wrapPeerConnectionEvent(window1, 'track', (e)=>{\n            e.receiver._pc = e.srcElement;\n            return e;\n        });\n        window1.RTCRtpReceiver.prototype.getStats = function getStats() {\n            const receiver = this;\n            return this._pc.getStats().then((result)=>filterStats(result, receiver.track, false));\n        };\n    }\n    if (!('getStats' in window1.RTCRtpSender.prototype && 'getStats' in window1.RTCRtpReceiver.prototype)) {\n        return;\n    }\n    // shim RTCPeerConnection.getStats(track).\n    const origGetStats = window1.RTCPeerConnection.prototype.getStats;\n    window1.RTCPeerConnection.prototype.getStats = function getStats() {\n        if (arguments.length > 0 && arguments[0] instanceof window1.MediaStreamTrack) {\n            const track = arguments[0];\n            let sender;\n            let receiver;\n            let err;\n            this.getSenders().forEach((s)=>{\n                if (s.track === track) {\n                    if (sender) {\n                        err = true;\n                    } else {\n                        sender = s;\n                    }\n                }\n            });\n            this.getReceivers().forEach((r)=>{\n                if (r.track === track) {\n                    if (receiver) {\n                        err = true;\n                    } else {\n                        receiver = r;\n                    }\n                }\n                return r.track === track;\n            });\n            if (err || sender && receiver) {\n                return Promise.reject(new DOMException('There are more than one sender or receiver for the track.', 'InvalidAccessError'));\n            } else if (sender) {\n                return sender.getStats();\n            } else if (receiver) {\n                return receiver.getStats();\n            }\n            return Promise.reject(new DOMException('There is no sender or receiver for the track.', 'InvalidAccessError'));\n        }\n        return origGetStats.apply(this, arguments);\n    };\n}\nfunction shimAddTrackRemoveTrackWithNative(window1) {\n    // shim addTrack/removeTrack with native variants in order to make\n    // the interactions with legacy getLocalStreams behave as in other browsers.\n    // Keeps a mapping stream.id => [stream, rtpsenders...]\n    window1.RTCPeerConnection.prototype.getLocalStreams = function getLocalStreams() {\n        this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n        return Object.keys(this._shimmedLocalStreams).map((streamId)=>this._shimmedLocalStreams[streamId][0]);\n    };\n    const origAddTrack = window1.RTCPeerConnection.prototype.addTrack;\n    window1.RTCPeerConnection.prototype.addTrack = function addTrack(track, stream) {\n        if (!stream) {\n            return origAddTrack.apply(this, arguments);\n        }\n        this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n        const sender = origAddTrack.apply(this, arguments);\n        if (!this._shimmedLocalStreams[stream.id]) {\n            this._shimmedLocalStreams[stream.id] = [\n                stream,\n                sender\n            ];\n        } else if (this._shimmedLocalStreams[stream.id].indexOf(sender) === -1) {\n            this._shimmedLocalStreams[stream.id].push(sender);\n        }\n        return sender;\n    };\n    const origAddStream = window1.RTCPeerConnection.prototype.addStream;\n    window1.RTCPeerConnection.prototype.addStream = function addStream(stream) {\n        this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n        stream.getTracks().forEach((track)=>{\n            const alreadyExists = this.getSenders().find((s)=>s.track === track);\n            if (alreadyExists) {\n                throw new DOMException('Track already exists.', 'InvalidAccessError');\n            }\n        });\n        const existingSenders = this.getSenders();\n        origAddStream.apply(this, arguments);\n        const newSenders = this.getSenders().filter((newSender)=>existingSenders.indexOf(newSender) === -1);\n        this._shimmedLocalStreams[stream.id] = [\n            stream\n        ].concat(newSenders);\n    };\n    const origRemoveStream = window1.RTCPeerConnection.prototype.removeStream;\n    window1.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {\n        this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n        delete this._shimmedLocalStreams[stream.id];\n        return origRemoveStream.apply(this, arguments);\n    };\n    const origRemoveTrack = window1.RTCPeerConnection.prototype.removeTrack;\n    window1.RTCPeerConnection.prototype.removeTrack = function removeTrack(sender) {\n        this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n        if (sender) {\n            Object.keys(this._shimmedLocalStreams).forEach((streamId)=>{\n                const idx = this._shimmedLocalStreams[streamId].indexOf(sender);\n                if (idx !== -1) {\n                    this._shimmedLocalStreams[streamId].splice(idx, 1);\n                }\n                if (this._shimmedLocalStreams[streamId].length === 1) {\n                    delete this._shimmedLocalStreams[streamId];\n                }\n            });\n        }\n        return origRemoveTrack.apply(this, arguments);\n    };\n}\nfunction shimAddTrackRemoveTrack(window1, browserDetails) {\n    if (!window1.RTCPeerConnection) {\n        return;\n    }\n    // shim addTrack and removeTrack.\n    if (window1.RTCPeerConnection.prototype.addTrack && browserDetails.version >= 65) {\n        return shimAddTrackRemoveTrackWithNative(window1);\n    }\n    // also shim pc.getLocalStreams when addTrack is shimmed\n    // to return the original streams.\n    const origGetLocalStreams = window1.RTCPeerConnection.prototype.getLocalStreams;\n    window1.RTCPeerConnection.prototype.getLocalStreams = function getLocalStreams() {\n        const nativeStreams = origGetLocalStreams.apply(this);\n        this._reverseStreams = this._reverseStreams || {};\n        return nativeStreams.map((stream)=>this._reverseStreams[stream.id]);\n    };\n    const origAddStream = window1.RTCPeerConnection.prototype.addStream;\n    window1.RTCPeerConnection.prototype.addStream = function addStream(stream) {\n        this._streams = this._streams || {};\n        this._reverseStreams = this._reverseStreams || {};\n        stream.getTracks().forEach((track)=>{\n            const alreadyExists = this.getSenders().find((s)=>s.track === track);\n            if (alreadyExists) {\n                throw new DOMException('Track already exists.', 'InvalidAccessError');\n            }\n        });\n        // Add identity mapping for consistency with addTrack.\n        // Unless this is being used with a stream from addTrack.\n        if (!this._reverseStreams[stream.id]) {\n            const newStream = new window1.MediaStream(stream.getTracks());\n            this._streams[stream.id] = newStream;\n            this._reverseStreams[newStream.id] = stream;\n            stream = newStream;\n        }\n        origAddStream.apply(this, [\n            stream\n        ]);\n    };\n    const origRemoveStream = window1.RTCPeerConnection.prototype.removeStream;\n    window1.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {\n        this._streams = this._streams || {};\n        this._reverseStreams = this._reverseStreams || {};\n        origRemoveStream.apply(this, [\n            this._streams[stream.id] || stream\n        ]);\n        delete this._reverseStreams[this._streams[stream.id] ? this._streams[stream.id].id : stream.id];\n        delete this._streams[stream.id];\n    };\n    window1.RTCPeerConnection.prototype.addTrack = function addTrack(track, stream) {\n        if (this.signalingState === 'closed') {\n            throw new DOMException('The RTCPeerConnection\\'s signalingState is \\'closed\\'.', 'InvalidStateError');\n        }\n        const streams = [].slice.call(arguments, 1);\n        if (streams.length !== 1 || !streams[0].getTracks().find((t)=>t === track)) {\n            // this is not fully correct but all we can manage without\n            // [[associated MediaStreams]] internal slot.\n            throw new DOMException('The adapter.js addTrack polyfill only supports a single ' + ' stream which is associated with the specified track.', 'NotSupportedError');\n        }\n        const alreadyExists = this.getSenders().find((s)=>s.track === track);\n        if (alreadyExists) {\n            throw new DOMException('Track already exists.', 'InvalidAccessError');\n        }\n        this._streams = this._streams || {};\n        this._reverseStreams = this._reverseStreams || {};\n        const oldStream = this._streams[stream.id];\n        if (oldStream) {\n            // this is using odd Chrome behaviour, use with caution:\n            // https://bugs.chromium.org/p/webrtc/issues/detail?id=7815\n            // Note: we rely on the high-level addTrack/dtmf shim to\n            // create the sender with a dtmf sender.\n            oldStream.addTrack(track);\n            // Trigger ONN async.\n            Promise.resolve().then(()=>{\n                this.dispatchEvent(new Event('negotiationneeded'));\n            });\n        } else {\n            const newStream = new window1.MediaStream([\n                track\n            ]);\n            this._streams[stream.id] = newStream;\n            this._reverseStreams[newStream.id] = stream;\n            this.addStream(newStream);\n        }\n        return this.getSenders().find((s)=>s.track === track);\n    };\n    // replace the internal stream id with the external one and\n    // vice versa.\n    function replaceInternalStreamId(pc, description) {\n        let sdp = description.sdp;\n        Object.keys(pc._reverseStreams || []).forEach((internalId)=>{\n            const externalStream = pc._reverseStreams[internalId];\n            const internalStream = pc._streams[externalStream.id];\n            sdp = sdp.replace(new RegExp(internalStream.id, 'g'), externalStream.id);\n        });\n        return new RTCSessionDescription({\n            type: description.type,\n            sdp\n        });\n    }\n    function replaceExternalStreamId(pc, description) {\n        let sdp = description.sdp;\n        Object.keys(pc._reverseStreams || []).forEach((internalId)=>{\n            const externalStream = pc._reverseStreams[internalId];\n            const internalStream = pc._streams[externalStream.id];\n            sdp = sdp.replace(new RegExp(externalStream.id, 'g'), internalStream.id);\n        });\n        return new RTCSessionDescription({\n            type: description.type,\n            sdp\n        });\n    }\n    [\n        'createOffer',\n        'createAnswer'\n    ].forEach(function(method) {\n        const nativeMethod = window1.RTCPeerConnection.prototype[method];\n        const methodObj = {\n            [method] () {\n                const args = arguments;\n                const isLegacyCall = arguments.length && typeof arguments[0] === 'function';\n                if (isLegacyCall) {\n                    return nativeMethod.apply(this, [\n                        (description)=>{\n                            const desc = replaceInternalStreamId(this, description);\n                            args[0].apply(null, [\n                                desc\n                            ]);\n                        },\n                        (err)=>{\n                            if (args[1]) {\n                                args[1].apply(null, err);\n                            }\n                        },\n                        arguments[2]\n                    ]);\n                }\n                return nativeMethod.apply(this, arguments).then((description)=>replaceInternalStreamId(this, description));\n            }\n        };\n        window1.RTCPeerConnection.prototype[method] = methodObj[method];\n    });\n    const origSetLocalDescription = window1.RTCPeerConnection.prototype.setLocalDescription;\n    window1.RTCPeerConnection.prototype.setLocalDescription = function setLocalDescription() {\n        if (!arguments.length || !arguments[0].type) {\n            return origSetLocalDescription.apply(this, arguments);\n        }\n        arguments[0] = replaceExternalStreamId(this, arguments[0]);\n        return origSetLocalDescription.apply(this, arguments);\n    };\n    // TODO: mangle getStats: https://w3c.github.io/webrtc-stats/#dom-rtcmediastreamstats-streamidentifier\n    const origLocalDescription = Object.getOwnPropertyDescriptor(window1.RTCPeerConnection.prototype, 'localDescription');\n    Object.defineProperty(window1.RTCPeerConnection.prototype, 'localDescription', {\n        get () {\n            const description = origLocalDescription.get.apply(this);\n            if (description.type === '') {\n                return description;\n            }\n            return replaceInternalStreamId(this, description);\n        }\n    });\n    window1.RTCPeerConnection.prototype.removeTrack = function removeTrack(sender) {\n        if (this.signalingState === 'closed') {\n            throw new DOMException('The RTCPeerConnection\\'s signalingState is \\'closed\\'.', 'InvalidStateError');\n        }\n        // We can not yet check for sender instanceof RTCRtpSender\n        // since we shim RTPSender. So we check if sender._pc is set.\n        if (!sender._pc) {\n            throw new DOMException('Argument 1 of RTCPeerConnection.removeTrack ' + 'does not implement interface RTCRtpSender.', 'TypeError');\n        }\n        const isLocal = sender._pc === this;\n        if (!isLocal) {\n            throw new DOMException('Sender was not created by this connection.', 'InvalidAccessError');\n        }\n        // Search for the native stream the senders track belongs to.\n        this._streams = this._streams || {};\n        let stream;\n        Object.keys(this._streams).forEach((streamid)=>{\n            const hasTrack = this._streams[streamid].getTracks().find((track)=>sender.track === track);\n            if (hasTrack) {\n                stream = this._streams[streamid];\n            }\n        });\n        if (stream) {\n            if (stream.getTracks().length === 1) {\n                // if this is the last track of the stream, remove the stream. This\n                // takes care of any shimmed _senders.\n                this.removeStream(this._reverseStreams[stream.id]);\n            } else {\n                // relying on the same odd chrome behaviour as above.\n                stream.removeTrack(sender.track);\n            }\n            this.dispatchEvent(new Event('negotiationneeded'));\n        }\n    };\n}\nfunction shimPeerConnection$1(window1, browserDetails) {\n    if (!window1.RTCPeerConnection && window1.webkitRTCPeerConnection) {\n        // very basic support for old versions.\n        window1.RTCPeerConnection = window1.webkitRTCPeerConnection;\n    }\n    if (!window1.RTCPeerConnection) {\n        return;\n    }\n    // shim implicit creation of RTCSessionDescription/RTCIceCandidate\n    if (browserDetails.version < 53) {\n        [\n            'setLocalDescription',\n            'setRemoteDescription',\n            'addIceCandidate'\n        ].forEach(function(method) {\n            const nativeMethod = window1.RTCPeerConnection.prototype[method];\n            const methodObj = {\n                [method] () {\n                    arguments[0] = new (method === 'addIceCandidate' ? window1.RTCIceCandidate : window1.RTCSessionDescription)(arguments[0]);\n                    return nativeMethod.apply(this, arguments);\n                }\n            };\n            window1.RTCPeerConnection.prototype[method] = methodObj[method];\n        });\n    }\n}\n// Attempt to fix ONN in plan-b mode.\nfunction fixNegotiationNeeded(window1, browserDetails) {\n    wrapPeerConnectionEvent(window1, 'negotiationneeded', (e)=>{\n        const pc = e.target;\n        if (browserDetails.version < 72 || pc.getConfiguration && pc.getConfiguration().sdpSemantics === 'plan-b') {\n            if (pc.signalingState !== 'stable') {\n                return;\n            }\n        }\n        return e;\n    });\n}\nvar chromeShim = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    fixNegotiationNeeded: fixNegotiationNeeded,\n    shimAddTrackRemoveTrack: shimAddTrackRemoveTrack,\n    shimAddTrackRemoveTrackWithNative: shimAddTrackRemoveTrackWithNative,\n    shimGetDisplayMedia: shimGetDisplayMedia$1,\n    shimGetSendersWithDtmf: shimGetSendersWithDtmf,\n    shimGetStats: shimGetStats,\n    shimGetUserMedia: shimGetUserMedia$2,\n    shimMediaStream: shimMediaStream,\n    shimOnTrack: shimOnTrack$1,\n    shimPeerConnection: shimPeerConnection$1,\n    shimSenderReceiverGetStats: shimSenderReceiverGetStats\n});\n/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */ /* eslint-env node */ function shimGetUserMedia$1(window1, browserDetails) {\n    const navigator1 = window1 && window1.navigator;\n    const MediaStreamTrack1 = window1 && window1.MediaStreamTrack;\n    navigator1.getUserMedia = function(constraints, onSuccess, onError) {\n        // Replace Firefox 44+'s deprecation warning with unprefixed version.\n        deprecated('navigator.getUserMedia', 'navigator.mediaDevices.getUserMedia');\n        navigator1.mediaDevices.getUserMedia(constraints).then(onSuccess, onError);\n    };\n    if (!(browserDetails.version > 55 && 'autoGainControl' in navigator1.mediaDevices.getSupportedConstraints())) {\n        const remap = function(obj, a, b) {\n            if (a in obj && !(b in obj)) {\n                obj[b] = obj[a];\n                delete obj[a];\n            }\n        };\n        const nativeGetUserMedia = navigator1.mediaDevices.getUserMedia.bind(navigator1.mediaDevices);\n        navigator1.mediaDevices.getUserMedia = function(c) {\n            if (typeof c === 'object' && typeof c.audio === 'object') {\n                c = JSON.parse(JSON.stringify(c));\n                remap(c.audio, 'autoGainControl', 'mozAutoGainControl');\n                remap(c.audio, 'noiseSuppression', 'mozNoiseSuppression');\n            }\n            return nativeGetUserMedia(c);\n        };\n        if (MediaStreamTrack1 && MediaStreamTrack1.prototype.getSettings) {\n            const nativeGetSettings = MediaStreamTrack1.prototype.getSettings;\n            MediaStreamTrack1.prototype.getSettings = function() {\n                const obj = nativeGetSettings.apply(this, arguments);\n                remap(obj, 'mozAutoGainControl', 'autoGainControl');\n                remap(obj, 'mozNoiseSuppression', 'noiseSuppression');\n                return obj;\n            };\n        }\n        if (MediaStreamTrack1 && MediaStreamTrack1.prototype.applyConstraints) {\n            const nativeApplyConstraints = MediaStreamTrack1.prototype.applyConstraints;\n            MediaStreamTrack1.prototype.applyConstraints = function(c) {\n                if (this.kind === 'audio' && typeof c === 'object') {\n                    c = JSON.parse(JSON.stringify(c));\n                    remap(c, 'autoGainControl', 'mozAutoGainControl');\n                    remap(c, 'noiseSuppression', 'mozNoiseSuppression');\n                }\n                return nativeApplyConstraints.apply(this, [\n                    c\n                ]);\n            };\n        }\n    }\n}\n/*\n *  Copyright (c) 2018 The adapter.js project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */ /* eslint-env node */ function shimGetDisplayMedia(window1, preferredMediaSource) {\n    if (window1.navigator.mediaDevices && 'getDisplayMedia' in window1.navigator.mediaDevices) {\n        return;\n    }\n    if (!window1.navigator.mediaDevices) {\n        return;\n    }\n    window1.navigator.mediaDevices.getDisplayMedia = function getDisplayMedia(constraints) {\n        if (!(constraints && constraints.video)) {\n            const err = new DOMException('getDisplayMedia without video ' + 'constraints is undefined');\n            err.name = 'NotFoundError';\n            // from https://heycam.github.io/webidl/#idl-DOMException-error-names\n            err.code = 8;\n            return Promise.reject(err);\n        }\n        if (constraints.video === true) {\n            constraints.video = {\n                mediaSource: preferredMediaSource\n            };\n        } else {\n            constraints.video.mediaSource = preferredMediaSource;\n        }\n        return window1.navigator.mediaDevices.getUserMedia(constraints);\n    };\n}\n/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */ /* eslint-env node */ function shimOnTrack(window1) {\n    if (typeof window1 === 'object' && window1.RTCTrackEvent && 'receiver' in window1.RTCTrackEvent.prototype && !('transceiver' in window1.RTCTrackEvent.prototype)) {\n        Object.defineProperty(window1.RTCTrackEvent.prototype, 'transceiver', {\n            get () {\n                return {\n                    receiver: this.receiver\n                };\n            }\n        });\n    }\n}\nfunction shimPeerConnection(window1, browserDetails) {\n    if (typeof window1 !== 'object' || !(window1.RTCPeerConnection || window1.mozRTCPeerConnection)) {\n        return; // probably media.peerconnection.enabled=false in about:config\n    }\n    if (!window1.RTCPeerConnection && window1.mozRTCPeerConnection) {\n        // very basic support for old versions.\n        window1.RTCPeerConnection = window1.mozRTCPeerConnection;\n    }\n    if (browserDetails.version < 53) {\n        // shim away need for obsolete RTCIceCandidate/RTCSessionDescription.\n        [\n            'setLocalDescription',\n            'setRemoteDescription',\n            'addIceCandidate'\n        ].forEach(function(method) {\n            const nativeMethod = window1.RTCPeerConnection.prototype[method];\n            const methodObj = {\n                [method] () {\n                    arguments[0] = new (method === 'addIceCandidate' ? window1.RTCIceCandidate : window1.RTCSessionDescription)(arguments[0]);\n                    return nativeMethod.apply(this, arguments);\n                }\n            };\n            window1.RTCPeerConnection.prototype[method] = methodObj[method];\n        });\n    }\n    const modernStatsTypes = {\n        inboundrtp: 'inbound-rtp',\n        outboundrtp: 'outbound-rtp',\n        candidatepair: 'candidate-pair',\n        localcandidate: 'local-candidate',\n        remotecandidate: 'remote-candidate'\n    };\n    const nativeGetStats = window1.RTCPeerConnection.prototype.getStats;\n    window1.RTCPeerConnection.prototype.getStats = function getStats() {\n        const [selector, onSucc, onErr] = arguments;\n        return nativeGetStats.apply(this, [\n            selector || null\n        ]).then((stats)=>{\n            if (browserDetails.version < 53 && !onSucc) {\n                // Shim only promise getStats with spec-hyphens in type names\n                // Leave callback version alone; misc old uses of forEach before Map\n                try {\n                    stats.forEach((stat)=>{\n                        stat.type = modernStatsTypes[stat.type] || stat.type;\n                    });\n                } catch (e) {\n                    if (e.name !== 'TypeError') {\n                        throw e;\n                    }\n                    // Avoid TypeError: \"type\" is read-only, in old versions. 34-43ish\n                    stats.forEach((stat, i)=>{\n                        stats.set(i, Object.assign({}, stat, {\n                            type: modernStatsTypes[stat.type] || stat.type\n                        }));\n                    });\n                }\n            }\n            return stats;\n        }).then(onSucc, onErr);\n    };\n}\nfunction shimSenderGetStats(window1) {\n    if (!(typeof window1 === 'object' && window1.RTCPeerConnection && window1.RTCRtpSender)) {\n        return;\n    }\n    if (window1.RTCRtpSender && 'getStats' in window1.RTCRtpSender.prototype) {\n        return;\n    }\n    const origGetSenders = window1.RTCPeerConnection.prototype.getSenders;\n    if (origGetSenders) {\n        window1.RTCPeerConnection.prototype.getSenders = function getSenders() {\n            const senders = origGetSenders.apply(this, []);\n            senders.forEach((sender)=>sender._pc = this);\n            return senders;\n        };\n    }\n    const origAddTrack = window1.RTCPeerConnection.prototype.addTrack;\n    if (origAddTrack) {\n        window1.RTCPeerConnection.prototype.addTrack = function addTrack() {\n            const sender = origAddTrack.apply(this, arguments);\n            sender._pc = this;\n            return sender;\n        };\n    }\n    window1.RTCRtpSender.prototype.getStats = function getStats() {\n        return this.track ? this._pc.getStats(this.track) : Promise.resolve(new Map());\n    };\n}\nfunction shimReceiverGetStats(window1) {\n    if (!(typeof window1 === 'object' && window1.RTCPeerConnection && window1.RTCRtpSender)) {\n        return;\n    }\n    if (window1.RTCRtpSender && 'getStats' in window1.RTCRtpReceiver.prototype) {\n        return;\n    }\n    const origGetReceivers = window1.RTCPeerConnection.prototype.getReceivers;\n    if (origGetReceivers) {\n        window1.RTCPeerConnection.prototype.getReceivers = function getReceivers() {\n            const receivers = origGetReceivers.apply(this, []);\n            receivers.forEach((receiver)=>receiver._pc = this);\n            return receivers;\n        };\n    }\n    wrapPeerConnectionEvent(window1, 'track', (e)=>{\n        e.receiver._pc = e.srcElement;\n        return e;\n    });\n    window1.RTCRtpReceiver.prototype.getStats = function getStats() {\n        return this._pc.getStats(this.track);\n    };\n}\nfunction shimRemoveStream(window1) {\n    if (!window1.RTCPeerConnection || 'removeStream' in window1.RTCPeerConnection.prototype) {\n        return;\n    }\n    window1.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {\n        deprecated('removeStream', 'removeTrack');\n        this.getSenders().forEach((sender)=>{\n            if (sender.track && stream.getTracks().includes(sender.track)) {\n                this.removeTrack(sender);\n            }\n        });\n    };\n}\nfunction shimRTCDataChannel(window1) {\n    // rename DataChannel to RTCDataChannel (native fix in FF60):\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=1173851\n    if (window1.DataChannel && !window1.RTCDataChannel) {\n        window1.RTCDataChannel = window1.DataChannel;\n    }\n}\nfunction shimAddTransceiver(window1) {\n    // https://github.com/webrtcHacks/adapter/issues/998#issuecomment-516921647\n    // Firefox ignores the init sendEncodings options passed to addTransceiver\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=1396918\n    if (!(typeof window1 === 'object' && window1.RTCPeerConnection)) {\n        return;\n    }\n    const origAddTransceiver = window1.RTCPeerConnection.prototype.addTransceiver;\n    if (origAddTransceiver) {\n        window1.RTCPeerConnection.prototype.addTransceiver = function addTransceiver() {\n            this.setParametersPromises = [];\n            // WebIDL input coercion and validation\n            let sendEncodings = arguments[1] && arguments[1].sendEncodings;\n            if (sendEncodings === undefined) {\n                sendEncodings = [];\n            }\n            sendEncodings = [\n                ...sendEncodings\n            ];\n            const shouldPerformCheck = sendEncodings.length > 0;\n            if (shouldPerformCheck) {\n                // If sendEncodings params are provided, validate grammar\n                sendEncodings.forEach((encodingParam)=>{\n                    if ('rid' in encodingParam) {\n                        const ridRegex = /^[a-z0-9]{0,16}$/i;\n                        if (!ridRegex.test(encodingParam.rid)) {\n                            throw new TypeError('Invalid RID value provided.');\n                        }\n                    }\n                    if ('scaleResolutionDownBy' in encodingParam) {\n                        if (!(parseFloat(encodingParam.scaleResolutionDownBy) >= 1.0)) {\n                            throw new RangeError('scale_resolution_down_by must be >= 1.0');\n                        }\n                    }\n                    if ('maxFramerate' in encodingParam) {\n                        if (!(parseFloat(encodingParam.maxFramerate) >= 0)) {\n                            throw new RangeError('max_framerate must be >= 0.0');\n                        }\n                    }\n                });\n            }\n            const transceiver = origAddTransceiver.apply(this, arguments);\n            if (shouldPerformCheck) {\n                // Check if the init options were applied. If not we do this in an\n                // asynchronous way and save the promise reference in a global object.\n                // This is an ugly hack, but at the same time is way more robust than\n                // checking the sender parameters before and after the createOffer\n                // Also note that after the createoffer we are not 100% sure that\n                // the params were asynchronously applied so we might miss the\n                // opportunity to recreate offer.\n                const { sender } = transceiver;\n                const params = sender.getParameters();\n                if (!('encodings' in params) || // Avoid being fooled by patched getParameters() below.\n                params.encodings.length === 1 && Object.keys(params.encodings[0]).length === 0) {\n                    params.encodings = sendEncodings;\n                    sender.sendEncodings = sendEncodings;\n                    this.setParametersPromises.push(sender.setParameters(params).then(()=>{\n                        delete sender.sendEncodings;\n                    }).catch(()=>{\n                        delete sender.sendEncodings;\n                    }));\n                }\n            }\n            return transceiver;\n        };\n    }\n}\nfunction shimGetParameters(window1) {\n    if (!(typeof window1 === 'object' && window1.RTCRtpSender)) {\n        return;\n    }\n    const origGetParameters = window1.RTCRtpSender.prototype.getParameters;\n    if (origGetParameters) {\n        window1.RTCRtpSender.prototype.getParameters = function getParameters() {\n            const params = origGetParameters.apply(this, arguments);\n            if (!('encodings' in params)) {\n                params.encodings = [].concat(this.sendEncodings || [\n                    {}\n                ]);\n            }\n            return params;\n        };\n    }\n}\nfunction shimCreateOffer(window1) {\n    // https://github.com/webrtcHacks/adapter/issues/998#issuecomment-516921647\n    // Firefox ignores the init sendEncodings options passed to addTransceiver\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=1396918\n    if (!(typeof window1 === 'object' && window1.RTCPeerConnection)) {\n        return;\n    }\n    const origCreateOffer = window1.RTCPeerConnection.prototype.createOffer;\n    window1.RTCPeerConnection.prototype.createOffer = function createOffer() {\n        if (this.setParametersPromises && this.setParametersPromises.length) {\n            return Promise.all(this.setParametersPromises).then(()=>{\n                return origCreateOffer.apply(this, arguments);\n            }).finally(()=>{\n                this.setParametersPromises = [];\n            });\n        }\n        return origCreateOffer.apply(this, arguments);\n    };\n}\nfunction shimCreateAnswer(window1) {\n    // https://github.com/webrtcHacks/adapter/issues/998#issuecomment-516921647\n    // Firefox ignores the init sendEncodings options passed to addTransceiver\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=1396918\n    if (!(typeof window1 === 'object' && window1.RTCPeerConnection)) {\n        return;\n    }\n    const origCreateAnswer = window1.RTCPeerConnection.prototype.createAnswer;\n    window1.RTCPeerConnection.prototype.createAnswer = function createAnswer() {\n        if (this.setParametersPromises && this.setParametersPromises.length) {\n            return Promise.all(this.setParametersPromises).then(()=>{\n                return origCreateAnswer.apply(this, arguments);\n            }).finally(()=>{\n                this.setParametersPromises = [];\n            });\n        }\n        return origCreateAnswer.apply(this, arguments);\n    };\n}\nvar firefoxShim = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    shimAddTransceiver: shimAddTransceiver,\n    shimCreateAnswer: shimCreateAnswer,\n    shimCreateOffer: shimCreateOffer,\n    shimGetDisplayMedia: shimGetDisplayMedia,\n    shimGetParameters: shimGetParameters,\n    shimGetUserMedia: shimGetUserMedia$1,\n    shimOnTrack: shimOnTrack,\n    shimPeerConnection: shimPeerConnection,\n    shimRTCDataChannel: shimRTCDataChannel,\n    shimReceiverGetStats: shimReceiverGetStats,\n    shimRemoveStream: shimRemoveStream,\n    shimSenderGetStats: shimSenderGetStats\n});\n/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */ function shimLocalStreamsAPI(window1) {\n    if (typeof window1 !== 'object' || !window1.RTCPeerConnection) {\n        return;\n    }\n    if (!('getLocalStreams' in window1.RTCPeerConnection.prototype)) {\n        window1.RTCPeerConnection.prototype.getLocalStreams = function getLocalStreams() {\n            if (!this._localStreams) {\n                this._localStreams = [];\n            }\n            return this._localStreams;\n        };\n    }\n    if (!('addStream' in window1.RTCPeerConnection.prototype)) {\n        const _addTrack = window1.RTCPeerConnection.prototype.addTrack;\n        window1.RTCPeerConnection.prototype.addStream = function addStream(stream) {\n            if (!this._localStreams) {\n                this._localStreams = [];\n            }\n            if (!this._localStreams.includes(stream)) {\n                this._localStreams.push(stream);\n            }\n            // Try to emulate Chrome's behaviour of adding in audio-video order.\n            // Safari orders by track id.\n            stream.getAudioTracks().forEach((track)=>_addTrack.call(this, track, stream));\n            stream.getVideoTracks().forEach((track)=>_addTrack.call(this, track, stream));\n        };\n        window1.RTCPeerConnection.prototype.addTrack = function addTrack(track) {\n            for(var _len = arguments.length, streams = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n                streams[_key - 1] = arguments[_key];\n            }\n            if (streams) {\n                streams.forEach((stream)=>{\n                    if (!this._localStreams) {\n                        this._localStreams = [\n                            stream\n                        ];\n                    } else if (!this._localStreams.includes(stream)) {\n                        this._localStreams.push(stream);\n                    }\n                });\n            }\n            return _addTrack.apply(this, arguments);\n        };\n    }\n    if (!('removeStream' in window1.RTCPeerConnection.prototype)) {\n        window1.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {\n            if (!this._localStreams) {\n                this._localStreams = [];\n            }\n            const index = this._localStreams.indexOf(stream);\n            if (index === -1) {\n                return;\n            }\n            this._localStreams.splice(index, 1);\n            const tracks = stream.getTracks();\n            this.getSenders().forEach((sender)=>{\n                if (tracks.includes(sender.track)) {\n                    this.removeTrack(sender);\n                }\n            });\n        };\n    }\n}\nfunction shimRemoteStreamsAPI(window1) {\n    if (typeof window1 !== 'object' || !window1.RTCPeerConnection) {\n        return;\n    }\n    if (!('getRemoteStreams' in window1.RTCPeerConnection.prototype)) {\n        window1.RTCPeerConnection.prototype.getRemoteStreams = function getRemoteStreams() {\n            return this._remoteStreams ? this._remoteStreams : [];\n        };\n    }\n    if (!('onaddstream' in window1.RTCPeerConnection.prototype)) {\n        Object.defineProperty(window1.RTCPeerConnection.prototype, 'onaddstream', {\n            get () {\n                return this._onaddstream;\n            },\n            set (f) {\n                if (this._onaddstream) {\n                    this.removeEventListener('addstream', this._onaddstream);\n                    this.removeEventListener('track', this._onaddstreampoly);\n                }\n                this.addEventListener('addstream', this._onaddstream = f);\n                this.addEventListener('track', this._onaddstreampoly = (e)=>{\n                    e.streams.forEach((stream)=>{\n                        if (!this._remoteStreams) {\n                            this._remoteStreams = [];\n                        }\n                        if (this._remoteStreams.includes(stream)) {\n                            return;\n                        }\n                        this._remoteStreams.push(stream);\n                        const event = new Event('addstream');\n                        event.stream = stream;\n                        this.dispatchEvent(event);\n                    });\n                });\n            }\n        });\n        const origSetRemoteDescription = window1.RTCPeerConnection.prototype.setRemoteDescription;\n        window1.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription() {\n            const pc = this;\n            if (!this._onaddstreampoly) {\n                this.addEventListener('track', this._onaddstreampoly = function(e) {\n                    e.streams.forEach((stream)=>{\n                        if (!pc._remoteStreams) {\n                            pc._remoteStreams = [];\n                        }\n                        if (pc._remoteStreams.indexOf(stream) >= 0) {\n                            return;\n                        }\n                        pc._remoteStreams.push(stream);\n                        const event = new Event('addstream');\n                        event.stream = stream;\n                        pc.dispatchEvent(event);\n                    });\n                });\n            }\n            return origSetRemoteDescription.apply(pc, arguments);\n        };\n    }\n}\nfunction shimCallbacksAPI(window1) {\n    if (typeof window1 !== 'object' || !window1.RTCPeerConnection) {\n        return;\n    }\n    const prototype = window1.RTCPeerConnection.prototype;\n    const origCreateOffer = prototype.createOffer;\n    const origCreateAnswer = prototype.createAnswer;\n    const setLocalDescription = prototype.setLocalDescription;\n    const setRemoteDescription = prototype.setRemoteDescription;\n    const addIceCandidate = prototype.addIceCandidate;\n    prototype.createOffer = function createOffer(successCallback, failureCallback) {\n        const options = arguments.length >= 2 ? arguments[2] : arguments[0];\n        const promise = origCreateOffer.apply(this, [\n            options\n        ]);\n        if (!failureCallback) {\n            return promise;\n        }\n        promise.then(successCallback, failureCallback);\n        return Promise.resolve();\n    };\n    prototype.createAnswer = function createAnswer(successCallback, failureCallback) {\n        const options = arguments.length >= 2 ? arguments[2] : arguments[0];\n        const promise = origCreateAnswer.apply(this, [\n            options\n        ]);\n        if (!failureCallback) {\n            return promise;\n        }\n        promise.then(successCallback, failureCallback);\n        return Promise.resolve();\n    };\n    let withCallback = function(description, successCallback, failureCallback) {\n        const promise = setLocalDescription.apply(this, [\n            description\n        ]);\n        if (!failureCallback) {\n            return promise;\n        }\n        promise.then(successCallback, failureCallback);\n        return Promise.resolve();\n    };\n    prototype.setLocalDescription = withCallback;\n    withCallback = function(description, successCallback, failureCallback) {\n        const promise = setRemoteDescription.apply(this, [\n            description\n        ]);\n        if (!failureCallback) {\n            return promise;\n        }\n        promise.then(successCallback, failureCallback);\n        return Promise.resolve();\n    };\n    prototype.setRemoteDescription = withCallback;\n    withCallback = function(candidate, successCallback, failureCallback) {\n        const promise = addIceCandidate.apply(this, [\n            candidate\n        ]);\n        if (!failureCallback) {\n            return promise;\n        }\n        promise.then(successCallback, failureCallback);\n        return Promise.resolve();\n    };\n    prototype.addIceCandidate = withCallback;\n}\nfunction shimGetUserMedia(window1) {\n    const navigator1 = window1 && window1.navigator;\n    if (navigator1.mediaDevices && navigator1.mediaDevices.getUserMedia) {\n        // shim not needed in Safari 12.1\n        const mediaDevices = navigator1.mediaDevices;\n        const _getUserMedia = mediaDevices.getUserMedia.bind(mediaDevices);\n        navigator1.mediaDevices.getUserMedia = (constraints)=>{\n            return _getUserMedia(shimConstraints(constraints));\n        };\n    }\n    if (!navigator1.getUserMedia && navigator1.mediaDevices && navigator1.mediaDevices.getUserMedia) {\n        navigator1.getUserMedia = (function getUserMedia(constraints, cb, errcb) {\n            navigator1.mediaDevices.getUserMedia(constraints).then(cb, errcb);\n        }).bind(navigator1);\n    }\n}\nfunction shimConstraints(constraints) {\n    if (constraints && constraints.video !== undefined) {\n        return Object.assign({}, constraints, {\n            video: compactObject(constraints.video)\n        });\n    }\n    return constraints;\n}\nfunction shimRTCIceServerUrls(window1) {\n    if (!window1.RTCPeerConnection) {\n        return;\n    }\n    // migrate from non-spec RTCIceServer.url to RTCIceServer.urls\n    const OrigPeerConnection = window1.RTCPeerConnection;\n    window1.RTCPeerConnection = function RTCPeerConnection1(pcConfig, pcConstraints) {\n        if (pcConfig && pcConfig.iceServers) {\n            const newIceServers = [];\n            for(let i = 0; i < pcConfig.iceServers.length; i++){\n                let server = pcConfig.iceServers[i];\n                if (server.urls === undefined && server.url) {\n                    deprecated('RTCIceServer.url', 'RTCIceServer.urls');\n                    server = JSON.parse(JSON.stringify(server));\n                    server.urls = server.url;\n                    delete server.url;\n                    newIceServers.push(server);\n                } else {\n                    newIceServers.push(pcConfig.iceServers[i]);\n                }\n            }\n            pcConfig.iceServers = newIceServers;\n        }\n        return new OrigPeerConnection(pcConfig, pcConstraints);\n    };\n    window1.RTCPeerConnection.prototype = OrigPeerConnection.prototype;\n    // wrap static methods. Currently just generateCertificate.\n    if ('generateCertificate' in OrigPeerConnection) {\n        Object.defineProperty(window1.RTCPeerConnection, 'generateCertificate', {\n            get () {\n                return OrigPeerConnection.generateCertificate;\n            }\n        });\n    }\n}\nfunction shimTrackEventTransceiver(window1) {\n    // Add event.transceiver member over deprecated event.receiver\n    if (typeof window1 === 'object' && window1.RTCTrackEvent && 'receiver' in window1.RTCTrackEvent.prototype && !('transceiver' in window1.RTCTrackEvent.prototype)) {\n        Object.defineProperty(window1.RTCTrackEvent.prototype, 'transceiver', {\n            get () {\n                return {\n                    receiver: this.receiver\n                };\n            }\n        });\n    }\n}\nfunction shimCreateOfferLegacy(window1) {\n    const origCreateOffer = window1.RTCPeerConnection.prototype.createOffer;\n    window1.RTCPeerConnection.prototype.createOffer = function createOffer(offerOptions) {\n        if (offerOptions) {\n            if (typeof offerOptions.offerToReceiveAudio !== 'undefined') {\n                // support bit values\n                offerOptions.offerToReceiveAudio = !!offerOptions.offerToReceiveAudio;\n            }\n            const audioTransceiver = this.getTransceivers().find((transceiver)=>transceiver.receiver.track.kind === 'audio');\n            if (offerOptions.offerToReceiveAudio === false && audioTransceiver) {\n                if (audioTransceiver.direction === 'sendrecv') {\n                    if (audioTransceiver.setDirection) {\n                        audioTransceiver.setDirection('sendonly');\n                    } else {\n                        audioTransceiver.direction = 'sendonly';\n                    }\n                } else if (audioTransceiver.direction === 'recvonly') {\n                    if (audioTransceiver.setDirection) {\n                        audioTransceiver.setDirection('inactive');\n                    } else {\n                        audioTransceiver.direction = 'inactive';\n                    }\n                }\n            } else if (offerOptions.offerToReceiveAudio === true && !audioTransceiver) {\n                this.addTransceiver('audio', {\n                    direction: 'recvonly'\n                });\n            }\n            if (typeof offerOptions.offerToReceiveVideo !== 'undefined') {\n                // support bit values\n                offerOptions.offerToReceiveVideo = !!offerOptions.offerToReceiveVideo;\n            }\n            const videoTransceiver = this.getTransceivers().find((transceiver)=>transceiver.receiver.track.kind === 'video');\n            if (offerOptions.offerToReceiveVideo === false && videoTransceiver) {\n                if (videoTransceiver.direction === 'sendrecv') {\n                    if (videoTransceiver.setDirection) {\n                        videoTransceiver.setDirection('sendonly');\n                    } else {\n                        videoTransceiver.direction = 'sendonly';\n                    }\n                } else if (videoTransceiver.direction === 'recvonly') {\n                    if (videoTransceiver.setDirection) {\n                        videoTransceiver.setDirection('inactive');\n                    } else {\n                        videoTransceiver.direction = 'inactive';\n                    }\n                }\n            } else if (offerOptions.offerToReceiveVideo === true && !videoTransceiver) {\n                this.addTransceiver('video', {\n                    direction: 'recvonly'\n                });\n            }\n        }\n        return origCreateOffer.apply(this, arguments);\n    };\n}\nfunction shimAudioContext(window1) {\n    if (typeof window1 !== 'object' || window1.AudioContext) {\n        return;\n    }\n    window1.AudioContext = window1.webkitAudioContext;\n}\nvar safariShim = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    shimAudioContext: shimAudioContext,\n    shimCallbacksAPI: shimCallbacksAPI,\n    shimConstraints: shimConstraints,\n    shimCreateOfferLegacy: shimCreateOfferLegacy,\n    shimGetUserMedia: shimGetUserMedia,\n    shimLocalStreamsAPI: shimLocalStreamsAPI,\n    shimRTCIceServerUrls: shimRTCIceServerUrls,\n    shimRemoteStreamsAPI: shimRemoteStreamsAPI,\n    shimTrackEventTransceiver: shimTrackEventTransceiver\n});\nvar sdp$1 = {\n    exports: {}\n};\n/* eslint-env node */ (function(module) {\n    // SDP helpers.\n    const SDPUtils = {};\n    // Generate an alphanumeric identifier for cname or mids.\n    // TODO: use UUIDs instead? https://gist.github.com/jed/982883\n    SDPUtils.generateIdentifier = function() {\n        return Math.random().toString(36).substring(2, 12);\n    };\n    // The RTCP CNAME used by all peerconnections from the same JS.\n    SDPUtils.localCName = SDPUtils.generateIdentifier();\n    // Splits SDP into lines, dealing with both CRLF and LF.\n    SDPUtils.splitLines = function(blob) {\n        return blob.trim().split('\\n').map((line)=>line.trim());\n    };\n    // Splits SDP into sessionpart and mediasections. Ensures CRLF.\n    SDPUtils.splitSections = function(blob) {\n        const parts = blob.split('\\nm=');\n        return parts.map((part, index)=>(index > 0 ? 'm=' + part : part).trim() + '\\r\\n');\n    };\n    // Returns the session description.\n    SDPUtils.getDescription = function(blob) {\n        const sections = SDPUtils.splitSections(blob);\n        return sections && sections[0];\n    };\n    // Returns the individual media sections.\n    SDPUtils.getMediaSections = function(blob) {\n        const sections = SDPUtils.splitSections(blob);\n        sections.shift();\n        return sections;\n    };\n    // Returns lines that start with a certain prefix.\n    SDPUtils.matchPrefix = function(blob, prefix) {\n        return SDPUtils.splitLines(blob).filter((line)=>line.indexOf(prefix) === 0);\n    };\n    // Parses an ICE candidate line. Sample input:\n    // candidate:702786350 2 udp 41819902 8.8.8.8 60769 typ relay raddr 8.8.8.8\n    // rport 55996\"\n    // Input can be prefixed with a=.\n    SDPUtils.parseCandidate = function(line) {\n        let parts;\n        // Parse both variants.\n        if (line.indexOf('a=candidate:') === 0) {\n            parts = line.substring(12).split(' ');\n        } else {\n            parts = line.substring(10).split(' ');\n        }\n        const candidate = {\n            foundation: parts[0],\n            component: {\n                1: 'rtp',\n                2: 'rtcp'\n            }[parts[1]] || parts[1],\n            protocol: parts[2].toLowerCase(),\n            priority: parseInt(parts[3], 10),\n            ip: parts[4],\n            address: parts[4],\n            // address is an alias for ip.\n            port: parseInt(parts[5], 10),\n            // skip parts[6] == 'typ'\n            type: parts[7]\n        };\n        for(let i = 8; i < parts.length; i += 2){\n            switch(parts[i]){\n                case 'raddr':\n                    candidate.relatedAddress = parts[i + 1];\n                    break;\n                case 'rport':\n                    candidate.relatedPort = parseInt(parts[i + 1], 10);\n                    break;\n                case 'tcptype':\n                    candidate.tcpType = parts[i + 1];\n                    break;\n                case 'ufrag':\n                    candidate.ufrag = parts[i + 1]; // for backward compatibility.\n                    candidate.usernameFragment = parts[i + 1];\n                    break;\n                default:\n                    // extension handling, in particular ufrag. Don't overwrite.\n                    if (candidate[parts[i]] === undefined) {\n                        candidate[parts[i]] = parts[i + 1];\n                    }\n                    break;\n            }\n        }\n        return candidate;\n    };\n    // Translates a candidate object into SDP candidate attribute.\n    // This does not include the a= prefix!\n    SDPUtils.writeCandidate = function(candidate) {\n        const sdp = [];\n        sdp.push(candidate.foundation);\n        const component = candidate.component;\n        if (component === 'rtp') {\n            sdp.push(1);\n        } else if (component === 'rtcp') {\n            sdp.push(2);\n        } else {\n            sdp.push(component);\n        }\n        sdp.push(candidate.protocol.toUpperCase());\n        sdp.push(candidate.priority);\n        sdp.push(candidate.address || candidate.ip);\n        sdp.push(candidate.port);\n        const type = candidate.type;\n        sdp.push('typ');\n        sdp.push(type);\n        if (type !== 'host' && candidate.relatedAddress && candidate.relatedPort) {\n            sdp.push('raddr');\n            sdp.push(candidate.relatedAddress);\n            sdp.push('rport');\n            sdp.push(candidate.relatedPort);\n        }\n        if (candidate.tcpType && candidate.protocol.toLowerCase() === 'tcp') {\n            sdp.push('tcptype');\n            sdp.push(candidate.tcpType);\n        }\n        if (candidate.usernameFragment || candidate.ufrag) {\n            sdp.push('ufrag');\n            sdp.push(candidate.usernameFragment || candidate.ufrag);\n        }\n        return 'candidate:' + sdp.join(' ');\n    };\n    // Parses an ice-options line, returns an array of option tags.\n    // Sample input:\n    // a=ice-options:foo bar\n    SDPUtils.parseIceOptions = function(line) {\n        return line.substring(14).split(' ');\n    };\n    // Parses a rtpmap line, returns RTCRtpCoddecParameters. Sample input:\n    // a=rtpmap:111 opus/48000/2\n    SDPUtils.parseRtpMap = function(line) {\n        let parts = line.substring(9).split(' ');\n        const parsed = {\n            payloadType: parseInt(parts.shift(), 10) // was: id\n        };\n        parts = parts[0].split('/');\n        parsed.name = parts[0];\n        parsed.clockRate = parseInt(parts[1], 10); // was: clockrate\n        parsed.channels = parts.length === 3 ? parseInt(parts[2], 10) : 1;\n        // legacy alias, got renamed back to channels in ORTC.\n        parsed.numChannels = parsed.channels;\n        return parsed;\n    };\n    // Generates a rtpmap line from RTCRtpCodecCapability or\n    // RTCRtpCodecParameters.\n    SDPUtils.writeRtpMap = function(codec) {\n        let pt = codec.payloadType;\n        if (codec.preferredPayloadType !== undefined) {\n            pt = codec.preferredPayloadType;\n        }\n        const channels = codec.channels || codec.numChannels || 1;\n        return 'a=rtpmap:' + pt + ' ' + codec.name + '/' + codec.clockRate + (channels !== 1 ? '/' + channels : '') + '\\r\\n';\n    };\n    // Parses a extmap line (headerextension from RFC 5285). Sample input:\n    // a=extmap:2 urn:ietf:params:rtp-hdrext:toffset\n    // a=extmap:2/sendonly urn:ietf:params:rtp-hdrext:toffset\n    SDPUtils.parseExtmap = function(line) {\n        const parts = line.substring(9).split(' ');\n        return {\n            id: parseInt(parts[0], 10),\n            direction: parts[0].indexOf('/') > 0 ? parts[0].split('/')[1] : 'sendrecv',\n            uri: parts[1],\n            attributes: parts.slice(2).join(' ')\n        };\n    };\n    // Generates an extmap line from RTCRtpHeaderExtensionParameters or\n    // RTCRtpHeaderExtension.\n    SDPUtils.writeExtmap = function(headerExtension) {\n        return 'a=extmap:' + (headerExtension.id || headerExtension.preferredId) + (headerExtension.direction && headerExtension.direction !== 'sendrecv' ? '/' + headerExtension.direction : '') + ' ' + headerExtension.uri + (headerExtension.attributes ? ' ' + headerExtension.attributes : '') + '\\r\\n';\n    };\n    // Parses a fmtp line, returns dictionary. Sample input:\n    // a=fmtp:96 vbr=on;cng=on\n    // Also deals with vbr=on; cng=on\n    SDPUtils.parseFmtp = function(line) {\n        const parsed = {};\n        let kv;\n        const parts = line.substring(line.indexOf(' ') + 1).split(';');\n        for(let j = 0; j < parts.length; j++){\n            kv = parts[j].trim().split('=');\n            parsed[kv[0].trim()] = kv[1];\n        }\n        return parsed;\n    };\n    // Generates a fmtp line from RTCRtpCodecCapability or RTCRtpCodecParameters.\n    SDPUtils.writeFmtp = function(codec) {\n        let line = '';\n        let pt = codec.payloadType;\n        if (codec.preferredPayloadType !== undefined) {\n            pt = codec.preferredPayloadType;\n        }\n        if (codec.parameters && Object.keys(codec.parameters).length) {\n            const params = [];\n            Object.keys(codec.parameters).forEach((param)=>{\n                if (codec.parameters[param] !== undefined) {\n                    params.push(param + '=' + codec.parameters[param]);\n                } else {\n                    params.push(param);\n                }\n            });\n            line += 'a=fmtp:' + pt + ' ' + params.join(';') + '\\r\\n';\n        }\n        return line;\n    };\n    // Parses a rtcp-fb line, returns RTCPRtcpFeedback object. Sample input:\n    // a=rtcp-fb:98 nack rpsi\n    SDPUtils.parseRtcpFb = function(line) {\n        const parts = line.substring(line.indexOf(' ') + 1).split(' ');\n        return {\n            type: parts.shift(),\n            parameter: parts.join(' ')\n        };\n    };\n    // Generate a=rtcp-fb lines from RTCRtpCodecCapability or RTCRtpCodecParameters.\n    SDPUtils.writeRtcpFb = function(codec) {\n        let lines = '';\n        let pt = codec.payloadType;\n        if (codec.preferredPayloadType !== undefined) {\n            pt = codec.preferredPayloadType;\n        }\n        if (codec.rtcpFeedback && codec.rtcpFeedback.length) {\n            // FIXME: special handling for trr-int?\n            codec.rtcpFeedback.forEach((fb)=>{\n                lines += 'a=rtcp-fb:' + pt + ' ' + fb.type + (fb.parameter && fb.parameter.length ? ' ' + fb.parameter : '') + '\\r\\n';\n            });\n        }\n        return lines;\n    };\n    // Parses a RFC 5576 ssrc media attribute. Sample input:\n    // a=ssrc:3735928559 cname:something\n    SDPUtils.parseSsrcMedia = function(line) {\n        const sp = line.indexOf(' ');\n        const parts = {\n            ssrc: parseInt(line.substring(7, sp), 10)\n        };\n        const colon = line.indexOf(':', sp);\n        if (colon > -1) {\n            parts.attribute = line.substring(sp + 1, colon);\n            parts.value = line.substring(colon + 1);\n        } else {\n            parts.attribute = line.substring(sp + 1);\n        }\n        return parts;\n    };\n    // Parse a ssrc-group line (see RFC 5576). Sample input:\n    // a=ssrc-group:semantics 12 34\n    SDPUtils.parseSsrcGroup = function(line) {\n        const parts = line.substring(13).split(' ');\n        return {\n            semantics: parts.shift(),\n            ssrcs: parts.map((ssrc)=>parseInt(ssrc, 10))\n        };\n    };\n    // Extracts the MID (RFC 5888) from a media section.\n    // Returns the MID or undefined if no mid line was found.\n    SDPUtils.getMid = function(mediaSection) {\n        const mid = SDPUtils.matchPrefix(mediaSection, 'a=mid:')[0];\n        if (mid) {\n            return mid.substring(6);\n        }\n    };\n    // Parses a fingerprint line for DTLS-SRTP.\n    SDPUtils.parseFingerprint = function(line) {\n        const parts = line.substring(14).split(' ');\n        return {\n            algorithm: parts[0].toLowerCase(),\n            // algorithm is case-sensitive in Edge.\n            value: parts[1].toUpperCase() // the definition is upper-case in RFC 4572.\n        };\n    };\n    // Extracts DTLS parameters from SDP media section or sessionpart.\n    // FIXME: for consistency with other functions this should only\n    //   get the fingerprint line as input. See also getIceParameters.\n    SDPUtils.getDtlsParameters = function(mediaSection, sessionpart) {\n        const lines = SDPUtils.matchPrefix(mediaSection + sessionpart, 'a=fingerprint:');\n        // Note: a=setup line is ignored since we use the 'auto' role in Edge.\n        return {\n            role: 'auto',\n            fingerprints: lines.map(SDPUtils.parseFingerprint)\n        };\n    };\n    // Serializes DTLS parameters to SDP.\n    SDPUtils.writeDtlsParameters = function(params, setupType) {\n        let sdp = 'a=setup:' + setupType + '\\r\\n';\n        params.fingerprints.forEach((fp)=>{\n            sdp += 'a=fingerprint:' + fp.algorithm + ' ' + fp.value + '\\r\\n';\n        });\n        return sdp;\n    };\n    // Parses a=crypto lines into\n    //   https://rawgit.com/aboba/edgertc/master/msortc-rs4.html#dictionary-rtcsrtpsdesparameters-members\n    SDPUtils.parseCryptoLine = function(line) {\n        const parts = line.substring(9).split(' ');\n        return {\n            tag: parseInt(parts[0], 10),\n            cryptoSuite: parts[1],\n            keyParams: parts[2],\n            sessionParams: parts.slice(3)\n        };\n    };\n    SDPUtils.writeCryptoLine = function(parameters) {\n        return 'a=crypto:' + parameters.tag + ' ' + parameters.cryptoSuite + ' ' + (typeof parameters.keyParams === 'object' ? SDPUtils.writeCryptoKeyParams(parameters.keyParams) : parameters.keyParams) + (parameters.sessionParams ? ' ' + parameters.sessionParams.join(' ') : '') + '\\r\\n';\n    };\n    // Parses the crypto key parameters into\n    //   https://rawgit.com/aboba/edgertc/master/msortc-rs4.html#rtcsrtpkeyparam*\n    SDPUtils.parseCryptoKeyParams = function(keyParams) {\n        if (keyParams.indexOf('inline:') !== 0) {\n            return null;\n        }\n        const parts = keyParams.substring(7).split('|');\n        return {\n            keyMethod: 'inline',\n            keySalt: parts[0],\n            lifeTime: parts[1],\n            mkiValue: parts[2] ? parts[2].split(':')[0] : undefined,\n            mkiLength: parts[2] ? parts[2].split(':')[1] : undefined\n        };\n    };\n    SDPUtils.writeCryptoKeyParams = function(keyParams) {\n        return keyParams.keyMethod + ':' + keyParams.keySalt + (keyParams.lifeTime ? '|' + keyParams.lifeTime : '') + (keyParams.mkiValue && keyParams.mkiLength ? '|' + keyParams.mkiValue + ':' + keyParams.mkiLength : '');\n    };\n    // Extracts all SDES parameters.\n    SDPUtils.getCryptoParameters = function(mediaSection, sessionpart) {\n        const lines = SDPUtils.matchPrefix(mediaSection + sessionpart, 'a=crypto:');\n        return lines.map(SDPUtils.parseCryptoLine);\n    };\n    // Parses ICE information from SDP media section or sessionpart.\n    // FIXME: for consistency with other functions this should only\n    //   get the ice-ufrag and ice-pwd lines as input.\n    SDPUtils.getIceParameters = function(mediaSection, sessionpart) {\n        const ufrag = SDPUtils.matchPrefix(mediaSection + sessionpart, 'a=ice-ufrag:')[0];\n        const pwd = SDPUtils.matchPrefix(mediaSection + sessionpart, 'a=ice-pwd:')[0];\n        if (!(ufrag && pwd)) {\n            return null;\n        }\n        return {\n            usernameFragment: ufrag.substring(12),\n            password: pwd.substring(10)\n        };\n    };\n    // Serializes ICE parameters to SDP.\n    SDPUtils.writeIceParameters = function(params) {\n        let sdp = 'a=ice-ufrag:' + params.usernameFragment + '\\r\\n' + 'a=ice-pwd:' + params.password + '\\r\\n';\n        if (params.iceLite) {\n            sdp += 'a=ice-lite\\r\\n';\n        }\n        return sdp;\n    };\n    // Parses the SDP media section and returns RTCRtpParameters.\n    SDPUtils.parseRtpParameters = function(mediaSection) {\n        const description = {\n            codecs: [],\n            headerExtensions: [],\n            fecMechanisms: [],\n            rtcp: []\n        };\n        const lines = SDPUtils.splitLines(mediaSection);\n        const mline = lines[0].split(' ');\n        description.profile = mline[2];\n        for(let i = 3; i < mline.length; i++){\n            // find all codecs from mline[3..]\n            const pt = mline[i];\n            const rtpmapline = SDPUtils.matchPrefix(mediaSection, 'a=rtpmap:' + pt + ' ')[0];\n            if (rtpmapline) {\n                const codec = SDPUtils.parseRtpMap(rtpmapline);\n                const fmtps = SDPUtils.matchPrefix(mediaSection, 'a=fmtp:' + pt + ' ');\n                // Only the first a=fmtp:<pt> is considered.\n                codec.parameters = fmtps.length ? SDPUtils.parseFmtp(fmtps[0]) : {};\n                codec.rtcpFeedback = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-fb:' + pt + ' ').map(SDPUtils.parseRtcpFb);\n                description.codecs.push(codec);\n                // parse FEC mechanisms from rtpmap lines.\n                switch(codec.name.toUpperCase()){\n                    case 'RED':\n                    case 'ULPFEC':\n                        description.fecMechanisms.push(codec.name.toUpperCase());\n                        break;\n                }\n            }\n        }\n        SDPUtils.matchPrefix(mediaSection, 'a=extmap:').forEach((line)=>{\n            description.headerExtensions.push(SDPUtils.parseExtmap(line));\n        });\n        const wildcardRtcpFb = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-fb:* ').map(SDPUtils.parseRtcpFb);\n        description.codecs.forEach((codec)=>{\n            wildcardRtcpFb.forEach((fb)=>{\n                const duplicate = codec.rtcpFeedback.find((existingFeedback)=>{\n                    return existingFeedback.type === fb.type && existingFeedback.parameter === fb.parameter;\n                });\n                if (!duplicate) {\n                    codec.rtcpFeedback.push(fb);\n                }\n            });\n        });\n        // FIXME: parse rtcp.\n        return description;\n    };\n    // Generates parts of the SDP media section describing the capabilities /\n    // parameters.\n    SDPUtils.writeRtpDescription = function(kind, caps) {\n        let sdp = '';\n        // Build the mline.\n        sdp += 'm=' + kind + ' ';\n        sdp += caps.codecs.length > 0 ? '9' : '0'; // reject if no codecs.\n        sdp += ' ' + (caps.profile || 'UDP/TLS/RTP/SAVPF') + ' ';\n        sdp += caps.codecs.map((codec)=>{\n            if (codec.preferredPayloadType !== undefined) {\n                return codec.preferredPayloadType;\n            }\n            return codec.payloadType;\n        }).join(' ') + '\\r\\n';\n        sdp += 'c=IN IP4 0.0.0.0\\r\\n';\n        sdp += 'a=rtcp:9 IN IP4 0.0.0.0\\r\\n';\n        // Add a=rtpmap lines for each codec. Also fmtp and rtcp-fb.\n        caps.codecs.forEach((codec)=>{\n            sdp += SDPUtils.writeRtpMap(codec);\n            sdp += SDPUtils.writeFmtp(codec);\n            sdp += SDPUtils.writeRtcpFb(codec);\n        });\n        let maxptime = 0;\n        caps.codecs.forEach((codec)=>{\n            if (codec.maxptime > maxptime) {\n                maxptime = codec.maxptime;\n            }\n        });\n        if (maxptime > 0) {\n            sdp += 'a=maxptime:' + maxptime + '\\r\\n';\n        }\n        if (caps.headerExtensions) {\n            caps.headerExtensions.forEach((extension)=>{\n                sdp += SDPUtils.writeExtmap(extension);\n            });\n        }\n        // FIXME: write fecMechanisms.\n        return sdp;\n    };\n    // Parses the SDP media section and returns an array of\n    // RTCRtpEncodingParameters.\n    SDPUtils.parseRtpEncodingParameters = function(mediaSection) {\n        const encodingParameters = [];\n        const description = SDPUtils.parseRtpParameters(mediaSection);\n        const hasRed = description.fecMechanisms.indexOf('RED') !== -1;\n        const hasUlpfec = description.fecMechanisms.indexOf('ULPFEC') !== -1;\n        // filter a=ssrc:... cname:, ignore PlanB-msid\n        const ssrcs = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:').map((line)=>SDPUtils.parseSsrcMedia(line)).filter((parts)=>parts.attribute === 'cname');\n        const primarySsrc = ssrcs.length > 0 && ssrcs[0].ssrc;\n        let secondarySsrc;\n        const flows = SDPUtils.matchPrefix(mediaSection, 'a=ssrc-group:FID').map((line)=>{\n            const parts = line.substring(17).split(' ');\n            return parts.map((part)=>parseInt(part, 10));\n        });\n        if (flows.length > 0 && flows[0].length > 1 && flows[0][0] === primarySsrc) {\n            secondarySsrc = flows[0][1];\n        }\n        description.codecs.forEach((codec)=>{\n            if (codec.name.toUpperCase() === 'RTX' && codec.parameters.apt) {\n                let encParam = {\n                    ssrc: primarySsrc,\n                    codecPayloadType: parseInt(codec.parameters.apt, 10)\n                };\n                if (primarySsrc && secondarySsrc) {\n                    encParam.rtx = {\n                        ssrc: secondarySsrc\n                    };\n                }\n                encodingParameters.push(encParam);\n                if (hasRed) {\n                    encParam = JSON.parse(JSON.stringify(encParam));\n                    encParam.fec = {\n                        ssrc: primarySsrc,\n                        mechanism: hasUlpfec ? 'red+ulpfec' : 'red'\n                    };\n                    encodingParameters.push(encParam);\n                }\n            }\n        });\n        if (encodingParameters.length === 0 && primarySsrc) {\n            encodingParameters.push({\n                ssrc: primarySsrc\n            });\n        }\n        // we support both b=AS and b=TIAS but interpret AS as TIAS.\n        let bandwidth = SDPUtils.matchPrefix(mediaSection, 'b=');\n        if (bandwidth.length) {\n            if (bandwidth[0].indexOf('b=TIAS:') === 0) {\n                bandwidth = parseInt(bandwidth[0].substring(7), 10);\n            } else if (bandwidth[0].indexOf('b=AS:') === 0) {\n                // use formula from JSEP to convert b=AS to TIAS value.\n                bandwidth = parseInt(bandwidth[0].substring(5), 10) * 1000 * 0.95 - 50 * 40 * 8;\n            } else {\n                bandwidth = undefined;\n            }\n            encodingParameters.forEach((params)=>{\n                params.maxBitrate = bandwidth;\n            });\n        }\n        return encodingParameters;\n    };\n    // parses http://draft.ortc.org/#rtcrtcpparameters*\n    SDPUtils.parseRtcpParameters = function(mediaSection) {\n        const rtcpParameters = {};\n        // Gets the first SSRC. Note that with RTX there might be multiple\n        // SSRCs.\n        const remoteSsrc = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:').map((line)=>SDPUtils.parseSsrcMedia(line)).filter((obj)=>obj.attribute === 'cname')[0];\n        if (remoteSsrc) {\n            rtcpParameters.cname = remoteSsrc.value;\n            rtcpParameters.ssrc = remoteSsrc.ssrc;\n        }\n        // Edge uses the compound attribute instead of reducedSize\n        // compound is !reducedSize\n        const rsize = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-rsize');\n        rtcpParameters.reducedSize = rsize.length > 0;\n        rtcpParameters.compound = rsize.length === 0;\n        // parses the rtcp-mux attrbute.\n        // Note that Edge does not support unmuxed RTCP.\n        const mux = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-mux');\n        rtcpParameters.mux = mux.length > 0;\n        return rtcpParameters;\n    };\n    SDPUtils.writeRtcpParameters = function(rtcpParameters) {\n        let sdp = '';\n        if (rtcpParameters.reducedSize) {\n            sdp += 'a=rtcp-rsize\\r\\n';\n        }\n        if (rtcpParameters.mux) {\n            sdp += 'a=rtcp-mux\\r\\n';\n        }\n        if (rtcpParameters.ssrc !== undefined && rtcpParameters.cname) {\n            sdp += 'a=ssrc:' + rtcpParameters.ssrc + ' cname:' + rtcpParameters.cname + '\\r\\n';\n        }\n        return sdp;\n    };\n    // parses either a=msid: or a=ssrc:... msid lines and returns\n    // the id of the MediaStream and MediaStreamTrack.\n    SDPUtils.parseMsid = function(mediaSection) {\n        let parts;\n        const spec = SDPUtils.matchPrefix(mediaSection, 'a=msid:');\n        if (spec.length === 1) {\n            parts = spec[0].substring(7).split(' ');\n            return {\n                stream: parts[0],\n                track: parts[1]\n            };\n        }\n        const planB = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:').map((line)=>SDPUtils.parseSsrcMedia(line)).filter((msidParts)=>msidParts.attribute === 'msid');\n        if (planB.length > 0) {\n            parts = planB[0].value.split(' ');\n            return {\n                stream: parts[0],\n                track: parts[1]\n            };\n        }\n    };\n    // SCTP\n    // parses draft-ietf-mmusic-sctp-sdp-26 first and falls back\n    // to draft-ietf-mmusic-sctp-sdp-05\n    SDPUtils.parseSctpDescription = function(mediaSection) {\n        const mline = SDPUtils.parseMLine(mediaSection);\n        const maxSizeLine = SDPUtils.matchPrefix(mediaSection, 'a=max-message-size:');\n        let maxMessageSize;\n        if (maxSizeLine.length > 0) {\n            maxMessageSize = parseInt(maxSizeLine[0].substring(19), 10);\n        }\n        if (isNaN(maxMessageSize)) {\n            maxMessageSize = 65536;\n        }\n        const sctpPort = SDPUtils.matchPrefix(mediaSection, 'a=sctp-port:');\n        if (sctpPort.length > 0) {\n            return {\n                port: parseInt(sctpPort[0].substring(12), 10),\n                protocol: mline.fmt,\n                maxMessageSize\n            };\n        }\n        const sctpMapLines = SDPUtils.matchPrefix(mediaSection, 'a=sctpmap:');\n        if (sctpMapLines.length > 0) {\n            const parts = sctpMapLines[0].substring(10).split(' ');\n            return {\n                port: parseInt(parts[0], 10),\n                protocol: parts[1],\n                maxMessageSize\n            };\n        }\n    };\n    // SCTP\n    // outputs the draft-ietf-mmusic-sctp-sdp-26 version that all browsers\n    // support by now receiving in this format, unless we originally parsed\n    // as the draft-ietf-mmusic-sctp-sdp-05 format (indicated by the m-line\n    // protocol of DTLS/SCTP -- without UDP/ or TCP/)\n    SDPUtils.writeSctpDescription = function(media, sctp) {\n        let output = [];\n        if (media.protocol !== 'DTLS/SCTP') {\n            output = [\n                'm=' + media.kind + ' 9 ' + media.protocol + ' ' + sctp.protocol + '\\r\\n',\n                'c=IN IP4 0.0.0.0\\r\\n',\n                'a=sctp-port:' + sctp.port + '\\r\\n'\n            ];\n        } else {\n            output = [\n                'm=' + media.kind + ' 9 ' + media.protocol + ' ' + sctp.port + '\\r\\n',\n                'c=IN IP4 0.0.0.0\\r\\n',\n                'a=sctpmap:' + sctp.port + ' ' + sctp.protocol + ' 65535\\r\\n'\n            ];\n        }\n        if (sctp.maxMessageSize !== undefined) {\n            output.push('a=max-message-size:' + sctp.maxMessageSize + '\\r\\n');\n        }\n        return output.join('');\n    };\n    // Generate a session ID for SDP.\n    // https://tools.ietf.org/html/draft-ietf-rtcweb-jsep-20#section-5.2.1\n    // recommends using a cryptographically random +ve 64-bit value\n    // but right now this should be acceptable and within the right range\n    SDPUtils.generateSessionId = function() {\n        return Math.random().toString().substr(2, 22);\n    };\n    // Write boiler plate for start of SDP\n    // sessId argument is optional - if not supplied it will\n    // be generated randomly\n    // sessVersion is optional and defaults to 2\n    // sessUser is optional and defaults to 'thisisadapterortc'\n    SDPUtils.writeSessionBoilerplate = function(sessId, sessVer, sessUser) {\n        let sessionId;\n        const version = sessVer !== undefined ? sessVer : 2;\n        if (sessId) {\n            sessionId = sessId;\n        } else {\n            sessionId = SDPUtils.generateSessionId();\n        }\n        const user = sessUser || 'thisisadapterortc';\n        // FIXME: sess-id should be an NTP timestamp.\n        return 'v=0\\r\\n' + 'o=' + user + ' ' + sessionId + ' ' + version + ' IN IP4 127.0.0.1\\r\\n' + 's=-\\r\\n' + 't=0 0\\r\\n';\n    };\n    // Gets the direction from the mediaSection or the sessionpart.\n    SDPUtils.getDirection = function(mediaSection, sessionpart) {\n        // Look for sendrecv, sendonly, recvonly, inactive, default to sendrecv.\n        const lines = SDPUtils.splitLines(mediaSection);\n        for(let i = 0; i < lines.length; i++){\n            switch(lines[i]){\n                case 'a=sendrecv':\n                case 'a=sendonly':\n                case 'a=recvonly':\n                case 'a=inactive':\n                    return lines[i].substring(2);\n            }\n        }\n        if (sessionpart) {\n            return SDPUtils.getDirection(sessionpart);\n        }\n        return 'sendrecv';\n    };\n    SDPUtils.getKind = function(mediaSection) {\n        const lines = SDPUtils.splitLines(mediaSection);\n        const mline = lines[0].split(' ');\n        return mline[0].substring(2);\n    };\n    SDPUtils.isRejected = function(mediaSection) {\n        return mediaSection.split(' ', 2)[1] === '0';\n    };\n    SDPUtils.parseMLine = function(mediaSection) {\n        const lines = SDPUtils.splitLines(mediaSection);\n        const parts = lines[0].substring(2).split(' ');\n        return {\n            kind: parts[0],\n            port: parseInt(parts[1], 10),\n            protocol: parts[2],\n            fmt: parts.slice(3).join(' ')\n        };\n    };\n    SDPUtils.parseOLine = function(mediaSection) {\n        const line = SDPUtils.matchPrefix(mediaSection, 'o=')[0];\n        const parts = line.substring(2).split(' ');\n        return {\n            username: parts[0],\n            sessionId: parts[1],\n            sessionVersion: parseInt(parts[2], 10),\n            netType: parts[3],\n            addressType: parts[4],\n            address: parts[5]\n        };\n    };\n    // a very naive interpretation of a valid SDP.\n    SDPUtils.isValidSDP = function(blob) {\n        if (typeof blob !== 'string' || blob.length === 0) {\n            return false;\n        }\n        const lines = SDPUtils.splitLines(blob);\n        for(let i = 0; i < lines.length; i++){\n            if (lines[i].length < 2 || lines[i].charAt(1) !== '=') {\n                return false;\n            }\n        // TODO: check the modifier a bit more.\n        }\n        return true;\n    };\n    // Expose public methods.\n    {\n        module.exports = SDPUtils;\n    }\n})(sdp$1);\nvar sdpExports = sdp$1.exports;\nvar SDPUtils = /*@__PURE__*/ getDefaultExportFromCjs(sdpExports);\nvar sdp = /*#__PURE__*/ _mergeNamespaces({\n    __proto__: null,\n    default: SDPUtils\n}, [\n    sdpExports\n]);\n/*\n *  Copyright (c) 2017 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */ /* eslint-env node */ function shimRTCIceCandidate(window1) {\n    // foundation is arbitrarily chosen as an indicator for full support for\n    // https://w3c.github.io/webrtc-pc/#rtcicecandidate-interface\n    if (!window1.RTCIceCandidate || window1.RTCIceCandidate && 'foundation' in window1.RTCIceCandidate.prototype) {\n        return;\n    }\n    const NativeRTCIceCandidate = window1.RTCIceCandidate;\n    window1.RTCIceCandidate = function RTCIceCandidate1(args) {\n        // Remove the a= which shouldn't be part of the candidate string.\n        if (typeof args === 'object' && args.candidate && args.candidate.indexOf('a=') === 0) {\n            args = JSON.parse(JSON.stringify(args));\n            args.candidate = args.candidate.substring(2);\n        }\n        if (args.candidate && args.candidate.length) {\n            // Augment the native candidate with the parsed fields.\n            const nativeCandidate = new NativeRTCIceCandidate(args);\n            const parsedCandidate = SDPUtils.parseCandidate(args.candidate);\n            for(const key in parsedCandidate){\n                if (!(key in nativeCandidate)) {\n                    Object.defineProperty(nativeCandidate, key, {\n                        value: parsedCandidate[key]\n                    });\n                }\n            }\n            // Override serializer to not serialize the extra attributes.\n            nativeCandidate.toJSON = function toJSON() {\n                return {\n                    candidate: nativeCandidate.candidate,\n                    sdpMid: nativeCandidate.sdpMid,\n                    sdpMLineIndex: nativeCandidate.sdpMLineIndex,\n                    usernameFragment: nativeCandidate.usernameFragment\n                };\n            };\n            return nativeCandidate;\n        }\n        return new NativeRTCIceCandidate(args);\n    };\n    window1.RTCIceCandidate.prototype = NativeRTCIceCandidate.prototype;\n    // Hook up the augmented candidate in onicecandidate and\n    // addEventListener('icecandidate', ...)\n    wrapPeerConnectionEvent(window1, 'icecandidate', (e)=>{\n        if (e.candidate) {\n            Object.defineProperty(e, 'candidate', {\n                value: new window1.RTCIceCandidate(e.candidate),\n                writable: 'false'\n            });\n        }\n        return e;\n    });\n}\nfunction shimRTCIceCandidateRelayProtocol(window1) {\n    if (!window1.RTCIceCandidate || window1.RTCIceCandidate && 'relayProtocol' in window1.RTCIceCandidate.prototype) {\n        return;\n    }\n    // Hook up the augmented candidate in onicecandidate and\n    // addEventListener('icecandidate', ...)\n    wrapPeerConnectionEvent(window1, 'icecandidate', (e)=>{\n        if (e.candidate) {\n            const parsedCandidate = SDPUtils.parseCandidate(e.candidate.candidate);\n            if (parsedCandidate.type === 'relay') {\n                // This is a libwebrtc-specific mapping of local type preference\n                // to relayProtocol.\n                e.candidate.relayProtocol = ({\n                    0: 'tls',\n                    1: 'tcp',\n                    2: 'udp'\n                })[parsedCandidate.priority >> 24];\n            }\n        }\n        return e;\n    });\n}\nfunction shimMaxMessageSize(window1, browserDetails) {\n    if (!window1.RTCPeerConnection) {\n        return;\n    }\n    if (!('sctp' in window1.RTCPeerConnection.prototype)) {\n        Object.defineProperty(window1.RTCPeerConnection.prototype, 'sctp', {\n            get () {\n                return typeof this._sctp === 'undefined' ? null : this._sctp;\n            }\n        });\n    }\n    const sctpInDescription = function(description) {\n        if (!description || !description.sdp) {\n            return false;\n        }\n        const sections = SDPUtils.splitSections(description.sdp);\n        sections.shift();\n        return sections.some((mediaSection)=>{\n            const mLine = SDPUtils.parseMLine(mediaSection);\n            return mLine && mLine.kind === 'application' && mLine.protocol.indexOf('SCTP') !== -1;\n        });\n    };\n    const getRemoteFirefoxVersion = function(description) {\n        // TODO: Is there a better solution for detecting Firefox?\n        const match = description.sdp.match(/mozilla...THIS_IS_SDPARTA-(\\d+)/);\n        if (match === null || match.length < 2) {\n            return -1;\n        }\n        const version = parseInt(match[1], 10);\n        // Test for NaN (yes, this is ugly)\n        return version !== version ? -1 : version;\n    };\n    const getCanSendMaxMessageSize = function(remoteIsFirefox) {\n        // Every implementation we know can send at least 64 KiB.\n        // Note: Although Chrome is technically able to send up to 256 KiB, the\n        //       data does not reach the other peer reliably.\n        //       See: https://bugs.chromium.org/p/webrtc/issues/detail?id=8419\n        let canSendMaxMessageSize = 65536;\n        if (browserDetails.browser === 'firefox') {\n            if (browserDetails.version < 57) {\n                if (remoteIsFirefox === -1) {\n                    // FF < 57 will send in 16 KiB chunks using the deprecated PPID\n                    // fragmentation.\n                    canSendMaxMessageSize = 16384;\n                } else {\n                    // However, other FF (and RAWRTC) can reassemble PPID-fragmented\n                    // messages. Thus, supporting ~2 GiB when sending.\n                    canSendMaxMessageSize = 2147483637;\n                }\n            } else if (browserDetails.version < 60) {\n                // Currently, all FF >= 57 will reset the remote maximum message size\n                // to the default value when a data channel is created at a later\n                // stage. :(\n                // See: https://bugzilla.mozilla.org/show_bug.cgi?id=1426831\n                canSendMaxMessageSize = browserDetails.version === 57 ? 65535 : 65536;\n            } else {\n                // FF >= 60 supports sending ~2 GiB\n                canSendMaxMessageSize = 2147483637;\n            }\n        }\n        return canSendMaxMessageSize;\n    };\n    const getMaxMessageSize = function(description, remoteIsFirefox) {\n        // Note: 65536 bytes is the default value from the SDP spec. Also,\n        //       every implementation we know supports receiving 65536 bytes.\n        let maxMessageSize = 65536;\n        // FF 57 has a slightly incorrect default remote max message size, so\n        // we need to adjust it here to avoid a failure when sending.\n        // See: https://bugzilla.mozilla.org/show_bug.cgi?id=1425697\n        if (browserDetails.browser === 'firefox' && browserDetails.version === 57) {\n            maxMessageSize = 65535;\n        }\n        const match = SDPUtils.matchPrefix(description.sdp, 'a=max-message-size:');\n        if (match.length > 0) {\n            maxMessageSize = parseInt(match[0].substring(19), 10);\n        } else if (browserDetails.browser === 'firefox' && remoteIsFirefox !== -1) {\n            // If the maximum message size is not present in the remote SDP and\n            // both local and remote are Firefox, the remote peer can receive\n            // ~2 GiB.\n            maxMessageSize = 2147483637;\n        }\n        return maxMessageSize;\n    };\n    const origSetRemoteDescription = window1.RTCPeerConnection.prototype.setRemoteDescription;\n    window1.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription() {\n        this._sctp = null;\n        // Chrome decided to not expose .sctp in plan-b mode.\n        // As usual, adapter.js has to do an 'ugly worakaround'\n        // to cover up the mess.\n        if (browserDetails.browser === 'chrome' && browserDetails.version >= 76) {\n            const { sdpSemantics } = this.getConfiguration();\n            if (sdpSemantics === 'plan-b') {\n                Object.defineProperty(this, 'sctp', {\n                    get () {\n                        return typeof this._sctp === 'undefined' ? null : this._sctp;\n                    },\n                    enumerable: true,\n                    configurable: true\n                });\n            }\n        }\n        if (sctpInDescription(arguments[0])) {\n            // Check if the remote is FF.\n            const isFirefox = getRemoteFirefoxVersion(arguments[0]);\n            // Get the maximum message size the local peer is capable of sending\n            const canSendMMS = getCanSendMaxMessageSize(isFirefox);\n            // Get the maximum message size of the remote peer.\n            const remoteMMS = getMaxMessageSize(arguments[0], isFirefox);\n            // Determine final maximum message size\n            let maxMessageSize;\n            if (canSendMMS === 0 && remoteMMS === 0) {\n                maxMessageSize = Number.POSITIVE_INFINITY;\n            } else if (canSendMMS === 0 || remoteMMS === 0) {\n                maxMessageSize = Math.max(canSendMMS, remoteMMS);\n            } else {\n                maxMessageSize = Math.min(canSendMMS, remoteMMS);\n            }\n            // Create a dummy RTCSctpTransport object and the 'maxMessageSize'\n            // attribute.\n            const sctp = {};\n            Object.defineProperty(sctp, 'maxMessageSize', {\n                get () {\n                    return maxMessageSize;\n                }\n            });\n            this._sctp = sctp;\n        }\n        return origSetRemoteDescription.apply(this, arguments);\n    };\n}\nfunction shimSendThrowTypeError(window1) {\n    if (!(window1.RTCPeerConnection && 'createDataChannel' in window1.RTCPeerConnection.prototype)) {\n        return;\n    }\n    // Note: Although Firefox >= 57 has a native implementation, the maximum\n    //       message size can be reset for all data channels at a later stage.\n    //       See: https://bugzilla.mozilla.org/show_bug.cgi?id=1426831\n    function wrapDcSend(dc, pc) {\n        const origDataChannelSend = dc.send;\n        dc.send = function send() {\n            const data = arguments[0];\n            const length = data.length || data.size || data.byteLength;\n            if (dc.readyState === 'open' && pc.sctp && length > pc.sctp.maxMessageSize) {\n                throw new TypeError('Message too large (can send a maximum of ' + pc.sctp.maxMessageSize + ' bytes)');\n            }\n            return origDataChannelSend.apply(dc, arguments);\n        };\n    }\n    const origCreateDataChannel = window1.RTCPeerConnection.prototype.createDataChannel;\n    window1.RTCPeerConnection.prototype.createDataChannel = function createDataChannel() {\n        const dataChannel = origCreateDataChannel.apply(this, arguments);\n        wrapDcSend(dataChannel, this);\n        return dataChannel;\n    };\n    wrapPeerConnectionEvent(window1, 'datachannel', (e)=>{\n        wrapDcSend(e.channel, e.target);\n        return e;\n    });\n}\n/* shims RTCConnectionState by pretending it is the same as iceConnectionState.\n * See https://bugs.chromium.org/p/webrtc/issues/detail?id=6145#c12\n * for why this is a valid hack in Chrome. In Firefox it is slightly incorrect\n * since DTLS failures would be hidden. See\n * https://bugzilla.mozilla.org/show_bug.cgi?id=1265827\n * for the Firefox tracking bug.\n */ function shimConnectionState(window1) {\n    if (!window1.RTCPeerConnection || 'connectionState' in window1.RTCPeerConnection.prototype) {\n        return;\n    }\n    const proto = window1.RTCPeerConnection.prototype;\n    Object.defineProperty(proto, 'connectionState', {\n        get () {\n            return ({\n                completed: 'connected',\n                checking: 'connecting'\n            })[this.iceConnectionState] || this.iceConnectionState;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(proto, 'onconnectionstatechange', {\n        get () {\n            return this._onconnectionstatechange || null;\n        },\n        set (cb) {\n            if (this._onconnectionstatechange) {\n                this.removeEventListener('connectionstatechange', this._onconnectionstatechange);\n                delete this._onconnectionstatechange;\n            }\n            if (cb) {\n                this.addEventListener('connectionstatechange', this._onconnectionstatechange = cb);\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    [\n        'setLocalDescription',\n        'setRemoteDescription'\n    ].forEach((method)=>{\n        const origMethod = proto[method];\n        proto[method] = function() {\n            if (!this._connectionstatechangepoly) {\n                this._connectionstatechangepoly = (e)=>{\n                    const pc = e.target;\n                    if (pc._lastConnectionState !== pc.connectionState) {\n                        pc._lastConnectionState = pc.connectionState;\n                        const newEvent = new Event('connectionstatechange', e);\n                        pc.dispatchEvent(newEvent);\n                    }\n                    return e;\n                };\n                this.addEventListener('iceconnectionstatechange', this._connectionstatechangepoly);\n            }\n            return origMethod.apply(this, arguments);\n        };\n    });\n}\nfunction removeExtmapAllowMixed(window1, browserDetails) {\n    /* remove a=extmap-allow-mixed for webrtc.org < M71 */ if (!window1.RTCPeerConnection) {\n        return;\n    }\n    if (browserDetails.browser === 'chrome' && browserDetails.version >= 71) {\n        return;\n    }\n    if (browserDetails.browser === 'safari' && browserDetails.version >= 605) {\n        return;\n    }\n    const nativeSRD = window1.RTCPeerConnection.prototype.setRemoteDescription;\n    window1.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription(desc) {\n        if (desc && desc.sdp && desc.sdp.indexOf('\\na=extmap-allow-mixed') !== -1) {\n            const sdp = desc.sdp.split('\\n').filter((line)=>{\n                return line.trim() !== 'a=extmap-allow-mixed';\n            }).join('\\n');\n            // Safari enforces read-only-ness of RTCSessionDescription fields.\n            if (window1.RTCSessionDescription && desc instanceof window1.RTCSessionDescription) {\n                arguments[0] = new window1.RTCSessionDescription({\n                    type: desc.type,\n                    sdp\n                });\n            } else {\n                desc.sdp = sdp;\n            }\n        }\n        return nativeSRD.apply(this, arguments);\n    };\n}\nfunction shimAddIceCandidateNullOrEmpty(window1, browserDetails) {\n    // Support for addIceCandidate(null or undefined)\n    // as well as addIceCandidate({candidate: \"\", ...})\n    // https://bugs.chromium.org/p/chromium/issues/detail?id=978582\n    // Note: must be called before other polyfills which change the signature.\n    if (!(window1.RTCPeerConnection && window1.RTCPeerConnection.prototype)) {\n        return;\n    }\n    const nativeAddIceCandidate = window1.RTCPeerConnection.prototype.addIceCandidate;\n    if (!nativeAddIceCandidate || nativeAddIceCandidate.length === 0) {\n        return;\n    }\n    window1.RTCPeerConnection.prototype.addIceCandidate = function addIceCandidate() {\n        if (!arguments[0]) {\n            if (arguments[1]) {\n                arguments[1].apply(null);\n            }\n            return Promise.resolve();\n        }\n        // Firefox 68+ emits and processes {candidate: \"\", ...}, ignore\n        // in older versions.\n        // Native support for ignoring exists for Chrome M77+.\n        // Safari ignores as well, exact version unknown but works in the same\n        // version that also ignores addIceCandidate(null).\n        if ((browserDetails.browser === 'chrome' && browserDetails.version < 78 || browserDetails.browser === 'firefox' && browserDetails.version < 68 || browserDetails.browser === 'safari') && arguments[0] && arguments[0].candidate === '') {\n            return Promise.resolve();\n        }\n        return nativeAddIceCandidate.apply(this, arguments);\n    };\n}\n// Note: Make sure to call this ahead of APIs that modify\n// setLocalDescription.length\nfunction shimParameterlessSetLocalDescription(window1, browserDetails) {\n    if (!(window1.RTCPeerConnection && window1.RTCPeerConnection.prototype)) {\n        return;\n    }\n    const nativeSetLocalDescription = window1.RTCPeerConnection.prototype.setLocalDescription;\n    if (!nativeSetLocalDescription || nativeSetLocalDescription.length === 0) {\n        return;\n    }\n    window1.RTCPeerConnection.prototype.setLocalDescription = function setLocalDescription() {\n        let desc = arguments[0] || {};\n        if (typeof desc !== 'object' || desc.type && desc.sdp) {\n            return nativeSetLocalDescription.apply(this, arguments);\n        }\n        // The remaining steps should technically happen when SLD comes off the\n        // RTCPeerConnection's operations chain (not ahead of going on it), but\n        // this is too difficult to shim. Instead, this shim only covers the\n        // common case where the operations chain is empty. This is imperfect, but\n        // should cover many cases. Rationale: Even if we can't reduce the glare\n        // window to zero on imperfect implementations, there's value in tapping\n        // into the perfect negotiation pattern that several browsers support.\n        desc = {\n            type: desc.type,\n            sdp: desc.sdp\n        };\n        if (!desc.type) {\n            switch(this.signalingState){\n                case 'stable':\n                case 'have-local-offer':\n                case 'have-remote-pranswer':\n                    desc.type = 'offer';\n                    break;\n                default:\n                    desc.type = 'answer';\n                    break;\n            }\n        }\n        if (desc.sdp || desc.type !== 'offer' && desc.type !== 'answer') {\n            return nativeSetLocalDescription.apply(this, [\n                desc\n            ]);\n        }\n        const func = desc.type === 'offer' ? this.createOffer : this.createAnswer;\n        return func.apply(this).then((d)=>nativeSetLocalDescription.apply(this, [\n                d\n            ]));\n    };\n}\nvar commonShim = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    removeExtmapAllowMixed: removeExtmapAllowMixed,\n    shimAddIceCandidateNullOrEmpty: shimAddIceCandidateNullOrEmpty,\n    shimConnectionState: shimConnectionState,\n    shimMaxMessageSize: shimMaxMessageSize,\n    shimParameterlessSetLocalDescription: shimParameterlessSetLocalDescription,\n    shimRTCIceCandidate: shimRTCIceCandidate,\n    shimRTCIceCandidateRelayProtocol: shimRTCIceCandidateRelayProtocol,\n    shimSendThrowTypeError: shimSendThrowTypeError\n});\n/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */ // Shimming starts here.\nfunction adapterFactory() {\n    let { window: window1 } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n        shimChrome: true,\n        shimFirefox: true,\n        shimSafari: true\n    };\n    // Utils.\n    const logging = log;\n    const browserDetails = detectBrowser(window1);\n    const adapter = {\n        browserDetails,\n        commonShim,\n        extractVersion: extractVersion,\n        disableLog: disableLog,\n        disableWarnings: disableWarnings,\n        // Expose sdp as a convenience. For production apps include directly.\n        sdp\n    };\n    // Shim browser if found.\n    switch(browserDetails.browser){\n        case 'chrome':\n            if (!chromeShim || !shimPeerConnection$1 || !options.shimChrome) {\n                logging('Chrome shim is not included in this adapter release.');\n                return adapter;\n            }\n            if (browserDetails.version === null) {\n                logging('Chrome shim can not determine version, not shimming.');\n                return adapter;\n            }\n            logging('adapter.js shimming chrome.');\n            // Export to the adapter global object visible in the browser.\n            adapter.browserShim = chromeShim;\n            // Must be called before shimPeerConnection.\n            shimAddIceCandidateNullOrEmpty(window1, browserDetails);\n            shimParameterlessSetLocalDescription(window1);\n            shimGetUserMedia$2(window1, browserDetails);\n            shimMediaStream(window1);\n            shimPeerConnection$1(window1, browserDetails);\n            shimOnTrack$1(window1);\n            shimAddTrackRemoveTrack(window1, browserDetails);\n            shimGetSendersWithDtmf(window1);\n            shimGetStats(window1);\n            shimSenderReceiverGetStats(window1);\n            fixNegotiationNeeded(window1, browserDetails);\n            shimRTCIceCandidate(window1);\n            shimRTCIceCandidateRelayProtocol(window1);\n            shimConnectionState(window1);\n            shimMaxMessageSize(window1, browserDetails);\n            shimSendThrowTypeError(window1);\n            removeExtmapAllowMixed(window1, browserDetails);\n            break;\n        case 'firefox':\n            if (!firefoxShim || !shimPeerConnection || !options.shimFirefox) {\n                logging('Firefox shim is not included in this adapter release.');\n                return adapter;\n            }\n            logging('adapter.js shimming firefox.');\n            // Export to the adapter global object visible in the browser.\n            adapter.browserShim = firefoxShim;\n            // Must be called before shimPeerConnection.\n            shimAddIceCandidateNullOrEmpty(window1, browserDetails);\n            shimParameterlessSetLocalDescription(window1);\n            shimGetUserMedia$1(window1, browserDetails);\n            shimPeerConnection(window1, browserDetails);\n            shimOnTrack(window1);\n            shimRemoveStream(window1);\n            shimSenderGetStats(window1);\n            shimReceiverGetStats(window1);\n            shimRTCDataChannel(window1);\n            shimAddTransceiver(window1);\n            shimGetParameters(window1);\n            shimCreateOffer(window1);\n            shimCreateAnswer(window1);\n            shimRTCIceCandidate(window1);\n            shimConnectionState(window1);\n            shimMaxMessageSize(window1, browserDetails);\n            shimSendThrowTypeError(window1);\n            break;\n        case 'safari':\n            if (!safariShim || !options.shimSafari) {\n                logging('Safari shim is not included in this adapter release.');\n                return adapter;\n            }\n            logging('adapter.js shimming safari.');\n            // Export to the adapter global object visible in the browser.\n            adapter.browserShim = safariShim;\n            // Must be called before shimCallbackAPI.\n            shimAddIceCandidateNullOrEmpty(window1, browserDetails);\n            shimParameterlessSetLocalDescription(window1);\n            shimRTCIceServerUrls(window1);\n            shimCreateOfferLegacy(window1);\n            shimCallbacksAPI(window1);\n            shimLocalStreamsAPI(window1);\n            shimRemoteStreamsAPI(window1);\n            shimTrackEventTransceiver(window1);\n            shimGetUserMedia(window1);\n            shimAudioContext(window1);\n            shimRTCIceCandidate(window1);\n            shimRTCIceCandidateRelayProtocol(window1);\n            shimMaxMessageSize(window1, browserDetails);\n            shimSendThrowTypeError(window1);\n            removeExtmapAllowMixed(window1, browserDetails);\n            break;\n        default:\n            logging('Unsupported browser!');\n            break;\n    }\n    return adapter;\n}\n/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */ /* eslint-env node */ adapterFactory({\n    window:  true ? undefined : 0\n});\nconst ENCRYPTION_ALGORITHM = 'AES-GCM';\n// How many consecutive frames can fail decrypting before a particular key gets marked as invalid\nconst DECRYPTION_FAILURE_TOLERANCE = 10;\n// flag set to indicate that e2ee has been setup for sender/receiver;\nconst E2EE_FLAG = 'lk_e2ee';\nconst SALT = 'LKFrameEncryptionKey';\nconst KEY_PROVIDER_DEFAULTS = {\n    sharedKey: false,\n    ratchetSalt: SALT,\n    ratchetWindowSize: 8,\n    failureTolerance: DECRYPTION_FAILURE_TOLERANCE\n};\nvar KeyProviderEvent;\n(function(KeyProviderEvent) {\n    KeyProviderEvent[\"SetKey\"] = \"setKey\";\n    KeyProviderEvent[\"RatchetRequest\"] = \"ratchetRequest\";\n    KeyProviderEvent[\"KeyRatcheted\"] = \"keyRatcheted\";\n})(KeyProviderEvent || (KeyProviderEvent = {}));\nvar KeyHandlerEvent;\n(function(KeyHandlerEvent) {\n    KeyHandlerEvent[\"KeyRatcheted\"] = \"keyRatcheted\";\n})(KeyHandlerEvent || (KeyHandlerEvent = {}));\nvar EncryptionEvent;\n(function(EncryptionEvent) {\n    EncryptionEvent[\"ParticipantEncryptionStatusChanged\"] = \"participantEncryptionStatusChanged\";\n    EncryptionEvent[\"EncryptionError\"] = \"encryptionError\";\n})(EncryptionEvent || (EncryptionEvent = {}));\nvar CryptorEvent;\n(function(CryptorEvent) {\n    CryptorEvent[\"Error\"] = \"cryptorError\";\n})(CryptorEvent || (CryptorEvent = {}));\nfunction isE2EESupported() {\n    return isInsertableStreamSupported() || isScriptTransformSupported();\n}\nfunction isScriptTransformSupported() {\n    // @ts-ignore\n    return typeof window.RTCRtpScriptTransform !== 'undefined';\n}\nfunction isInsertableStreamSupported() {\n    return typeof window.RTCRtpSender !== 'undefined' && // @ts-ignore\n    typeof window.RTCRtpSender.prototype.createEncodedStreams !== 'undefined';\n}\nfunction isVideoFrame(frame) {\n    return 'type' in frame;\n}\nfunction importKey(keyBytes) {\n    let algorithm = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n        name: ENCRYPTION_ALGORITHM\n    };\n    let usage = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'encrypt';\n    return __awaiter(this, void 0, void 0, function*() {\n        // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/importKey\n        return crypto.subtle.importKey('raw', keyBytes, algorithm, false, usage === 'derive' ? [\n            'deriveBits',\n            'deriveKey'\n        ] : [\n            'encrypt',\n            'decrypt'\n        ]);\n    });\n}\nfunction createKeyMaterialFromString(password) {\n    return __awaiter(this, void 0, void 0, function*() {\n        let enc = new TextEncoder();\n        const keyMaterial = yield crypto.subtle.importKey('raw', enc.encode(password), {\n            name: 'PBKDF2'\n        }, false, [\n            'deriveBits',\n            'deriveKey'\n        ]);\n        return keyMaterial;\n    });\n}\nfunction createKeyMaterialFromBuffer(cryptoBuffer) {\n    return __awaiter(this, void 0, void 0, function*() {\n        const keyMaterial = yield crypto.subtle.importKey('raw', cryptoBuffer, 'HKDF', false, [\n            'deriveBits',\n            'deriveKey'\n        ]);\n        return keyMaterial;\n    });\n}\nfunction getAlgoOptions(algorithmName, salt) {\n    const textEncoder = new TextEncoder();\n    const encodedSalt = textEncoder.encode(salt);\n    switch(algorithmName){\n        case 'HKDF':\n            return {\n                name: 'HKDF',\n                salt: encodedSalt,\n                hash: 'SHA-256',\n                info: new ArrayBuffer(128)\n            };\n        case 'PBKDF2':\n            {\n                return {\n                    name: 'PBKDF2',\n                    salt: encodedSalt,\n                    hash: 'SHA-256',\n                    iterations: 100000\n                };\n            }\n        default:\n            throw new Error(\"algorithm \".concat(algorithmName, \" is currently unsupported\"));\n    }\n}\n/**\n * Derives a set of keys from the master key.\n * See https://tools.ietf.org/html/draft-omara-sframe-00#section-4.3.1\n */ function deriveKeys(material, salt) {\n    return __awaiter(this, void 0, void 0, function*() {\n        const algorithmOptions = getAlgoOptions(material.algorithm.name, salt);\n        // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/deriveKey#HKDF\n        // https://developer.mozilla.org/en-US/docs/Web/API/HkdfParams\n        const encryptionKey = yield crypto.subtle.deriveKey(algorithmOptions, material, {\n            name: ENCRYPTION_ALGORITHM,\n            length: 128\n        }, false, [\n            'encrypt',\n            'decrypt'\n        ]);\n        return {\n            material,\n            encryptionKey\n        };\n    });\n}\nfunction createE2EEKey() {\n    return window.crypto.getRandomValues(new Uint8Array(32));\n}\n/**\n * Ratchets a key. See\n * https://tools.ietf.org/html/draft-omara-sframe-00#section-4.3.5.1\n */ function ratchet(material, salt) {\n    return __awaiter(this, void 0, void 0, function*() {\n        const algorithmOptions = getAlgoOptions(material.algorithm.name, salt);\n        // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/deriveBits\n        return crypto.subtle.deriveBits(algorithmOptions, material, 256);\n    });\n}\nfunction needsRbspUnescaping(frameData) {\n    for(var i = 0; i < frameData.length - 3; i++){\n        if (frameData[i] == 0 && frameData[i + 1] == 0 && frameData[i + 2] == 3) return true;\n    }\n    return false;\n}\nfunction parseRbsp(stream) {\n    const dataOut = [];\n    var length = stream.length;\n    for(var i = 0; i < stream.length;){\n        // Be careful about over/underflow here. byte_length_ - 3 can underflow, and\n        // i + 3 can overflow, but byte_length_ - i can't, because i < byte_length_\n        // above, and that expression will produce the number of bytes left in\n        // the stream including the byte at i.\n        if (length - i >= 3 && !stream[i] && !stream[i + 1] && stream[i + 2] == 3) {\n            // Two rbsp bytes.\n            dataOut.push(stream[i++]);\n            dataOut.push(stream[i++]);\n            // Skip the emulation byte.\n            i++;\n        } else {\n            // Single rbsp byte.\n            dataOut.push(stream[i++]);\n        }\n    }\n    return new Uint8Array(dataOut);\n}\nconst kZerosInStartSequence = 2;\nconst kEmulationByte = 3;\nfunction writeRbsp(data_in) {\n    const dataOut = [];\n    var numConsecutiveZeros = 0;\n    for(var i = 0; i < data_in.length; ++i){\n        var byte = data_in[i];\n        if (byte <= kEmulationByte && numConsecutiveZeros >= kZerosInStartSequence) {\n            // Need to escape.\n            dataOut.push(kEmulationByte);\n            numConsecutiveZeros = 0;\n        }\n        dataOut.push(byte);\n        if (byte == 0) {\n            ++numConsecutiveZeros;\n        } else {\n            numConsecutiveZeros = 0;\n        }\n    }\n    return new Uint8Array(dataOut);\n}\n/**\n * @experimental\n */ class BaseKeyProvider extends eventsExports.EventEmitter {\n    constructor(){\n        let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        super();\n        /**\n     * callback being invoked after a ratchet request has been performed on a participant\n     * that surfaces the new key material.\n     * @param material\n     * @param keyIndex\n     */ this.onKeyRatcheted = (material, keyIndex)=>{\n            livekitLogger.debug('key ratcheted event received', {\n                material,\n                keyIndex\n            });\n        };\n        this.keyInfoMap = new Map();\n        this.options = Object.assign(Object.assign({}, KEY_PROVIDER_DEFAULTS), options);\n        this.on(KeyProviderEvent.KeyRatcheted, this.onKeyRatcheted);\n    }\n    /**\n   * callback to invoke once a key has been set for a participant\n   * @param key\n   * @param participantIdentity\n   * @param keyIndex\n   */ onSetEncryptionKey(key, participantIdentity, keyIndex) {\n        const keyInfo = {\n            key,\n            participantIdentity,\n            keyIndex\n        };\n        this.keyInfoMap.set(\"\".concat(participantIdentity !== null && participantIdentity !== void 0 ? participantIdentity : 'shared', \"-\").concat(keyIndex !== null && keyIndex !== void 0 ? keyIndex : 0), keyInfo);\n        this.emit(KeyProviderEvent.SetKey, keyInfo);\n    }\n    getKeys() {\n        return Array.from(this.keyInfoMap.values());\n    }\n    getOptions() {\n        return this.options;\n    }\n    ratchetKey(participantIdentity, keyIndex) {\n        this.emit(KeyProviderEvent.RatchetRequest, participantIdentity, keyIndex);\n    }\n}\n/**\n * A basic KeyProvider implementation intended for a single shared\n * passphrase between all participants\n * @experimental\n */ class ExternalE2EEKeyProvider extends BaseKeyProvider {\n    constructor(){\n        let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        const opts = Object.assign(Object.assign({}, options), {\n            sharedKey: true,\n            // for a shared key provider failing to decrypt for a specific participant\n            // should not mark the key as invalid, so we accept wrong keys forever\n            // and won't try to auto-ratchet\n            ratchetWindowSize: 0,\n            failureTolerance: -1\n        });\n        super(opts);\n    }\n    /**\n   * Accepts a passphrase that's used to create the crypto keys.\n   * When passing in a string, PBKDF2 is used.\n   * When passing in an Array buffer of cryptographically random numbers, HKDF is being used. (recommended)\n   * @param key\n   */ setKey(key) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const derivedKey = typeof key === 'string' ? yield createKeyMaterialFromString(key) : yield createKeyMaterialFromBuffer(key);\n            this.onSetEncryptionKey(derivedKey);\n        });\n    }\n}\nclass LivekitError extends Error {\n    constructor(code, message){\n        super(message || 'an error has occured');\n        this.code = code;\n    }\n}\nclass ConnectionError extends LivekitError {\n    constructor(message, reason, status){\n        super(1, message);\n        this.status = status;\n        this.reason = reason;\n    }\n}\nclass DeviceUnsupportedError extends LivekitError {\n    constructor(message){\n        super(21, message !== null && message !== void 0 ? message : 'device is unsupported');\n    }\n}\nclass TrackInvalidError extends LivekitError {\n    constructor(message){\n        super(20, message !== null && message !== void 0 ? message : 'track is invalid');\n    }\n}\nclass UnsupportedServer extends LivekitError {\n    constructor(message){\n        super(10, message !== null && message !== void 0 ? message : 'unsupported server');\n    }\n}\nclass UnexpectedConnectionState extends LivekitError {\n    constructor(message){\n        super(12, message !== null && message !== void 0 ? message : 'unexpected connection state');\n    }\n}\nclass NegotiationError extends LivekitError {\n    constructor(message){\n        super(13, message !== null && message !== void 0 ? message : 'unable to negotiate');\n    }\n}\nclass PublishDataError extends LivekitError {\n    constructor(message){\n        super(13, message !== null && message !== void 0 ? message : 'unable to publish data');\n    }\n}\nvar MediaDeviceFailure;\n(function(MediaDeviceFailure) {\n    // user rejected permissions\n    MediaDeviceFailure[\"PermissionDenied\"] = \"PermissionDenied\";\n    // device is not available\n    MediaDeviceFailure[\"NotFound\"] = \"NotFound\";\n    // device is in use. On Windows, only a single tab may get access to a device at a time.\n    MediaDeviceFailure[\"DeviceInUse\"] = \"DeviceInUse\";\n    MediaDeviceFailure[\"Other\"] = \"Other\";\n})(MediaDeviceFailure || (MediaDeviceFailure = {}));\n(function(MediaDeviceFailure) {\n    function getFailure(error) {\n        if (error && 'name' in error) {\n            if (error.name === 'NotFoundError' || error.name === 'DevicesNotFoundError') {\n                return MediaDeviceFailure.NotFound;\n            }\n            if (error.name === 'NotAllowedError' || error.name === 'PermissionDeniedError') {\n                return MediaDeviceFailure.PermissionDenied;\n            }\n            if (error.name === 'NotReadableError' || error.name === 'TrackStartError') {\n                return MediaDeviceFailure.DeviceInUse;\n            }\n            return MediaDeviceFailure.Other;\n        }\n    }\n    MediaDeviceFailure.getFailure = getFailure;\n})(MediaDeviceFailure || (MediaDeviceFailure = {}));\n/**\n * Events are the primary way LiveKit notifies your application of changes.\n *\n * The following are events emitted by [[Room]], listen to room events like\n *\n * ```typescript\n * room.on(RoomEvent.TrackPublished, (track, publication, participant) => {})\n * ```\n */ var RoomEvent;\n(function(RoomEvent) {\n    /**\n   * When the connection to the server has been established\n   */ RoomEvent[\"Connected\"] = \"connected\";\n    /**\n   * When the connection to the server has been interrupted and it's attempting\n   * to reconnect.\n   */ RoomEvent[\"Reconnecting\"] = \"reconnecting\";\n    /**\n   * Fires when a reconnection has been successful.\n   */ RoomEvent[\"Reconnected\"] = \"reconnected\";\n    /**\n   * When disconnected from room. This fires when room.disconnect() is called or\n   * when an unrecoverable connection issue had occured\n   */ RoomEvent[\"Disconnected\"] = \"disconnected\";\n    /**\n   * Whenever the connection state of the room changes\n   *\n   * args: ([[ConnectionState]])\n   */ RoomEvent[\"ConnectionStateChanged\"] = \"connectionStateChanged\";\n    /**\n   * @deprecated StateChanged has been renamed to ConnectionStateChanged\n   */ RoomEvent[\"StateChanged\"] = \"connectionStateChanged\";\n    /**\n   * When input or output devices on the machine have changed.\n   */ RoomEvent[\"MediaDevicesChanged\"] = \"mediaDevicesChanged\";\n    /**\n   * When a [[RemoteParticipant]] joins *after* the local\n   * participant. It will not emit events for participants that are already\n   * in the room\n   *\n   * args: ([[RemoteParticipant]])\n   */ RoomEvent[\"ParticipantConnected\"] = \"participantConnected\";\n    /**\n   * When a [[RemoteParticipant]] leaves *after* the local\n   * participant has joined.\n   *\n   * args: ([[RemoteParticipant]])\n   */ RoomEvent[\"ParticipantDisconnected\"] = \"participantDisconnected\";\n    /**\n   * When a new track is published to room *after* the local\n   * participant has joined. It will not fire for tracks that are already published.\n   *\n   * A track published doesn't mean the participant has subscribed to it. It's\n   * simply reflecting the state of the room.\n   *\n   * args: ([[RemoteTrackPublication]], [[RemoteParticipant]])\n   */ RoomEvent[\"TrackPublished\"] = \"trackPublished\";\n    /**\n   * The [[LocalParticipant]] has subscribed to a new track. This event will **always**\n   * fire as long as new tracks are ready for use.\n   *\n   * args: ([[RemoteTrack]], [[RemoteTrackPublication]], [[RemoteParticipant]])\n   */ RoomEvent[\"TrackSubscribed\"] = \"trackSubscribed\";\n    /**\n   * Could not subscribe to a track\n   *\n   * args: (track sid, [[RemoteParticipant]])\n   */ RoomEvent[\"TrackSubscriptionFailed\"] = \"trackSubscriptionFailed\";\n    /**\n   * A [[RemoteParticipant]] has unpublished a track\n   *\n   * args: ([[RemoteTrackPublication]], [[RemoteParticipant]])\n   */ RoomEvent[\"TrackUnpublished\"] = \"trackUnpublished\";\n    /**\n   * A subscribed track is no longer available. Clients should listen to this\n   * event and ensure they detach tracks.\n   *\n   * args: ([[Track]], [[RemoteTrackPublication]], [[RemoteParticipant]])\n   */ RoomEvent[\"TrackUnsubscribed\"] = \"trackUnsubscribed\";\n    /**\n   * A track that was muted, fires on both [[RemoteParticipant]]s and [[LocalParticipant]]\n   *\n   * args: ([[TrackPublication]], [[Participant]])\n   */ RoomEvent[\"TrackMuted\"] = \"trackMuted\";\n    /**\n   * A track that was unmuted, fires on both [[RemoteParticipant]]s and [[LocalParticipant]]\n   *\n   * args: ([[TrackPublication]], [[Participant]])\n   */ RoomEvent[\"TrackUnmuted\"] = \"trackUnmuted\";\n    /**\n   * A local track was published successfully. This event is helpful to know\n   * when to update your local UI with the newly published track.\n   *\n   * args: ([[LocalTrackPublication]], [[LocalParticipant]])\n   */ RoomEvent[\"LocalTrackPublished\"] = \"localTrackPublished\";\n    /**\n   * A local track was unpublished. This event is helpful to know when to remove\n   * the local track from your UI.\n   *\n   * When a user stops sharing their screen by pressing \"End\" on the browser UI,\n   * this event will also fire.\n   *\n   * args: ([[LocalTrackPublication]], [[LocalParticipant]])\n   */ RoomEvent[\"LocalTrackUnpublished\"] = \"localTrackUnpublished\";\n    /**\n   * When a local audio track is published the SDK checks whether there is complete silence\n   * on that track and emits the LocalAudioSilenceDetected event in that case.\n   * This allows for applications to show UI informing users that they might have to\n   * reset their audio hardware or check for proper device connectivity.\n   */ RoomEvent[\"LocalAudioSilenceDetected\"] = \"localAudioSilenceDetected\";\n    /**\n   * Active speakers changed. List of speakers are ordered by their audio level.\n   * loudest speakers first. This will include the LocalParticipant too.\n   *\n   * Speaker updates are sent only to the publishing participant and their subscribers.\n   *\n   * args: (Array<[[Participant]]>)\n   */ RoomEvent[\"ActiveSpeakersChanged\"] = \"activeSpeakersChanged\";\n    /**\n   * Participant metadata is a simple way for app-specific state to be pushed to\n   * all users.\n   * When RoomService.UpdateParticipantMetadata is called to change a participant's\n   * state, *all*  participants in the room will fire this event.\n   *\n   * args: (prevMetadata: string, [[Participant]])\n   *\n   */ RoomEvent[\"ParticipantMetadataChanged\"] = \"participantMetadataChanged\";\n    /**\n   * Participant's display name changed\n   *\n   * args: (name: string, [[Participant]])\n   *\n   */ RoomEvent[\"ParticipantNameChanged\"] = \"participantNameChanged\";\n    /**\n   * Room metadata is a simple way for app-specific state to be pushed to\n   * all users.\n   * When RoomService.UpdateRoomMetadata is called to change a room's state,\n   * *all*  participants in the room will fire this event.\n   *\n   * args: (string)\n   */ RoomEvent[\"RoomMetadataChanged\"] = \"roomMetadataChanged\";\n    /**\n   * Data received from another participant.\n   * Data packets provides the ability to use LiveKit to send/receive arbitrary payloads.\n   * All participants in the room will receive the messages sent to the room.\n   *\n   * args: (payload: Uint8Array, participant: [[Participant]], kind: [[DataPacket_Kind]], topic?: string)\n   */ RoomEvent[\"DataReceived\"] = \"dataReceived\";\n    /**\n   * Connection quality was changed for a Participant. It'll receive updates\n   * from the local participant, as well as any [[RemoteParticipant]]s that we are\n   * subscribed to.\n   *\n   * args: (connectionQuality: [[ConnectionQuality]], participant: [[Participant]])\n   */ RoomEvent[\"ConnectionQualityChanged\"] = \"connectionQualityChanged\";\n    /**\n   * StreamState indicates if a subscribed (remote) track has been paused by the SFU\n   * (typically this happens because of subscriber's bandwidth constraints)\n   *\n   * When bandwidth conditions allow, the track will be resumed automatically.\n   * TrackStreamStateChanged will also be emitted when that happens.\n   *\n   * args: (pub: [[RemoteTrackPublication]], streamState: [[Track.StreamState]],\n   *        participant: [[RemoteParticipant]])\n   */ RoomEvent[\"TrackStreamStateChanged\"] = \"trackStreamStateChanged\";\n    /**\n   * One of subscribed tracks have changed its permissions for the current\n   * participant. If permission was revoked, then the track will no longer\n   * be subscribed. If permission was granted, a TrackSubscribed event will\n   * be emitted.\n   *\n   * args: (pub: [[RemoteTrackPublication]],\n   *        status: [[TrackPublication.PermissionStatus]],\n   *        participant: [[RemoteParticipant]])\n   */ RoomEvent[\"TrackSubscriptionPermissionChanged\"] = \"trackSubscriptionPermissionChanged\";\n    /**\n   * One of subscribed tracks have changed its status for the current\n   * participant.\n   *\n   * args: (pub: [[RemoteTrackPublication]],\n   *        status: [[TrackPublication.SubscriptionStatus]],\n   *        participant: [[RemoteParticipant]])\n   */ RoomEvent[\"TrackSubscriptionStatusChanged\"] = \"trackSubscriptionStatusChanged\";\n    /**\n   * LiveKit will attempt to autoplay all audio tracks when you attach them to\n   * audio elements. However, if that fails, we'll notify you via AudioPlaybackStatusChanged.\n   * `Room.canPlaybackAudio` will indicate if audio playback is permitted.\n   */ RoomEvent[\"AudioPlaybackStatusChanged\"] = \"audioPlaybackChanged\";\n    /**\n   * LiveKit will attempt to autoplay all video tracks when you attach them to\n   * a video element. However, if that fails, we'll notify you via VideoPlaybackStatusChanged.\n   * Calling `room.startVideo()` in a user gesture event handler will resume the video playback.\n   */ RoomEvent[\"VideoPlaybackStatusChanged\"] = \"videoPlaybackChanged\";\n    /**\n   * When we have encountered an error while attempting to create a track.\n   * The errors take place in getUserMedia().\n   * Use MediaDeviceFailure.getFailure(error) to get the reason of failure.\n   * [[LocalParticipant.lastCameraError]] and [[LocalParticipant.lastMicrophoneError]]\n   * will indicate if it had an error while creating the audio or video track respectively.\n   *\n   * args: (error: Error)\n   */ RoomEvent[\"MediaDevicesError\"] = \"mediaDevicesError\";\n    /**\n   * A participant's permission has changed. Currently only fired on LocalParticipant.\n   * args: (prevPermissions: [[ParticipantPermission]], participant: [[Participant]])\n   */ RoomEvent[\"ParticipantPermissionsChanged\"] = \"participantPermissionsChanged\";\n    /**\n   * Signal connected, can publish tracks.\n   */ RoomEvent[\"SignalConnected\"] = \"signalConnected\";\n    /**\n   * Recording of a room has started/stopped. Room.isRecording will be updated too.\n   * args: (isRecording: boolean)\n   */ RoomEvent[\"RecordingStatusChanged\"] = \"recordingStatusChanged\";\n    RoomEvent[\"ParticipantEncryptionStatusChanged\"] = \"participantEncryptionStatusChanged\";\n    RoomEvent[\"EncryptionError\"] = \"encryptionError\";\n    /**\n   * Emits whenever the current buffer status of a data channel changes\n   * args: (isLow: boolean, kind: [[DataPacket_Kind]])\n   */ RoomEvent[\"DCBufferStatusChanged\"] = \"dcBufferStatusChanged\";\n    /**\n   * Triggered by a call to room.switchActiveDevice\n   * args: (kind: MediaDeviceKind, deviceId: string)\n   */ RoomEvent[\"ActiveDeviceChanged\"] = \"activeDeviceChanged\";\n})(RoomEvent || (RoomEvent = {}));\nvar ParticipantEvent;\n(function(ParticipantEvent) {\n    /**\n   * When a new track is published to room *after* the local\n   * participant has joined. It will not fire for tracks that are already published.\n   *\n   * A track published doesn't mean the participant has subscribed to it. It's\n   * simply reflecting the state of the room.\n   *\n   * args: ([[RemoteTrackPublication]])\n   */ ParticipantEvent[\"TrackPublished\"] = \"trackPublished\";\n    /**\n   * Successfully subscribed to the [[RemoteParticipant]]'s track.\n   * This event will **always** fire as long as new tracks are ready for use.\n   *\n   * args: ([[RemoteTrack]], [[RemoteTrackPublication]])\n   */ ParticipantEvent[\"TrackSubscribed\"] = \"trackSubscribed\";\n    /**\n   * Could not subscribe to a track\n   *\n   * args: (track sid)\n   */ ParticipantEvent[\"TrackSubscriptionFailed\"] = \"trackSubscriptionFailed\";\n    /**\n   * A [[RemoteParticipant]] has unpublished a track\n   *\n   * args: ([[RemoteTrackPublication]])\n   */ ParticipantEvent[\"TrackUnpublished\"] = \"trackUnpublished\";\n    /**\n   * A subscribed track is no longer available. Clients should listen to this\n   * event and ensure they detach tracks.\n   *\n   * args: ([[RemoteTrack]], [[RemoteTrackPublication]])\n   */ ParticipantEvent[\"TrackUnsubscribed\"] = \"trackUnsubscribed\";\n    /**\n   * A track that was muted, fires on both [[RemoteParticipant]]s and [[LocalParticipant]]\n   *\n   * args: ([[TrackPublication]])\n   */ ParticipantEvent[\"TrackMuted\"] = \"trackMuted\";\n    /**\n   * A track that was unmuted, fires on both [[RemoteParticipant]]s and [[LocalParticipant]]\n   *\n   * args: ([[TrackPublication]])\n   */ ParticipantEvent[\"TrackUnmuted\"] = \"trackUnmuted\";\n    /**\n   * A local track was published successfully. This event is helpful to know\n   * when to update your local UI with the newly published track.\n   *\n   * args: ([[LocalTrackPublication]])\n   */ ParticipantEvent[\"LocalTrackPublished\"] = \"localTrackPublished\";\n    /**\n   * A local track was unpublished. This event is helpful to know when to remove\n   * the local track from your UI.\n   *\n   * When a user stops sharing their screen by pressing \"End\" on the browser UI,\n   * this event will also fire.\n   *\n   * args: ([[LocalTrackPublication]])\n   */ ParticipantEvent[\"LocalTrackUnpublished\"] = \"localTrackUnpublished\";\n    /**\n   * Participant metadata is a simple way for app-specific state to be pushed to\n   * all users.\n   * When RoomService.UpdateParticipantMetadata is called to change a participant's\n   * state, *all*  participants in the room will fire this event.\n   * To access the current metadata, see [[Participant.metadata]].\n   *\n   * args: (prevMetadata: string)\n   *\n   */ ParticipantEvent[\"ParticipantMetadataChanged\"] = \"participantMetadataChanged\";\n    /**\n   * Participant's display name changed\n   *\n   * args: (name: string, [[Participant]])\n   *\n   */ ParticipantEvent[\"ParticipantNameChanged\"] = \"participantNameChanged\";\n    /**\n   * Data received from this participant as sender.\n   * Data packets provides the ability to use LiveKit to send/receive arbitrary payloads.\n   * All participants in the room will receive the messages sent to the room.\n   *\n   * args: (payload: Uint8Array, kind: [[DataPacket_Kind]])\n   */ ParticipantEvent[\"DataReceived\"] = \"dataReceived\";\n    /**\n   * Has speaking status changed for the current participant\n   *\n   * args: (speaking: boolean)\n   */ ParticipantEvent[\"IsSpeakingChanged\"] = \"isSpeakingChanged\";\n    /**\n   * Connection quality was changed for a Participant. It'll receive updates\n   * from the local participant, as well as any [[RemoteParticipant]]s that we are\n   * subscribed to.\n   *\n   * args: (connectionQuality: [[ConnectionQuality]])\n   */ ParticipantEvent[\"ConnectionQualityChanged\"] = \"connectionQualityChanged\";\n    /**\n   * StreamState indicates if a subscribed track has been paused by the SFU\n   * (typically this happens because of subscriber's bandwidth constraints)\n   *\n   * When bandwidth conditions allow, the track will be resumed automatically.\n   * TrackStreamStateChanged will also be emitted when that happens.\n   *\n   * args: (pub: [[RemoteTrackPublication]], streamState: [[Track.StreamState]])\n   */ ParticipantEvent[\"TrackStreamStateChanged\"] = \"trackStreamStateChanged\";\n    /**\n   * One of subscribed tracks have changed its permissions for the current\n   * participant. If permission was revoked, then the track will no longer\n   * be subscribed. If permission was granted, a TrackSubscribed event will\n   * be emitted.\n   *\n   * args: (pub: [[RemoteTrackPublication]],\n   *        status: [[TrackPublication.SubscriptionStatus]])\n   */ ParticipantEvent[\"TrackSubscriptionPermissionChanged\"] = \"trackSubscriptionPermissionChanged\";\n    /**\n   * One of the remote participants publications has changed its subscription status.\n   *\n   */ ParticipantEvent[\"TrackSubscriptionStatusChanged\"] = \"trackSubscriptionStatusChanged\";\n    // fired only on LocalParticipant\n    /** @internal */ ParticipantEvent[\"MediaDevicesError\"] = \"mediaDevicesError\";\n    // fired only on LocalParticipant\n    /** @internal */ ParticipantEvent[\"AudioStreamAcquired\"] = \"audioStreamAcquired\";\n    /**\n   * A participant's permission has changed. Currently only fired on LocalParticipant.\n   * args: (prevPermissions: [[ParticipantPermission]])\n   */ ParticipantEvent[\"ParticipantPermissionsChanged\"] = \"participantPermissionsChanged\";\n    /** @internal */ ParticipantEvent[\"PCTrackAdded\"] = \"pcTrackAdded\";\n})(ParticipantEvent || (ParticipantEvent = {}));\n/** @internal */ var EngineEvent;\n(function(EngineEvent) {\n    EngineEvent[\"TransportsCreated\"] = \"transportsCreated\";\n    EngineEvent[\"Connected\"] = \"connected\";\n    EngineEvent[\"Disconnected\"] = \"disconnected\";\n    EngineEvent[\"Resuming\"] = \"resuming\";\n    EngineEvent[\"Resumed\"] = \"resumed\";\n    EngineEvent[\"Restarting\"] = \"restarting\";\n    EngineEvent[\"Restarted\"] = \"restarted\";\n    EngineEvent[\"SignalResumed\"] = \"signalResumed\";\n    EngineEvent[\"SignalRestarted\"] = \"signalRestarted\";\n    EngineEvent[\"Closing\"] = \"closing\";\n    EngineEvent[\"MediaTrackAdded\"] = \"mediaTrackAdded\";\n    EngineEvent[\"ActiveSpeakersUpdate\"] = \"activeSpeakersUpdate\";\n    EngineEvent[\"DataPacketReceived\"] = \"dataPacketReceived\";\n    EngineEvent[\"RTPVideoMapUpdate\"] = \"rtpVideoMapUpdate\";\n    EngineEvent[\"DCBufferStatusChanged\"] = \"dcBufferStatusChanged\";\n    EngineEvent[\"ParticipantUpdate\"] = \"participantUpdate\";\n    EngineEvent[\"RoomUpdate\"] = \"roomUpdate\";\n    EngineEvent[\"SpeakersChanged\"] = \"speakersChanged\";\n    EngineEvent[\"StreamStateChanged\"] = \"streamStateChanged\";\n    EngineEvent[\"ConnectionQualityUpdate\"] = \"connectionQualityUpdate\";\n    EngineEvent[\"SubscriptionError\"] = \"subscriptionError\";\n    EngineEvent[\"SubscriptionPermissionUpdate\"] = \"subscriptionPermissionUpdate\";\n    EngineEvent[\"RemoteMute\"] = \"remoteMute\";\n    EngineEvent[\"SubscribedQualityUpdate\"] = \"subscribedQualityUpdate\";\n    EngineEvent[\"LocalTrackUnpublished\"] = \"localTrackUnpublished\";\n})(EngineEvent || (EngineEvent = {}));\nvar TrackEvent;\n(function(TrackEvent) {\n    TrackEvent[\"Message\"] = \"message\";\n    TrackEvent[\"Muted\"] = \"muted\";\n    TrackEvent[\"Unmuted\"] = \"unmuted\";\n    /**\n   * Only fires on LocalTracks\n   */ TrackEvent[\"Restarted\"] = \"restarted\";\n    TrackEvent[\"Ended\"] = \"ended\";\n    TrackEvent[\"Subscribed\"] = \"subscribed\";\n    TrackEvent[\"Unsubscribed\"] = \"unsubscribed\";\n    /** @internal */ TrackEvent[\"UpdateSettings\"] = \"updateSettings\";\n    /** @internal */ TrackEvent[\"UpdateSubscription\"] = \"updateSubscription\";\n    /** @internal */ TrackEvent[\"AudioPlaybackStarted\"] = \"audioPlaybackStarted\";\n    /** @internal */ TrackEvent[\"AudioPlaybackFailed\"] = \"audioPlaybackFailed\";\n    /**\n   * @internal\n   * Only fires on LocalAudioTrack instances\n   */ TrackEvent[\"AudioSilenceDetected\"] = \"audioSilenceDetected\";\n    /** @internal */ TrackEvent[\"VisibilityChanged\"] = \"visibilityChanged\";\n    /** @internal */ TrackEvent[\"VideoDimensionsChanged\"] = \"videoDimensionsChanged\";\n    /** @internal */ TrackEvent[\"VideoPlaybackStarted\"] = \"videoPlaybackStarted\";\n    /** @internal */ TrackEvent[\"VideoPlaybackFailed\"] = \"videoPlaybackFailed\";\n    /** @internal */ TrackEvent[\"ElementAttached\"] = \"elementAttached\";\n    /** @internal */ TrackEvent[\"ElementDetached\"] = \"elementDetached\";\n    /**\n   * @internal\n   * Only fires on LocalTracks\n   */ TrackEvent[\"UpstreamPaused\"] = \"upstreamPaused\";\n    /**\n   * @internal\n   * Only fires on LocalTracks\n   */ TrackEvent[\"UpstreamResumed\"] = \"upstreamResumed\";\n    /**\n   * @internal\n   * Fires on RemoteTrackPublication\n   */ TrackEvent[\"SubscriptionPermissionChanged\"] = \"subscriptionPermissionChanged\";\n    /**\n   * Fires on RemoteTrackPublication\n   */ TrackEvent[\"SubscriptionStatusChanged\"] = \"subscriptionStatusChanged\";\n    /**\n   * Fires on RemoteTrackPublication\n   */ TrackEvent[\"SubscriptionFailed\"] = \"subscriptionFailed\";\n})(TrackEvent || (TrackEvent = {}));\nfunction r(r, e, n) {\n    var i, t, o;\n    void 0 === e && (e = 50), void 0 === n && (n = {});\n    var a = null != (i = n.isImmediate) && i, u = null != (t = n.callback) && t, c = n.maxWait, v = Date.now(), l = [];\n    function f() {\n        if (void 0 !== c) {\n            var r = Date.now() - v;\n            if (r + e >= c) return c - r;\n        }\n        return e;\n    }\n    var d = function() {\n        var e = [].slice.call(arguments), n = this;\n        return new Promise(function(i, t) {\n            var c = a && void 0 === o;\n            if (void 0 !== o && clearTimeout(o), o = setTimeout(function() {\n                if (o = void 0, v = Date.now(), !a) {\n                    var i = r.apply(n, e);\n                    u && u(i), l.forEach(function(r) {\n                        return (0, r.resolve)(i);\n                    }), l = [];\n                }\n            }, f()), c) {\n                var d = r.apply(n, e);\n                return u && u(d), i(d);\n            }\n            l.push({\n                resolve: i,\n                reject: t\n            });\n        });\n    };\n    return d.cancel = function(r) {\n        void 0 !== o && clearTimeout(o), l.forEach(function(e) {\n            return (0, e.reject)(r);\n        }), l = [];\n    }, d;\n}\n// tiny, simplified version of https://github.com/lancedikson/bowser/blob/master/src/parser-browsers.js\n// reduced to only differentiate Chrome(ium) based browsers / Firefox / Safari\nconst commonVersionIdentifier = /version\\/(\\d+(\\.?_?\\d+)+)/i;\nlet browserDetails;\n/**\n * @internal\n */ function getBrowser(userAgent) {\n    let force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    if (typeof userAgent === 'undefined' && typeof navigator === 'undefined') {\n        return;\n    }\n    const ua = (userAgent !== null && userAgent !== void 0 ? userAgent : navigator.userAgent).toLowerCase();\n    if (browserDetails === undefined || force) {\n        const browser = browsersList.find((_ref)=>{\n            let { test } = _ref;\n            return test.test(ua);\n        });\n        browserDetails = browser === null || browser === void 0 ? void 0 : browser.describe(ua);\n    }\n    return browserDetails;\n}\nconst browsersList = [\n    {\n        test: /firefox|iceweasel|fxios/i,\n        describe (ua) {\n            const browser = {\n                name: 'Firefox',\n                version: getMatch(/(?:firefox|iceweasel|fxios)[\\s/](\\d+(\\.?_?\\d+)+)/i, ua),\n                os: ua.toLowerCase().includes('fxios') ? 'iOS' : undefined\n            };\n            return browser;\n        }\n    },\n    {\n        test: /chrom|crios|crmo/i,\n        describe (ua) {\n            const browser = {\n                name: 'Chrome',\n                version: getMatch(/(?:chrome|chromium|crios|crmo)\\/(\\d+(\\.?_?\\d+)+)/i, ua),\n                os: ua.toLowerCase().includes('crios') ? 'iOS' : undefined\n            };\n            return browser;\n        }\n    },\n    /* Safari */ {\n        test: /safari|applewebkit/i,\n        describe (ua) {\n            const browser = {\n                name: 'Safari',\n                version: getMatch(commonVersionIdentifier, ua),\n                os: ua.includes('mobile/') ? 'iOS' : 'macOS'\n            };\n            return browser;\n        }\n    }\n];\nfunction getMatch(exp, ua) {\n    let id = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n    const match = ua.match(exp);\n    return match && match.length >= id && match[id] || '';\n}\nvar version$1 = \"1.15.11\";\nconst version = version$1;\nconst protocolVersion = 11;\n/**\n * Timers that can be overridden with platform specific implementations\n * that ensure that they are fired. These should be used when it is critical\n * that the timer fires on time.\n */ class CriticalTimers {\n}\n// eslint-disable-next-line @typescript-eslint/no-implied-eval\nCriticalTimers.setTimeout = function() {\n    return setTimeout(...arguments);\n};\n// eslint-disable-next-line @typescript-eslint/no-implied-eval\nCriticalTimers.setInterval = function() {\n    return setInterval(...arguments);\n};\nCriticalTimers.clearTimeout = function() {\n    return clearTimeout(...arguments);\n};\nCriticalTimers.clearInterval = function() {\n    return clearInterval(...arguments);\n};\nclass VideoPreset {\n    constructor(width, height, maxBitrate, maxFramerate, priority){\n        this.width = width;\n        this.height = height;\n        this.encoding = {\n            maxBitrate,\n            maxFramerate,\n            priority\n        };\n    }\n    get resolution() {\n        return {\n            width: this.width,\n            height: this.height,\n            frameRate: this.encoding.maxFramerate,\n            aspectRatio: this.width / this.height\n        };\n    }\n}\nconst backupCodecs = [\n    'vp8',\n    'h264'\n];\nconst videoCodecs = [\n    'vp8',\n    'h264',\n    'vp9',\n    'av1'\n];\nfunction isBackupCodec(codec) {\n    return !!backupCodecs.find((backup)=>backup === codec);\n}\nvar AudioPresets;\n(function(AudioPresets) {\n    AudioPresets.telephone = {\n        maxBitrate: 12000\n    };\n    AudioPresets.speech = {\n        maxBitrate: 20000\n    };\n    AudioPresets.music = {\n        maxBitrate: 32000\n    };\n    AudioPresets.musicStereo = {\n        maxBitrate: 48000\n    };\n    AudioPresets.musicHighQuality = {\n        maxBitrate: 64000\n    };\n    AudioPresets.musicHighQualityStereo = {\n        maxBitrate: 96000\n    };\n})(AudioPresets || (AudioPresets = {}));\n/**\n * Sane presets for video resolution/encoding\n */ const VideoPresets = {\n    h90: new VideoPreset(160, 90, 90000, 20),\n    h180: new VideoPreset(320, 180, 160000, 20),\n    h216: new VideoPreset(384, 216, 180000, 20),\n    h360: new VideoPreset(640, 360, 450000, 20),\n    h540: new VideoPreset(960, 540, 800000, 25),\n    h720: new VideoPreset(1280, 720, 1700000, 30),\n    h1080: new VideoPreset(1920, 1080, 3000000, 30),\n    h1440: new VideoPreset(2560, 1440, 5000000, 30),\n    h2160: new VideoPreset(3840, 2160, 8000000, 30)\n};\n/**\n * Four by three presets\n */ const VideoPresets43 = {\n    h120: new VideoPreset(160, 120, 70000, 20),\n    h180: new VideoPreset(240, 180, 125000, 20),\n    h240: new VideoPreset(320, 240, 140000, 20),\n    h360: new VideoPreset(480, 360, 330000, 20),\n    h480: new VideoPreset(640, 480, 500000, 20),\n    h540: new VideoPreset(720, 540, 600000, 25),\n    h720: new VideoPreset(960, 720, 1300000, 30),\n    h1080: new VideoPreset(1440, 1080, 2300000, 30),\n    h1440: new VideoPreset(1920, 1440, 3800000, 30)\n};\nconst ScreenSharePresets = {\n    h360fps3: new VideoPreset(640, 360, 200000, 3, 'medium'),\n    h360fps15: new VideoPreset(640, 360, 400000, 15, 'medium'),\n    h720fps5: new VideoPreset(1280, 720, 800000, 5, 'medium'),\n    h720fps15: new VideoPreset(1280, 720, 1500000, 15, 'medium'),\n    h720fps30: new VideoPreset(1280, 720, 2000000, 30, 'medium'),\n    h1080fps15: new VideoPreset(1920, 1080, 2500000, 15, 'medium'),\n    h1080fps30: new VideoPreset(1920, 1080, 5000000, 30, 'medium'),\n    // original resolution, without resizing\n    original: new VideoPreset(0, 0, 7000000, 30, 'medium')\n};\n// Copyright 2023 LiveKit, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * @generated from enum livekit.SignalTarget\n */ var SignalTarget;\n(function(SignalTarget) {\n    /**\n   * @generated from enum value: PUBLISHER = 0;\n   */ SignalTarget[SignalTarget[\"PUBLISHER\"] = 0] = \"PUBLISHER\";\n    /**\n   * @generated from enum value: SUBSCRIBER = 1;\n   */ SignalTarget[SignalTarget[\"SUBSCRIBER\"] = 1] = \"SUBSCRIBER\";\n})(SignalTarget || (SignalTarget = {}));\n// Retrieve enum metadata with: proto3.getEnumType(SignalTarget)\nproto3.util.setEnumType(SignalTarget, \"livekit.SignalTarget\", [\n    {\n        no: 0,\n        name: \"PUBLISHER\"\n    },\n    {\n        no: 1,\n        name: \"SUBSCRIBER\"\n    }\n]);\n/**\n * @generated from enum livekit.StreamState\n */ var StreamState;\n(function(StreamState) {\n    /**\n   * @generated from enum value: ACTIVE = 0;\n   */ StreamState[StreamState[\"ACTIVE\"] = 0] = \"ACTIVE\";\n    /**\n   * @generated from enum value: PAUSED = 1;\n   */ StreamState[StreamState[\"PAUSED\"] = 1] = \"PAUSED\";\n})(StreamState || (StreamState = {}));\n// Retrieve enum metadata with: proto3.getEnumType(StreamState)\nproto3.util.setEnumType(StreamState, \"livekit.StreamState\", [\n    {\n        no: 0,\n        name: \"ACTIVE\"\n    },\n    {\n        no: 1,\n        name: \"PAUSED\"\n    }\n]);\n/**\n * @generated from enum livekit.CandidateProtocol\n */ var CandidateProtocol;\n(function(CandidateProtocol) {\n    /**\n   * @generated from enum value: UDP = 0;\n   */ CandidateProtocol[CandidateProtocol[\"UDP\"] = 0] = \"UDP\";\n    /**\n   * @generated from enum value: TCP = 1;\n   */ CandidateProtocol[CandidateProtocol[\"TCP\"] = 1] = \"TCP\";\n    /**\n   * @generated from enum value: TLS = 2;\n   */ CandidateProtocol[CandidateProtocol[\"TLS\"] = 2] = \"TLS\";\n})(CandidateProtocol || (CandidateProtocol = {}));\n// Retrieve enum metadata with: proto3.getEnumType(CandidateProtocol)\nproto3.util.setEnumType(CandidateProtocol, \"livekit.CandidateProtocol\", [\n    {\n        no: 0,\n        name: \"UDP\"\n    },\n    {\n        no: 1,\n        name: \"TCP\"\n    },\n    {\n        no: 2,\n        name: \"TLS\"\n    }\n]);\n/**\n * @generated from message livekit.SignalRequest\n */ class SignalRequest extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from oneof livekit.SignalRequest.message\n     */ this.message = {\n            case: undefined\n        };\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new SignalRequest().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new SignalRequest().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new SignalRequest().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(SignalRequest, a, b);\n    }\n}\nSignalRequest.runtime = proto3;\nSignalRequest.typeName = \"livekit.SignalRequest\";\nSignalRequest.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"offer\",\n            kind: \"message\",\n            T: SessionDescription,\n            oneof: \"message\"\n        },\n        {\n            no: 2,\n            name: \"answer\",\n            kind: \"message\",\n            T: SessionDescription,\n            oneof: \"message\"\n        },\n        {\n            no: 3,\n            name: \"trickle\",\n            kind: \"message\",\n            T: TrickleRequest,\n            oneof: \"message\"\n        },\n        {\n            no: 4,\n            name: \"add_track\",\n            kind: \"message\",\n            T: AddTrackRequest,\n            oneof: \"message\"\n        },\n        {\n            no: 5,\n            name: \"mute\",\n            kind: \"message\",\n            T: MuteTrackRequest,\n            oneof: \"message\"\n        },\n        {\n            no: 6,\n            name: \"subscription\",\n            kind: \"message\",\n            T: UpdateSubscription,\n            oneof: \"message\"\n        },\n        {\n            no: 7,\n            name: \"track_setting\",\n            kind: \"message\",\n            T: UpdateTrackSettings,\n            oneof: \"message\"\n        },\n        {\n            no: 8,\n            name: \"leave\",\n            kind: \"message\",\n            T: LeaveRequest,\n            oneof: \"message\"\n        },\n        {\n            no: 10,\n            name: \"update_layers\",\n            kind: \"message\",\n            T: UpdateVideoLayers,\n            oneof: \"message\"\n        },\n        {\n            no: 11,\n            name: \"subscription_permission\",\n            kind: \"message\",\n            T: SubscriptionPermission,\n            oneof: \"message\"\n        },\n        {\n            no: 12,\n            name: \"sync_state\",\n            kind: \"message\",\n            T: SyncState,\n            oneof: \"message\"\n        },\n        {\n            no: 13,\n            name: \"simulate\",\n            kind: \"message\",\n            T: SimulateScenario,\n            oneof: \"message\"\n        },\n        {\n            no: 14,\n            name: \"ping\",\n            kind: \"scalar\",\n            T: 3 /* ScalarType.INT64 */ ,\n            oneof: \"message\"\n        },\n        {\n            no: 15,\n            name: \"update_metadata\",\n            kind: \"message\",\n            T: UpdateParticipantMetadata,\n            oneof: \"message\"\n        },\n        {\n            no: 16,\n            name: \"ping_req\",\n            kind: \"message\",\n            T: Ping,\n            oneof: \"message\"\n        }\n    ]);\n/**\n * @generated from message livekit.SignalResponse\n */ class SignalResponse extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from oneof livekit.SignalResponse.message\n     */ this.message = {\n            case: undefined\n        };\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new SignalResponse().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new SignalResponse().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new SignalResponse().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(SignalResponse, a, b);\n    }\n}\nSignalResponse.runtime = proto3;\nSignalResponse.typeName = \"livekit.SignalResponse\";\nSignalResponse.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"join\",\n            kind: \"message\",\n            T: JoinResponse,\n            oneof: \"message\"\n        },\n        {\n            no: 2,\n            name: \"answer\",\n            kind: \"message\",\n            T: SessionDescription,\n            oneof: \"message\"\n        },\n        {\n            no: 3,\n            name: \"offer\",\n            kind: \"message\",\n            T: SessionDescription,\n            oneof: \"message\"\n        },\n        {\n            no: 4,\n            name: \"trickle\",\n            kind: \"message\",\n            T: TrickleRequest,\n            oneof: \"message\"\n        },\n        {\n            no: 5,\n            name: \"update\",\n            kind: \"message\",\n            T: ParticipantUpdate,\n            oneof: \"message\"\n        },\n        {\n            no: 6,\n            name: \"track_published\",\n            kind: \"message\",\n            T: TrackPublishedResponse,\n            oneof: \"message\"\n        },\n        {\n            no: 8,\n            name: \"leave\",\n            kind: \"message\",\n            T: LeaveRequest,\n            oneof: \"message\"\n        },\n        {\n            no: 9,\n            name: \"mute\",\n            kind: \"message\",\n            T: MuteTrackRequest,\n            oneof: \"message\"\n        },\n        {\n            no: 10,\n            name: \"speakers_changed\",\n            kind: \"message\",\n            T: SpeakersChanged,\n            oneof: \"message\"\n        },\n        {\n            no: 11,\n            name: \"room_update\",\n            kind: \"message\",\n            T: RoomUpdate,\n            oneof: \"message\"\n        },\n        {\n            no: 12,\n            name: \"connection_quality\",\n            kind: \"message\",\n            T: ConnectionQualityUpdate,\n            oneof: \"message\"\n        },\n        {\n            no: 13,\n            name: \"stream_state_update\",\n            kind: \"message\",\n            T: StreamStateUpdate,\n            oneof: \"message\"\n        },\n        {\n            no: 14,\n            name: \"subscribed_quality_update\",\n            kind: \"message\",\n            T: SubscribedQualityUpdate,\n            oneof: \"message\"\n        },\n        {\n            no: 15,\n            name: \"subscription_permission_update\",\n            kind: \"message\",\n            T: SubscriptionPermissionUpdate,\n            oneof: \"message\"\n        },\n        {\n            no: 16,\n            name: \"refresh_token\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ ,\n            oneof: \"message\"\n        },\n        {\n            no: 17,\n            name: \"track_unpublished\",\n            kind: \"message\",\n            T: TrackUnpublishedResponse,\n            oneof: \"message\"\n        },\n        {\n            no: 18,\n            name: \"pong\",\n            kind: \"scalar\",\n            T: 3 /* ScalarType.INT64 */ ,\n            oneof: \"message\"\n        },\n        {\n            no: 19,\n            name: \"reconnect\",\n            kind: \"message\",\n            T: ReconnectResponse,\n            oneof: \"message\"\n        },\n        {\n            no: 20,\n            name: \"pong_resp\",\n            kind: \"message\",\n            T: Pong,\n            oneof: \"message\"\n        },\n        {\n            no: 21,\n            name: \"subscription_response\",\n            kind: \"message\",\n            T: SubscriptionResponse,\n            oneof: \"message\"\n        }\n    ]);\n/**\n * @generated from message livekit.SimulcastCodec\n */ class SimulcastCodec extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: string codec = 1;\n     */ this.codec = \"\";\n        /**\n     * @generated from field: string cid = 2;\n     */ this.cid = \"\";\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new SimulcastCodec().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new SimulcastCodec().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new SimulcastCodec().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(SimulcastCodec, a, b);\n    }\n}\nSimulcastCodec.runtime = proto3;\nSimulcastCodec.typeName = \"livekit.SimulcastCodec\";\nSimulcastCodec.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"codec\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 2,\n            name: \"cid\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        }\n    ]);\n/**\n * @generated from message livekit.AddTrackRequest\n */ class AddTrackRequest extends Message {\n    constructor(data){\n        super();\n        /**\n     * client ID of track, to match it when RTC track is received\n     *\n     * @generated from field: string cid = 1;\n     */ this.cid = \"\";\n        /**\n     * @generated from field: string name = 2;\n     */ this.name = \"\";\n        /**\n     * @generated from field: livekit.TrackType type = 3;\n     */ this.type = TrackType.AUDIO;\n        /**\n     * to be deprecated in favor of layers\n     *\n     * @generated from field: uint32 width = 4;\n     */ this.width = 0;\n        /**\n     * @generated from field: uint32 height = 5;\n     */ this.height = 0;\n        /**\n     * true to add track and initialize to muted\n     *\n     * @generated from field: bool muted = 6;\n     */ this.muted = false;\n        /**\n     * true if DTX (Discontinuous Transmission) is disabled for audio\n     *\n     * @generated from field: bool disable_dtx = 7;\n     */ this.disableDtx = false;\n        /**\n     * @generated from field: livekit.TrackSource source = 8;\n     */ this.source = TrackSource.UNKNOWN;\n        /**\n     * @generated from field: repeated livekit.VideoLayer layers = 9;\n     */ this.layers = [];\n        /**\n     * @generated from field: repeated livekit.SimulcastCodec simulcast_codecs = 10;\n     */ this.simulcastCodecs = [];\n        /**\n     * server ID of track, publish new codec to exist track\n     *\n     * @generated from field: string sid = 11;\n     */ this.sid = \"\";\n        /**\n     * @generated from field: bool stereo = 12;\n     */ this.stereo = false;\n        /**\n     * true if RED (Redundant Encoding) is disabled for audio\n     *\n     * @generated from field: bool disable_red = 13;\n     */ this.disableRed = false;\n        /**\n     * @generated from field: livekit.Encryption.Type encryption = 14;\n     */ this.encryption = Encryption_Type.NONE;\n        /**\n     * which stream the track belongs to, used to group tracks together.\n     * if not specified, server will infer it from track source to bundle camera/microphone, screenshare/audio together\n     *\n     * @generated from field: string stream = 15;\n     */ this.stream = \"\";\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new AddTrackRequest().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new AddTrackRequest().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new AddTrackRequest().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(AddTrackRequest, a, b);\n    }\n}\nAddTrackRequest.runtime = proto3;\nAddTrackRequest.typeName = \"livekit.AddTrackRequest\";\nAddTrackRequest.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"cid\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 2,\n            name: \"name\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 3,\n            name: \"type\",\n            kind: \"enum\",\n            T: proto3.getEnumType(TrackType)\n        },\n        {\n            no: 4,\n            name: \"width\",\n            kind: \"scalar\",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 5,\n            name: \"height\",\n            kind: \"scalar\",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 6,\n            name: \"muted\",\n            kind: \"scalar\",\n            T: 8 /* ScalarType.BOOL */ \n        },\n        {\n            no: 7,\n            name: \"disable_dtx\",\n            kind: \"scalar\",\n            T: 8 /* ScalarType.BOOL */ \n        },\n        {\n            no: 8,\n            name: \"source\",\n            kind: \"enum\",\n            T: proto3.getEnumType(TrackSource)\n        },\n        {\n            no: 9,\n            name: \"layers\",\n            kind: \"message\",\n            T: VideoLayer,\n            repeated: true\n        },\n        {\n            no: 10,\n            name: \"simulcast_codecs\",\n            kind: \"message\",\n            T: SimulcastCodec,\n            repeated: true\n        },\n        {\n            no: 11,\n            name: \"sid\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 12,\n            name: \"stereo\",\n            kind: \"scalar\",\n            T: 8 /* ScalarType.BOOL */ \n        },\n        {\n            no: 13,\n            name: \"disable_red\",\n            kind: \"scalar\",\n            T: 8 /* ScalarType.BOOL */ \n        },\n        {\n            no: 14,\n            name: \"encryption\",\n            kind: \"enum\",\n            T: proto3.getEnumType(Encryption_Type)\n        },\n        {\n            no: 15,\n            name: \"stream\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        }\n    ]);\n/**\n * @generated from message livekit.TrickleRequest\n */ class TrickleRequest extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: string candidateInit = 1;\n     */ this.candidateInit = \"\";\n        /**\n     * @generated from field: livekit.SignalTarget target = 2;\n     */ this.target = SignalTarget.PUBLISHER;\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new TrickleRequest().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new TrickleRequest().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new TrickleRequest().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(TrickleRequest, a, b);\n    }\n}\nTrickleRequest.runtime = proto3;\nTrickleRequest.typeName = \"livekit.TrickleRequest\";\nTrickleRequest.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"candidateInit\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 2,\n            name: \"target\",\n            kind: \"enum\",\n            T: proto3.getEnumType(SignalTarget)\n        }\n    ]);\n/**\n * @generated from message livekit.MuteTrackRequest\n */ class MuteTrackRequest extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: string sid = 1;\n     */ this.sid = \"\";\n        /**\n     * @generated from field: bool muted = 2;\n     */ this.muted = false;\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new MuteTrackRequest().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new MuteTrackRequest().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new MuteTrackRequest().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(MuteTrackRequest, a, b);\n    }\n}\nMuteTrackRequest.runtime = proto3;\nMuteTrackRequest.typeName = \"livekit.MuteTrackRequest\";\nMuteTrackRequest.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"sid\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 2,\n            name: \"muted\",\n            kind: \"scalar\",\n            T: 8 /* ScalarType.BOOL */ \n        }\n    ]);\n/**\n * @generated from message livekit.JoinResponse\n */ class JoinResponse extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: repeated livekit.ParticipantInfo other_participants = 3;\n     */ this.otherParticipants = [];\n        /**\n     * deprecated. use server_info.version instead.\n     *\n     * @generated from field: string server_version = 4;\n     */ this.serverVersion = \"\";\n        /**\n     * @generated from field: repeated livekit.ICEServer ice_servers = 5;\n     */ this.iceServers = [];\n        /**\n     * use subscriber as the primary PeerConnection\n     *\n     * @generated from field: bool subscriber_primary = 6;\n     */ this.subscriberPrimary = false;\n        /**\n     * when the current server isn't available, return alternate url to retry connection\n     * when this is set, the other fields will be largely empty\n     *\n     * @generated from field: string alternative_url = 7;\n     */ this.alternativeUrl = \"\";\n        /**\n     * deprecated. use server_info.region instead.\n     *\n     * @generated from field: string server_region = 9;\n     */ this.serverRegion = \"\";\n        /**\n     * @generated from field: int32 ping_timeout = 10;\n     */ this.pingTimeout = 0;\n        /**\n     * @generated from field: int32 ping_interval = 11;\n     */ this.pingInterval = 0;\n        /**\n     * Server-Injected-Frame byte trailer, used to identify unencrypted frames when e2ee is enabled\n     *\n     * @generated from field: bytes sif_trailer = 13;\n     */ this.sifTrailer = new Uint8Array(0);\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new JoinResponse().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new JoinResponse().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new JoinResponse().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(JoinResponse, a, b);\n    }\n}\nJoinResponse.runtime = proto3;\nJoinResponse.typeName = \"livekit.JoinResponse\";\nJoinResponse.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"room\",\n            kind: \"message\",\n            T: Room$1\n        },\n        {\n            no: 2,\n            name: \"participant\",\n            kind: \"message\",\n            T: ParticipantInfo\n        },\n        {\n            no: 3,\n            name: \"other_participants\",\n            kind: \"message\",\n            T: ParticipantInfo,\n            repeated: true\n        },\n        {\n            no: 4,\n            name: \"server_version\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 5,\n            name: \"ice_servers\",\n            kind: \"message\",\n            T: ICEServer,\n            repeated: true\n        },\n        {\n            no: 6,\n            name: \"subscriber_primary\",\n            kind: \"scalar\",\n            T: 8 /* ScalarType.BOOL */ \n        },\n        {\n            no: 7,\n            name: \"alternative_url\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 8,\n            name: \"client_configuration\",\n            kind: \"message\",\n            T: ClientConfiguration\n        },\n        {\n            no: 9,\n            name: \"server_region\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 10,\n            name: \"ping_timeout\",\n            kind: \"scalar\",\n            T: 5 /* ScalarType.INT32 */ \n        },\n        {\n            no: 11,\n            name: \"ping_interval\",\n            kind: \"scalar\",\n            T: 5 /* ScalarType.INT32 */ \n        },\n        {\n            no: 12,\n            name: \"server_info\",\n            kind: \"message\",\n            T: ServerInfo\n        },\n        {\n            no: 13,\n            name: \"sif_trailer\",\n            kind: \"scalar\",\n            T: 12 /* ScalarType.BYTES */ \n        }\n    ]);\n/**\n * @generated from message livekit.ReconnectResponse\n */ class ReconnectResponse extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: repeated livekit.ICEServer ice_servers = 1;\n     */ this.iceServers = [];\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new ReconnectResponse().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new ReconnectResponse().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new ReconnectResponse().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(ReconnectResponse, a, b);\n    }\n}\nReconnectResponse.runtime = proto3;\nReconnectResponse.typeName = \"livekit.ReconnectResponse\";\nReconnectResponse.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"ice_servers\",\n            kind: \"message\",\n            T: ICEServer,\n            repeated: true\n        },\n        {\n            no: 2,\n            name: \"client_configuration\",\n            kind: \"message\",\n            T: ClientConfiguration\n        }\n    ]);\n/**\n * @generated from message livekit.TrackPublishedResponse\n */ class TrackPublishedResponse extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: string cid = 1;\n     */ this.cid = \"\";\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new TrackPublishedResponse().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new TrackPublishedResponse().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new TrackPublishedResponse().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(TrackPublishedResponse, a, b);\n    }\n}\nTrackPublishedResponse.runtime = proto3;\nTrackPublishedResponse.typeName = \"livekit.TrackPublishedResponse\";\nTrackPublishedResponse.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"cid\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 2,\n            name: \"track\",\n            kind: \"message\",\n            T: TrackInfo\n        }\n    ]);\n/**\n * @generated from message livekit.TrackUnpublishedResponse\n */ class TrackUnpublishedResponse extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: string track_sid = 1;\n     */ this.trackSid = \"\";\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new TrackUnpublishedResponse().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new TrackUnpublishedResponse().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new TrackUnpublishedResponse().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(TrackUnpublishedResponse, a, b);\n    }\n}\nTrackUnpublishedResponse.runtime = proto3;\nTrackUnpublishedResponse.typeName = \"livekit.TrackUnpublishedResponse\";\nTrackUnpublishedResponse.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"track_sid\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        }\n    ]);\n/**\n * @generated from message livekit.SessionDescription\n */ class SessionDescription extends Message {\n    constructor(data){\n        super();\n        /**\n     * \"answer\" | \"offer\" | \"pranswer\" | \"rollback\"\n     *\n     * @generated from field: string type = 1;\n     */ this.type = \"\";\n        /**\n     * @generated from field: string sdp = 2;\n     */ this.sdp = \"\";\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new SessionDescription().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new SessionDescription().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new SessionDescription().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(SessionDescription, a, b);\n    }\n}\nSessionDescription.runtime = proto3;\nSessionDescription.typeName = \"livekit.SessionDescription\";\nSessionDescription.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"type\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 2,\n            name: \"sdp\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        }\n    ]);\n/**\n * @generated from message livekit.ParticipantUpdate\n */ class ParticipantUpdate extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: repeated livekit.ParticipantInfo participants = 1;\n     */ this.participants = [];\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new ParticipantUpdate().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new ParticipantUpdate().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new ParticipantUpdate().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(ParticipantUpdate, a, b);\n    }\n}\nParticipantUpdate.runtime = proto3;\nParticipantUpdate.typeName = \"livekit.ParticipantUpdate\";\nParticipantUpdate.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"participants\",\n            kind: \"message\",\n            T: ParticipantInfo,\n            repeated: true\n        }\n    ]);\n/**\n * @generated from message livekit.UpdateSubscription\n */ class UpdateSubscription extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: repeated string track_sids = 1;\n     */ this.trackSids = [];\n        /**\n     * @generated from field: bool subscribe = 2;\n     */ this.subscribe = false;\n        /**\n     * @generated from field: repeated livekit.ParticipantTracks participant_tracks = 3;\n     */ this.participantTracks = [];\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new UpdateSubscription().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new UpdateSubscription().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new UpdateSubscription().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(UpdateSubscription, a, b);\n    }\n}\nUpdateSubscription.runtime = proto3;\nUpdateSubscription.typeName = \"livekit.UpdateSubscription\";\nUpdateSubscription.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"track_sids\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ ,\n            repeated: true\n        },\n        {\n            no: 2,\n            name: \"subscribe\",\n            kind: \"scalar\",\n            T: 8 /* ScalarType.BOOL */ \n        },\n        {\n            no: 3,\n            name: \"participant_tracks\",\n            kind: \"message\",\n            T: ParticipantTracks,\n            repeated: true\n        }\n    ]);\n/**\n * @generated from message livekit.UpdateTrackSettings\n */ class UpdateTrackSettings extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: repeated string track_sids = 1;\n     */ this.trackSids = [];\n        /**\n     * when true, the track is placed in a paused state, with no new data returned\n     *\n     * @generated from field: bool disabled = 3;\n     */ this.disabled = false;\n        /**\n     * deprecated in favor of width & height\n     *\n     * @generated from field: livekit.VideoQuality quality = 4;\n     */ this.quality = VideoQuality.LOW;\n        /**\n     * for video, width to receive\n     *\n     * @generated from field: uint32 width = 5;\n     */ this.width = 0;\n        /**\n     * for video, height to receive\n     *\n     * @generated from field: uint32 height = 6;\n     */ this.height = 0;\n        /**\n     * @generated from field: uint32 fps = 7;\n     */ this.fps = 0;\n        /**\n     * subscription priority. 1 being the highest (0 is unset)\n     * when unset, server sill assign priority based on the order of subscription\n     * server will use priority in the following ways:\n     * 1. when subscribed tracks exceed per-participant subscription limit, server will\n     *    pause the lowest priority tracks\n     * 2. when the network is congested, server will assign available bandwidth to\n     *    higher priority tracks first. lowest priority tracks can be paused\n     *\n     * @generated from field: uint32 priority = 8;\n     */ this.priority = 0;\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new UpdateTrackSettings().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new UpdateTrackSettings().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new UpdateTrackSettings().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(UpdateTrackSettings, a, b);\n    }\n}\nUpdateTrackSettings.runtime = proto3;\nUpdateTrackSettings.typeName = \"livekit.UpdateTrackSettings\";\nUpdateTrackSettings.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"track_sids\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ ,\n            repeated: true\n        },\n        {\n            no: 3,\n            name: \"disabled\",\n            kind: \"scalar\",\n            T: 8 /* ScalarType.BOOL */ \n        },\n        {\n            no: 4,\n            name: \"quality\",\n            kind: \"enum\",\n            T: proto3.getEnumType(VideoQuality)\n        },\n        {\n            no: 5,\n            name: \"width\",\n            kind: \"scalar\",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 6,\n            name: \"height\",\n            kind: \"scalar\",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 7,\n            name: \"fps\",\n            kind: \"scalar\",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 8,\n            name: \"priority\",\n            kind: \"scalar\",\n            T: 13 /* ScalarType.UINT32 */ \n        }\n    ]);\n/**\n * @generated from message livekit.LeaveRequest\n */ class LeaveRequest extends Message {\n    constructor(data){\n        super();\n        /**\n     * sent when server initiates the disconnect due to server-restart\n     * indicates clients should attempt full-reconnect sequence\n     *\n     * @generated from field: bool can_reconnect = 1;\n     */ this.canReconnect = false;\n        /**\n     * @generated from field: livekit.DisconnectReason reason = 2;\n     */ this.reason = DisconnectReason.UNKNOWN_REASON;\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new LeaveRequest().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new LeaveRequest().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new LeaveRequest().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(LeaveRequest, a, b);\n    }\n}\nLeaveRequest.runtime = proto3;\nLeaveRequest.typeName = \"livekit.LeaveRequest\";\nLeaveRequest.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"can_reconnect\",\n            kind: \"scalar\",\n            T: 8 /* ScalarType.BOOL */ \n        },\n        {\n            no: 2,\n            name: \"reason\",\n            kind: \"enum\",\n            T: proto3.getEnumType(DisconnectReason)\n        }\n    ]);\n/**\n * message to indicate published video track dimensions are changing\n *\n * @generated from message livekit.UpdateVideoLayers\n */ class UpdateVideoLayers extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: string track_sid = 1;\n     */ this.trackSid = \"\";\n        /**\n     * @generated from field: repeated livekit.VideoLayer layers = 2;\n     */ this.layers = [];\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new UpdateVideoLayers().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new UpdateVideoLayers().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new UpdateVideoLayers().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(UpdateVideoLayers, a, b);\n    }\n}\nUpdateVideoLayers.runtime = proto3;\nUpdateVideoLayers.typeName = \"livekit.UpdateVideoLayers\";\nUpdateVideoLayers.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"track_sid\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 2,\n            name: \"layers\",\n            kind: \"message\",\n            T: VideoLayer,\n            repeated: true\n        }\n    ]);\n/**\n * @generated from message livekit.UpdateParticipantMetadata\n */ class UpdateParticipantMetadata extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: string metadata = 1;\n     */ this.metadata = \"\";\n        /**\n     * @generated from field: string name = 2;\n     */ this.name = \"\";\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new UpdateParticipantMetadata().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new UpdateParticipantMetadata().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new UpdateParticipantMetadata().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(UpdateParticipantMetadata, a, b);\n    }\n}\nUpdateParticipantMetadata.runtime = proto3;\nUpdateParticipantMetadata.typeName = \"livekit.UpdateParticipantMetadata\";\nUpdateParticipantMetadata.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"metadata\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 2,\n            name: \"name\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        }\n    ]);\n/**\n * @generated from message livekit.ICEServer\n */ class ICEServer extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: repeated string urls = 1;\n     */ this.urls = [];\n        /**\n     * @generated from field: string username = 2;\n     */ this.username = \"\";\n        /**\n     * @generated from field: string credential = 3;\n     */ this.credential = \"\";\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new ICEServer().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new ICEServer().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new ICEServer().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(ICEServer, a, b);\n    }\n}\nICEServer.runtime = proto3;\nICEServer.typeName = \"livekit.ICEServer\";\nICEServer.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"urls\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ ,\n            repeated: true\n        },\n        {\n            no: 2,\n            name: \"username\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 3,\n            name: \"credential\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        }\n    ]);\n/**\n * @generated from message livekit.SpeakersChanged\n */ class SpeakersChanged extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: repeated livekit.SpeakerInfo speakers = 1;\n     */ this.speakers = [];\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new SpeakersChanged().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new SpeakersChanged().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new SpeakersChanged().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(SpeakersChanged, a, b);\n    }\n}\nSpeakersChanged.runtime = proto3;\nSpeakersChanged.typeName = \"livekit.SpeakersChanged\";\nSpeakersChanged.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"speakers\",\n            kind: \"message\",\n            T: SpeakerInfo,\n            repeated: true\n        }\n    ]);\n/**\n * @generated from message livekit.RoomUpdate\n */ class RoomUpdate extends Message {\n    constructor(data){\n        super();\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new RoomUpdate().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new RoomUpdate().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new RoomUpdate().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(RoomUpdate, a, b);\n    }\n}\nRoomUpdate.runtime = proto3;\nRoomUpdate.typeName = \"livekit.RoomUpdate\";\nRoomUpdate.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"room\",\n            kind: \"message\",\n            T: Room$1\n        }\n    ]);\n/**\n * @generated from message livekit.ConnectionQualityInfo\n */ class ConnectionQualityInfo extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: string participant_sid = 1;\n     */ this.participantSid = \"\";\n        /**\n     * @generated from field: livekit.ConnectionQuality quality = 2;\n     */ this.quality = ConnectionQuality$1.POOR;\n        /**\n     * @generated from field: float score = 3;\n     */ this.score = 0;\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new ConnectionQualityInfo().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new ConnectionQualityInfo().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new ConnectionQualityInfo().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(ConnectionQualityInfo, a, b);\n    }\n}\nConnectionQualityInfo.runtime = proto3;\nConnectionQualityInfo.typeName = \"livekit.ConnectionQualityInfo\";\nConnectionQualityInfo.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"participant_sid\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 2,\n            name: \"quality\",\n            kind: \"enum\",\n            T: proto3.getEnumType(ConnectionQuality$1)\n        },\n        {\n            no: 3,\n            name: \"score\",\n            kind: \"scalar\",\n            T: 2 /* ScalarType.FLOAT */ \n        }\n    ]);\n/**\n * @generated from message livekit.ConnectionQualityUpdate\n */ class ConnectionQualityUpdate extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: repeated livekit.ConnectionQualityInfo updates = 1;\n     */ this.updates = [];\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new ConnectionQualityUpdate().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new ConnectionQualityUpdate().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new ConnectionQualityUpdate().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(ConnectionQualityUpdate, a, b);\n    }\n}\nConnectionQualityUpdate.runtime = proto3;\nConnectionQualityUpdate.typeName = \"livekit.ConnectionQualityUpdate\";\nConnectionQualityUpdate.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"updates\",\n            kind: \"message\",\n            T: ConnectionQualityInfo,\n            repeated: true\n        }\n    ]);\n/**\n * @generated from message livekit.StreamStateInfo\n */ class StreamStateInfo extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: string participant_sid = 1;\n     */ this.participantSid = \"\";\n        /**\n     * @generated from field: string track_sid = 2;\n     */ this.trackSid = \"\";\n        /**\n     * @generated from field: livekit.StreamState state = 3;\n     */ this.state = StreamState.ACTIVE;\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new StreamStateInfo().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new StreamStateInfo().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new StreamStateInfo().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(StreamStateInfo, a, b);\n    }\n}\nStreamStateInfo.runtime = proto3;\nStreamStateInfo.typeName = \"livekit.StreamStateInfo\";\nStreamStateInfo.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"participant_sid\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 2,\n            name: \"track_sid\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 3,\n            name: \"state\",\n            kind: \"enum\",\n            T: proto3.getEnumType(StreamState)\n        }\n    ]);\n/**\n * @generated from message livekit.StreamStateUpdate\n */ class StreamStateUpdate extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: repeated livekit.StreamStateInfo stream_states = 1;\n     */ this.streamStates = [];\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new StreamStateUpdate().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new StreamStateUpdate().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new StreamStateUpdate().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(StreamStateUpdate, a, b);\n    }\n}\nStreamStateUpdate.runtime = proto3;\nStreamStateUpdate.typeName = \"livekit.StreamStateUpdate\";\nStreamStateUpdate.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"stream_states\",\n            kind: \"message\",\n            T: StreamStateInfo,\n            repeated: true\n        }\n    ]);\n/**\n * @generated from message livekit.SubscribedQuality\n */ class SubscribedQuality extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: livekit.VideoQuality quality = 1;\n     */ this.quality = VideoQuality.LOW;\n        /**\n     * @generated from field: bool enabled = 2;\n     */ this.enabled = false;\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new SubscribedQuality().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new SubscribedQuality().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new SubscribedQuality().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(SubscribedQuality, a, b);\n    }\n}\nSubscribedQuality.runtime = proto3;\nSubscribedQuality.typeName = \"livekit.SubscribedQuality\";\nSubscribedQuality.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"quality\",\n            kind: \"enum\",\n            T: proto3.getEnumType(VideoQuality)\n        },\n        {\n            no: 2,\n            name: \"enabled\",\n            kind: \"scalar\",\n            T: 8 /* ScalarType.BOOL */ \n        }\n    ]);\n/**\n * @generated from message livekit.SubscribedCodec\n */ class SubscribedCodec extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: string codec = 1;\n     */ this.codec = \"\";\n        /**\n     * @generated from field: repeated livekit.SubscribedQuality qualities = 2;\n     */ this.qualities = [];\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new SubscribedCodec().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new SubscribedCodec().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new SubscribedCodec().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(SubscribedCodec, a, b);\n    }\n}\nSubscribedCodec.runtime = proto3;\nSubscribedCodec.typeName = \"livekit.SubscribedCodec\";\nSubscribedCodec.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"codec\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 2,\n            name: \"qualities\",\n            kind: \"message\",\n            T: SubscribedQuality,\n            repeated: true\n        }\n    ]);\n/**\n * @generated from message livekit.SubscribedQualityUpdate\n */ class SubscribedQualityUpdate extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: string track_sid = 1;\n     */ this.trackSid = \"\";\n        /**\n     * @generated from field: repeated livekit.SubscribedQuality subscribed_qualities = 2;\n     */ this.subscribedQualities = [];\n        /**\n     * @generated from field: repeated livekit.SubscribedCodec subscribed_codecs = 3;\n     */ this.subscribedCodecs = [];\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new SubscribedQualityUpdate().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new SubscribedQualityUpdate().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new SubscribedQualityUpdate().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(SubscribedQualityUpdate, a, b);\n    }\n}\nSubscribedQualityUpdate.runtime = proto3;\nSubscribedQualityUpdate.typeName = \"livekit.SubscribedQualityUpdate\";\nSubscribedQualityUpdate.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"track_sid\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 2,\n            name: \"subscribed_qualities\",\n            kind: \"message\",\n            T: SubscribedQuality,\n            repeated: true\n        },\n        {\n            no: 3,\n            name: \"subscribed_codecs\",\n            kind: \"message\",\n            T: SubscribedCodec,\n            repeated: true\n        }\n    ]);\n/**\n * @generated from message livekit.TrackPermission\n */ class TrackPermission extends Message {\n    constructor(data){\n        super();\n        /**\n     * permission could be granted either by participant sid or identity\n     *\n     * @generated from field: string participant_sid = 1;\n     */ this.participantSid = \"\";\n        /**\n     * @generated from field: bool all_tracks = 2;\n     */ this.allTracks = false;\n        /**\n     * @generated from field: repeated string track_sids = 3;\n     */ this.trackSids = [];\n        /**\n     * @generated from field: string participant_identity = 4;\n     */ this.participantIdentity = \"\";\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new TrackPermission().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new TrackPermission().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new TrackPermission().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(TrackPermission, a, b);\n    }\n}\nTrackPermission.runtime = proto3;\nTrackPermission.typeName = \"livekit.TrackPermission\";\nTrackPermission.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"participant_sid\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 2,\n            name: \"all_tracks\",\n            kind: \"scalar\",\n            T: 8 /* ScalarType.BOOL */ \n        },\n        {\n            no: 3,\n            name: \"track_sids\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ ,\n            repeated: true\n        },\n        {\n            no: 4,\n            name: \"participant_identity\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        }\n    ]);\n/**\n * @generated from message livekit.SubscriptionPermission\n */ class SubscriptionPermission extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: bool all_participants = 1;\n     */ this.allParticipants = false;\n        /**\n     * @generated from field: repeated livekit.TrackPermission track_permissions = 2;\n     */ this.trackPermissions = [];\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new SubscriptionPermission().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new SubscriptionPermission().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new SubscriptionPermission().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(SubscriptionPermission, a, b);\n    }\n}\nSubscriptionPermission.runtime = proto3;\nSubscriptionPermission.typeName = \"livekit.SubscriptionPermission\";\nSubscriptionPermission.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"all_participants\",\n            kind: \"scalar\",\n            T: 8 /* ScalarType.BOOL */ \n        },\n        {\n            no: 2,\n            name: \"track_permissions\",\n            kind: \"message\",\n            T: TrackPermission,\n            repeated: true\n        }\n    ]);\n/**\n * @generated from message livekit.SubscriptionPermissionUpdate\n */ class SubscriptionPermissionUpdate extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: string participant_sid = 1;\n     */ this.participantSid = \"\";\n        /**\n     * @generated from field: string track_sid = 2;\n     */ this.trackSid = \"\";\n        /**\n     * @generated from field: bool allowed = 3;\n     */ this.allowed = false;\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new SubscriptionPermissionUpdate().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new SubscriptionPermissionUpdate().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new SubscriptionPermissionUpdate().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(SubscriptionPermissionUpdate, a, b);\n    }\n}\nSubscriptionPermissionUpdate.runtime = proto3;\nSubscriptionPermissionUpdate.typeName = \"livekit.SubscriptionPermissionUpdate\";\nSubscriptionPermissionUpdate.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"participant_sid\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 2,\n            name: \"track_sid\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 3,\n            name: \"allowed\",\n            kind: \"scalar\",\n            T: 8 /* ScalarType.BOOL */ \n        }\n    ]);\n/**\n * @generated from message livekit.SyncState\n */ class SyncState extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: repeated livekit.TrackPublishedResponse publish_tracks = 3;\n     */ this.publishTracks = [];\n        /**\n     * @generated from field: repeated livekit.DataChannelInfo data_channels = 4;\n     */ this.dataChannels = [];\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new SyncState().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new SyncState().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new SyncState().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(SyncState, a, b);\n    }\n}\nSyncState.runtime = proto3;\nSyncState.typeName = \"livekit.SyncState\";\nSyncState.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"answer\",\n            kind: \"message\",\n            T: SessionDescription\n        },\n        {\n            no: 2,\n            name: \"subscription\",\n            kind: \"message\",\n            T: UpdateSubscription\n        },\n        {\n            no: 3,\n            name: \"publish_tracks\",\n            kind: \"message\",\n            T: TrackPublishedResponse,\n            repeated: true\n        },\n        {\n            no: 4,\n            name: \"data_channels\",\n            kind: \"message\",\n            T: DataChannelInfo,\n            repeated: true\n        },\n        {\n            no: 5,\n            name: \"offer\",\n            kind: \"message\",\n            T: SessionDescription\n        }\n    ]);\n/**\n * @generated from message livekit.DataChannelInfo\n */ class DataChannelInfo extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: string label = 1;\n     */ this.label = \"\";\n        /**\n     * @generated from field: uint32 id = 2;\n     */ this.id = 0;\n        /**\n     * @generated from field: livekit.SignalTarget target = 3;\n     */ this.target = SignalTarget.PUBLISHER;\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new DataChannelInfo().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new DataChannelInfo().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new DataChannelInfo().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(DataChannelInfo, a, b);\n    }\n}\nDataChannelInfo.runtime = proto3;\nDataChannelInfo.typeName = \"livekit.DataChannelInfo\";\nDataChannelInfo.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"label\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 2,\n            name: \"id\",\n            kind: \"scalar\",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 3,\n            name: \"target\",\n            kind: \"enum\",\n            T: proto3.getEnumType(SignalTarget)\n        }\n    ]);\n/**\n * @generated from message livekit.SimulateScenario\n */ class SimulateScenario extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from oneof livekit.SimulateScenario.scenario\n     */ this.scenario = {\n            case: undefined\n        };\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new SimulateScenario().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new SimulateScenario().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new SimulateScenario().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(SimulateScenario, a, b);\n    }\n}\nSimulateScenario.runtime = proto3;\nSimulateScenario.typeName = \"livekit.SimulateScenario\";\nSimulateScenario.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"speaker_update\",\n            kind: \"scalar\",\n            T: 5 /* ScalarType.INT32 */ ,\n            oneof: \"scenario\"\n        },\n        {\n            no: 2,\n            name: \"node_failure\",\n            kind: \"scalar\",\n            T: 8 /* ScalarType.BOOL */ ,\n            oneof: \"scenario\"\n        },\n        {\n            no: 3,\n            name: \"migration\",\n            kind: \"scalar\",\n            T: 8 /* ScalarType.BOOL */ ,\n            oneof: \"scenario\"\n        },\n        {\n            no: 4,\n            name: \"server_leave\",\n            kind: \"scalar\",\n            T: 8 /* ScalarType.BOOL */ ,\n            oneof: \"scenario\"\n        },\n        {\n            no: 5,\n            name: \"switch_candidate_protocol\",\n            kind: \"enum\",\n            T: proto3.getEnumType(CandidateProtocol),\n            oneof: \"scenario\"\n        },\n        {\n            no: 6,\n            name: \"subscriber_bandwidth\",\n            kind: \"scalar\",\n            T: 3 /* ScalarType.INT64 */ ,\n            oneof: \"scenario\"\n        },\n        {\n            no: 7,\n            name: \"disconnect_signal_on_resume\",\n            kind: \"scalar\",\n            T: 8 /* ScalarType.BOOL */ ,\n            oneof: \"scenario\"\n        },\n        {\n            no: 8,\n            name: \"disconnect_signal_on_resume_no_messages\",\n            kind: \"scalar\",\n            T: 8 /* ScalarType.BOOL */ ,\n            oneof: \"scenario\"\n        }\n    ]);\n/**\n * @generated from message livekit.Ping\n */ class Ping extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: int64 timestamp = 1;\n     */ this.timestamp = protoInt64.zero;\n        /**\n     * rtt in milliseconds calculated by client\n     *\n     * @generated from field: int64 rtt = 2;\n     */ this.rtt = protoInt64.zero;\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new Ping().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new Ping().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new Ping().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(Ping, a, b);\n    }\n}\nPing.runtime = proto3;\nPing.typeName = \"livekit.Ping\";\nPing.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"timestamp\",\n            kind: \"scalar\",\n            T: 3 /* ScalarType.INT64 */ \n        },\n        {\n            no: 2,\n            name: \"rtt\",\n            kind: \"scalar\",\n            T: 3 /* ScalarType.INT64 */ \n        }\n    ]);\n/**\n * @generated from message livekit.Pong\n */ class Pong extends Message {\n    constructor(data){\n        super();\n        /**\n     * timestamp field of last received ping request\n     *\n     * @generated from field: int64 last_ping_timestamp = 1;\n     */ this.lastPingTimestamp = protoInt64.zero;\n        /**\n     * @generated from field: int64 timestamp = 2;\n     */ this.timestamp = protoInt64.zero;\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new Pong().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new Pong().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new Pong().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(Pong, a, b);\n    }\n}\nPong.runtime = proto3;\nPong.typeName = \"livekit.Pong\";\nPong.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"last_ping_timestamp\",\n            kind: \"scalar\",\n            T: 3 /* ScalarType.INT64 */ \n        },\n        {\n            no: 2,\n            name: \"timestamp\",\n            kind: \"scalar\",\n            T: 3 /* ScalarType.INT64 */ \n        }\n    ]);\n/**\n * @generated from message livekit.RegionSettings\n */ class RegionSettings extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: repeated livekit.RegionInfo regions = 1;\n     */ this.regions = [];\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new RegionSettings().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new RegionSettings().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new RegionSettings().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(RegionSettings, a, b);\n    }\n}\nRegionSettings.runtime = proto3;\nRegionSettings.typeName = \"livekit.RegionSettings\";\nRegionSettings.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"regions\",\n            kind: \"message\",\n            T: RegionInfo,\n            repeated: true\n        }\n    ]);\n/**\n * @generated from message livekit.RegionInfo\n */ class RegionInfo extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: string region = 1;\n     */ this.region = \"\";\n        /**\n     * @generated from field: string url = 2;\n     */ this.url = \"\";\n        /**\n     * @generated from field: int64 distance = 3;\n     */ this.distance = protoInt64.zero;\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new RegionInfo().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new RegionInfo().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new RegionInfo().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(RegionInfo, a, b);\n    }\n}\nRegionInfo.runtime = proto3;\nRegionInfo.typeName = \"livekit.RegionInfo\";\nRegionInfo.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"region\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 2,\n            name: \"url\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 3,\n            name: \"distance\",\n            kind: \"scalar\",\n            T: 3 /* ScalarType.INT64 */ \n        }\n    ]);\n/**\n * @generated from message livekit.SubscriptionResponse\n */ class SubscriptionResponse extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: string track_sid = 1;\n     */ this.trackSid = \"\";\n        /**\n     * @generated from field: livekit.SubscriptionError err = 2;\n     */ this.err = SubscriptionError.SE_UNKNOWN;\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new SubscriptionResponse().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new SubscriptionResponse().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new SubscriptionResponse().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(SubscriptionResponse, a, b);\n    }\n}\nSubscriptionResponse.runtime = proto3;\nSubscriptionResponse.typeName = \"livekit.SubscriptionResponse\";\nSubscriptionResponse.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"track_sid\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 2,\n            name: \"err\",\n            kind: \"enum\",\n            T: proto3.getEnumType(SubscriptionError)\n        }\n    ]);\nfunction cloneDeep(value) {\n    if (typeof value === 'undefined') {\n        return;\n    }\n    if (typeof structuredClone === 'function') {\n        return structuredClone(value);\n    } else {\n        return JSON.parse(JSON.stringify(value));\n    }\n}\nconst BACKGROUND_REACTION_DELAY = 5000;\n// keep old audio elements when detached, we would re-use them since on iOS\n// Safari tracks which audio elements have been \"blessed\" by the user.\nconst recycledElements = [];\nclass Track extends eventsExports.EventEmitter {\n    constructor(mediaTrack, kind){\n        let loggerOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        var _a;\n        super();\n        this.attachedElements = [];\n        this.isMuted = false;\n        /**\n     * indicates current state of stream, it'll indicate `paused` if the track\n     * has been paused by congestion controller\n     */ this.streamState = Track.StreamState.Active;\n        this.isInBackground = false;\n        this._currentBitrate = 0;\n        this.log = livekitLogger;\n        this.appVisibilityChangedListener = ()=>{\n            if (this.backgroundTimeout) {\n                clearTimeout(this.backgroundTimeout);\n            }\n            // delay app visibility update if it goes to hidden\n            // update immediately if it comes back to focus\n            if (document.visibilityState === 'hidden') {\n                this.backgroundTimeout = setTimeout(()=>this.handleAppVisibilityChanged(), BACKGROUND_REACTION_DELAY);\n            } else {\n                this.handleAppVisibilityChanged();\n            }\n        };\n        this.log = getLogger((_a = loggerOptions.loggerName) !== null && _a !== void 0 ? _a : LoggerNames.Track);\n        this.loggerContextCb = loggerOptions.loggerContextCb;\n        this.setMaxListeners(100);\n        this.kind = kind;\n        this._mediaStreamTrack = mediaTrack;\n        this._mediaStreamID = mediaTrack.id;\n        this.source = Track.Source.Unknown;\n    }\n    get logContext() {\n        var _a;\n        return Object.assign(Object.assign({}, (_a = this.loggerContextCb) === null || _a === void 0 ? void 0 : _a.call(this)), getLogContextFromTrack(this));\n    }\n    /** current receive bits per second */ get currentBitrate() {\n        return this._currentBitrate;\n    }\n    get mediaStreamTrack() {\n        return this._mediaStreamTrack;\n    }\n    /**\n   * @internal\n   * used for keep mediaStream's first id, since it's id might change\n   * if we disable/enable a track\n   */ get mediaStreamID() {\n        return this._mediaStreamID;\n    }\n    attach(element) {\n        let elementType = 'audio';\n        if (this.kind === Track.Kind.Video) {\n            elementType = 'video';\n        }\n        if (this.attachedElements.length === 0 && Track.Kind.Video) {\n            this.addAppVisibilityListener();\n        }\n        if (!element) {\n            if (elementType === 'audio') {\n                recycledElements.forEach((e)=>{\n                    if (e.parentElement === null && !element) {\n                        element = e;\n                    }\n                });\n                if (element) {\n                    // remove it from pool\n                    recycledElements.splice(recycledElements.indexOf(element), 1);\n                }\n            }\n            if (!element) {\n                element = document.createElement(elementType);\n            }\n        }\n        if (!this.attachedElements.includes(element)) {\n            this.attachedElements.push(element);\n        }\n        // even if we believe it's already attached to the element, it's possible\n        // the element's srcObject was set to something else out of band.\n        // we'll want to re-attach it in that case\n        attachToElement(this.mediaStreamTrack, element);\n        // handle auto playback failures\n        const allMediaStreamTracks = element.srcObject.getTracks();\n        const hasAudio = allMediaStreamTracks.some((tr)=>tr.kind === 'audio');\n        // manually play media to detect auto playback status\n        element.play().then(()=>{\n            this.emit(hasAudio ? TrackEvent.AudioPlaybackStarted : TrackEvent.VideoPlaybackStarted);\n        }).catch((e)=>{\n            if (e.name === 'NotAllowedError') {\n                this.emit(hasAudio ? TrackEvent.AudioPlaybackFailed : TrackEvent.VideoPlaybackFailed, e);\n            } else if (e.name === 'AbortError') {\n                // commonly triggered by another `play` request, only log for debugging purposes\n                livekitLogger.debug(\"\".concat(hasAudio ? 'audio' : 'video', \" playback aborted, likely due to new play request\"));\n            } else {\n                livekitLogger.warn(\"could not playback \".concat(hasAudio ? 'audio' : 'video'), e);\n            }\n            // If audio playback isn't allowed make sure we still play back the video\n            if (hasAudio && element && allMediaStreamTracks.some((tr)=>tr.kind === 'video') && e.name === 'NotAllowedError') {\n                element.muted = true;\n                element.play().catch(()=>{\n                // catch for Safari, exceeded options at this point to automatically play the media element\n                });\n            }\n        });\n        this.emit(TrackEvent.ElementAttached, element);\n        return element;\n    }\n    detach(element) {\n        try {\n            // detach from a single element\n            if (element) {\n                detachTrack(this.mediaStreamTrack, element);\n                const idx = this.attachedElements.indexOf(element);\n                if (idx >= 0) {\n                    this.attachedElements.splice(idx, 1);\n                    this.recycleElement(element);\n                    this.emit(TrackEvent.ElementDetached, element);\n                }\n                return element;\n            }\n            const detached = [];\n            this.attachedElements.forEach((elm)=>{\n                detachTrack(this.mediaStreamTrack, elm);\n                detached.push(elm);\n                this.recycleElement(elm);\n                this.emit(TrackEvent.ElementDetached, elm);\n            });\n            // remove all tracks\n            this.attachedElements = [];\n            return detached;\n        } finally{\n            if (this.attachedElements.length === 0) {\n                this.removeAppVisibilityListener();\n            }\n        }\n    }\n    stop() {\n        this.stopMonitor();\n        this._mediaStreamTrack.stop();\n    }\n    enable() {\n        this._mediaStreamTrack.enabled = true;\n    }\n    disable() {\n        this._mediaStreamTrack.enabled = false;\n    }\n    /* @internal */ stopMonitor() {\n        if (this.monitorInterval) {\n            clearInterval(this.monitorInterval);\n        }\n    }\n    /** @internal */ updateLoggerOptions(loggerOptions) {\n        if (loggerOptions.loggerName) {\n            this.log = getLogger(loggerOptions.loggerName);\n        }\n        if (loggerOptions.loggerContextCb) {\n            this.loggerContextCb = loggerOptions.loggerContextCb;\n        }\n    }\n    recycleElement(element) {\n        if (element instanceof HTMLAudioElement) {\n            // we only need to re-use a single element\n            let shouldCache = true;\n            element.pause();\n            recycledElements.forEach((e)=>{\n                if (!e.parentElement) {\n                    shouldCache = false;\n                }\n            });\n            if (shouldCache) {\n                recycledElements.push(element);\n            }\n        }\n    }\n    handleAppVisibilityChanged() {\n        return __awaiter(this, void 0, void 0, function*() {\n            this.isInBackground = document.visibilityState === 'hidden';\n        });\n    }\n    addAppVisibilityListener() {\n        if (isWeb()) {\n            this.isInBackground = document.visibilityState === 'hidden';\n            document.addEventListener('visibilitychange', this.appVisibilityChangedListener);\n        } else {\n            this.isInBackground = false;\n        }\n    }\n    removeAppVisibilityListener() {\n        if (isWeb()) {\n            document.removeEventListener('visibilitychange', this.appVisibilityChangedListener);\n        }\n    }\n}\nfunction attachToElement(track, element) {\n    let mediaStream;\n    if (element.srcObject instanceof MediaStream) {\n        mediaStream = element.srcObject;\n    } else {\n        mediaStream = new MediaStream();\n    }\n    // check if track matches existing track\n    let existingTracks;\n    if (track.kind === 'audio') {\n        existingTracks = mediaStream.getAudioTracks();\n    } else {\n        existingTracks = mediaStream.getVideoTracks();\n    }\n    if (!existingTracks.includes(track)) {\n        existingTracks.forEach((et)=>{\n            mediaStream.removeTrack(et);\n        });\n        mediaStream.addTrack(track);\n    }\n    if (!isSafari() || !(element instanceof HTMLVideoElement)) {\n        // when in low power mode (applies to both macOS and iOS), Safari will show a play/pause overlay\n        // when a video starts that has the `autoplay` attribute is set.\n        // we work around this by _not_ setting the autoplay attribute on safari and instead call `setTimeout(() => el.play(),0)` further down\n        element.autoplay = true;\n    }\n    // In case there are no audio tracks present on the mediastream, we set the element as muted to ensure autoplay works\n    element.muted = mediaStream.getAudioTracks().length === 0;\n    if (element instanceof HTMLVideoElement) {\n        element.playsInline = true;\n    }\n    // avoid flicker\n    if (element.srcObject !== mediaStream) {\n        element.srcObject = mediaStream;\n        if ((isSafari() || isFireFox()) && element instanceof HTMLVideoElement) {\n            // Firefox also has a timing issue where video doesn't actually get attached unless\n            // performed out-of-band\n            // Safari 15 has a bug where in certain layouts, video element renders\n            // black until the page is resized or other changes take place.\n            // Resetting the src triggers it to render.\n            // https://developer.apple.com/forums/thread/690523\n            setTimeout(()=>{\n                element.srcObject = mediaStream;\n                // Safari 15 sometimes fails to start a video\n                // when the window is backgrounded before the first frame is drawn\n                // manually calling play here seems to fix that\n                element.play().catch(()=>{\n                /** do nothing */ });\n            }, 0);\n        }\n    }\n}\n/** @internal */ function detachTrack(track, element) {\n    if (element.srcObject instanceof MediaStream) {\n        const mediaStream = element.srcObject;\n        mediaStream.removeTrack(track);\n        if (mediaStream.getTracks().length > 0) {\n            element.srcObject = mediaStream;\n        } else {\n            element.srcObject = null;\n        }\n    }\n}\n(function(Track) {\n    let Kind;\n    (function(Kind) {\n        Kind[\"Audio\"] = \"audio\";\n        Kind[\"Video\"] = \"video\";\n        Kind[\"Unknown\"] = \"unknown\";\n    })(Kind = Track.Kind || (Track.Kind = {}));\n    let Source;\n    (function(Source) {\n        Source[\"Camera\"] = \"camera\";\n        Source[\"Microphone\"] = \"microphone\";\n        Source[\"ScreenShare\"] = \"screen_share\";\n        Source[\"ScreenShareAudio\"] = \"screen_share_audio\";\n        Source[\"Unknown\"] = \"unknown\";\n    })(Source = Track.Source || (Track.Source = {}));\n    let StreamState$1;\n    (function(StreamState) {\n        StreamState[\"Active\"] = \"active\";\n        StreamState[\"Paused\"] = \"paused\";\n        StreamState[\"Unknown\"] = \"unknown\";\n    })(StreamState$1 = Track.StreamState || (Track.StreamState = {}));\n    /** @internal */ function kindToProto(k) {\n        switch(k){\n            case Kind.Audio:\n                return TrackType.AUDIO;\n            case Kind.Video:\n                return TrackType.VIDEO;\n            default:\n                // FIXME this was UNRECOGNIZED before\n                return TrackType.DATA;\n        }\n    }\n    Track.kindToProto = kindToProto;\n    /** @internal */ function kindFromProto(t) {\n        switch(t){\n            case TrackType.AUDIO:\n                return Kind.Audio;\n            case TrackType.VIDEO:\n                return Kind.Video;\n            default:\n                return Kind.Unknown;\n        }\n    }\n    Track.kindFromProto = kindFromProto;\n    /** @internal */ function sourceToProto(s) {\n        switch(s){\n            case Source.Camera:\n                return TrackSource.CAMERA;\n            case Source.Microphone:\n                return TrackSource.MICROPHONE;\n            case Source.ScreenShare:\n                return TrackSource.SCREEN_SHARE;\n            case Source.ScreenShareAudio:\n                return TrackSource.SCREEN_SHARE_AUDIO;\n            default:\n                return TrackSource.UNKNOWN;\n        }\n    }\n    Track.sourceToProto = sourceToProto;\n    /** @internal */ function sourceFromProto(s) {\n        switch(s){\n            case TrackSource.CAMERA:\n                return Source.Camera;\n            case TrackSource.MICROPHONE:\n                return Source.Microphone;\n            case TrackSource.SCREEN_SHARE:\n                return Source.ScreenShare;\n            case TrackSource.SCREEN_SHARE_AUDIO:\n                return Source.ScreenShareAudio;\n            default:\n                return Source.Unknown;\n        }\n    }\n    Track.sourceFromProto = sourceFromProto;\n    /** @internal */ function streamStateFromProto(s) {\n        switch(s){\n            case StreamState.ACTIVE:\n                return StreamState$1.Active;\n            case StreamState.PAUSED:\n                return StreamState$1.Paused;\n            default:\n                return StreamState$1.Unknown;\n        }\n    }\n    Track.streamStateFromProto = streamStateFromProto;\n})(Track || (Track = {}));\nfunction mergeDefaultOptions(options, audioDefaults, videoDefaults) {\n    var _a;\n    const opts = (_a = cloneDeep(options)) !== null && _a !== void 0 ? _a : {};\n    if (opts.audio === true) opts.audio = {};\n    if (opts.video === true) opts.video = {};\n    // use defaults\n    if (opts.audio) {\n        mergeObjectWithoutOverwriting(opts.audio, audioDefaults);\n    }\n    if (opts.video) {\n        mergeObjectWithoutOverwriting(opts.video, videoDefaults);\n    }\n    return opts;\n}\nfunction mergeObjectWithoutOverwriting(mainObject, objectToMerge) {\n    Object.keys(objectToMerge).forEach((key)=>{\n        if (mainObject[key] === undefined) mainObject[key] = objectToMerge[key];\n    });\n    return mainObject;\n}\nfunction constraintsForOptions(options) {\n    const constraints = {};\n    if (options.video) {\n        // default video options\n        if (typeof options.video === 'object') {\n            const videoOptions = {};\n            const target = videoOptions;\n            const source = options.video;\n            Object.keys(source).forEach((key)=>{\n                switch(key){\n                    case 'resolution':\n                        // flatten VideoResolution fields\n                        mergeObjectWithoutOverwriting(target, source.resolution);\n                        break;\n                    default:\n                        target[key] = source[key];\n                }\n            });\n            constraints.video = videoOptions;\n        } else {\n            constraints.video = options.video;\n        }\n    } else {\n        constraints.video = false;\n    }\n    if (options.audio) {\n        if (typeof options.audio === 'object') {\n            constraints.audio = options.audio;\n        } else {\n            constraints.audio = true;\n        }\n    } else {\n        constraints.audio = false;\n    }\n    return constraints;\n}\n/**\n * This function detects silence on a given [[Track]] instance.\n * Returns true if the track seems to be entirely silent.\n */ function detectSilence(track) {\n    let timeOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 200;\n    return __awaiter(this, void 0, void 0, function*() {\n        const ctx = getNewAudioContext();\n        if (ctx) {\n            const analyser = ctx.createAnalyser();\n            analyser.fftSize = 2048;\n            const bufferLength = analyser.frequencyBinCount;\n            const dataArray = new Uint8Array(bufferLength);\n            const source = ctx.createMediaStreamSource(new MediaStream([\n                track.mediaStreamTrack\n            ]));\n            source.connect(analyser);\n            yield sleep(timeOffset);\n            analyser.getByteTimeDomainData(dataArray);\n            const someNoise = dataArray.some((sample)=>sample !== 128 && sample !== 0);\n            ctx.close();\n            return !someNoise;\n        }\n        return false;\n    });\n}\n/**\n * @internal\n */ function getNewAudioContext() {\n    const AudioContext1 = // @ts-ignore\n     false && (0);\n    if (AudioContext1) {\n        return new AudioContext1({\n            latencyHint: 'interactive'\n        });\n    }\n}\n/**\n * @internal\n */ function sourceToKind(source) {\n    if (source === Track.Source.Microphone) {\n        return 'audioinput';\n    } else if (source === Track.Source.Camera) {\n        return 'videoinput';\n    } else {\n        return undefined;\n    }\n}\n/**\n * @internal\n */ function screenCaptureToDisplayMediaStreamOptions(options) {\n    var _a, _b;\n    let videoConstraints = (_a = options.video) !== null && _a !== void 0 ? _a : true;\n    // treat 0 as uncapped\n    if (options.resolution && options.resolution.width > 0 && options.resolution.height > 0) {\n        videoConstraints = typeof videoConstraints === 'boolean' ? {} : videoConstraints;\n        if (isSafari()) {\n            videoConstraints = Object.assign(Object.assign({}, videoConstraints), {\n                width: {\n                    max: options.resolution.width\n                },\n                height: {\n                    max: options.resolution.height\n                },\n                frameRate: options.resolution.frameRate\n            });\n        } else {\n            videoConstraints = Object.assign(Object.assign({}, videoConstraints), {\n                width: {\n                    ideal: options.resolution.width\n                },\n                height: {\n                    ideal: options.resolution.height\n                },\n                frameRate: options.resolution.frameRate\n            });\n        }\n    }\n    return {\n        audio: (_b = options.audio) !== null && _b !== void 0 ? _b : false,\n        video: videoConstraints,\n        // @ts-expect-error support for experimental display media features\n        controller: options.controller,\n        selfBrowserSurface: options.selfBrowserSurface,\n        surfaceSwitching: options.surfaceSwitching,\n        systemAudio: options.systemAudio\n    };\n}\nfunction mimeTypeToVideoCodecString(mimeType) {\n    const codec = mimeType.split('/')[1].toLowerCase();\n    if (!videoCodecs.includes(codec)) {\n        throw Error(\"Video codec not supported: \".concat(codec));\n    }\n    return codec;\n}\nfunction getTrackPublicationInfo(tracks) {\n    const infos = [];\n    tracks.forEach((track)=>{\n        if (track.track !== undefined) {\n            infos.push(new TrackPublishedResponse({\n                cid: track.track.mediaStreamID,\n                track: track.trackInfo\n            }));\n        }\n    });\n    return infos;\n}\nfunction getLogContextFromTrack(track) {\n    if (track instanceof Track) {\n        return {\n            trackSid: track.sid,\n            trackSource: track.source,\n            trackMuted: track.isMuted,\n            trackEnabled: track.mediaStreamTrack.enabled,\n            trackKind: track.kind\n        };\n    } else {\n        return {\n            trackSid: track.trackSid,\n            trackName: track.trackName,\n            track: track.track ? getLogContextFromTrack(track.track) : undefined,\n            trackEnabled: track.isEnabled,\n            trackEncrypted: track.isEncrypted,\n            trackMimeType: track.mimeType\n        };\n    }\n}\nconst separator = '|';\nconst ddExtensionURI = 'https://aomediacodec.github.io/av1-rtp-spec/#dependency-descriptor-rtp-header-extension';\nfunction unpackStreamId(packed) {\n    const parts = packed.split(separator);\n    if (parts.length > 1) {\n        return [\n            parts[0],\n            packed.substr(parts[0].length + 1)\n        ];\n    }\n    return [\n        packed,\n        ''\n    ];\n}\nfunction sleep(duration) {\n    return __awaiter(this, void 0, void 0, function*() {\n        return new Promise((resolve)=>CriticalTimers.setTimeout(resolve, duration));\n    });\n}\n/** @internal */ function supportsTransceiver() {\n    return 'addTransceiver' in RTCPeerConnection.prototype;\n}\n/** @internal */ function supportsAddTrack() {\n    return 'addTrack' in RTCPeerConnection.prototype;\n}\nfunction supportsAdaptiveStream() {\n    return typeof ResizeObserver !== undefined && typeof IntersectionObserver !== undefined;\n}\nfunction supportsDynacast() {\n    return supportsTransceiver();\n}\nfunction supportsAV1() {\n    if (!('getCapabilities' in RTCRtpSender)) {\n        return false;\n    }\n    if (isSafari()) {\n        // Safari 17 on iPhone14 reports AV1 capability, but does not actually support it\n        return false;\n    }\n    const capabilities = RTCRtpSender.getCapabilities('video');\n    let hasAV1 = false;\n    if (capabilities) {\n        for (const codec of capabilities.codecs){\n            if (codec.mimeType === 'video/AV1') {\n                hasAV1 = true;\n                break;\n            }\n        }\n    }\n    return hasAV1;\n}\nfunction supportsVP9() {\n    if (!('getCapabilities' in RTCRtpSender)) {\n        return false;\n    }\n    if (isFireFox()) {\n        // technically speaking FireFox supports VP9, but SVC publishing is broken\n        // https://bugzilla.mozilla.org/show_bug.cgi?id=1633876\n        return false;\n    }\n    if (isSafari()) {\n        const browser = getBrowser();\n        if ((browser === null || browser === void 0 ? void 0 : browser.version) && compareVersions(browser.version, '16') < 0) {\n            // Safari 16 and below does not support VP9\n            return false;\n        }\n    }\n    const capabilities = RTCRtpSender.getCapabilities('video');\n    let hasVP9 = false;\n    if (capabilities) {\n        for (const codec of capabilities.codecs){\n            if (codec.mimeType === 'video/VP9') {\n                hasVP9 = true;\n                break;\n            }\n        }\n    }\n    return hasVP9;\n}\nfunction isSVCCodec(codec) {\n    return codec === 'av1' || codec === 'vp9';\n}\nfunction supportsSetSinkId(elm) {\n    if (!document) {\n        return false;\n    }\n    if (!elm) {\n        elm = document.createElement('audio');\n    }\n    return 'setSinkId' in elm;\n}\nconst setCodecPreferencesVersions = {\n    Chrome: '100',\n    Safari: '15',\n    Firefox: '100'\n};\nfunction supportsSetCodecPreferences(transceiver) {\n    if (!isWeb()) {\n        return false;\n    }\n    if (!('setCodecPreferences' in transceiver)) {\n        return false;\n    }\n    const browser = getBrowser();\n    if (!(browser === null || browser === void 0 ? void 0 : browser.name) || !browser.version) {\n        // version is required\n        return false;\n    }\n    const v = setCodecPreferencesVersions[browser.name];\n    if (v) {\n        return compareVersions(browser.version, v) >= 0;\n    }\n    return false;\n}\nfunction isBrowserSupported() {\n    return supportsTransceiver() || supportsAddTrack();\n}\nfunction isFireFox() {\n    var _a;\n    return ((_a = getBrowser()) === null || _a === void 0 ? void 0 : _a.name) === 'Firefox';\n}\nfunction isChromiumBased() {\n    var _a;\n    return ((_a = getBrowser()) === null || _a === void 0 ? void 0 : _a.name) === 'Chrome';\n}\nfunction isSafari() {\n    var _a;\n    return ((_a = getBrowser()) === null || _a === void 0 ? void 0 : _a.name) === 'Safari';\n}\nfunction isSafari17() {\n    const b = getBrowser();\n    return (b === null || b === void 0 ? void 0 : b.name) === 'Safari' && b.version.startsWith('17.');\n}\nfunction isMobile() {\n    if (!isWeb()) return false;\n    return /Tablet|iPad|Mobile|Android|BlackBerry/.test(navigator.userAgent);\n}\nfunction isWeb() {\n    return typeof document !== 'undefined';\n}\nfunction isReactNative() {\n    // navigator.product is deprecated on browsers, but will be set appropriately for react-native.\n    return navigator.product == 'ReactNative';\n}\nfunction isCloud(serverUrl) {\n    return serverUrl.hostname.endsWith('.livekit.cloud') || serverUrl.hostname.endsWith('.livekit.run');\n}\nfunction getLKReactNativeInfo() {\n    // global defined only for ReactNative.\n    // @ts-ignore\n    if (global && global.LiveKitReactNativeGlobal) {\n        // @ts-ignore\n        return global.LiveKitReactNativeGlobal;\n    }\n    return undefined;\n}\nfunction getReactNativeOs() {\n    if (!isReactNative()) {\n        return undefined;\n    }\n    let info = getLKReactNativeInfo();\n    if (info) {\n        return info.platform;\n    }\n    return undefined;\n}\nfunction getDevicePixelRatio() {\n    if (isWeb()) {\n        return window.devicePixelRatio;\n    }\n    if (isReactNative()) {\n        let info = getLKReactNativeInfo();\n        if (info) {\n            return info.devicePixelRatio;\n        }\n    }\n    return 1;\n}\nfunction compareVersions(v1, v2) {\n    const parts1 = v1.split('.');\n    const parts2 = v2.split('.');\n    const k = Math.min(parts1.length, parts2.length);\n    for(let i = 0; i < k; ++i){\n        const p1 = parseInt(parts1[i], 10);\n        const p2 = parseInt(parts2[i], 10);\n        if (p1 > p2) return 1;\n        if (p1 < p2) return -1;\n        if (i === k - 1 && p1 === p2) return 0;\n    }\n    if (v1 === '' && v2 !== '') {\n        return -1;\n    } else if (v2 === '') {\n        return 1;\n    }\n    return parts1.length == parts2.length ? 0 : parts1.length < parts2.length ? -1 : 1;\n}\nfunction roDispatchCallback(entries) {\n    for (const entry of entries){\n        entry.target.handleResize(entry);\n    }\n}\nfunction ioDispatchCallback(entries) {\n    for (const entry of entries){\n        entry.target.handleVisibilityChanged(entry);\n    }\n}\nlet resizeObserver = null;\nconst getResizeObserver = ()=>{\n    if (!resizeObserver) resizeObserver = new ResizeObserver(roDispatchCallback);\n    return resizeObserver;\n};\nlet intersectionObserver = null;\nconst getIntersectionObserver = ()=>{\n    if (!intersectionObserver) {\n        intersectionObserver = new IntersectionObserver(ioDispatchCallback, {\n            root: null,\n            rootMargin: '0px'\n        });\n    }\n    return intersectionObserver;\n};\nfunction getClientInfo() {\n    var _a;\n    const info = new ClientInfo({\n        sdk: ClientInfo_SDK.JS,\n        protocol: protocolVersion,\n        version\n    });\n    if (isReactNative()) {\n        info.os = (_a = getReactNativeOs()) !== null && _a !== void 0 ? _a : '';\n    }\n    return info;\n}\nlet emptyVideoStreamTrack;\nfunction getEmptyVideoStreamTrack() {\n    if (!emptyVideoStreamTrack) {\n        emptyVideoStreamTrack = createDummyVideoStreamTrack();\n    }\n    return emptyVideoStreamTrack.clone();\n}\nfunction createDummyVideoStreamTrack() {\n    let width = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 16;\n    let height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 16;\n    let enabled = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    let paintContent = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    const canvas = document.createElement('canvas');\n    // the canvas size is set to 16 by default, because electron apps seem to fail with smaller values\n    canvas.width = width;\n    canvas.height = height;\n    const ctx = canvas.getContext('2d');\n    ctx === null || ctx === void 0 ? void 0 : ctx.fillRect(0, 0, canvas.width, canvas.height);\n    if (paintContent && ctx) {\n        ctx.beginPath();\n        ctx.arc(width / 2, height / 2, 50, 0, Math.PI * 2, true);\n        ctx.closePath();\n        ctx.fillStyle = 'grey';\n        ctx.fill();\n    }\n    // @ts-ignore\n    const dummyStream = canvas.captureStream();\n    const [dummyTrack] = dummyStream.getTracks();\n    if (!dummyTrack) {\n        throw Error('Could not get empty media stream video track');\n    }\n    dummyTrack.enabled = enabled;\n    return dummyTrack;\n}\nlet emptyAudioStreamTrack;\nfunction getEmptyAudioStreamTrack() {\n    if (!emptyAudioStreamTrack) {\n        // implementation adapted from https://blog.mozilla.org/webrtc/warm-up-with-replacetrack/\n        const ctx = new AudioContext();\n        const oscillator = ctx.createOscillator();\n        const gain = ctx.createGain();\n        gain.gain.setValueAtTime(0, 0);\n        const dst = ctx.createMediaStreamDestination();\n        oscillator.connect(gain);\n        gain.connect(dst);\n        oscillator.start();\n        [emptyAudioStreamTrack] = dst.stream.getAudioTracks();\n        if (!emptyAudioStreamTrack) {\n            throw Error('Could not get empty media stream audio track');\n        }\n        emptyAudioStreamTrack.enabled = false;\n    }\n    return emptyAudioStreamTrack.clone();\n}\nclass Future {\n    constructor(futureBase, onFinally){\n        this.onFinally = onFinally;\n        this.promise = new Promise((resolve, reject)=>__awaiter(this, void 0, void 0, function*() {\n                this.resolve = resolve;\n                this.reject = reject;\n                if (futureBase) {\n                    yield futureBase(resolve, reject);\n                }\n            })).finally(()=>{\n            var _a;\n            return (_a = this.onFinally) === null || _a === void 0 ? void 0 : _a.call(this);\n        });\n    }\n}\n/**\n * Creates and returns an analyser web audio node that is attached to the provided track.\n * Additionally returns a convenience method `calculateVolume` to perform instant volume readings on that track.\n * Call the returned `cleanup` function to close the audioContext that has been created for the instance of this helper\n */ function createAudioAnalyser(track, options) {\n    const opts = Object.assign({\n        cloneTrack: false,\n        fftSize: 2048,\n        smoothingTimeConstant: 0.8,\n        minDecibels: -100,\n        maxDecibels: -80\n    }, options);\n    const audioContext = getNewAudioContext();\n    if (!audioContext) {\n        throw new Error('Audio Context not supported on this browser');\n    }\n    const streamTrack = opts.cloneTrack ? track.mediaStreamTrack.clone() : track.mediaStreamTrack;\n    const mediaStreamSource = audioContext.createMediaStreamSource(new MediaStream([\n        streamTrack\n    ]));\n    const analyser = audioContext.createAnalyser();\n    analyser.minDecibels = opts.minDecibels;\n    analyser.maxDecibels = opts.maxDecibels;\n    analyser.fftSize = opts.fftSize;\n    analyser.smoothingTimeConstant = opts.smoothingTimeConstant;\n    mediaStreamSource.connect(analyser);\n    const dataArray = new Uint8Array(analyser.frequencyBinCount);\n    /**\n   * Calculates the current volume of the track in the range from 0 to 1\n   */ const calculateVolume = ()=>{\n        analyser.getByteFrequencyData(dataArray);\n        let sum = 0;\n        for (const amplitude of dataArray){\n            sum += Math.pow(amplitude / 255, 2);\n        }\n        const volume = Math.sqrt(sum / dataArray.length);\n        return volume;\n    };\n    const cleanup = ()=>__awaiter(this, void 0, void 0, function*() {\n            yield audioContext.close();\n            if (opts.cloneTrack) {\n                streamTrack.stop();\n            }\n        });\n    return {\n        calculateVolume,\n        analyser,\n        cleanup\n    };\n}\nclass Mutex {\n    constructor(){\n        this._locking = Promise.resolve();\n        this._locks = 0;\n    }\n    isLocked() {\n        return this._locks > 0;\n    }\n    lock() {\n        this._locks += 1;\n        let unlockNext;\n        const willLock = new Promise((resolve)=>unlockNext = ()=>{\n                this._locks -= 1;\n                resolve();\n            });\n        const willUnlock = this._locking.then(()=>unlockNext);\n        this._locking = this._locking.then(()=>willLock);\n        return willUnlock;\n    }\n}\nfunction isVideoCodec(maybeCodec) {\n    return videoCodecs.includes(maybeCodec);\n}\nfunction unwrapConstraint(constraint) {\n    if (typeof constraint === 'string') {\n        return constraint;\n    }\n    if (Array.isArray(constraint)) {\n        return constraint[0];\n    }\n    if (constraint.exact) {\n        if (Array.isArray(constraint.exact)) {\n            return constraint.exact[0];\n        }\n        return constraint.exact;\n    }\n    if (constraint.ideal) {\n        if (Array.isArray(constraint.ideal)) {\n            return constraint.ideal[0];\n        }\n        return constraint.ideal;\n    }\n    throw Error('could not unwrap constraint');\n}\nfunction toWebsocketUrl(url) {\n    if (url.startsWith('http')) {\n        return url.replace(/^(http)/, 'ws');\n    }\n    return url;\n}\nfunction toHttpUrl(url) {\n    if (url.startsWith('ws')) {\n        return url.replace(/^(ws)/, 'http');\n    }\n    return url;\n}\nconst defaultId = 'default';\nclass DeviceManager {\n    static getInstance() {\n        if (this.instance === undefined) {\n            this.instance = new DeviceManager();\n        }\n        return this.instance;\n    }\n    getDevices(kind) {\n        let requestPermissions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            if (((_a = DeviceManager.userMediaPromiseMap) === null || _a === void 0 ? void 0 : _a.size) > 0) {\n                livekitLogger.debug('awaiting getUserMedia promise');\n                try {\n                    if (kind) {\n                        yield DeviceManager.userMediaPromiseMap.get(kind);\n                    } else {\n                        yield Promise.all(DeviceManager.userMediaPromiseMap.values());\n                    }\n                } catch (e) {\n                    livekitLogger.warn('error waiting for media permissons');\n                }\n            }\n            let devices = yield navigator.mediaDevices.enumerateDevices();\n            if (requestPermissions && // for safari we need to skip this check, as otherwise it will re-acquire user media and fail on iOS https://bugs.webkit.org/show_bug.cgi?id=179363\n            !(isSafari() && this.hasDeviceInUse(kind))) {\n                const isDummyDeviceOrEmpty = devices.length === 0 || devices.some((device)=>{\n                    const noLabel = device.label === '';\n                    const isRelevant = kind ? device.kind === kind : true;\n                    return noLabel && isRelevant;\n                });\n                if (isDummyDeviceOrEmpty) {\n                    const permissionsToAcquire = {\n                        video: kind !== 'audioinput' && kind !== 'audiooutput',\n                        audio: kind !== 'videoinput'\n                    };\n                    const stream = yield navigator.mediaDevices.getUserMedia(permissionsToAcquire);\n                    devices = yield navigator.mediaDevices.enumerateDevices();\n                    stream.getTracks().forEach((track)=>{\n                        track.stop();\n                    });\n                }\n            }\n            if (kind) {\n                devices = devices.filter((device)=>device.kind === kind);\n            }\n            return devices;\n        });\n    }\n    normalizeDeviceId(kind, deviceId, groupId) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (deviceId !== defaultId) {\n                return deviceId;\n            }\n            // resolve actual device id if it's 'default': Chrome returns it when no\n            // device has been chosen\n            const devices = yield this.getDevices(kind);\n            const device = devices.find((d)=>d.groupId === groupId && d.deviceId !== defaultId);\n            return device === null || device === void 0 ? void 0 : device.deviceId;\n        });\n    }\n    hasDeviceInUse(kind) {\n        return kind ? DeviceManager.userMediaPromiseMap.has(kind) : DeviceManager.userMediaPromiseMap.size > 0;\n    }\n}\nDeviceManager.mediaDeviceKinds = [\n    'audioinput',\n    'audiooutput',\n    'videoinput'\n];\nDeviceManager.userMediaPromiseMap = new Map();\nconst defaultDimensionsTimeout = 1000;\nclass LocalTrack extends Track {\n    get constraints() {\n        return this._constraints;\n    }\n    /**\n   *\n   * @param mediaTrack\n   * @param kind\n   * @param constraints MediaTrackConstraints that are being used when restarting or reacquiring tracks\n   * @param userProvidedTrack Signals to the SDK whether or not the mediaTrack should be managed (i.e. released and reacquired) internally by the SDK\n   */ constructor(mediaTrack, kind, constraints){\n        let userProvidedTrack = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n        let loggerOptions = arguments.length > 4 ? arguments[4] : undefined;\n        super(mediaTrack, kind, loggerOptions);\n        this._isUpstreamPaused = false;\n        this.handleTrackMuteEvent = ()=>this.debouncedTrackMuteHandler().catch(()=>this.log.debug('track mute bounce got cancelled by an unmute event', this.logContext));\n        this.debouncedTrackMuteHandler = r(()=>__awaiter(this, void 0, void 0, function*() {\n                yield this.pauseUpstream();\n            }), 5000);\n        this.handleTrackUnmuteEvent = ()=>__awaiter(this, void 0, void 0, function*() {\n                this.debouncedTrackMuteHandler.cancel('unmute');\n                yield this.resumeUpstream();\n            });\n        this.handleEnded = ()=>{\n            if (this.isInBackground) {\n                this.reacquireTrack = true;\n            }\n            this._mediaStreamTrack.removeEventListener('mute', this.handleTrackMuteEvent);\n            this._mediaStreamTrack.removeEventListener('unmute', this.handleTrackUnmuteEvent);\n            this.emit(TrackEvent.Ended, this);\n        };\n        this.reacquireTrack = false;\n        this.providedByUser = userProvidedTrack;\n        this.muteLock = new Mutex();\n        this.pauseUpstreamLock = new Mutex();\n        this.processorLock = new Mutex();\n        this.setMediaStreamTrack(mediaTrack, true);\n        // added to satisfy TS compiler, constraints are synced with MediaStreamTrack\n        this._constraints = mediaTrack.getConstraints();\n        if (constraints) {\n            this._constraints = constraints;\n        }\n    }\n    get id() {\n        return this._mediaStreamTrack.id;\n    }\n    get dimensions() {\n        if (this.kind !== Track.Kind.Video) {\n            return undefined;\n        }\n        const { width, height } = this._mediaStreamTrack.getSettings();\n        if (width && height) {\n            return {\n                width,\n                height\n            };\n        }\n        return undefined;\n    }\n    get isUpstreamPaused() {\n        return this._isUpstreamPaused;\n    }\n    get isUserProvided() {\n        return this.providedByUser;\n    }\n    get mediaStreamTrack() {\n        var _a, _b;\n        return (_b = (_a = this.processor) === null || _a === void 0 ? void 0 : _a.processedTrack) !== null && _b !== void 0 ? _b : this._mediaStreamTrack;\n    }\n    setMediaStreamTrack(newTrack, force) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (newTrack === this._mediaStreamTrack && !force) {\n                return;\n            }\n            if (this._mediaStreamTrack) {\n                // detach\n                this.attachedElements.forEach((el)=>{\n                    detachTrack(this._mediaStreamTrack, el);\n                });\n                this.debouncedTrackMuteHandler.cancel('new-track');\n                this._mediaStreamTrack.removeEventListener('ended', this.handleEnded);\n                this._mediaStreamTrack.removeEventListener('mute', this.handleTrackMuteEvent);\n                this._mediaStreamTrack.removeEventListener('unmute', this.handleTrackUnmuteEvent);\n            }\n            this.mediaStream = new MediaStream([\n                newTrack\n            ]);\n            if (newTrack) {\n                newTrack.addEventListener('ended', this.handleEnded);\n                // when underlying track emits mute, it indicates that the device is unable\n                // to produce media. In this case we'll need to signal with remote that\n                // the track is \"muted\"\n                // note this is different from LocalTrack.mute because we do not want to\n                // touch MediaStreamTrack.enabled\n                newTrack.addEventListener('mute', this.handleTrackMuteEvent);\n                newTrack.addEventListener('unmute', this.handleTrackUnmuteEvent);\n                this._constraints = newTrack.getConstraints();\n            }\n            let processedTrack;\n            if (this.processor && newTrack && this.processorElement) {\n                this.log.debug('restarting processor', this.logContext);\n                if (this.kind === 'unknown') {\n                    throw TypeError('cannot set processor on track of unknown kind');\n                }\n                attachToElement(newTrack, this.processorElement);\n                // ensure the processorElement itself stays muted\n                this.processorElement.muted = true;\n                yield this.processor.restart({\n                    track: newTrack,\n                    kind: this.kind,\n                    element: this.processorElement\n                });\n                processedTrack = this.processor.processedTrack;\n            }\n            if (this.sender) {\n                yield this.sender.replaceTrack(processedTrack !== null && processedTrack !== void 0 ? processedTrack : newTrack);\n            }\n            // if `newTrack` is different from the existing track, stop the\n            // older track just before replacing it\n            if (!this.providedByUser && this._mediaStreamTrack !== newTrack) {\n                this._mediaStreamTrack.stop();\n            }\n            this._mediaStreamTrack = newTrack;\n            if (newTrack) {\n                // sync muted state with the enabled state of the newly provided track\n                this._mediaStreamTrack.enabled = !this.isMuted;\n                // when a valid track is replace, we'd want to start producing\n                yield this.resumeUpstream();\n                this.attachedElements.forEach((el)=>{\n                    attachToElement(processedTrack !== null && processedTrack !== void 0 ? processedTrack : newTrack, el);\n                });\n            }\n        });\n    }\n    waitForDimensions() {\n        let timeout = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultDimensionsTimeout;\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            if (this.kind === Track.Kind.Audio) {\n                throw new Error('cannot get dimensions for audio tracks');\n            }\n            if (((_a = getBrowser()) === null || _a === void 0 ? void 0 : _a.os) === 'iOS') {\n                // browsers report wrong initial resolution on iOS.\n                // when slightly delaying the call to .getSettings(), the correct resolution is being reported\n                yield sleep(10);\n            }\n            const started = Date.now();\n            while(Date.now() - started < timeout){\n                const dims = this.dimensions;\n                if (dims) {\n                    return dims;\n                }\n                yield sleep(50);\n            }\n            throw new TrackInvalidError('unable to get track dimensions after timeout');\n        });\n    }\n    /**\n   * @returns DeviceID of the device that is currently being used for this track\n   */ getDeviceId() {\n        return __awaiter(this, void 0, void 0, function*() {\n            // screen share doesn't have a usable device id\n            if (this.source === Track.Source.ScreenShare) {\n                return;\n            }\n            const { deviceId, groupId } = this._mediaStreamTrack.getSettings();\n            const kind = this.kind === Track.Kind.Audio ? 'audioinput' : 'videoinput';\n            return DeviceManager.getInstance().normalizeDeviceId(kind, deviceId, groupId);\n        });\n    }\n    mute() {\n        return __awaiter(this, void 0, void 0, function*() {\n            this.setTrackMuted(true);\n            return this;\n        });\n    }\n    unmute() {\n        return __awaiter(this, void 0, void 0, function*() {\n            this.setTrackMuted(false);\n            return this;\n        });\n    }\n    replaceTrack(track) {\n        let userProvidedTrack = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n        return __awaiter(this, void 0, void 0, function*() {\n            if (!this.sender) {\n                throw new TrackInvalidError('unable to replace an unpublished track');\n            }\n            this.log.debug('replace MediaStreamTrack', this.logContext);\n            yield this.setMediaStreamTrack(track);\n            // this must be synced *after* setting mediaStreamTrack above, since it relies\n            // on the previous state in order to cleanup\n            this.providedByUser = userProvidedTrack;\n            if (this.processor) {\n                yield this.stopProcessor();\n            }\n            return this;\n        });\n    }\n    restart(constraints) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (!constraints) {\n                constraints = this._constraints;\n            }\n            this.log.debug('restarting track with constraints', Object.assign(Object.assign({}, this.logContext), {\n                constraints\n            }));\n            const streamConstraints = {\n                audio: false,\n                video: false\n            };\n            if (this.kind === Track.Kind.Video) {\n                streamConstraints.video = constraints;\n            } else {\n                streamConstraints.audio = constraints;\n            }\n            // these steps are duplicated from setMediaStreamTrack because we must stop\n            // the previous tracks before new tracks can be acquired\n            this.attachedElements.forEach((el)=>{\n                detachTrack(this.mediaStreamTrack, el);\n            });\n            this._mediaStreamTrack.removeEventListener('ended', this.handleEnded);\n            // on Safari, the old audio track must be stopped before attempting to acquire\n            // the new track, otherwise the new track will stop with\n            // 'A MediaStreamTrack ended due to a capture failure`\n            this._mediaStreamTrack.stop();\n            // create new track and attach\n            const mediaStream = yield navigator.mediaDevices.getUserMedia(streamConstraints);\n            const newTrack = mediaStream.getTracks()[0];\n            newTrack.addEventListener('ended', this.handleEnded);\n            this.log.debug('re-acquired MediaStreamTrack', this.logContext);\n            yield this.setMediaStreamTrack(newTrack);\n            this._constraints = constraints;\n            this.emit(TrackEvent.Restarted, this);\n            return this;\n        });\n    }\n    setTrackMuted(muted) {\n        this.log.debug(\"setting \".concat(this.kind, \" track \").concat(muted ? 'muted' : 'unmuted'), this.logContext);\n        if (this.isMuted === muted && this._mediaStreamTrack.enabled !== muted) {\n            return;\n        }\n        this.isMuted = muted;\n        this._mediaStreamTrack.enabled = !muted;\n        this.emit(muted ? TrackEvent.Muted : TrackEvent.Unmuted, this);\n    }\n    get needsReAcquisition() {\n        return this._mediaStreamTrack.readyState !== 'live' || this._mediaStreamTrack.muted || !this._mediaStreamTrack.enabled || this.reacquireTrack;\n    }\n    handleAppVisibilityChanged() {\n        const _super = Object.create(null, {\n            handleAppVisibilityChanged: {\n                get: ()=>super.handleAppVisibilityChanged\n            }\n        });\n        return __awaiter(this, void 0, void 0, function*() {\n            yield _super.handleAppVisibilityChanged.call(this);\n            if (!isMobile()) return;\n            this.log.debug(\"visibility changed, is in Background: \".concat(this.isInBackground), this.logContext);\n            if (!this.isInBackground && this.needsReAcquisition && !this.isUserProvided && !this.isMuted) {\n                this.log.debug(\"track needs to be reacquired, restarting \".concat(this.source), this.logContext);\n                yield this.restart();\n                this.reacquireTrack = false;\n            }\n        });\n    }\n    stop() {\n        var _a;\n        super.stop();\n        this._mediaStreamTrack.removeEventListener('ended', this.handleEnded);\n        this._mediaStreamTrack.removeEventListener('mute', this.handleTrackMuteEvent);\n        this._mediaStreamTrack.removeEventListener('unmute', this.handleTrackUnmuteEvent);\n        (_a = this.processor) === null || _a === void 0 ? void 0 : _a.destroy();\n        this.processor = undefined;\n    }\n    /**\n   * pauses publishing to the server without disabling the local MediaStreamTrack\n   * this is used to display a user's own video locally while pausing publishing to\n   * the server.\n   * this API is unsupported on Safari < 12 due to a bug\n   **/ pauseUpstream() {\n        return __awaiter(this, void 0, void 0, function*() {\n            const unlock = yield this.pauseUpstreamLock.lock();\n            try {\n                if (this._isUpstreamPaused === true) {\n                    return;\n                }\n                if (!this.sender) {\n                    this.log.warn('unable to pause upstream for an unpublished track', this.logContext);\n                    return;\n                }\n                this._isUpstreamPaused = true;\n                this.emit(TrackEvent.UpstreamPaused, this);\n                const browser = getBrowser();\n                if ((browser === null || browser === void 0 ? void 0 : browser.name) === 'Safari' && compareVersions(browser.version, '12.0') < 0) {\n                    // https://bugs.webkit.org/show_bug.cgi?id=184911\n                    throw new DeviceUnsupportedError('pauseUpstream is not supported on Safari < 12.');\n                }\n                yield this.sender.replaceTrack(null);\n            } finally{\n                unlock();\n            }\n        });\n    }\n    resumeUpstream() {\n        return __awaiter(this, void 0, void 0, function*() {\n            const unlock = yield this.pauseUpstreamLock.lock();\n            try {\n                if (this._isUpstreamPaused === false) {\n                    return;\n                }\n                if (!this.sender) {\n                    this.log.warn('unable to resume upstream for an unpublished track', this.logContext);\n                    return;\n                }\n                this._isUpstreamPaused = false;\n                this.emit(TrackEvent.UpstreamResumed, this);\n                // this operation is noop if mediastreamtrack is already being sent\n                yield this.sender.replaceTrack(this._mediaStreamTrack);\n            } finally{\n                unlock();\n            }\n        });\n    }\n    /**\n   * Gets the RTCStatsReport for the LocalTrack's underlying RTCRtpSender\n   * See https://developer.mozilla.org/en-US/docs/Web/API/RTCStatsReport\n   *\n   * @returns Promise<RTCStatsReport> | undefined\n   */ getRTCStatsReport() {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            if (!((_a = this.sender) === null || _a === void 0 ? void 0 : _a.getStats)) {\n                return;\n            }\n            const statsReport = yield this.sender.getStats();\n            return statsReport;\n        });\n    }\n    /**\n   * Sets a processor on this track.\n   * See https://github.com/livekit/track-processors-js for example usage\n   *\n   * @experimental\n   *\n   * @param processor\n   * @param showProcessedStreamLocally\n   * @returns\n   */ setProcessor(processor) {\n        let showProcessedStreamLocally = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n        var _a, _b;\n        return __awaiter(this, void 0, void 0, function*() {\n            const unlock = yield this.processorLock.lock();\n            try {\n                this.log.debug('setting up processor', this.logContext);\n                if (this.processor) {\n                    yield this.stopProcessor();\n                }\n                if (this.kind === 'unknown') {\n                    throw TypeError('cannot set processor on track of unknown kind');\n                }\n                this.processorElement = (_a = this.processorElement) !== null && _a !== void 0 ? _a : document.createElement(this.kind);\n                attachToElement(this._mediaStreamTrack, this.processorElement);\n                this.processorElement.muted = true;\n                this.processorElement.play().catch((error)=>this.log.error('failed to play processor element', Object.assign(Object.assign({}, this.logContext), {\n                        error\n                    })));\n                const processorOptions = {\n                    kind: this.kind,\n                    track: this._mediaStreamTrack,\n                    element: this.processorElement\n                };\n                yield processor.init(processorOptions);\n                this.processor = processor;\n                if (this.processor.processedTrack) {\n                    for (const el of this.attachedElements){\n                        if (el !== this.processorElement && showProcessedStreamLocally) {\n                            detachTrack(this._mediaStreamTrack, el);\n                            attachToElement(this.processor.processedTrack, el);\n                        }\n                    }\n                    yield (_b = this.sender) === null || _b === void 0 ? void 0 : _b.replaceTrack(this.processor.processedTrack);\n                }\n            } finally{\n                unlock();\n            }\n        });\n    }\n    getProcessor() {\n        return this.processor;\n    }\n    /**\n   * Stops the track processor\n   * See https://github.com/livekit/track-processors-js for example usage\n   *\n   * @experimental\n   * @returns\n   */ stopProcessor() {\n        var _a, _b;\n        return __awaiter(this, void 0, void 0, function*() {\n            if (!this.processor) return;\n            this.log.debug('stopping processor', this.logContext);\n            (_a = this.processor.processedTrack) === null || _a === void 0 ? void 0 : _a.stop();\n            yield this.processor.destroy();\n            this.processor = undefined;\n            (_b = this.processorElement) === null || _b === void 0 ? void 0 : _b.remove();\n            this.processorElement = undefined;\n            yield this.restart();\n        });\n    }\n}\n/**\n * @experimental\n */ class E2EEManager extends eventsExports.EventEmitter {\n    constructor(options){\n        super();\n        this.onWorkerMessage = (ev)=>{\n            var _a, _b;\n            const { kind, data } = ev.data;\n            switch(kind){\n                case 'error':\n                    livekitLogger.error(data.error.message);\n                    this.emit(EncryptionEvent.EncryptionError, data.error);\n                    break;\n                case 'initAck':\n                    if (data.enabled) {\n                        this.keyProvider.getKeys().forEach((keyInfo)=>{\n                            this.postKey(keyInfo);\n                        });\n                    }\n                    break;\n                case 'enable':\n                    if (this.encryptionEnabled !== data.enabled && data.participantIdentity === ((_a = this.room) === null || _a === void 0 ? void 0 : _a.localParticipant.identity)) {\n                        this.emit(EncryptionEvent.ParticipantEncryptionStatusChanged, data.enabled, this.room.localParticipant);\n                        this.encryptionEnabled = data.enabled;\n                    } else if (data.participantIdentity) {\n                        const participant = (_b = this.room) === null || _b === void 0 ? void 0 : _b.getParticipantByIdentity(data.participantIdentity);\n                        if (!participant) {\n                            throw TypeError(\"couldn't set encryption status, participant not found\".concat(data.participantIdentity));\n                        }\n                        this.emit(EncryptionEvent.ParticipantEncryptionStatusChanged, data.enabled, participant);\n                    }\n                    if (this.encryptionEnabled) {\n                        this.keyProvider.getKeys().forEach((keyInfo)=>{\n                            this.postKey(keyInfo);\n                        });\n                    }\n                    break;\n                case 'ratchetKey':\n                    this.keyProvider.emit(KeyProviderEvent.KeyRatcheted, data.material, data.keyIndex);\n                    break;\n            }\n        };\n        this.onWorkerError = (ev)=>{\n            livekitLogger.error('e2ee worker encountered an error:', {\n                error: ev.error\n            });\n            this.emit(EncryptionEvent.EncryptionError, ev.error);\n        };\n        this.keyProvider = options.keyProvider;\n        this.worker = options.worker;\n        this.encryptionEnabled = false;\n    }\n    /**\n   * @internal\n   */ setup(room) {\n        if (!isE2EESupported()) {\n            throw new DeviceUnsupportedError('tried to setup end-to-end encryption on an unsupported browser');\n        }\n        livekitLogger.info('setting up e2ee');\n        if (room !== this.room) {\n            this.room = room;\n            this.setupEventListeners(room, this.keyProvider);\n            // this.worker = new Worker('');\n            const msg = {\n                kind: 'init',\n                data: {\n                    keyProviderOptions: this.keyProvider.getOptions()\n                }\n            };\n            if (this.worker) {\n                livekitLogger.info(\"initializing worker\", {\n                    worker: this.worker\n                });\n                this.worker.onmessage = this.onWorkerMessage;\n                this.worker.onerror = this.onWorkerError;\n                this.worker.postMessage(msg);\n            }\n        }\n    }\n    /**\n   * @internal\n   */ setParticipantCryptorEnabled(enabled, participantIdentity) {\n        livekitLogger.debug(\"set e2ee to \".concat(enabled, \" for participant \").concat(participantIdentity));\n        this.postEnable(enabled, participantIdentity);\n    }\n    /**\n   * @internal\n   */ setSifTrailer(trailer) {\n        if (!trailer || trailer.length === 0) {\n            livekitLogger.warn(\"ignoring server sent trailer as it's empty\");\n        } else {\n            this.postSifTrailer(trailer);\n        }\n    }\n    setupEngine(engine) {\n        engine.on(EngineEvent.RTPVideoMapUpdate, (rtpMap)=>{\n            this.postRTPMap(rtpMap);\n        });\n    }\n    setupEventListeners(room, keyProvider) {\n        room.on(RoomEvent.TrackPublished, (pub, participant)=>this.setParticipantCryptorEnabled(pub.trackInfo.encryption !== Encryption_Type.NONE, participant.identity));\n        room.on(RoomEvent.ConnectionStateChanged, (state)=>{\n            if (state === ConnectionState.Connected) {\n                room.participants.forEach((participant)=>{\n                    participant.tracks.forEach((pub)=>{\n                        this.setParticipantCryptorEnabled(pub.trackInfo.encryption !== Encryption_Type.NONE, participant.identity);\n                    });\n                });\n            }\n        }).on(RoomEvent.TrackUnsubscribed, (track, _, participant)=>{\n            var _a;\n            const msg = {\n                kind: 'removeTransform',\n                data: {\n                    participantIdentity: participant.identity,\n                    trackId: track.mediaStreamID\n                }\n            };\n            (_a = this.worker) === null || _a === void 0 ? void 0 : _a.postMessage(msg);\n        }).on(RoomEvent.TrackSubscribed, (track, pub, participant)=>{\n            this.setupE2EEReceiver(track, participant.identity, pub.trackInfo);\n        }).on(RoomEvent.SignalConnected, ()=>{\n            if (!this.room) {\n                throw new TypeError(\"expected room to be present on signal connect\");\n            }\n            this.setParticipantCryptorEnabled(this.room.localParticipant.isE2EEEnabled, this.room.localParticipant.identity);\n            keyProvider.getKeys().forEach((keyInfo)=>{\n                this.postKey(keyInfo);\n            });\n        });\n        room.localParticipant.on(ParticipantEvent.LocalTrackPublished, (publication)=>__awaiter(this, void 0, void 0, function*() {\n                this.setupE2EESender(publication.track, publication.track.sender);\n            }));\n        keyProvider.on(KeyProviderEvent.SetKey, (keyInfo)=>this.postKey(keyInfo)).on(KeyProviderEvent.RatchetRequest, (participantId, keyIndex)=>this.postRatchetRequest(participantId, keyIndex));\n    }\n    postRatchetRequest(participantIdentity, keyIndex) {\n        if (!this.worker) {\n            throw Error('could not ratchet key, worker is missing');\n        }\n        const msg = {\n            kind: 'ratchetRequest',\n            data: {\n                participantIdentity: participantIdentity,\n                keyIndex\n            }\n        };\n        this.worker.postMessage(msg);\n    }\n    postKey(_ref) {\n        let { key, participantIdentity, keyIndex } = _ref;\n        var _a;\n        if (!this.worker) {\n            throw Error('could not set key, worker is missing');\n        }\n        const msg = {\n            kind: 'setKey',\n            data: {\n                participantIdentity: participantIdentity,\n                isPublisher: participantIdentity === ((_a = this.room) === null || _a === void 0 ? void 0 : _a.localParticipant.identity),\n                key,\n                keyIndex\n            }\n        };\n        this.worker.postMessage(msg);\n    }\n    postEnable(enabled, participantIdentity) {\n        if (this.worker) {\n            const enableMsg = {\n                kind: 'enable',\n                data: {\n                    enabled,\n                    participantIdentity\n                }\n            };\n            this.worker.postMessage(enableMsg);\n        } else {\n            throw new ReferenceError('failed to enable e2ee, worker is not ready');\n        }\n    }\n    postRTPMap(map) {\n        var _a;\n        if (!this.worker) {\n            throw TypeError('could not post rtp map, worker is missing');\n        }\n        if (!((_a = this.room) === null || _a === void 0 ? void 0 : _a.localParticipant.identity)) {\n            throw TypeError('could not post rtp map, local participant identity is missing');\n        }\n        const msg = {\n            kind: 'setRTPMap',\n            data: {\n                map,\n                participantIdentity: this.room.localParticipant.identity\n            }\n        };\n        this.worker.postMessage(msg);\n    }\n    postSifTrailer(trailer) {\n        if (!this.worker) {\n            throw Error('could not post SIF trailer, worker is missing');\n        }\n        const msg = {\n            kind: 'setSifTrailer',\n            data: {\n                trailer\n            }\n        };\n        this.worker.postMessage(msg);\n    }\n    setupE2EEReceiver(track, remoteId, trackInfo) {\n        if (!track.receiver) {\n            return;\n        }\n        if (!(trackInfo === null || trackInfo === void 0 ? void 0 : trackInfo.mimeType) || trackInfo.mimeType === '') {\n            throw new TypeError('MimeType missing from trackInfo, cannot set up E2EE cryptor');\n        }\n        this.handleReceiver(track.receiver, track.mediaStreamID, remoteId, track.kind === 'video' ? mimeTypeToVideoCodecString(trackInfo.mimeType) : undefined);\n    }\n    setupE2EESender(track, sender) {\n        if (!(track instanceof LocalTrack) || !sender) {\n            if (!sender) livekitLogger.warn('early return because sender is not ready');\n            return;\n        }\n        this.handleSender(sender, track.mediaStreamID, undefined);\n    }\n    /**\n   * Handles the given {@code RTCRtpReceiver} by creating a {@code TransformStream} which will inject\n   * a frame decoder.\n   *\n   */ handleReceiver(receiver, trackId, participantIdentity, codec) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (!this.worker) {\n                return;\n            }\n            if (isScriptTransformSupported()) {\n                const options = {\n                    kind: 'decode',\n                    participantIdentity,\n                    trackId,\n                    codec\n                };\n                // @ts-ignore\n                receiver.transform = new RTCRtpScriptTransform(this.worker, options);\n            } else {\n                if (E2EE_FLAG in receiver && codec) {\n                    // only update codec\n                    const msg = {\n                        kind: 'updateCodec',\n                        data: {\n                            trackId,\n                            codec,\n                            participantIdentity: participantIdentity\n                        }\n                    };\n                    this.worker.postMessage(msg);\n                    return;\n                }\n                // @ts-ignore\n                let writable = receiver.writableStream;\n                // @ts-ignore\n                let readable = receiver.readableStream;\n                if (!writable || !readable) {\n                    // @ts-ignore\n                    const receiverStreams = receiver.createEncodedStreams();\n                    // @ts-ignore\n                    receiver.writableStream = receiverStreams.writable;\n                    writable = receiverStreams.writable;\n                    // @ts-ignore\n                    receiver.readableStream = receiverStreams.readable;\n                    readable = receiverStreams.readable;\n                }\n                const msg = {\n                    kind: 'decode',\n                    data: {\n                        readableStream: readable,\n                        writableStream: writable,\n                        trackId: trackId,\n                        codec,\n                        participantIdentity: participantIdentity\n                    }\n                };\n                this.worker.postMessage(msg, [\n                    readable,\n                    writable\n                ]);\n            }\n            // @ts-ignore\n            receiver[E2EE_FLAG] = true;\n        });\n    }\n    /**\n   * Handles the given {@code RTCRtpSender} by creating a {@code TransformStream} which will inject\n   * a frame encoder.\n   *\n   */ handleSender(sender, trackId, codec) {\n        var _a;\n        if (E2EE_FLAG in sender || !this.worker) {\n            return;\n        }\n        if (!((_a = this.room) === null || _a === void 0 ? void 0 : _a.localParticipant.identity) || this.room.localParticipant.identity === '') {\n            throw TypeError('local identity needs to be known in order to set up encrypted sender');\n        }\n        if (isScriptTransformSupported()) {\n            livekitLogger.info('initialize script transform');\n            const options = {\n                kind: 'encode',\n                participantIdentity: this.room.localParticipant.identity,\n                trackId,\n                codec\n            };\n            // @ts-ignore\n            sender.transform = new RTCRtpScriptTransform(this.worker, options);\n        } else {\n            livekitLogger.info('initialize encoded streams');\n            // @ts-ignore\n            const senderStreams = sender.createEncodedStreams();\n            const msg = {\n                kind: 'encode',\n                data: {\n                    readableStream: senderStreams.readable,\n                    writableStream: senderStreams.writable,\n                    codec,\n                    trackId,\n                    participantIdentity: this.room.localParticipant.identity\n                }\n            };\n            this.worker.postMessage(msg, [\n                senderStreams.readable,\n                senderStreams.writable\n            ]);\n        }\n        // @ts-ignore\n        sender[E2EE_FLAG] = true;\n    }\n}\nvar QueueTaskStatus;\n(function(QueueTaskStatus) {\n    QueueTaskStatus[QueueTaskStatus[\"WAITING\"] = 0] = \"WAITING\";\n    QueueTaskStatus[QueueTaskStatus[\"RUNNING\"] = 1] = \"RUNNING\";\n    QueueTaskStatus[QueueTaskStatus[\"COMPLETED\"] = 2] = \"COMPLETED\";\n})(QueueTaskStatus || (QueueTaskStatus = {}));\nclass AsyncQueue {\n    constructor(){\n        this.pendingTasks = new Map();\n        this.taskMutex = new Mutex();\n        this.nextTaskIndex = 0;\n    }\n    run(task) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const taskInfo = {\n                id: this.nextTaskIndex++,\n                enqueuedAt: Date.now(),\n                status: QueueTaskStatus.WAITING\n            };\n            this.pendingTasks.set(taskInfo.id, taskInfo);\n            const unlock = yield this.taskMutex.lock();\n            try {\n                taskInfo.executedAt = Date.now();\n                taskInfo.status = QueueTaskStatus.RUNNING;\n                return yield task();\n            } finally{\n                taskInfo.status = QueueTaskStatus.COMPLETED;\n                this.pendingTasks.delete(taskInfo.id);\n                unlock();\n            }\n        });\n    }\n    flush() {\n        return __awaiter(this, void 0, void 0, function*() {\n            return this.run(()=>__awaiter(this, void 0, void 0, function*() {}));\n        });\n    }\n    snapshot() {\n        return Array.from(this.pendingTasks.values());\n    }\n}\nconst passThroughQueueSignals = [\n    'syncState',\n    'trickle',\n    'offer',\n    'answer',\n    'simulate',\n    'leave'\n];\nfunction canPassThroughQueue(req) {\n    const canPass = passThroughQueueSignals.indexOf(req.case) >= 0;\n    livekitLogger.trace('request allowed to bypass queue:', {\n        canPass,\n        req\n    });\n    return canPass;\n}\nvar SignalConnectionState;\n(function(SignalConnectionState) {\n    SignalConnectionState[SignalConnectionState[\"CONNECTING\"] = 0] = \"CONNECTING\";\n    SignalConnectionState[SignalConnectionState[\"CONNECTED\"] = 1] = \"CONNECTED\";\n    SignalConnectionState[SignalConnectionState[\"RECONNECTING\"] = 2] = \"RECONNECTING\";\n    SignalConnectionState[SignalConnectionState[\"DISCONNECTING\"] = 3] = \"DISCONNECTING\";\n    SignalConnectionState[SignalConnectionState[\"DISCONNECTED\"] = 4] = \"DISCONNECTED\";\n})(SignalConnectionState || (SignalConnectionState = {}));\n/** @internal */ class SignalClient {\n    get currentState() {\n        return this.state;\n    }\n    get isDisconnected() {\n        return this.state === SignalConnectionState.DISCONNECTING || this.state === SignalConnectionState.DISCONNECTED;\n    }\n    get isEstablishingConnection() {\n        return this.state === SignalConnectionState.CONNECTING || this.state === SignalConnectionState.RECONNECTING;\n    }\n    constructor(){\n        let useJSON = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n        let loggerOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        var _a;\n        /** signal rtt in milliseconds */ this.rtt = 0;\n        this.state = SignalConnectionState.DISCONNECTED;\n        this.log = livekitLogger;\n        /** @internal */ this.resetCallbacks = ()=>{\n            this.onAnswer = undefined;\n            this.onLeave = undefined;\n            this.onLocalTrackPublished = undefined;\n            this.onLocalTrackUnpublished = undefined;\n            this.onNegotiateRequested = undefined;\n            this.onOffer = undefined;\n            this.onRemoteMuteChanged = undefined;\n            this.onSubscribedQualityUpdate = undefined;\n            this.onTokenRefresh = undefined;\n            this.onTrickle = undefined;\n            this.onClose = undefined;\n        };\n        this.log = getLogger((_a = loggerOptions.loggerName) !== null && _a !== void 0 ? _a : LoggerNames.Signal);\n        this.loggerContextCb = loggerOptions.loggerContextCb;\n        this.useJSON = useJSON;\n        this.requestQueue = new AsyncQueue();\n        this.queuedRequests = [];\n        this.closingLock = new Mutex();\n        this.connectionLock = new Mutex();\n        this.state = SignalConnectionState.DISCONNECTED;\n    }\n    get logContext() {\n        var _a, _b;\n        return (_b = (_a = this.loggerContextCb) === null || _a === void 0 ? void 0 : _a.call(this)) !== null && _b !== void 0 ? _b : {};\n    }\n    join(url, token, opts, abortSignal) {\n        return __awaiter(this, void 0, void 0, function*() {\n            // during a full reconnect, we'd want to start the sequence even if currently\n            // connected\n            this.state = SignalConnectionState.CONNECTING;\n            this.options = opts;\n            const res = yield this.connect(url, token, opts, abortSignal);\n            return res;\n        });\n    }\n    reconnect(url, token, sid, reason) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (!this.options) {\n                this.log.warn('attempted to reconnect without signal options being set, ignoring', this.logContext);\n                return;\n            }\n            this.state = SignalConnectionState.RECONNECTING;\n            // clear ping interval and restart it once reconnected\n            this.clearPingInterval();\n            const res = yield this.connect(url, token, Object.assign(Object.assign({}, this.options), {\n                reconnect: true,\n                sid,\n                reconnectReason: reason\n            }));\n            return res;\n        });\n    }\n    connect(url, token, opts, abortSignal) {\n        this.connectOptions = opts;\n        url = toWebsocketUrl(url);\n        // strip trailing slash\n        url = url.replace(/\\/$/, '');\n        url += '/rtc';\n        const clientInfo = getClientInfo();\n        const params = createConnectionParams(token, clientInfo, opts);\n        return new Promise((resolve, reject)=>__awaiter(this, void 0, void 0, function*() {\n                const unlock = yield this.connectionLock.lock();\n                try {\n                    const abortHandler = ()=>__awaiter(this, void 0, void 0, function*() {\n                            this.close();\n                            clearTimeout(wsTimeout);\n                            reject(new ConnectionError('room connection has been cancelled (signal)'));\n                        });\n                    const wsTimeout = setTimeout(()=>{\n                        this.close();\n                        reject(new ConnectionError('room connection has timed out (signal)'));\n                    }, opts.websocketTimeout);\n                    if (abortSignal === null || abortSignal === void 0 ? void 0 : abortSignal.aborted) {\n                        abortHandler();\n                    }\n                    abortSignal === null || abortSignal === void 0 ? void 0 : abortSignal.addEventListener('abort', abortHandler);\n                    this.log.debug(\"connecting to \".concat(url + params), this.logContext);\n                    if (this.ws) {\n                        yield this.close(false);\n                    }\n                    this.ws = new WebSocket(url + params);\n                    this.ws.binaryType = 'arraybuffer';\n                    this.ws.onopen = ()=>{\n                        clearTimeout(wsTimeout);\n                    };\n                    this.ws.onerror = (ev)=>__awaiter(this, void 0, void 0, function*() {\n                            if (this.state !== SignalConnectionState.CONNECTED) {\n                                clearTimeout(wsTimeout);\n                                try {\n                                    const resp = yield fetch(\"http\".concat(url.substring(2), \"/validate\").concat(params));\n                                    if (resp.status.toFixed(0).startsWith('4')) {\n                                        const msg = yield resp.text();\n                                        reject(new ConnectionError(msg, 0 /* ConnectionErrorReason.NotAllowed */ , resp.status));\n                                    } else {\n                                        reject(new ConnectionError('Internal error', 2 /* ConnectionErrorReason.InternalError */ , resp.status));\n                                    }\n                                } catch (e) {\n                                    reject(new ConnectionError('server was not reachable', 1 /* ConnectionErrorReason.ServerUnreachable */ ));\n                                }\n                                return;\n                            }\n                            // other errors, handle\n                            this.handleWSError(ev);\n                        });\n                    this.ws.onmessage = (ev)=>__awaiter(this, void 0, void 0, function*() {\n                            var _a, _b, _c, _d;\n                            // not considered connected until JoinResponse is received\n                            let resp;\n                            if (typeof ev.data === 'string') {\n                                const json = JSON.parse(ev.data);\n                                resp = SignalResponse.fromJson(json);\n                            } else if (ev.data instanceof ArrayBuffer) {\n                                resp = SignalResponse.fromBinary(new Uint8Array(ev.data));\n                            } else {\n                                this.log.error(\"could not decode websocket message: \".concat(typeof ev.data), this.logContext);\n                                return;\n                            }\n                            if (this.state !== SignalConnectionState.CONNECTED) {\n                                let shouldProcessMessage = false;\n                                // handle join message only\n                                if (((_a = resp.message) === null || _a === void 0 ? void 0 : _a.case) === 'join') {\n                                    this.state = SignalConnectionState.CONNECTED;\n                                    abortSignal === null || abortSignal === void 0 ? void 0 : abortSignal.removeEventListener('abort', abortHandler);\n                                    this.pingTimeoutDuration = resp.message.value.pingTimeout;\n                                    this.pingIntervalDuration = resp.message.value.pingInterval;\n                                    if (this.pingTimeoutDuration && this.pingTimeoutDuration > 0) {\n                                        this.log.debug('ping config', Object.assign(Object.assign({}, this.logContext), {\n                                            timeout: this.pingTimeoutDuration,\n                                            interval: this.pingIntervalDuration\n                                        }));\n                                        this.startPingInterval();\n                                    }\n                                    resolve(resp.message.value);\n                                } else if (this.state === SignalConnectionState.RECONNECTING && resp.message.case !== 'leave') {\n                                    // in reconnecting, any message received means signal reconnected\n                                    this.state = SignalConnectionState.CONNECTED;\n                                    abortSignal === null || abortSignal === void 0 ? void 0 : abortSignal.removeEventListener('abort', abortHandler);\n                                    this.startPingInterval();\n                                    if (((_b = resp.message) === null || _b === void 0 ? void 0 : _b.case) === 'reconnect') {\n                                        resolve((_c = resp.message) === null || _c === void 0 ? void 0 : _c.value);\n                                    } else {\n                                        resolve();\n                                        shouldProcessMessage = true;\n                                    }\n                                } else if (this.isEstablishingConnection && resp.message.case === 'leave') {\n                                    reject(new ConnectionError('Received leave request while trying to (re)connect', 4 /* ConnectionErrorReason.LeaveRequest */ ));\n                                } else if (!opts.reconnect) {\n                                    // non-reconnect case, should receive join response first\n                                    reject(new ConnectionError(\"did not receive join response, got \".concat((_d = resp.message) === null || _d === void 0 ? void 0 : _d.case, \" instead\")));\n                                }\n                                if (!shouldProcessMessage) {\n                                    return;\n                                }\n                            }\n                            if (this.signalLatency) {\n                                yield sleep(this.signalLatency);\n                            }\n                            this.handleSignalResponse(resp);\n                        });\n                    this.ws.onclose = (ev)=>{\n                        if (this.isEstablishingConnection) {\n                            reject(new ConnectionError('Websocket got closed during a (re)connection attempt'));\n                        }\n                        this.log.warn(\"websocket closed\", Object.assign(Object.assign({}, this.logContext), {\n                            reason: ev.reason,\n                            state: this.state\n                        }));\n                        this.handleOnClose(ev.reason);\n                    };\n                } finally{\n                    unlock();\n                }\n            }));\n    }\n    close() {\n        let updateState = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n        return __awaiter(this, void 0, void 0, function*() {\n            const unlock = yield this.closingLock.lock();\n            try {\n                if (updateState) {\n                    this.state = SignalConnectionState.DISCONNECTING;\n                }\n                if (this.ws) {\n                    this.ws.onmessage = null;\n                    this.ws.onopen = null;\n                    this.ws.onclose = null;\n                    // calling `ws.close()` only starts the closing handshake (CLOSING state), prefer to wait until state is actually CLOSED\n                    const closePromise = new Promise((resolve)=>{\n                        if (this.ws) {\n                            this.ws.onclose = ()=>{\n                                resolve();\n                            };\n                        } else {\n                            resolve();\n                        }\n                    });\n                    if (this.ws.readyState < this.ws.CLOSING) {\n                        this.ws.close();\n                        // 250ms grace period for ws to close gracefully\n                        yield Promise.race([\n                            closePromise,\n                            sleep(250)\n                        ]);\n                    }\n                    this.ws = undefined;\n                }\n            } finally{\n                if (updateState) {\n                    this.state = SignalConnectionState.DISCONNECTED;\n                }\n                this.clearPingInterval();\n                unlock();\n            }\n        });\n    }\n    // initial offer after joining\n    sendOffer(offer) {\n        this.log.debug('sending offer', Object.assign(Object.assign({}, this.logContext), {\n            offerSdp: offer.sdp\n        }));\n        this.sendRequest({\n            case: 'offer',\n            value: toProtoSessionDescription(offer)\n        });\n    }\n    // answer a server-initiated offer\n    sendAnswer(answer) {\n        this.log.debug('sending answer', Object.assign(Object.assign({}, this.logContext), {\n            answerSdp: answer.sdp\n        }));\n        return this.sendRequest({\n            case: 'answer',\n            value: toProtoSessionDescription(answer)\n        });\n    }\n    sendIceCandidate(candidate, target) {\n        this.log.trace('sending ice candidate', Object.assign(Object.assign({}, this.logContext), {\n            candidate\n        }));\n        return this.sendRequest({\n            case: 'trickle',\n            value: new TrickleRequest({\n                candidateInit: JSON.stringify(candidate),\n                target\n            })\n        });\n    }\n    sendMuteTrack(trackSid, muted) {\n        return this.sendRequest({\n            case: 'mute',\n            value: new MuteTrackRequest({\n                sid: trackSid,\n                muted\n            })\n        });\n    }\n    sendAddTrack(req) {\n        return this.sendRequest({\n            case: 'addTrack',\n            value: req\n        });\n    }\n    sendUpdateLocalMetadata(metadata, name) {\n        return this.sendRequest({\n            case: 'updateMetadata',\n            value: new UpdateParticipantMetadata({\n                metadata,\n                name\n            })\n        });\n    }\n    sendUpdateTrackSettings(settings) {\n        this.sendRequest({\n            case: 'trackSetting',\n            value: settings\n        });\n    }\n    sendUpdateSubscription(sub) {\n        return this.sendRequest({\n            case: 'subscription',\n            value: sub\n        });\n    }\n    sendSyncState(sync) {\n        return this.sendRequest({\n            case: 'syncState',\n            value: sync\n        });\n    }\n    sendUpdateVideoLayers(trackSid, layers) {\n        return this.sendRequest({\n            case: 'updateLayers',\n            value: new UpdateVideoLayers({\n                trackSid,\n                layers\n            })\n        });\n    }\n    sendUpdateSubscriptionPermissions(allParticipants, trackPermissions) {\n        return this.sendRequest({\n            case: 'subscriptionPermission',\n            value: new SubscriptionPermission({\n                allParticipants,\n                trackPermissions\n            })\n        });\n    }\n    sendSimulateScenario(scenario) {\n        return this.sendRequest({\n            case: 'simulate',\n            value: scenario\n        });\n    }\n    sendPing() {\n        /** send both of ping and pingReq for compatibility to old and new server */ return Promise.all([\n            this.sendRequest({\n                case: 'ping',\n                value: protoInt64.parse(Date.now())\n            }),\n            this.sendRequest({\n                case: 'pingReq',\n                value: new Ping({\n                    timestamp: protoInt64.parse(Date.now()),\n                    rtt: protoInt64.parse(this.rtt)\n                })\n            })\n        ]);\n    }\n    sendLeave() {\n        return this.sendRequest({\n            case: 'leave',\n            value: new LeaveRequest({\n                canReconnect: false,\n                reason: DisconnectReason.CLIENT_INITIATED\n            })\n        });\n    }\n    sendRequest(message) {\n        let fromQueue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n        return __awaiter(this, void 0, void 0, function*() {\n            // capture all requests while reconnecting and put them in a queue\n            // unless the request originates from the queue, then don't enqueue again\n            const canQueue = !fromQueue && !canPassThroughQueue(message);\n            if (canQueue && this.state === SignalConnectionState.RECONNECTING) {\n                this.queuedRequests.push(()=>__awaiter(this, void 0, void 0, function*() {\n                        yield this.sendRequest(message, true);\n                    }));\n                return;\n            }\n            // make sure previously queued requests are being sent first\n            if (!fromQueue) {\n                yield this.requestQueue.flush();\n            }\n            if (this.signalLatency) {\n                yield sleep(this.signalLatency);\n            }\n            if (!this.ws || this.ws.readyState !== this.ws.OPEN) {\n                this.log.error(\"cannot send signal request before connected, type: \".concat(message === null || message === void 0 ? void 0 : message.case), this.logContext);\n                return;\n            }\n            const req = new SignalRequest({\n                message\n            });\n            try {\n                if (this.useJSON) {\n                    this.ws.send(req.toJsonString());\n                } else {\n                    this.ws.send(req.toBinary());\n                }\n            } catch (e) {\n                this.log.error('error sending signal message', Object.assign(Object.assign({}, this.logContext), {\n                    error: e\n                }));\n            }\n        });\n    }\n    handleSignalResponse(res) {\n        var _a, _b;\n        const msg = res.message;\n        if (msg == undefined) {\n            this.log.debug('received unsupported message', this.logContext);\n            return;\n        }\n        let pingHandled = false;\n        if (msg.case === 'answer') {\n            const sd = fromProtoSessionDescription(msg.value);\n            if (this.onAnswer) {\n                this.onAnswer(sd);\n            }\n        } else if (msg.case === 'offer') {\n            const sd = fromProtoSessionDescription(msg.value);\n            if (this.onOffer) {\n                this.onOffer(sd);\n            }\n        } else if (msg.case === 'trickle') {\n            const candidate = JSON.parse(msg.value.candidateInit);\n            if (this.onTrickle) {\n                this.onTrickle(candidate, msg.value.target);\n            }\n        } else if (msg.case === 'update') {\n            if (this.onParticipantUpdate) {\n                this.onParticipantUpdate((_a = msg.value.participants) !== null && _a !== void 0 ? _a : []);\n            }\n        } else if (msg.case === 'trackPublished') {\n            if (this.onLocalTrackPublished) {\n                this.onLocalTrackPublished(msg.value);\n            }\n        } else if (msg.case === 'speakersChanged') {\n            if (this.onSpeakersChanged) {\n                this.onSpeakersChanged((_b = msg.value.speakers) !== null && _b !== void 0 ? _b : []);\n            }\n        } else if (msg.case === 'leave') {\n            if (this.onLeave) {\n                this.onLeave(msg.value);\n            }\n        } else if (msg.case === 'mute') {\n            if (this.onRemoteMuteChanged) {\n                this.onRemoteMuteChanged(msg.value.sid, msg.value.muted);\n            }\n        } else if (msg.case === 'roomUpdate') {\n            if (this.onRoomUpdate && msg.value.room) {\n                this.onRoomUpdate(msg.value.room);\n            }\n        } else if (msg.case === 'connectionQuality') {\n            if (this.onConnectionQuality) {\n                this.onConnectionQuality(msg.value);\n            }\n        } else if (msg.case === 'streamStateUpdate') {\n            if (this.onStreamStateUpdate) {\n                this.onStreamStateUpdate(msg.value);\n            }\n        } else if (msg.case === 'subscribedQualityUpdate') {\n            if (this.onSubscribedQualityUpdate) {\n                this.onSubscribedQualityUpdate(msg.value);\n            }\n        } else if (msg.case === 'subscriptionPermissionUpdate') {\n            if (this.onSubscriptionPermissionUpdate) {\n                this.onSubscriptionPermissionUpdate(msg.value);\n            }\n        } else if (msg.case === 'refreshToken') {\n            if (this.onTokenRefresh) {\n                this.onTokenRefresh(msg.value);\n            }\n        } else if (msg.case === 'trackUnpublished') {\n            if (this.onLocalTrackUnpublished) {\n                this.onLocalTrackUnpublished(msg.value);\n            }\n        } else if (msg.case === 'subscriptionResponse') {\n            if (this.onSubscriptionError) {\n                this.onSubscriptionError(msg.value);\n            }\n        } else if (msg.case === 'pong') ;\n        else if (msg.case === 'pongResp') {\n            this.rtt = Date.now() - Number.parseInt(msg.value.lastPingTimestamp.toString());\n            this.resetPingTimeout();\n            pingHandled = true;\n        } else {\n            this.log.debug('unsupported message', Object.assign(Object.assign({}, this.logContext), {\n                msgCase: msg.case\n            }));\n        }\n        if (!pingHandled) {\n            this.resetPingTimeout();\n        }\n    }\n    setReconnected() {\n        while(this.queuedRequests.length > 0){\n            const req = this.queuedRequests.shift();\n            if (req) {\n                this.requestQueue.run(req);\n            }\n        }\n    }\n    handleOnClose(reason) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (this.state === SignalConnectionState.DISCONNECTED) return;\n            const onCloseCallback = this.onClose;\n            yield this.close();\n            this.log.debug(\"websocket connection closed: \".concat(reason), Object.assign(Object.assign({}, this.logContext), {\n                reason\n            }));\n            if (onCloseCallback) {\n                onCloseCallback(reason);\n            }\n        });\n    }\n    handleWSError(ev) {\n        this.log.error('websocket error', Object.assign(Object.assign({}, this.logContext), {\n            error: ev\n        }));\n    }\n    /**\n   * Resets the ping timeout and starts a new timeout.\n   * Call this after receiving a pong message\n   */ resetPingTimeout() {\n        this.clearPingTimeout();\n        if (!this.pingTimeoutDuration) {\n            this.log.warn('ping timeout duration not set', this.logContext);\n            return;\n        }\n        this.pingTimeout = CriticalTimers.setTimeout(()=>{\n            this.log.warn(\"ping timeout triggered. last pong received at: \".concat(new Date(Date.now() - this.pingTimeoutDuration * 1000).toUTCString()), this.logContext);\n            this.handleOnClose('ping timeout');\n        }, this.pingTimeoutDuration * 1000);\n    }\n    /**\n   * Clears ping timeout (does not start a new timeout)\n   */ clearPingTimeout() {\n        if (this.pingTimeout) {\n            CriticalTimers.clearTimeout(this.pingTimeout);\n        }\n    }\n    startPingInterval() {\n        this.clearPingInterval();\n        this.resetPingTimeout();\n        if (!this.pingIntervalDuration) {\n            this.log.warn('ping interval duration not set', this.logContext);\n            return;\n        }\n        this.log.debug('start ping interval', this.logContext);\n        this.pingInterval = CriticalTimers.setInterval(()=>{\n            this.sendPing();\n        }, this.pingIntervalDuration * 1000);\n    }\n    clearPingInterval() {\n        this.log.debug('clearing ping interval', this.logContext);\n        this.clearPingTimeout();\n        if (this.pingInterval) {\n            CriticalTimers.clearInterval(this.pingInterval);\n        }\n    }\n}\nfunction fromProtoSessionDescription(sd) {\n    const rsd = {\n        type: 'offer',\n        sdp: sd.sdp\n    };\n    switch(sd.type){\n        case 'answer':\n        case 'offer':\n        case 'pranswer':\n        case 'rollback':\n            rsd.type = sd.type;\n            break;\n    }\n    return rsd;\n}\nfunction toProtoSessionDescription(rsd) {\n    const sd = new SessionDescription({\n        sdp: rsd.sdp,\n        type: rsd.type\n    });\n    return sd;\n}\nfunction createConnectionParams(token, info, opts) {\n    var _a;\n    const params = new URLSearchParams();\n    params.set('access_token', token);\n    // opts\n    if (opts.reconnect) {\n        params.set('reconnect', '1');\n        if (opts.sid) {\n            params.set('sid', opts.sid);\n        }\n    }\n    params.set('auto_subscribe', opts.autoSubscribe ? '1' : '0');\n    // ClientInfo\n    params.set('sdk', isReactNative() ? 'reactnative' : 'js');\n    params.set('version', info.version);\n    params.set('protocol', info.protocol.toString());\n    if (info.deviceModel) {\n        params.set('device_model', info.deviceModel);\n    }\n    if (info.os) {\n        params.set('os', info.os);\n    }\n    if (info.osVersion) {\n        params.set('os_version', info.osVersion);\n    }\n    if (info.browser) {\n        params.set('browser', info.browser);\n    }\n    if (info.browserVersion) {\n        params.set('browser_version', info.browserVersion);\n    }\n    if (opts.publishOnly !== undefined) {\n        params.set('publish', opts.publishOnly);\n    }\n    if (opts.adaptiveStream) {\n        params.set('adaptive_stream', '1');\n    }\n    if (opts.reconnectReason) {\n        params.set('reconnect_reason', opts.reconnectReason.toString());\n    }\n    // @ts-ignore\n    if ((_a = navigator.connection) === null || _a === void 0 ? void 0 : _a.type) {\n        // @ts-ignore\n        params.set('network', navigator.connection.type);\n    }\n    return \"?\".concat(params.toString());\n}\nvar parser$1 = {};\nvar grammar$2 = {\n    exports: {}\n};\nvar grammar$1 = grammar$2.exports = {\n    v: [\n        {\n            name: 'version',\n            reg: /^(\\d*)$/\n        }\n    ],\n    o: [\n        {\n            // o=- 20518 0 IN IP4 203.0.113.1\n            // NB: sessionId will be a String in most cases because it is huge\n            name: 'origin',\n            reg: /^(\\S*) (\\d*) (\\d*) (\\S*) IP(\\d) (\\S*)/,\n            names: [\n                'username',\n                'sessionId',\n                'sessionVersion',\n                'netType',\n                'ipVer',\n                'address'\n            ],\n            format: '%s %s %d %s IP%d %s'\n        }\n    ],\n    // default parsing of these only (though some of these feel outdated)\n    s: [\n        {\n            name: 'name'\n        }\n    ],\n    i: [\n        {\n            name: 'description'\n        }\n    ],\n    u: [\n        {\n            name: 'uri'\n        }\n    ],\n    e: [\n        {\n            name: 'email'\n        }\n    ],\n    p: [\n        {\n            name: 'phone'\n        }\n    ],\n    z: [\n        {\n            name: 'timezones'\n        }\n    ],\n    // TODO: this one can actually be parsed properly...\n    r: [\n        {\n            name: 'repeats'\n        }\n    ],\n    // TODO: this one can also be parsed properly\n    // k: [{}], // outdated thing ignored\n    t: [\n        {\n            // t=0 0\n            name: 'timing',\n            reg: /^(\\d*) (\\d*)/,\n            names: [\n                'start',\n                'stop'\n            ],\n            format: '%d %d'\n        }\n    ],\n    c: [\n        {\n            // c=IN IP4 10.47.197.26\n            name: 'connection',\n            reg: /^IN IP(\\d) (\\S*)/,\n            names: [\n                'version',\n                'ip'\n            ],\n            format: 'IN IP%d %s'\n        }\n    ],\n    b: [\n        {\n            // b=AS:4000\n            push: 'bandwidth',\n            reg: /^(TIAS|AS|CT|RR|RS):(\\d*)/,\n            names: [\n                'type',\n                'limit'\n            ],\n            format: '%s:%s'\n        }\n    ],\n    m: [\n        {\n            // m=video 51744 RTP/AVP 126 97 98 34 31\n            // NB: special - pushes to session\n            // TODO: rtp/fmtp should be filtered by the payloads found here?\n            reg: /^(\\w*) (\\d*) ([\\w/]*)(?: (.*))?/,\n            names: [\n                'type',\n                'port',\n                'protocol',\n                'payloads'\n            ],\n            format: '%s %d %s %s'\n        }\n    ],\n    a: [\n        {\n            // a=rtpmap:110 opus/48000/2\n            push: 'rtp',\n            reg: /^rtpmap:(\\d*) ([\\w\\-.]*)(?:\\s*\\/(\\d*)(?:\\s*\\/(\\S*))?)?/,\n            names: [\n                'payload',\n                'codec',\n                'rate',\n                'encoding'\n            ],\n            format: function(o) {\n                return o.encoding ? 'rtpmap:%d %s/%s/%s' : o.rate ? 'rtpmap:%d %s/%s' : 'rtpmap:%d %s';\n            }\n        },\n        {\n            // a=fmtp:108 profile-level-id=24;object=23;bitrate=64000\n            // a=fmtp:111 minptime=10; useinbandfec=1\n            push: 'fmtp',\n            reg: /^fmtp:(\\d*) ([\\S| ]*)/,\n            names: [\n                'payload',\n                'config'\n            ],\n            format: 'fmtp:%d %s'\n        },\n        {\n            // a=control:streamid=0\n            name: 'control',\n            reg: /^control:(.*)/,\n            format: 'control:%s'\n        },\n        {\n            // a=rtcp:65179 IN IP4 193.84.77.194\n            name: 'rtcp',\n            reg: /^rtcp:(\\d*)(?: (\\S*) IP(\\d) (\\S*))?/,\n            names: [\n                'port',\n                'netType',\n                'ipVer',\n                'address'\n            ],\n            format: function(o) {\n                return o.address != null ? 'rtcp:%d %s IP%d %s' : 'rtcp:%d';\n            }\n        },\n        {\n            // a=rtcp-fb:98 trr-int 100\n            push: 'rtcpFbTrrInt',\n            reg: /^rtcp-fb:(\\*|\\d*) trr-int (\\d*)/,\n            names: [\n                'payload',\n                'value'\n            ],\n            format: 'rtcp-fb:%s trr-int %d'\n        },\n        {\n            // a=rtcp-fb:98 nack rpsi\n            push: 'rtcpFb',\n            reg: /^rtcp-fb:(\\*|\\d*) ([\\w-_]*)(?: ([\\w-_]*))?/,\n            names: [\n                'payload',\n                'type',\n                'subtype'\n            ],\n            format: function(o) {\n                return o.subtype != null ? 'rtcp-fb:%s %s %s' : 'rtcp-fb:%s %s';\n            }\n        },\n        {\n            // a=extmap:2 urn:ietf:params:rtp-hdrext:toffset\n            // a=extmap:1/recvonly URI-gps-string\n            // a=extmap:3 urn:ietf:params:rtp-hdrext:encrypt urn:ietf:params:rtp-hdrext:smpte-tc 25@600/24\n            push: 'ext',\n            reg: /^extmap:(\\d+)(?:\\/(\\w+))?(?: (urn:ietf:params:rtp-hdrext:encrypt))? (\\S*)(?: (\\S*))?/,\n            names: [\n                'value',\n                'direction',\n                'encrypt-uri',\n                'uri',\n                'config'\n            ],\n            format: function(o) {\n                return 'extmap:%d' + (o.direction ? '/%s' : '%v') + (o['encrypt-uri'] ? ' %s' : '%v') + ' %s' + (o.config ? ' %s' : '');\n            }\n        },\n        {\n            // a=extmap-allow-mixed\n            name: 'extmapAllowMixed',\n            reg: /^(extmap-allow-mixed)/\n        },\n        {\n            // a=crypto:1 AES_CM_128_HMAC_SHA1_80 inline:PS1uQCVeeCFCanVmcjkpPywjNWhcYD0mXXtxaVBR|2^20|1:32\n            push: 'crypto',\n            reg: /^crypto:(\\d*) ([\\w_]*) (\\S*)(?: (\\S*))?/,\n            names: [\n                'id',\n                'suite',\n                'config',\n                'sessionConfig'\n            ],\n            format: function(o) {\n                return o.sessionConfig != null ? 'crypto:%d %s %s %s' : 'crypto:%d %s %s';\n            }\n        },\n        {\n            // a=setup:actpass\n            name: 'setup',\n            reg: /^setup:(\\w*)/,\n            format: 'setup:%s'\n        },\n        {\n            // a=connection:new\n            name: 'connectionType',\n            reg: /^connection:(new|existing)/,\n            format: 'connection:%s'\n        },\n        {\n            // a=mid:1\n            name: 'mid',\n            reg: /^mid:([^\\s]*)/,\n            format: 'mid:%s'\n        },\n        {\n            // a=msid:0c8b064d-d807-43b4-b434-f92a889d8587 98178685-d409-46e0-8e16-7ef0db0db64a\n            name: 'msid',\n            reg: /^msid:(.*)/,\n            format: 'msid:%s'\n        },\n        {\n            // a=ptime:20\n            name: 'ptime',\n            reg: /^ptime:(\\d*(?:\\.\\d*)*)/,\n            format: 'ptime:%d'\n        },\n        {\n            // a=maxptime:60\n            name: 'maxptime',\n            reg: /^maxptime:(\\d*(?:\\.\\d*)*)/,\n            format: 'maxptime:%d'\n        },\n        {\n            // a=sendrecv\n            name: 'direction',\n            reg: /^(sendrecv|recvonly|sendonly|inactive)/\n        },\n        {\n            // a=ice-lite\n            name: 'icelite',\n            reg: /^(ice-lite)/\n        },\n        {\n            // a=ice-ufrag:F7gI\n            name: 'iceUfrag',\n            reg: /^ice-ufrag:(\\S*)/,\n            format: 'ice-ufrag:%s'\n        },\n        {\n            // a=ice-pwd:x9cml/YzichV2+XlhiMu8g\n            name: 'icePwd',\n            reg: /^ice-pwd:(\\S*)/,\n            format: 'ice-pwd:%s'\n        },\n        {\n            // a=fingerprint:SHA-1 00:11:22:33:44:55:66:77:88:99:AA:BB:CC:DD:EE:FF:00:11:22:33\n            name: 'fingerprint',\n            reg: /^fingerprint:(\\S*) (\\S*)/,\n            names: [\n                'type',\n                'hash'\n            ],\n            format: 'fingerprint:%s %s'\n        },\n        {\n            // a=candidate:0 1 UDP 2113667327 203.0.113.1 54400 typ host\n            // a=candidate:1162875081 1 udp 2113937151 192.168.34.75 60017 typ host generation 0 network-id 3 network-cost 10\n            // a=candidate:3289912957 2 udp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 generation 0 network-id 3 network-cost 10\n            // a=candidate:229815620 1 tcp 1518280447 192.168.150.19 60017 typ host tcptype active generation 0 network-id 3 network-cost 10\n            // a=candidate:3289912957 2 tcp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 tcptype passive generation 0 network-id 3 network-cost 10\n            push: 'candidates',\n            reg: /^candidate:(\\S*) (\\d*) (\\S*) (\\d*) (\\S*) (\\d*) typ (\\S*)(?: raddr (\\S*) rport (\\d*))?(?: tcptype (\\S*))?(?: generation (\\d*))?(?: network-id (\\d*))?(?: network-cost (\\d*))?/,\n            names: [\n                'foundation',\n                'component',\n                'transport',\n                'priority',\n                'ip',\n                'port',\n                'type',\n                'raddr',\n                'rport',\n                'tcptype',\n                'generation',\n                'network-id',\n                'network-cost'\n            ],\n            format: function(o) {\n                var str = 'candidate:%s %d %s %d %s %d typ %s';\n                str += o.raddr != null ? ' raddr %s rport %d' : '%v%v';\n                // NB: candidate has three optional chunks, so %void middles one if it's missing\n                str += o.tcptype != null ? ' tcptype %s' : '%v';\n                if (o.generation != null) {\n                    str += ' generation %d';\n                }\n                str += o['network-id'] != null ? ' network-id %d' : '%v';\n                str += o['network-cost'] != null ? ' network-cost %d' : '%v';\n                return str;\n            }\n        },\n        {\n            // a=end-of-candidates (keep after the candidates line for readability)\n            name: 'endOfCandidates',\n            reg: /^(end-of-candidates)/\n        },\n        {\n            // a=remote-candidates:1 203.0.113.1 54400 2 203.0.113.1 54401 ...\n            name: 'remoteCandidates',\n            reg: /^remote-candidates:(.*)/,\n            format: 'remote-candidates:%s'\n        },\n        {\n            // a=ice-options:google-ice\n            name: 'iceOptions',\n            reg: /^ice-options:(\\S*)/,\n            format: 'ice-options:%s'\n        },\n        {\n            // a=ssrc:2566107569 cname:t9YU8M1UxTF8Y1A1\n            push: 'ssrcs',\n            reg: /^ssrc:(\\d*) ([\\w_-]*)(?::(.*))?/,\n            names: [\n                'id',\n                'attribute',\n                'value'\n            ],\n            format: function(o) {\n                var str = 'ssrc:%d';\n                if (o.attribute != null) {\n                    str += ' %s';\n                    if (o.value != null) {\n                        str += ':%s';\n                    }\n                }\n                return str;\n            }\n        },\n        {\n            // a=ssrc-group:FEC 1 2\n            // a=ssrc-group:FEC-FR 3004364195 1080772241\n            push: 'ssrcGroups',\n            // token-char = %x21 / %x23-27 / %x2A-2B / %x2D-2E / %x30-39 / %x41-5A / %x5E-7E\n            reg: /^ssrc-group:([\\x21\\x23\\x24\\x25\\x26\\x27\\x2A\\x2B\\x2D\\x2E\\w]*) (.*)/,\n            names: [\n                'semantics',\n                'ssrcs'\n            ],\n            format: 'ssrc-group:%s %s'\n        },\n        {\n            // a=msid-semantic: WMS Jvlam5X3SX1OP6pn20zWogvaKJz5Hjf9OnlV\n            name: 'msidSemantic',\n            reg: /^msid-semantic:\\s?(\\w*) (\\S*)/,\n            names: [\n                'semantic',\n                'token'\n            ],\n            format: 'msid-semantic: %s %s' // space after ':' is not accidental\n        },\n        {\n            // a=group:BUNDLE audio video\n            push: 'groups',\n            reg: /^group:(\\w*) (.*)/,\n            names: [\n                'type',\n                'mids'\n            ],\n            format: 'group:%s %s'\n        },\n        {\n            // a=rtcp-mux\n            name: 'rtcpMux',\n            reg: /^(rtcp-mux)/\n        },\n        {\n            // a=rtcp-rsize\n            name: 'rtcpRsize',\n            reg: /^(rtcp-rsize)/\n        },\n        {\n            // a=sctpmap:5000 webrtc-datachannel 1024\n            name: 'sctpmap',\n            reg: /^sctpmap:([\\w_/]*) (\\S*)(?: (\\S*))?/,\n            names: [\n                'sctpmapNumber',\n                'app',\n                'maxMessageSize'\n            ],\n            format: function(o) {\n                return o.maxMessageSize != null ? 'sctpmap:%s %s %s' : 'sctpmap:%s %s';\n            }\n        },\n        {\n            // a=x-google-flag:conference\n            name: 'xGoogleFlag',\n            reg: /^x-google-flag:([^\\s]*)/,\n            format: 'x-google-flag:%s'\n        },\n        {\n            // a=rid:1 send max-width=1280;max-height=720;max-fps=30;depend=0\n            push: 'rids',\n            reg: /^rid:([\\d\\w]+) (\\w+)(?: ([\\S| ]*))?/,\n            names: [\n                'id',\n                'direction',\n                'params'\n            ],\n            format: function(o) {\n                return o.params ? 'rid:%s %s %s' : 'rid:%s %s';\n            }\n        },\n        {\n            // a=imageattr:97 send [x=800,y=640,sar=1.1,q=0.6] [x=480,y=320] recv [x=330,y=250]\n            // a=imageattr:* send [x=800,y=640] recv *\n            // a=imageattr:100 recv [x=320,y=240]\n            push: 'imageattrs',\n            reg: new RegExp(// a=imageattr:97\n            '^imageattr:(\\\\d+|\\\\*)' + // send [x=800,y=640,sar=1.1,q=0.6] [x=480,y=320]\n            '[\\\\s\\\\t]+(send|recv)[\\\\s\\\\t]+(\\\\*|\\\\[\\\\S+\\\\](?:[\\\\s\\\\t]+\\\\[\\\\S+\\\\])*)' + // recv [x=330,y=250]\n            '(?:[\\\\s\\\\t]+(recv|send)[\\\\s\\\\t]+(\\\\*|\\\\[\\\\S+\\\\](?:[\\\\s\\\\t]+\\\\[\\\\S+\\\\])*))?'),\n            names: [\n                'pt',\n                'dir1',\n                'attrs1',\n                'dir2',\n                'attrs2'\n            ],\n            format: function(o) {\n                return 'imageattr:%s %s %s' + (o.dir2 ? ' %s %s' : '');\n            }\n        },\n        {\n            // a=simulcast:send 1,2,3;~4,~5 recv 6;~7,~8\n            // a=simulcast:recv 1;4,5 send 6;7\n            name: 'simulcast',\n            reg: new RegExp(// a=simulcast:\n            '^simulcast:' + // send 1,2,3;~4,~5\n            '(send|recv) ([a-zA-Z0-9\\\\-_~;,]+)' + // space + recv 6;~7,~8\n            '(?:\\\\s?(send|recv) ([a-zA-Z0-9\\\\-_~;,]+))?' + // end\n            '$'),\n            names: [\n                'dir1',\n                'list1',\n                'dir2',\n                'list2'\n            ],\n            format: function(o) {\n                return 'simulcast:%s %s' + (o.dir2 ? ' %s %s' : '');\n            }\n        },\n        {\n            // old simulcast draft 03 (implemented by Firefox)\n            //   https://tools.ietf.org/html/draft-ietf-mmusic-sdp-simulcast-03\n            // a=simulcast: recv pt=97;98 send pt=97\n            // a=simulcast: send rid=5;6;7 paused=6,7\n            name: 'simulcast_03',\n            reg: /^simulcast:[\\s\\t]+([\\S+\\s\\t]+)$/,\n            names: [\n                'value'\n            ],\n            format: 'simulcast: %s'\n        },\n        {\n            // a=framerate:25\n            // a=framerate:29.97\n            name: 'framerate',\n            reg: /^framerate:(\\d+(?:$|\\.\\d+))/,\n            format: 'framerate:%s'\n        },\n        {\n            // RFC4570\n            // a=source-filter: incl IN IP4 239.5.2.31 10.1.15.5\n            name: 'sourceFilter',\n            reg: /^source-filter: *(excl|incl) (\\S*) (IP4|IP6|\\*) (\\S*) (.*)/,\n            names: [\n                'filterMode',\n                'netType',\n                'addressTypes',\n                'destAddress',\n                'srcList'\n            ],\n            format: 'source-filter: %s %s %s %s %s'\n        },\n        {\n            // a=bundle-only\n            name: 'bundleOnly',\n            reg: /^(bundle-only)/\n        },\n        {\n            // a=label:1\n            name: 'label',\n            reg: /^label:(.+)/,\n            format: 'label:%s'\n        },\n        {\n            // RFC version 26 for SCTP over DTLS\n            // https://tools.ietf.org/html/draft-ietf-mmusic-sctp-sdp-26#section-5\n            name: 'sctpPort',\n            reg: /^sctp-port:(\\d+)$/,\n            format: 'sctp-port:%s'\n        },\n        {\n            // RFC version 26 for SCTP over DTLS\n            // https://tools.ietf.org/html/draft-ietf-mmusic-sctp-sdp-26#section-6\n            name: 'maxMessageSize',\n            reg: /^max-message-size:(\\d+)$/,\n            format: 'max-message-size:%s'\n        },\n        {\n            // RFC7273\n            // a=ts-refclk:ptp=IEEE1588-2008:39-A7-94-FF-FE-07-CB-D0:37\n            push: 'tsRefClocks',\n            reg: /^ts-refclk:([^\\s=]*)(?:=(\\S*))?/,\n            names: [\n                'clksrc',\n                'clksrcExt'\n            ],\n            format: function(o) {\n                return 'ts-refclk:%s' + (o.clksrcExt != null ? '=%s' : '');\n            }\n        },\n        {\n            // RFC7273\n            // a=mediaclk:direct=963214424\n            name: 'mediaClk',\n            reg: /^mediaclk:(?:id=(\\S*))? *([^\\s=]*)(?:=(\\S*))?(?: *rate=(\\d+)\\/(\\d+))?/,\n            names: [\n                'id',\n                'mediaClockName',\n                'mediaClockValue',\n                'rateNumerator',\n                'rateDenominator'\n            ],\n            format: function(o) {\n                var str = 'mediaclk:';\n                str += o.id != null ? 'id=%s %s' : '%v%s';\n                str += o.mediaClockValue != null ? '=%s' : '';\n                str += o.rateNumerator != null ? ' rate=%s' : '';\n                str += o.rateDenominator != null ? '/%s' : '';\n                return str;\n            }\n        },\n        {\n            // a=keywds:keywords\n            name: 'keywords',\n            reg: /^keywds:(.+)$/,\n            format: 'keywds:%s'\n        },\n        {\n            // a=content:main\n            name: 'content',\n            reg: /^content:(.+)/,\n            format: 'content:%s'\n        },\n        // BFCP https://tools.ietf.org/html/rfc4583\n        {\n            // a=floorctrl:c-s\n            name: 'bfcpFloorCtrl',\n            reg: /^floorctrl:(c-only|s-only|c-s)/,\n            format: 'floorctrl:%s'\n        },\n        {\n            // a=confid:1\n            name: 'bfcpConfId',\n            reg: /^confid:(\\d+)/,\n            format: 'confid:%s'\n        },\n        {\n            // a=userid:1\n            name: 'bfcpUserId',\n            reg: /^userid:(\\d+)/,\n            format: 'userid:%s'\n        },\n        {\n            // a=floorid:1\n            name: 'bfcpFloorId',\n            reg: /^floorid:(.+) (?:m-stream|mstrm):(.+)/,\n            names: [\n                'id',\n                'mStream'\n            ],\n            format: 'floorid:%s mstrm:%s'\n        },\n        {\n            // any a= that we don't understand is kept verbatim on media.invalid\n            push: 'invalid',\n            names: [\n                'value'\n            ]\n        }\n    ]\n};\n// set sensible defaults to avoid polluting the grammar with boring details\nObject.keys(grammar$1).forEach(function(key) {\n    var objs = grammar$1[key];\n    objs.forEach(function(obj) {\n        if (!obj.reg) {\n            obj.reg = /(.*)/;\n        }\n        if (!obj.format) {\n            obj.format = '%s';\n        }\n    });\n});\nvar grammarExports = grammar$2.exports;\n(function(exports) {\n    var toIntIfInt = function(v) {\n        return String(Number(v)) === v ? Number(v) : v;\n    };\n    var attachProperties = function(match, location, names, rawName) {\n        if (rawName && !names) {\n            location[rawName] = toIntIfInt(match[1]);\n        } else {\n            for(var i = 0; i < names.length; i += 1){\n                if (match[i + 1] != null) {\n                    location[names[i]] = toIntIfInt(match[i + 1]);\n                }\n            }\n        }\n    };\n    var parseReg = function(obj, location, content) {\n        var needsBlank = obj.name && obj.names;\n        if (obj.push && !location[obj.push]) {\n            location[obj.push] = [];\n        } else if (needsBlank && !location[obj.name]) {\n            location[obj.name] = {};\n        }\n        var keyLocation = obj.push ? {} : // blank object that will be pushed\n        needsBlank ? location[obj.name] : location; // otherwise, named location or root\n        attachProperties(content.match(obj.reg), keyLocation, obj.names, obj.name);\n        if (obj.push) {\n            location[obj.push].push(keyLocation);\n        }\n    };\n    var grammar = grammarExports;\n    var validLine = RegExp.prototype.test.bind(/^([a-z])=(.*)/);\n    exports.parse = function(sdp) {\n        var session = {}, media = [], location = session; // points at where properties go under (one of the above)\n        // parse lines we understand\n        sdp.split(/(\\r\\n|\\r|\\n)/).filter(validLine).forEach(function(l) {\n            var type = l[0];\n            var content = l.slice(2);\n            if (type === 'm') {\n                media.push({\n                    rtp: [],\n                    fmtp: []\n                });\n                location = media[media.length - 1]; // point at latest media line\n            }\n            for(var j = 0; j < (grammar[type] || []).length; j += 1){\n                var obj = grammar[type][j];\n                if (obj.reg.test(content)) {\n                    return parseReg(obj, location, content);\n                }\n            }\n        });\n        session.media = media; // link it up\n        return session;\n    };\n    var paramReducer = function(acc, expr) {\n        var s = expr.split(/=(.+)/, 2);\n        if (s.length === 2) {\n            acc[s[0]] = toIntIfInt(s[1]);\n        } else if (s.length === 1 && expr.length > 1) {\n            acc[s[0]] = undefined;\n        }\n        return acc;\n    };\n    exports.parseParams = function(str) {\n        return str.split(/;\\s?/).reduce(paramReducer, {});\n    };\n    // For backward compatibility - alias will be removed in 3.0.0\n    exports.parseFmtpConfig = exports.parseParams;\n    exports.parsePayloads = function(str) {\n        return str.toString().split(' ').map(Number);\n    };\n    exports.parseRemoteCandidates = function(str) {\n        var candidates = [];\n        var parts = str.split(' ').map(toIntIfInt);\n        for(var i = 0; i < parts.length; i += 3){\n            candidates.push({\n                component: parts[i],\n                ip: parts[i + 1],\n                port: parts[i + 2]\n            });\n        }\n        return candidates;\n    };\n    exports.parseImageAttributes = function(str) {\n        return str.split(' ').map(function(item) {\n            return item.substring(1, item.length - 1).split(',').reduce(paramReducer, {});\n        });\n    };\n    exports.parseSimulcastStreamList = function(str) {\n        return str.split(';').map(function(stream) {\n            return stream.split(',').map(function(format) {\n                var scid, paused = false;\n                if (format[0] !== '~') {\n                    scid = toIntIfInt(format);\n                } else {\n                    scid = toIntIfInt(format.substring(1, format.length));\n                    paused = true;\n                }\n                return {\n                    scid: scid,\n                    paused: paused\n                };\n            });\n        });\n    };\n})(parser$1);\nvar grammar = grammarExports;\n// customized util.format - discards excess arguments and can void middle ones\nvar formatRegExp = /%[sdv%]/g;\nvar format = function(formatStr) {\n    var i = 1;\n    var args = arguments;\n    var len = args.length;\n    return formatStr.replace(formatRegExp, function(x) {\n        if (i >= len) {\n            return x; // missing argument\n        }\n        var arg = args[i];\n        i += 1;\n        switch(x){\n            case '%%':\n                return '%';\n            case '%s':\n                return String(arg);\n            case '%d':\n                return Number(arg);\n            case '%v':\n                return '';\n        }\n    });\n// NB: we discard excess arguments - they are typically undefined from makeLine\n};\nvar makeLine = function(type, obj, location) {\n    var str = obj.format instanceof Function ? obj.format(obj.push ? location : location[obj.name]) : obj.format;\n    var args = [\n        type + '=' + str\n    ];\n    if (obj.names) {\n        for(var i = 0; i < obj.names.length; i += 1){\n            var n = obj.names[i];\n            if (obj.name) {\n                args.push(location[obj.name][n]);\n            } else {\n                // for mLine and push attributes\n                args.push(location[obj.names[i]]);\n            }\n        }\n    } else {\n        args.push(location[obj.name]);\n    }\n    return format.apply(null, args);\n};\n// RFC specified order\n// TODO: extend this with all the rest\nvar defaultOuterOrder = [\n    'v',\n    'o',\n    's',\n    'i',\n    'u',\n    'e',\n    'p',\n    'c',\n    'b',\n    't',\n    'r',\n    'z',\n    'a'\n];\nvar defaultInnerOrder = [\n    'i',\n    'c',\n    'b',\n    'a'\n];\nvar writer$1 = function(session, opts) {\n    opts = opts || {};\n    // ensure certain properties exist\n    if (session.version == null) {\n        session.version = 0; // 'v=0' must be there (only defined version atm)\n    }\n    if (session.name == null) {\n        session.name = ' '; // 's= ' must be there if no meaningful name set\n    }\n    session.media.forEach(function(mLine) {\n        if (mLine.payloads == null) {\n            mLine.payloads = '';\n        }\n    });\n    var outerOrder = opts.outerOrder || defaultOuterOrder;\n    var innerOrder = opts.innerOrder || defaultInnerOrder;\n    var sdp = [];\n    // loop through outerOrder for matching properties on session\n    outerOrder.forEach(function(type) {\n        grammar[type].forEach(function(obj) {\n            if (obj.name in session && session[obj.name] != null) {\n                sdp.push(makeLine(type, obj, session));\n            } else if (obj.push in session && session[obj.push] != null) {\n                session[obj.push].forEach(function(el) {\n                    sdp.push(makeLine(type, obj, el));\n                });\n            }\n        });\n    });\n    // then for each media line, follow the innerOrder\n    session.media.forEach(function(mLine) {\n        sdp.push(makeLine('m', grammar.m[0], mLine));\n        innerOrder.forEach(function(type) {\n            grammar[type].forEach(function(obj) {\n                if (obj.name in mLine && mLine[obj.name] != null) {\n                    sdp.push(makeLine(type, obj, mLine));\n                } else if (obj.push in mLine && mLine[obj.push] != null) {\n                    mLine[obj.push].forEach(function(el) {\n                        sdp.push(makeLine(type, obj, el));\n                    });\n                }\n            });\n        });\n    });\n    return sdp.join('\\r\\n') + '\\r\\n';\n};\nvar parser = parser$1;\nvar writer = writer$1;\nvar write = writer;\nvar parse = parser.parse;\nparser.parseParams;\nparser.parseFmtpConfig; // Alias of parseParams().\nparser.parsePayloads;\nparser.parseRemoteCandidates;\nparser.parseImageAttributes;\nparser.parseSimulcastStreamList;\n/* The svc codec (av1/vp9) would use a very low bitrate at the begining and\nincrease slowly by the bandwidth estimator until it reach the target bitrate. The\nprocess commonly cost more than 10 seconds cause subscriber will get blur video at\nthe first few seconds. So we use a 70% of target bitrate here as the start bitrate to\neliminate this issue.\n*/ const startBitrateForSVC = 0.7;\nconst PCEvents = {\n    NegotiationStarted: 'negotiationStarted',\n    NegotiationComplete: 'negotiationComplete',\n    RTPVideoPayloadTypes: 'rtpVideoPayloadTypes'\n};\n/** @internal */ class PCTransport extends eventsExports.EventEmitter {\n    get pc() {\n        if (!this._pc) {\n            this._pc = this.createPC();\n        }\n        return this._pc;\n    }\n    constructor(config){\n        let mediaConstraints = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        let loggerOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        var _a;\n        super();\n        this.log = livekitLogger;\n        this.pendingCandidates = [];\n        this.restartingIce = false;\n        this.renegotiate = false;\n        this.trackBitrates = [];\n        this.remoteStereoMids = [];\n        this.remoteNackMids = [];\n        // debounced negotiate interface\n        this.negotiate = r((onError)=>__awaiter(this, void 0, void 0, function*() {\n                this.emit(PCEvents.NegotiationStarted);\n                try {\n                    yield this.createAndSendOffer();\n                } catch (e) {\n                    if (onError) {\n                        onError(e);\n                    } else {\n                        throw e;\n                    }\n                }\n            }), 100);\n        this.close = ()=>{\n            if (!this._pc) {\n                return;\n            }\n            this._pc.close();\n            this._pc.onconnectionstatechange = null;\n            this._pc.oniceconnectionstatechange = null;\n            this._pc.onicegatheringstatechange = null;\n            this._pc.ondatachannel = null;\n            this._pc.onnegotiationneeded = null;\n            this._pc.onsignalingstatechange = null;\n            this._pc.onicecandidate = null;\n            this._pc.ondatachannel = null;\n            this._pc.ontrack = null;\n            this._pc.onconnectionstatechange = null;\n            this._pc.oniceconnectionstatechange = null;\n            this._pc = null;\n        };\n        this.log = getLogger((_a = loggerOptions.loggerName) !== null && _a !== void 0 ? _a : LoggerNames.PCTransport);\n        this.loggerOptions = loggerOptions;\n        this.config = config;\n        this.mediaConstraints = mediaConstraints;\n        this._pc = this.createPC();\n    }\n    createPC() {\n        const pc = isChromiumBased() ? // @ts-expect-error chrome allows additional media constraints to be passed into the RTCPeerConnection constructor\n        new RTCPeerConnection(this.config, this.mediaConstraints) : new RTCPeerConnection(this.config);\n        pc.onicecandidate = (ev)=>{\n            var _a;\n            if (!ev.candidate) return;\n            (_a = this.onIceCandidate) === null || _a === void 0 ? void 0 : _a.call(this, ev.candidate);\n        };\n        pc.onicecandidateerror = (ev)=>{\n            var _a;\n            (_a = this.onIceCandidateError) === null || _a === void 0 ? void 0 : _a.call(this, ev);\n        };\n        pc.oniceconnectionstatechange = ()=>{\n            var _a;\n            (_a = this.onIceConnectionStateChange) === null || _a === void 0 ? void 0 : _a.call(this, pc.iceConnectionState);\n        };\n        pc.onsignalingstatechange = ()=>{\n            var _a;\n            (_a = this.onSignalingStatechange) === null || _a === void 0 ? void 0 : _a.call(this, pc.signalingState);\n        };\n        pc.onconnectionstatechange = ()=>{\n            var _a;\n            (_a = this.onConnectionStateChange) === null || _a === void 0 ? void 0 : _a.call(this, pc.connectionState);\n        };\n        pc.ondatachannel = (ev)=>{\n            var _a;\n            (_a = this.onDataChannel) === null || _a === void 0 ? void 0 : _a.call(this, ev);\n        };\n        pc.ontrack = (ev)=>{\n            var _a;\n            (_a = this.onTrack) === null || _a === void 0 ? void 0 : _a.call(this, ev);\n        };\n        return pc;\n    }\n    get logContext() {\n        var _a, _b;\n        return Object.assign({}, (_b = (_a = this.loggerOptions).loggerContextCb) === null || _b === void 0 ? void 0 : _b.call(_a));\n    }\n    get isICEConnected() {\n        return this._pc !== null && (this.pc.iceConnectionState === 'connected' || this.pc.iceConnectionState === 'completed');\n    }\n    addIceCandidate(candidate) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (this.pc.remoteDescription && !this.restartingIce) {\n                return this.pc.addIceCandidate(candidate);\n            }\n            this.pendingCandidates.push(candidate);\n        });\n    }\n    setRemoteDescription(sd) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            let mungedSDP = undefined;\n            if (sd.type === 'offer') {\n                let { stereoMids, nackMids } = extractStereoAndNackAudioFromOffer(sd);\n                this.remoteStereoMids = stereoMids;\n                this.remoteNackMids = nackMids;\n            } else if (sd.type === 'answer') {\n                const sdpParsed = parse((_a = sd.sdp) !== null && _a !== void 0 ? _a : '');\n                sdpParsed.media.forEach((media)=>{\n                    if (media.type === 'audio') {\n                        // mung sdp for opus bitrate settings\n                        this.trackBitrates.some((trackbr)=>{\n                            if (!trackbr.transceiver || media.mid != trackbr.transceiver.mid) {\n                                return false;\n                            }\n                            let codecPayload = 0;\n                            media.rtp.some((rtp)=>{\n                                if (rtp.codec.toUpperCase() === trackbr.codec.toUpperCase()) {\n                                    codecPayload = rtp.payload;\n                                    return true;\n                                }\n                                return false;\n                            });\n                            if (codecPayload === 0) {\n                                return true;\n                            }\n                            let fmtpFound = false;\n                            for (const fmtp of media.fmtp){\n                                if (fmtp.payload === codecPayload) {\n                                    fmtp.config = fmtp.config.split(';').filter((attr)=>!attr.includes('maxaveragebitrate')).join(';');\n                                    if (trackbr.maxbr > 0) {\n                                        fmtp.config += \";maxaveragebitrate=\".concat(trackbr.maxbr * 1000);\n                                    }\n                                    fmtpFound = true;\n                                    break;\n                                }\n                            }\n                            if (!fmtpFound) {\n                                if (trackbr.maxbr > 0) {\n                                    media.fmtp.push({\n                                        payload: codecPayload,\n                                        config: \"maxaveragebitrate=\".concat(trackbr.maxbr * 1000)\n                                    });\n                                }\n                            }\n                            return true;\n                        });\n                    }\n                });\n                mungedSDP = write(sdpParsed);\n            }\n            yield this.setMungedSDP(sd, mungedSDP, true);\n            this.pendingCandidates.forEach((candidate)=>{\n                this.pc.addIceCandidate(candidate);\n            });\n            this.pendingCandidates = [];\n            this.restartingIce = false;\n            if (this.renegotiate) {\n                this.renegotiate = false;\n                yield this.createAndSendOffer();\n            } else if (sd.type === 'answer') {\n                this.emit(PCEvents.NegotiationComplete);\n                if (sd.sdp) {\n                    const sdpParsed = parse(sd.sdp);\n                    sdpParsed.media.forEach((media)=>{\n                        if (media.type === 'video') {\n                            this.emit(PCEvents.RTPVideoPayloadTypes, media.rtp);\n                        }\n                    });\n                }\n            }\n        });\n    }\n    createAndSendOffer(options) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            if (this.onOffer === undefined) {\n                return;\n            }\n            if (options === null || options === void 0 ? void 0 : options.iceRestart) {\n                this.log.debug('restarting ICE', this.logContext);\n                this.restartingIce = true;\n            }\n            if (this._pc && this._pc.signalingState === 'have-local-offer') {\n                // we're waiting for the peer to accept our offer, so we'll just wait\n                // the only exception to this is when ICE restart is needed\n                const currentSD = this._pc.remoteDescription;\n                if ((options === null || options === void 0 ? void 0 : options.iceRestart) && currentSD) {\n                    // TODO: handle when ICE restart is needed but we don't have a remote description\n                    // the best thing to do is to recreate the peerconnection\n                    yield this._pc.setRemoteDescription(currentSD);\n                } else {\n                    this.renegotiate = true;\n                    return;\n                }\n            } else if (!this._pc || this._pc.signalingState === 'closed') {\n                this.log.warn('could not createOffer with closed peer connection', this.logContext);\n                return;\n            }\n            // actually negotiate\n            this.log.debug('starting to negotiate', this.logContext);\n            const offer = yield this.pc.createOffer(options);\n            const sdpParsed = parse((_a = offer.sdp) !== null && _a !== void 0 ? _a : '');\n            sdpParsed.media.forEach((media)=>{\n                if (media.type === 'audio') {\n                    ensureAudioNackAndStereo(media, [], []);\n                } else if (media.type === 'video') {\n                    ensureVideoDDExtensionForSVC(media);\n                    // mung sdp for codec bitrate setting that can't apply by sendEncoding\n                    this.trackBitrates.some((trackbr)=>{\n                        if (!media.msid || !trackbr.cid || !media.msid.includes(trackbr.cid)) {\n                            return false;\n                        }\n                        let codecPayload = 0;\n                        media.rtp.some((rtp)=>{\n                            if (rtp.codec.toUpperCase() === trackbr.codec.toUpperCase()) {\n                                codecPayload = rtp.payload;\n                                return true;\n                            }\n                            return false;\n                        });\n                        if (codecPayload === 0) {\n                            return true;\n                        }\n                        let fmtpFound = false;\n                        for (const fmtp of media.fmtp){\n                            if (fmtp.payload === codecPayload) {\n                                if (!fmtp.config.includes('x-google-start-bitrate')) {\n                                    fmtp.config += \";x-google-start-bitrate=\".concat(Math.round(trackbr.maxbr * startBitrateForSVC));\n                                }\n                                if (!fmtp.config.includes('x-google-max-bitrate')) {\n                                    fmtp.config += \";x-google-max-bitrate=\".concat(trackbr.maxbr);\n                                }\n                                fmtpFound = true;\n                                break;\n                            }\n                        }\n                        if (!fmtpFound) {\n                            media.fmtp.push({\n                                payload: codecPayload,\n                                config: \"x-google-start-bitrate=\".concat(Math.round(trackbr.maxbr * startBitrateForSVC), \";x-google-max-bitrate=\").concat(trackbr.maxbr)\n                            });\n                        }\n                        return true;\n                    });\n                }\n            });\n            yield this.setMungedSDP(offer, write(sdpParsed));\n            this.onOffer(offer);\n        });\n    }\n    createAndSetAnswer() {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            const answer = yield this.pc.createAnswer();\n            const sdpParsed = parse((_a = answer.sdp) !== null && _a !== void 0 ? _a : '');\n            sdpParsed.media.forEach((media)=>{\n                if (media.type === 'audio') {\n                    ensureAudioNackAndStereo(media, this.remoteStereoMids, this.remoteNackMids);\n                }\n            });\n            yield this.setMungedSDP(answer, write(sdpParsed));\n            return answer;\n        });\n    }\n    createDataChannel(label, dataChannelDict) {\n        return this.pc.createDataChannel(label, dataChannelDict);\n    }\n    addTransceiver(mediaStreamTrack, transceiverInit) {\n        return this.pc.addTransceiver(mediaStreamTrack, transceiverInit);\n    }\n    addTrack(track) {\n        if (!this._pc) {\n            throw new UnexpectedConnectionState('PC closed, cannot add track');\n        }\n        return this._pc.addTrack(track);\n    }\n    setTrackCodecBitrate(info) {\n        this.trackBitrates.push(info);\n    }\n    setConfiguration(rtcConfig) {\n        var _a;\n        if (!this._pc) {\n            throw new UnexpectedConnectionState('PC closed, cannot configure');\n        }\n        return (_a = this._pc) === null || _a === void 0 ? void 0 : _a.setConfiguration(rtcConfig);\n    }\n    canRemoveTrack() {\n        var _a;\n        return !!((_a = this._pc) === null || _a === void 0 ? void 0 : _a.removeTrack);\n    }\n    removeTrack(sender) {\n        var _a;\n        return (_a = this._pc) === null || _a === void 0 ? void 0 : _a.removeTrack(sender);\n    }\n    getConnectionState() {\n        var _a, _b;\n        return (_b = (_a = this._pc) === null || _a === void 0 ? void 0 : _a.connectionState) !== null && _b !== void 0 ? _b : 'closed';\n    }\n    getICEConnectionState() {\n        var _a, _b;\n        return (_b = (_a = this._pc) === null || _a === void 0 ? void 0 : _a.iceConnectionState) !== null && _b !== void 0 ? _b : 'closed';\n    }\n    getSignallingState() {\n        var _a, _b;\n        return (_b = (_a = this._pc) === null || _a === void 0 ? void 0 : _a.signalingState) !== null && _b !== void 0 ? _b : 'closed';\n    }\n    getTransceivers() {\n        var _a, _b;\n        return (_b = (_a = this._pc) === null || _a === void 0 ? void 0 : _a.getTransceivers()) !== null && _b !== void 0 ? _b : [];\n    }\n    getSenders() {\n        var _a, _b;\n        return (_b = (_a = this._pc) === null || _a === void 0 ? void 0 : _a.getSenders()) !== null && _b !== void 0 ? _b : [];\n    }\n    getLocalDescription() {\n        var _a;\n        return (_a = this._pc) === null || _a === void 0 ? void 0 : _a.localDescription;\n    }\n    getRemoteDescription() {\n        var _a;\n        return (_a = this.pc) === null || _a === void 0 ? void 0 : _a.remoteDescription;\n    }\n    getStats() {\n        return this.pc.getStats();\n    }\n    getConnectedAddress() {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            if (!this._pc) {\n                return;\n            }\n            let selectedCandidatePairId = '';\n            const candidatePairs = new Map();\n            // id -> candidate ip\n            const candidates = new Map();\n            const stats = yield this._pc.getStats();\n            stats.forEach((v)=>{\n                switch(v.type){\n                    case 'transport':\n                        selectedCandidatePairId = v.selectedCandidatePairId;\n                        break;\n                    case 'candidate-pair':\n                        if (selectedCandidatePairId === '' && v.selected) {\n                            selectedCandidatePairId = v.id;\n                        }\n                        candidatePairs.set(v.id, v);\n                        break;\n                    case 'remote-candidate':\n                        candidates.set(v.id, \"\".concat(v.address, \":\").concat(v.port));\n                        break;\n                }\n            });\n            if (selectedCandidatePairId === '') {\n                return undefined;\n            }\n            const selectedID = (_a = candidatePairs.get(selectedCandidatePairId)) === null || _a === void 0 ? void 0 : _a.remoteCandidateId;\n            if (selectedID === undefined) {\n                return undefined;\n            }\n            return candidates.get(selectedID);\n        });\n    }\n    setMungedSDP(sd, munged, remote) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (munged) {\n                const originalSdp = sd.sdp;\n                sd.sdp = munged;\n                try {\n                    this.log.debug(\"setting munged \".concat(remote ? 'remote' : 'local', \" description\"), this.logContext);\n                    if (remote) {\n                        yield this.pc.setRemoteDescription(sd);\n                    } else {\n                        yield this.pc.setLocalDescription(sd);\n                    }\n                    return;\n                } catch (e) {\n                    this.log.warn(\"not able to set \".concat(sd.type, \", falling back to unmodified sdp\"), Object.assign(Object.assign({}, this.logContext), {\n                        error: e,\n                        sdp: munged\n                    }));\n                    sd.sdp = originalSdp;\n                }\n            }\n            try {\n                if (remote) {\n                    yield this.pc.setRemoteDescription(sd);\n                } else {\n                    yield this.pc.setLocalDescription(sd);\n                }\n            } catch (e) {\n                // this error cannot always be caught.\n                // If the local description has a setCodecPreferences error, this error will be uncaught\n                let msg = 'unknown error';\n                if (e instanceof Error) {\n                    msg = e.message;\n                } else if (typeof e === 'string') {\n                    msg = e;\n                }\n                const fields = {\n                    error: msg,\n                    sdp: sd.sdp\n                };\n                if (!remote && this.pc.remoteDescription) {\n                    fields.remoteSdp = this.pc.remoteDescription;\n                }\n                this.log.error(\"unable to set \".concat(sd.type), Object.assign(Object.assign({}, this.logContext), {\n                    fields\n                }));\n                throw new NegotiationError(msg);\n            }\n        });\n    }\n}\nfunction ensureAudioNackAndStereo(media, stereoMids, nackMids) {\n    // found opus codec to add nack fb\n    let opusPayload = 0;\n    media.rtp.some((rtp)=>{\n        if (rtp.codec === 'opus') {\n            opusPayload = rtp.payload;\n            return true;\n        }\n        return false;\n    });\n    // add nack rtcpfb if not exist\n    if (opusPayload > 0) {\n        if (!media.rtcpFb) {\n            media.rtcpFb = [];\n        }\n        if (nackMids.includes(media.mid) && !media.rtcpFb.some((fb)=>fb.payload === opusPayload && fb.type === 'nack')) {\n            media.rtcpFb.push({\n                payload: opusPayload,\n                type: 'nack'\n            });\n        }\n        if (stereoMids.includes(media.mid)) {\n            media.fmtp.some((fmtp)=>{\n                if (fmtp.payload === opusPayload) {\n                    if (!fmtp.config.includes('stereo=1')) {\n                        fmtp.config += ';stereo=1';\n                    }\n                    return true;\n                }\n                return false;\n            });\n        }\n    }\n}\nfunction ensureVideoDDExtensionForSVC(media) {\n    var _a, _b, _c, _d;\n    const codec = (_b = (_a = media.rtp[0]) === null || _a === void 0 ? void 0 : _a.codec) === null || _b === void 0 ? void 0 : _b.toLowerCase();\n    if (!isSVCCodec(codec)) {\n        return;\n    }\n    let maxID = 0;\n    const ddFound = (_c = media.ext) === null || _c === void 0 ? void 0 : _c.some((ext)=>{\n        if (ext.uri === ddExtensionURI) {\n            return true;\n        }\n        if (ext.value > maxID) {\n            maxID = ext.value;\n        }\n        return false;\n    });\n    if (!ddFound) {\n        (_d = media.ext) === null || _d === void 0 ? void 0 : _d.push({\n            value: maxID + 1,\n            uri: ddExtensionURI\n        });\n    }\n}\nfunction extractStereoAndNackAudioFromOffer(offer) {\n    var _a;\n    const stereoMids = [];\n    const nackMids = [];\n    const sdpParsed = parse((_a = offer.sdp) !== null && _a !== void 0 ? _a : '');\n    let opusPayload = 0;\n    sdpParsed.media.forEach((media)=>{\n        var _a;\n        if (media.type === 'audio') {\n            media.rtp.some((rtp)=>{\n                if (rtp.codec === 'opus') {\n                    opusPayload = rtp.payload;\n                    return true;\n                }\n                return false;\n            });\n            if ((_a = media.rtcpFb) === null || _a === void 0 ? void 0 : _a.some((fb)=>fb.payload === opusPayload && fb.type === 'nack')) {\n                nackMids.push(media.mid);\n            }\n            media.fmtp.some((fmtp)=>{\n                if (fmtp.payload === opusPayload) {\n                    if (fmtp.config.includes('sprop-stereo=1')) {\n                        stereoMids.push(media.mid);\n                    }\n                    return true;\n                }\n                return false;\n            });\n        }\n    });\n    return {\n        stereoMids,\n        nackMids\n    };\n}\nconst defaultVideoCodec = 'vp8';\nconst publishDefaults = {\n    /**\n   * @deprecated\n   */ audioBitrate: AudioPresets.music.maxBitrate,\n    audioPreset: AudioPresets.music,\n    dtx: true,\n    red: true,\n    forceStereo: false,\n    simulcast: true,\n    screenShareEncoding: ScreenSharePresets.h1080fps15.encoding,\n    stopMicTrackOnMute: false,\n    videoCodec: defaultVideoCodec,\n    backupCodec: true\n};\nconst audioDefaults = {\n    autoGainControl: true,\n    echoCancellation: true,\n    noiseSuppression: true\n};\nconst videoDefaults = {\n    resolution: VideoPresets.h720.resolution\n};\nconst roomOptionDefaults = {\n    adaptiveStream: false,\n    dynacast: false,\n    stopLocalTrackOnUnpublish: true,\n    reconnectPolicy: new DefaultReconnectPolicy(),\n    disconnectOnPageLeave: true,\n    expWebAudioMix: false\n};\nconst roomConnectOptionDefaults = {\n    autoSubscribe: true,\n    maxRetries: 1,\n    peerConnectionTimeout: 15000,\n    websocketTimeout: 15000\n};\nvar PCTransportState;\n(function(PCTransportState) {\n    PCTransportState[PCTransportState[\"NEW\"] = 0] = \"NEW\";\n    PCTransportState[PCTransportState[\"CONNECTING\"] = 1] = \"CONNECTING\";\n    PCTransportState[PCTransportState[\"CONNECTED\"] = 2] = \"CONNECTED\";\n    PCTransportState[PCTransportState[\"FAILED\"] = 3] = \"FAILED\";\n    PCTransportState[PCTransportState[\"CLOSING\"] = 4] = \"CLOSING\";\n    PCTransportState[PCTransportState[\"CLOSED\"] = 5] = \"CLOSED\";\n})(PCTransportState || (PCTransportState = {}));\nclass PCTransportManager {\n    get needsPublisher() {\n        return this.isPublisherConnectionRequired;\n    }\n    get needsSubscriber() {\n        return this.isSubscriberConnectionRequired;\n    }\n    get currentState() {\n        return this.state;\n    }\n    constructor(rtcConfig, subscriberPrimary, loggerOptions){\n        var _a;\n        this.peerConnectionTimeout = roomConnectOptionDefaults.peerConnectionTimeout;\n        this.log = livekitLogger;\n        this.updateState = ()=>{\n            var _a;\n            const previousState = this.state;\n            const connectionStates = this.requiredTransports.map((tr)=>tr.getConnectionState());\n            if (connectionStates.every((st)=>st === 'connected')) {\n                this.state = PCTransportState.CONNECTED;\n            } else if (connectionStates.some((st)=>st === 'failed')) {\n                this.state = PCTransportState.FAILED;\n            } else if (connectionStates.some((st)=>st === 'connecting')) {\n                this.state = PCTransportState.CONNECTING;\n            } else if (connectionStates.every((st)=>st === 'closed')) {\n                this.state = PCTransportState.CLOSED;\n            } else if (connectionStates.some((st)=>st === 'closed')) {\n                this.state = PCTransportState.CLOSING;\n            } else if (connectionStates.every((st)=>st === 'new')) {\n                this.state = PCTransportState.NEW;\n            }\n            if (previousState !== this.state) {\n                this.log.debug(\"pc state change: from \".concat(PCTransportState[previousState], \" to \").concat(PCTransportState[this.state]), this.logContext);\n                (_a = this.onStateChange) === null || _a === void 0 ? void 0 : _a.call(this, this.state, this.publisher.getConnectionState(), this.subscriber.getConnectionState());\n            }\n        };\n        this.log = getLogger((_a = loggerOptions.loggerName) !== null && _a !== void 0 ? _a : LoggerNames.PCManager);\n        this.loggerOptions = loggerOptions;\n        this.isPublisherConnectionRequired = !subscriberPrimary;\n        this.isSubscriberConnectionRequired = subscriberPrimary;\n        const googConstraints = {\n            optional: [\n                {\n                    googDscp: true\n                }\n            ]\n        };\n        this.publisher = new PCTransport(rtcConfig, googConstraints, loggerOptions);\n        this.subscriber = new PCTransport(rtcConfig, loggerOptions);\n        this.publisher.onConnectionStateChange = this.updateState;\n        this.subscriber.onConnectionStateChange = this.updateState;\n        this.publisher.onIceConnectionStateChange = this.updateState;\n        this.subscriber.onIceConnectionStateChange = this.updateState;\n        this.publisher.onSignalingStatechange = this.updateState;\n        this.subscriber.onSignalingStatechange = this.updateState;\n        this.publisher.onIceCandidate = (candidate)=>{\n            var _a;\n            (_a = this.onIceCandidate) === null || _a === void 0 ? void 0 : _a.call(this, candidate, SignalTarget.PUBLISHER);\n        };\n        this.subscriber.onIceCandidate = (candidate)=>{\n            var _a;\n            (_a = this.onIceCandidate) === null || _a === void 0 ? void 0 : _a.call(this, candidate, SignalTarget.SUBSCRIBER);\n        };\n        // in subscriber primary mode, server side opens sub data channels.\n        this.subscriber.onDataChannel = (ev)=>{\n            var _a;\n            (_a = this.onDataChannel) === null || _a === void 0 ? void 0 : _a.call(this, ev);\n        };\n        this.subscriber.onTrack = (ev)=>{\n            var _a;\n            (_a = this.onTrack) === null || _a === void 0 ? void 0 : _a.call(this, ev);\n        };\n        this.publisher.onOffer = (offer)=>{\n            var _a;\n            (_a = this.onPublisherOffer) === null || _a === void 0 ? void 0 : _a.call(this, offer);\n        };\n        this.state = PCTransportState.NEW;\n        this.connectionLock = new Mutex();\n    }\n    get logContext() {\n        var _a, _b;\n        return Object.assign({}, (_b = (_a = this.loggerOptions).loggerContextCb) === null || _b === void 0 ? void 0 : _b.call(_a));\n    }\n    requirePublisher() {\n        let require = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n        this.isPublisherConnectionRequired = require;\n        this.updateState();\n    }\n    requireSubscriber() {\n        let require = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n        this.isSubscriberConnectionRequired = require;\n        this.updateState();\n    }\n    createAndSendPublisherOffer(options) {\n        return this.publisher.createAndSendOffer(options);\n    }\n    setPublisherAnswer(sd) {\n        return this.publisher.setRemoteDescription(sd);\n    }\n    removeTrack(sender) {\n        return this.publisher.removeTrack(sender);\n    }\n    close() {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (this.publisher && this.publisher.getSignallingState() !== 'closed') {\n                const publisher = this.publisher;\n                for (const sender of publisher.getSenders()){\n                    try {\n                        // TODO: react-native-webrtc doesn't have removeTrack yet.\n                        if (publisher.canRemoveTrack()) {\n                            publisher.removeTrack(sender);\n                        }\n                    } catch (e) {\n                        this.log.warn('could not removeTrack', Object.assign(Object.assign({}, this.logContext), {\n                            error: e\n                        }));\n                    }\n                }\n            }\n            yield Promise.all([\n                this.publisher.close(),\n                this.subscriber.close()\n            ]);\n            this.updateState();\n        });\n    }\n    triggerIceRestart() {\n        return __awaiter(this, void 0, void 0, function*() {\n            this.subscriber.restartingIce = true;\n            // only restart publisher if it's needed\n            if (this.needsPublisher) {\n                yield this.createAndSendPublisherOffer({\n                    iceRestart: true\n                });\n            }\n        });\n    }\n    addIceCandidate(candidate, target) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (target === SignalTarget.PUBLISHER) {\n                yield this.publisher.addIceCandidate(candidate);\n            } else {\n                yield this.subscriber.addIceCandidate(candidate);\n            }\n        });\n    }\n    createSubscriberAnswerFromOffer(sd) {\n        return __awaiter(this, void 0, void 0, function*() {\n            this.log.debug('received server offer', Object.assign(Object.assign({}, this.logContext), {\n                RTCSdpType: sd.type,\n                sdp: sd.sdp,\n                signalingState: this.subscriber.getSignallingState().toString()\n            }));\n            yield this.subscriber.setRemoteDescription(sd);\n            // answer the offer\n            const answer = yield this.subscriber.createAndSetAnswer();\n            return answer;\n        });\n    }\n    updateConfiguration(config, iceRestart) {\n        this.publisher.setConfiguration(config);\n        this.subscriber.setConfiguration(config);\n        if (iceRestart) {\n            this.triggerIceRestart();\n        }\n    }\n    ensurePCTransportConnection(abortController, timeout) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            const unlock = yield this.connectionLock.lock();\n            try {\n                if (this.isPublisherConnectionRequired && this.publisher.getConnectionState() !== 'connected' && this.publisher.getConnectionState() !== 'connecting') {\n                    this.log.debug('negotiation required, start negotiating', this.logContext);\n                    this.publisher.negotiate();\n                }\n                yield Promise.all((_a = this.requiredTransports) === null || _a === void 0 ? void 0 : _a.map((transport)=>this.ensureTransportConnected(transport, abortController, timeout)));\n            } finally{\n                unlock();\n            }\n        });\n    }\n    negotiate(abortController) {\n        return __awaiter(this, void 0, void 0, function*() {\n            return new Promise((resolve, reject)=>__awaiter(this, void 0, void 0, function*() {\n                    const negotiationTimeout = setTimeout(()=>{\n                        reject('negotiation timed out');\n                    }, this.peerConnectionTimeout);\n                    const abortHandler = ()=>{\n                        clearTimeout(negotiationTimeout);\n                        reject('negotiation aborted');\n                    };\n                    abortController.signal.addEventListener('abort', abortHandler);\n                    this.publisher.once(PCEvents.NegotiationStarted, ()=>{\n                        if (abortController.signal.aborted) {\n                            return;\n                        }\n                        this.publisher.once(PCEvents.NegotiationComplete, ()=>{\n                            clearTimeout(negotiationTimeout);\n                            resolve();\n                        });\n                    });\n                    yield this.publisher.negotiate((e)=>{\n                        clearTimeout(negotiationTimeout);\n                        reject(e);\n                    });\n                }));\n        });\n    }\n    addPublisherTransceiver(track, transceiverInit) {\n        return this.publisher.addTransceiver(track, transceiverInit);\n    }\n    addPublisherTrack(track) {\n        return this.publisher.addTrack(track);\n    }\n    createPublisherDataChannel(label, dataChannelDict) {\n        return this.publisher.createDataChannel(label, dataChannelDict);\n    }\n    /**\n   * Returns the first required transport's address if no explicit target is specified\n   */ getConnectedAddress(target) {\n        if (target === SignalTarget.PUBLISHER) {\n            return this.publisher.getConnectedAddress();\n        } else if (target === SignalTarget.SUBSCRIBER) {\n            return this.publisher.getConnectedAddress();\n        }\n        return this.requiredTransports[0].getConnectedAddress();\n    }\n    get requiredTransports() {\n        const transports = [];\n        if (this.isPublisherConnectionRequired) {\n            transports.push(this.publisher);\n        }\n        if (this.isSubscriberConnectionRequired) {\n            transports.push(this.subscriber);\n        }\n        return transports;\n    }\n    ensureTransportConnected(pcTransport, abortController) {\n        let timeout = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.peerConnectionTimeout;\n        return __awaiter(this, void 0, void 0, function*() {\n            const connectionState = pcTransport.getConnectionState();\n            if (connectionState === 'connected') {\n                return;\n            }\n            return new Promise((resolve, reject)=>__awaiter(this, void 0, void 0, function*() {\n                    const abortHandler = ()=>{\n                        this.log.warn('abort transport connection', this.logContext);\n                        CriticalTimers.clearTimeout(connectTimeout);\n                        reject(new ConnectionError('room connection has been cancelled', 3 /* ConnectionErrorReason.Cancelled */ ));\n                    };\n                    if (abortController === null || abortController === void 0 ? void 0 : abortController.signal.aborted) {\n                        abortHandler();\n                    }\n                    abortController === null || abortController === void 0 ? void 0 : abortController.signal.addEventListener('abort', abortHandler);\n                    const connectTimeout = CriticalTimers.setTimeout(()=>{\n                        abortController === null || abortController === void 0 ? void 0 : abortController.signal.removeEventListener('abort', abortHandler);\n                        reject(new ConnectionError('could not establish pc connection'));\n                    }, timeout);\n                    while(this.state !== PCTransportState.CONNECTED){\n                        yield sleep(50); // FIXME we shouldn't rely on `sleep` in the connection paths, as it invokes `setTimeout` which can be drastically throttled by browser implementations\n                        if (abortController === null || abortController === void 0 ? void 0 : abortController.signal.aborted) {\n                            reject(new ConnectionError('room connection has been cancelled', 3 /* ConnectionErrorReason.Cancelled */ ));\n                            return;\n                        }\n                    }\n                    CriticalTimers.clearTimeout(connectTimeout);\n                    abortController === null || abortController === void 0 ? void 0 : abortController.signal.removeEventListener('abort', abortHandler);\n                    resolve();\n                }));\n        });\n    }\n}\nconst lossyDataChannel = '_lossy';\nconst reliableDataChannel = '_reliable';\nconst minReconnectWait = 2 * 1000;\nconst leaveReconnect = 'leave-reconnect';\nvar PCState;\n(function(PCState) {\n    PCState[PCState[\"New\"] = 0] = \"New\";\n    PCState[PCState[\"Connected\"] = 1] = \"Connected\";\n    PCState[PCState[\"Disconnected\"] = 2] = \"Disconnected\";\n    PCState[PCState[\"Reconnecting\"] = 3] = \"Reconnecting\";\n    PCState[PCState[\"Closed\"] = 4] = \"Closed\";\n})(PCState || (PCState = {}));\n/** @internal */ class RTCEngine extends eventsExports.EventEmitter {\n    get isClosed() {\n        return this._isClosed;\n    }\n    constructor(options){\n        var _a;\n        super();\n        this.options = options;\n        this.rtcConfig = {};\n        this.peerConnectionTimeout = roomConnectOptionDefaults.peerConnectionTimeout;\n        this.fullReconnectOnNext = false;\n        this.subscriberPrimary = false;\n        this.pcState = PCState.New;\n        this._isClosed = true;\n        this.pendingTrackResolvers = {};\n        this.reconnectAttempts = 0;\n        this.reconnectStart = 0;\n        this.attemptingReconnect = false;\n        /** keeps track of how often an initial join connection has been tried */ this.joinAttempts = 0;\n        /** specifies how often an initial join connection is allowed to retry */ this.maxJoinAttempts = 1;\n        this.shouldFailNext = false;\n        this.log = livekitLogger;\n        this.handleDataChannel = (_ref)=>{\n            let { channel } = _ref;\n            return __awaiter(this, void 0, void 0, function*() {\n                if (!channel) {\n                    return;\n                }\n                if (channel.label === reliableDataChannel) {\n                    this.reliableDCSub = channel;\n                } else if (channel.label === lossyDataChannel) {\n                    this.lossyDCSub = channel;\n                } else {\n                    return;\n                }\n                this.log.debug(\"on data channel \".concat(channel.id, \", \").concat(channel.label), this.logContext);\n                channel.onmessage = this.handleDataMessage;\n            });\n        };\n        this.handleDataMessage = (message)=>__awaiter(this, void 0, void 0, function*() {\n                var _b, _c;\n                // make sure to respect incoming data message order by processing message events one after the other\n                const unlock = yield this.dataProcessLock.lock();\n                try {\n                    // decode\n                    let buffer;\n                    if (message.data instanceof ArrayBuffer) {\n                        buffer = message.data;\n                    } else if (message.data instanceof Blob) {\n                        buffer = yield message.data.arrayBuffer();\n                    } else {\n                        this.log.error('unsupported data type', Object.assign(Object.assign({}, this.logContext), {\n                            data: message.data\n                        }));\n                        return;\n                    }\n                    const dp = DataPacket.fromBinary(new Uint8Array(buffer));\n                    if (((_b = dp.value) === null || _b === void 0 ? void 0 : _b.case) === 'speaker') {\n                        // dispatch speaker updates\n                        this.emit(EngineEvent.ActiveSpeakersUpdate, dp.value.value.speakers);\n                    } else if (((_c = dp.value) === null || _c === void 0 ? void 0 : _c.case) === 'user') {\n                        this.emit(EngineEvent.DataPacketReceived, dp.value.value, dp.kind);\n                    }\n                } finally{\n                    unlock();\n                }\n            });\n        this.handleDataError = (event)=>{\n            const channel = event.currentTarget;\n            const channelKind = channel.maxRetransmits === 0 ? 'lossy' : 'reliable';\n            if (event instanceof ErrorEvent && event.error) {\n                const { error } = event.error;\n                this.log.error(\"DataChannel error on \".concat(channelKind, \": \").concat(event.message), Object.assign(Object.assign({}, this.logContext), {\n                    error\n                }));\n            } else {\n                this.log.error(\"Unknown DataChannel error on \".concat(channelKind), Object.assign(Object.assign({}, this.logContext), {\n                    event\n                }));\n            }\n        };\n        this.handleBufferedAmountLow = (event)=>{\n            const channel = event.currentTarget;\n            const channelKind = channel.maxRetransmits === 0 ? DataPacket_Kind.LOSSY : DataPacket_Kind.RELIABLE;\n            this.updateAndEmitDCBufferStatus(channelKind);\n        };\n        // websocket reconnect behavior. if websocket is interrupted, and the PeerConnection\n        // continues to work, we can reconnect to websocket to continue the session\n        // after a number of retries, we'll close and give up permanently\n        this.handleDisconnect = (connection, disconnectReason)=>{\n            if (this._isClosed) {\n                return;\n            }\n            this.log.warn(\"\".concat(connection, \" disconnected\"), this.logContext);\n            if (this.reconnectAttempts === 0) {\n                // only reset start time on the first try\n                this.reconnectStart = Date.now();\n            }\n            const disconnect = (duration)=>{\n                this.log.warn(\"could not recover connection after \".concat(this.reconnectAttempts, \" attempts, \").concat(duration, \"ms. giving up\"), this.logContext);\n                this.emit(EngineEvent.Disconnected);\n                this.close();\n            };\n            const duration = Date.now() - this.reconnectStart;\n            let delay = this.getNextRetryDelay({\n                elapsedMs: duration,\n                retryCount: this.reconnectAttempts\n            });\n            if (delay === null) {\n                disconnect(duration);\n                return;\n            }\n            if (connection === leaveReconnect) {\n                delay = 0;\n            }\n            this.log.debug(\"reconnecting in \".concat(delay, \"ms\"), this.logContext);\n            this.clearReconnectTimeout();\n            if (this.token && this.regionUrlProvider) {\n                // token may have been refreshed, we do not want to recreate the regionUrlProvider\n                // since the current engine may have inherited a regional url\n                this.regionUrlProvider.updateToken(this.token);\n            }\n            this.reconnectTimeout = CriticalTimers.setTimeout(()=>this.attemptReconnect(disconnectReason), delay);\n        };\n        this.waitForRestarted = ()=>{\n            return new Promise((resolve, reject)=>{\n                if (this.pcState === PCState.Connected) {\n                    resolve();\n                }\n                const onRestarted = ()=>{\n                    this.off(EngineEvent.Disconnected, onDisconnected);\n                    resolve();\n                };\n                const onDisconnected = ()=>{\n                    this.off(EngineEvent.Restarted, onRestarted);\n                    reject();\n                };\n                this.once(EngineEvent.Restarted, onRestarted);\n                this.once(EngineEvent.Disconnected, onDisconnected);\n            });\n        };\n        this.updateAndEmitDCBufferStatus = (kind)=>{\n            const status = this.isBufferStatusLow(kind);\n            if (typeof status !== 'undefined' && status !== this.dcBufferStatus.get(kind)) {\n                this.dcBufferStatus.set(kind, status);\n                this.emit(EngineEvent.DCBufferStatusChanged, status, kind);\n            }\n        };\n        this.isBufferStatusLow = (kind)=>{\n            const dc = this.dataChannelForKind(kind);\n            if (dc) {\n                return dc.bufferedAmount <= dc.bufferedAmountLowThreshold;\n            }\n        };\n        this.handleBrowserOnLine = ()=>{\n            // in case the engine is currently reconnecting, attempt a reconnect immediately after the browser state has changed to 'onLine'\n            if (this.client.currentState === SignalConnectionState.RECONNECTING) {\n                this.clearReconnectTimeout();\n                this.attemptReconnect(ReconnectReason.RR_SIGNAL_DISCONNECTED);\n            }\n        };\n        this.log = getLogger((_a = options.loggerName) !== null && _a !== void 0 ? _a : LoggerNames.Engine);\n        this.loggerOptions = {\n            loggerName: options.loggerName,\n            loggerContextCb: ()=>this.logContext\n        };\n        this.client = new SignalClient(undefined, this.loggerOptions);\n        this.client.signalLatency = this.options.expSignalLatency;\n        this.reconnectPolicy = this.options.reconnectPolicy;\n        this.registerOnLineListener();\n        this.closingLock = new Mutex();\n        this.dataProcessLock = new Mutex();\n        this.dcBufferStatus = new Map([\n            [\n                DataPacket_Kind.LOSSY,\n                true\n            ],\n            [\n                DataPacket_Kind.RELIABLE,\n                true\n            ]\n        ]);\n        this.client.onParticipantUpdate = (updates)=>this.emit(EngineEvent.ParticipantUpdate, updates);\n        this.client.onConnectionQuality = (update)=>this.emit(EngineEvent.ConnectionQualityUpdate, update);\n        this.client.onRoomUpdate = (update)=>this.emit(EngineEvent.RoomUpdate, update);\n        this.client.onSubscriptionError = (resp)=>this.emit(EngineEvent.SubscriptionError, resp);\n        this.client.onSubscriptionPermissionUpdate = (update)=>this.emit(EngineEvent.SubscriptionPermissionUpdate, update);\n        this.client.onSpeakersChanged = (update)=>this.emit(EngineEvent.SpeakersChanged, update);\n        this.client.onStreamStateUpdate = (update)=>this.emit(EngineEvent.StreamStateChanged, update);\n    }\n    /** @internal */ get logContext() {\n        var _a, _b, _c, _d, _e, _f;\n        return {\n            room: (_b = (_a = this.latestJoinResponse) === null || _a === void 0 ? void 0 : _a.room) === null || _b === void 0 ? void 0 : _b.name,\n            roomSid: (_d = (_c = this.latestJoinResponse) === null || _c === void 0 ? void 0 : _c.room) === null || _d === void 0 ? void 0 : _d.sid,\n            identity: (_f = (_e = this.latestJoinResponse) === null || _e === void 0 ? void 0 : _e.participant) === null || _f === void 0 ? void 0 : _f.identity\n        };\n    }\n    join(url, token, opts, abortSignal) {\n        return __awaiter(this, void 0, void 0, function*() {\n            this.url = url;\n            this.token = token;\n            this.signalOpts = opts;\n            this.maxJoinAttempts = opts.maxRetries;\n            try {\n                this.joinAttempts += 1;\n                this.setupSignalClientCallbacks();\n                const joinResponse = yield this.client.join(url, token, opts, abortSignal);\n                this._isClosed = false;\n                this.latestJoinResponse = joinResponse;\n                this.subscriberPrimary = joinResponse.subscriberPrimary;\n                if (!this.pcManager) {\n                    yield this.configure(joinResponse);\n                }\n                // create offer\n                if (!this.subscriberPrimary) {\n                    this.negotiate();\n                }\n                this.clientConfiguration = joinResponse.clientConfiguration;\n                return joinResponse;\n            } catch (e) {\n                if (e instanceof ConnectionError) {\n                    if (e.reason === 1 /* ConnectionErrorReason.ServerUnreachable */ ) {\n                        this.log.warn(\"Couldn't connect to server, attempt \".concat(this.joinAttempts, \" of \").concat(this.maxJoinAttempts), this.logContext);\n                        if (this.joinAttempts < this.maxJoinAttempts) {\n                            return this.join(url, token, opts, abortSignal);\n                        }\n                    }\n                }\n                throw e;\n            }\n        });\n    }\n    close() {\n        return __awaiter(this, void 0, void 0, function*() {\n            const unlock = yield this.closingLock.lock();\n            if (this.isClosed) {\n                unlock();\n                return;\n            }\n            try {\n                this._isClosed = true;\n                this.emit(EngineEvent.Closing);\n                this.removeAllListeners();\n                this.deregisterOnLineListener();\n                this.clearPendingReconnect();\n                yield this.cleanupPeerConnections();\n                yield this.cleanupClient();\n            } finally{\n                unlock();\n            }\n        });\n    }\n    cleanupPeerConnections() {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            yield (_a = this.pcManager) === null || _a === void 0 ? void 0 : _a.close();\n            this.pcManager = undefined;\n            const dcCleanup = (dc)=>{\n                if (!dc) return;\n                dc.close();\n                dc.onbufferedamountlow = null;\n                dc.onclose = null;\n                dc.onclosing = null;\n                dc.onerror = null;\n                dc.onmessage = null;\n                dc.onopen = null;\n            };\n            dcCleanup(this.lossyDC);\n            dcCleanup(this.lossyDCSub);\n            dcCleanup(this.reliableDC);\n            dcCleanup(this.reliableDCSub);\n            this.lossyDC = undefined;\n            this.lossyDCSub = undefined;\n            this.reliableDC = undefined;\n            this.reliableDCSub = undefined;\n        });\n    }\n    cleanupClient() {\n        return __awaiter(this, void 0, void 0, function*() {\n            yield this.client.close();\n            this.client.resetCallbacks();\n        });\n    }\n    addTrack(req) {\n        if (this.pendingTrackResolvers[req.cid]) {\n            throw new TrackInvalidError('a track with the same ID has already been published');\n        }\n        return new Promise((resolve, reject)=>{\n            const publicationTimeout = setTimeout(()=>{\n                delete this.pendingTrackResolvers[req.cid];\n                reject(new ConnectionError('publication of local track timed out, no response from server'));\n            }, 10000);\n            this.pendingTrackResolvers[req.cid] = {\n                resolve: (info)=>{\n                    clearTimeout(publicationTimeout);\n                    resolve(info);\n                },\n                reject: ()=>{\n                    clearTimeout(publicationTimeout);\n                    reject(new Error('Cancelled publication by calling unpublish'));\n                }\n            };\n            this.client.sendAddTrack(req);\n        });\n    }\n    /**\n   * Removes sender from PeerConnection, returning true if it was removed successfully\n   * and a negotiation is necessary\n   * @param sender\n   * @returns\n   */ removeTrack(sender) {\n        if (sender.track && this.pendingTrackResolvers[sender.track.id]) {\n            const { reject } = this.pendingTrackResolvers[sender.track.id];\n            if (reject) {\n                reject();\n            }\n            delete this.pendingTrackResolvers[sender.track.id];\n        }\n        try {\n            this.pcManager.removeTrack(sender);\n            return true;\n        } catch (e) {\n            this.log.warn('failed to remove track', Object.assign(Object.assign({}, this.logContext), {\n                error: e\n            }));\n        }\n        return false;\n    }\n    updateMuteStatus(trackSid, muted) {\n        this.client.sendMuteTrack(trackSid, muted);\n    }\n    get dataSubscriberReadyState() {\n        var _a;\n        return (_a = this.reliableDCSub) === null || _a === void 0 ? void 0 : _a.readyState;\n    }\n    getConnectedServerAddress() {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            return (_a = this.pcManager) === null || _a === void 0 ? void 0 : _a.getConnectedAddress();\n        });\n    }\n    /* @internal */ setRegionUrlProvider(provider) {\n        this.regionUrlProvider = provider;\n    }\n    configure(joinResponse) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            // already configured\n            if (this.pcManager && this.pcManager.currentState !== PCTransportState.NEW) {\n                return;\n            }\n            this.participantSid = (_a = joinResponse.participant) === null || _a === void 0 ? void 0 : _a.sid;\n            const rtcConfig = this.makeRTCConfiguration(joinResponse);\n            this.pcManager = new PCTransportManager(rtcConfig, joinResponse.subscriberPrimary, this.loggerOptions);\n            this.emit(EngineEvent.TransportsCreated, this.pcManager.publisher, this.pcManager.subscriber);\n            this.pcManager.onIceCandidate = (candidate, target)=>{\n                this.client.sendIceCandidate(candidate, target);\n            };\n            this.pcManager.onPublisherOffer = (offer)=>{\n                this.client.sendOffer(offer);\n            };\n            this.pcManager.onDataChannel = this.handleDataChannel;\n            this.pcManager.onStateChange = (connectionState, publisherState, subscriberState)=>__awaiter(this, void 0, void 0, function*() {\n                    this.log.debug(\"primary PC state changed \".concat(connectionState), this.logContext);\n                    if (connectionState === PCTransportState.CONNECTED) {\n                        const shouldEmit = this.pcState === PCState.New;\n                        this.pcState = PCState.Connected;\n                        if (shouldEmit) {\n                            this.emit(EngineEvent.Connected, joinResponse);\n                        }\n                    } else if (connectionState === PCTransportState.FAILED) {\n                        // on Safari, PeerConnection will switch to 'disconnected' during renegotiation\n                        if (this.pcState === PCState.Connected) {\n                            this.pcState = PCState.Disconnected;\n                            this.handleDisconnect('peerconnection failed', subscriberState === 'failed' ? ReconnectReason.RR_SUBSCRIBER_FAILED : ReconnectReason.RR_PUBLISHER_FAILED);\n                        }\n                    }\n                });\n            this.pcManager.onTrack = (ev)=>{\n                this.emit(EngineEvent.MediaTrackAdded, ev.track, ev.streams[0], ev.receiver);\n            };\n            this.createDataChannels();\n        });\n    }\n    setupSignalClientCallbacks() {\n        // configure signaling client\n        this.client.onAnswer = (sd)=>__awaiter(this, void 0, void 0, function*() {\n                if (!this.pcManager) {\n                    return;\n                }\n                this.log.debug('received server answer', Object.assign(Object.assign({}, this.logContext), {\n                    RTCSdpType: sd.type\n                }));\n                yield this.pcManager.setPublisherAnswer(sd);\n            });\n        // add candidate on trickle\n        this.client.onTrickle = (candidate, target)=>{\n            if (!this.pcManager) {\n                return;\n            }\n            this.log.trace('got ICE candidate from peer', Object.assign(Object.assign({}, this.logContext), {\n                candidate,\n                target\n            }));\n            this.pcManager.addIceCandidate(candidate, target);\n        };\n        // when server creates an offer for the client\n        this.client.onOffer = (sd)=>__awaiter(this, void 0, void 0, function*() {\n                if (!this.pcManager) {\n                    return;\n                }\n                const answer = yield this.pcManager.createSubscriberAnswerFromOffer(sd);\n                this.client.sendAnswer(answer);\n            });\n        this.client.onLocalTrackPublished = (res)=>{\n            var _a;\n            this.log.debug('received trackPublishedResponse', Object.assign(Object.assign({}, this.logContext), {\n                cid: res.cid,\n                track: (_a = res.track) === null || _a === void 0 ? void 0 : _a.sid\n            }));\n            if (!this.pendingTrackResolvers[res.cid]) {\n                this.log.error(\"missing track resolver for \".concat(res.cid), Object.assign(Object.assign({}, this.logContext), {\n                    cid: res.cid\n                }));\n                return;\n            }\n            const { resolve } = this.pendingTrackResolvers[res.cid];\n            delete this.pendingTrackResolvers[res.cid];\n            resolve(res.track);\n        };\n        this.client.onLocalTrackUnpublished = (response)=>{\n            this.emit(EngineEvent.LocalTrackUnpublished, response);\n        };\n        this.client.onTokenRefresh = (token)=>{\n            this.token = token;\n        };\n        this.client.onRemoteMuteChanged = (trackSid, muted)=>{\n            this.emit(EngineEvent.RemoteMute, trackSid, muted);\n        };\n        this.client.onSubscribedQualityUpdate = (update)=>{\n            this.emit(EngineEvent.SubscribedQualityUpdate, update);\n        };\n        this.client.onClose = ()=>{\n            this.handleDisconnect('signal', ReconnectReason.RR_SIGNAL_DISCONNECTED);\n        };\n        this.client.onLeave = (leave)=>{\n            if (leave === null || leave === void 0 ? void 0 : leave.canReconnect) {\n                this.fullReconnectOnNext = true;\n                // reconnect immediately instead of waiting for next attempt\n                this.handleDisconnect(leaveReconnect);\n            } else {\n                this.emit(EngineEvent.Disconnected, leave === null || leave === void 0 ? void 0 : leave.reason);\n                this.close();\n            }\n            this.log.debug('client leave request', Object.assign(Object.assign({}, this.logContext), {\n                reason: leave === null || leave === void 0 ? void 0 : leave.reason\n            }));\n        };\n    }\n    makeRTCConfiguration(serverResponse) {\n        var _a;\n        const rtcConfig = Object.assign({}, this.rtcConfig);\n        if ((_a = this.signalOpts) === null || _a === void 0 ? void 0 : _a.e2eeEnabled) {\n            this.log.debug('E2EE - setting up transports with insertable streams', this.logContext);\n            //  this makes sure that no data is sent before the transforms are ready\n            // @ts-ignore\n            rtcConfig.encodedInsertableStreams = true;\n        }\n        // update ICE servers before creating PeerConnection\n        if (serverResponse.iceServers && !rtcConfig.iceServers) {\n            const rtcIceServers = [];\n            serverResponse.iceServers.forEach((iceServer)=>{\n                const rtcIceServer = {\n                    urls: iceServer.urls\n                };\n                if (iceServer.username) rtcIceServer.username = iceServer.username;\n                if (iceServer.credential) {\n                    rtcIceServer.credential = iceServer.credential;\n                }\n                rtcIceServers.push(rtcIceServer);\n            });\n            rtcConfig.iceServers = rtcIceServers;\n        }\n        if (serverResponse.clientConfiguration && serverResponse.clientConfiguration.forceRelay === ClientConfigSetting.ENABLED) {\n            rtcConfig.iceTransportPolicy = 'relay';\n        }\n        // @ts-ignore\n        rtcConfig.sdpSemantics = 'unified-plan';\n        // @ts-ignore\n        rtcConfig.continualGatheringPolicy = 'gather_continually';\n        return rtcConfig;\n    }\n    createDataChannels() {\n        if (!this.pcManager) {\n            return;\n        }\n        // clear old data channel callbacks if recreate\n        if (this.lossyDC) {\n            this.lossyDC.onmessage = null;\n            this.lossyDC.onerror = null;\n        }\n        if (this.reliableDC) {\n            this.reliableDC.onmessage = null;\n            this.reliableDC.onerror = null;\n        }\n        // create data channels\n        this.lossyDC = this.pcManager.createPublisherDataChannel(lossyDataChannel, {\n            // will drop older packets that arrive\n            ordered: true,\n            maxRetransmits: 0\n        });\n        this.reliableDC = this.pcManager.createPublisherDataChannel(reliableDataChannel, {\n            ordered: true\n        });\n        // also handle messages over the pub channel, for backwards compatibility\n        this.lossyDC.onmessage = this.handleDataMessage;\n        this.reliableDC.onmessage = this.handleDataMessage;\n        // handle datachannel errors\n        this.lossyDC.onerror = this.handleDataError;\n        this.reliableDC.onerror = this.handleDataError;\n        // set up dc buffer threshold, set to 64kB (otherwise 0 by default)\n        this.lossyDC.bufferedAmountLowThreshold = 65535;\n        this.reliableDC.bufferedAmountLowThreshold = 65535;\n        // handle buffer amount low events\n        this.lossyDC.onbufferedamountlow = this.handleBufferedAmountLow;\n        this.reliableDC.onbufferedamountlow = this.handleBufferedAmountLow;\n    }\n    setPreferredCodec(transceiver, kind, videoCodec) {\n        if (!('getCapabilities' in RTCRtpSender)) {\n            return;\n        }\n        const cap = RTCRtpSender.getCapabilities(kind);\n        if (!cap) return;\n        this.log.debug('get sender capabilities', Object.assign(Object.assign({}, this.logContext), {\n            cap\n        }));\n        const matched = [];\n        const partialMatched = [];\n        const unmatched = [];\n        cap.codecs.forEach((c)=>{\n            const codec = c.mimeType.toLowerCase();\n            if (codec === 'audio/opus') {\n                matched.push(c);\n                return;\n            }\n            const matchesVideoCodec = codec === \"video/\".concat(videoCodec);\n            if (!matchesVideoCodec) {\n                unmatched.push(c);\n                return;\n            }\n            // for h264 codecs that have sdpFmtpLine available, use only if the\n            // profile-level-id is 42e01f for cross-browser compatibility\n            if (videoCodec === 'h264') {\n                if (c.sdpFmtpLine && c.sdpFmtpLine.includes('profile-level-id=42e01f')) {\n                    matched.push(c);\n                } else {\n                    partialMatched.push(c);\n                }\n                return;\n            }\n            matched.push(c);\n        });\n        if (supportsSetCodecPreferences(transceiver)) {\n            transceiver.setCodecPreferences(matched.concat(partialMatched, unmatched));\n        }\n    }\n    createSender(track, opts, encodings) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (supportsTransceiver()) {\n                const sender = yield this.createTransceiverRTCRtpSender(track, opts, encodings);\n                return sender;\n            }\n            if (supportsAddTrack()) {\n                this.log.warn('using add-track fallback', this.logContext);\n                const sender = yield this.createRTCRtpSender(track.mediaStreamTrack);\n                return sender;\n            }\n            throw new UnexpectedConnectionState('Required webRTC APIs not supported on this device');\n        });\n    }\n    createSimulcastSender(track, simulcastTrack, opts, encodings) {\n        return __awaiter(this, void 0, void 0, function*() {\n            // store RTCRtpSender\n            if (supportsTransceiver()) {\n                return this.createSimulcastTransceiverSender(track, simulcastTrack, opts, encodings);\n            }\n            if (supportsAddTrack()) {\n                this.log.debug('using add-track fallback', this.logContext);\n                return this.createRTCRtpSender(track.mediaStreamTrack);\n            }\n            throw new UnexpectedConnectionState('Cannot stream on this device');\n        });\n    }\n    createTransceiverRTCRtpSender(track, opts, encodings) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (!this.pcManager) {\n                throw new UnexpectedConnectionState('publisher is closed');\n            }\n            const streams = [];\n            if (track.mediaStream) {\n                streams.push(track.mediaStream);\n            }\n            const transceiverInit = {\n                direction: 'sendonly',\n                streams\n            };\n            if (encodings) {\n                transceiverInit.sendEncodings = encodings;\n            }\n            // addTransceiver for react-native is async. web is synchronous, but await won't effect it.\n            const transceiver = yield this.pcManager.addPublisherTransceiver(track.mediaStreamTrack, transceiverInit);\n            if (track.kind === Track.Kind.Video && opts.videoCodec) {\n                this.setPreferredCodec(transceiver, track.kind, opts.videoCodec);\n                track.codec = opts.videoCodec;\n            }\n            return transceiver.sender;\n        });\n    }\n    createSimulcastTransceiverSender(track, simulcastTrack, opts, encodings) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (!this.pcManager) {\n                throw new UnexpectedConnectionState('publisher is closed');\n            }\n            const transceiverInit = {\n                direction: 'sendonly'\n            };\n            if (encodings) {\n                transceiverInit.sendEncodings = encodings;\n            }\n            // addTransceiver for react-native is async. web is synchronous, but await won't effect it.\n            const transceiver = yield this.pcManager.addPublisherTransceiver(simulcastTrack.mediaStreamTrack, transceiverInit);\n            if (!opts.videoCodec) {\n                return;\n            }\n            this.setPreferredCodec(transceiver, track.kind, opts.videoCodec);\n            track.setSimulcastTrackSender(opts.videoCodec, transceiver.sender);\n            return transceiver.sender;\n        });\n    }\n    createRTCRtpSender(track) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (!this.pcManager) {\n                throw new UnexpectedConnectionState('publisher is closed');\n            }\n            return this.pcManager.addPublisherTrack(track);\n        });\n    }\n    attemptReconnect(reason) {\n        var _a, _b, _c;\n        return __awaiter(this, void 0, void 0, function*() {\n            if (this._isClosed) {\n                return;\n            }\n            // guard for attempting reconnection multiple times while one attempt is still not finished\n            if (this.attemptingReconnect) {\n                livekitLogger.warn('already attempting reconnect, returning early', this.logContext);\n                return;\n            }\n            if (((_a = this.clientConfiguration) === null || _a === void 0 ? void 0 : _a.resumeConnection) === ClientConfigSetting.DISABLED || // signaling state could change to closed due to hardware sleep\n            // those connections cannot be resumed\n            ((_c = (_b = this.pcManager) === null || _b === void 0 ? void 0 : _b.currentState) !== null && _c !== void 0 ? _c : PCTransportState.NEW) === PCTransportState.NEW) {\n                this.fullReconnectOnNext = true;\n            }\n            try {\n                this.attemptingReconnect = true;\n                if (this.fullReconnectOnNext) {\n                    yield this.restartConnection();\n                } else {\n                    yield this.resumeConnection(reason);\n                }\n                this.clearPendingReconnect();\n                this.fullReconnectOnNext = false;\n            } catch (e) {\n                this.reconnectAttempts += 1;\n                let recoverable = true;\n                if (e instanceof UnexpectedConnectionState) {\n                    this.log.debug('received unrecoverable error', Object.assign(Object.assign({}, this.logContext), {\n                        error: e\n                    }));\n                    // unrecoverable\n                    recoverable = false;\n                } else if (!(e instanceof SignalReconnectError)) {\n                    // cannot resume\n                    this.fullReconnectOnNext = true;\n                }\n                if (recoverable) {\n                    this.handleDisconnect('reconnect', ReconnectReason.RR_UNKNOWN);\n                } else {\n                    this.log.info(\"could not recover connection after \".concat(this.reconnectAttempts, \" attempts, \").concat(Date.now() - this.reconnectStart, \"ms. giving up\"), this.logContext);\n                    this.emit(EngineEvent.Disconnected);\n                    yield this.close();\n                }\n            } finally{\n                this.attemptingReconnect = false;\n            }\n        });\n    }\n    getNextRetryDelay(context) {\n        try {\n            return this.reconnectPolicy.nextRetryDelayInMs(context);\n        } catch (e) {\n            this.log.warn('encountered error in reconnect policy', Object.assign(Object.assign({}, this.logContext), {\n                error: e\n            }));\n        }\n        // error in user code with provided reconnect policy, stop reconnecting\n        return null;\n    }\n    restartConnection(regionUrl) {\n        var _a, _b, _c;\n        return __awaiter(this, void 0, void 0, function*() {\n            try {\n                if (!this.url || !this.token) {\n                    // permanent failure, don't attempt reconnection\n                    throw new UnexpectedConnectionState('could not reconnect, url or token not saved');\n                }\n                this.log.info(\"reconnecting, attempt: \".concat(this.reconnectAttempts), this.logContext);\n                this.emit(EngineEvent.Restarting);\n                if (!this.client.isDisconnected) {\n                    yield this.client.sendLeave();\n                }\n                yield this.cleanupPeerConnections();\n                yield this.cleanupClient();\n                let joinResponse;\n                try {\n                    if (!this.signalOpts) {\n                        this.log.warn('attempted connection restart, without signal options present', this.logContext);\n                        throw new SignalReconnectError();\n                    }\n                    // in case a regionUrl is passed, the region URL takes precedence\n                    joinResponse = yield this.join(regionUrl !== null && regionUrl !== void 0 ? regionUrl : this.url, this.token, this.signalOpts);\n                } catch (e) {\n                    if (e instanceof ConnectionError && e.reason === 0 /* ConnectionErrorReason.NotAllowed */ ) {\n                        throw new UnexpectedConnectionState('could not reconnect, token might be expired');\n                    }\n                    throw new SignalReconnectError();\n                }\n                if (this.shouldFailNext) {\n                    this.shouldFailNext = false;\n                    throw new Error('simulated failure');\n                }\n                this.client.setReconnected();\n                this.emit(EngineEvent.SignalRestarted, joinResponse);\n                yield this.waitForPCReconnected();\n                // re-check signal connection state before setting engine as resumed\n                if (this.client.currentState !== SignalConnectionState.CONNECTED) {\n                    throw new SignalReconnectError('Signal connection got severed during reconnect');\n                }\n                (_a = this.regionUrlProvider) === null || _a === void 0 ? void 0 : _a.resetAttempts();\n                // reconnect success\n                this.emit(EngineEvent.Restarted);\n            } catch (error) {\n                const nextRegionUrl = yield (_b = this.regionUrlProvider) === null || _b === void 0 ? void 0 : _b.getNextBestRegionUrl();\n                if (nextRegionUrl) {\n                    yield this.restartConnection(nextRegionUrl);\n                    return;\n                } else {\n                    // no more regions to try (or we're not on cloud)\n                    (_c = this.regionUrlProvider) === null || _c === void 0 ? void 0 : _c.resetAttempts();\n                    throw error;\n                }\n            }\n        });\n    }\n    resumeConnection(reason) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            if (!this.url || !this.token) {\n                // permanent failure, don't attempt reconnection\n                throw new UnexpectedConnectionState('could not reconnect, url or token not saved');\n            }\n            // trigger publisher reconnect\n            if (!this.pcManager) {\n                throw new UnexpectedConnectionState('publisher and subscriber connections unset');\n            }\n            this.log.info(\"resuming signal connection, attempt \".concat(this.reconnectAttempts), this.logContext);\n            this.emit(EngineEvent.Resuming);\n            try {\n                this.setupSignalClientCallbacks();\n                const res = yield this.client.reconnect(this.url, this.token, this.participantSid, reason);\n                if (res) {\n                    const rtcConfig = this.makeRTCConfiguration(res);\n                    this.pcManager.updateConfiguration(rtcConfig);\n                }\n            } catch (error) {\n                let message = '';\n                if (error instanceof Error) {\n                    message = error.message;\n                    this.log.error(error.message, Object.assign(Object.assign({}, this.logContext), {\n                        error\n                    }));\n                }\n                if (error instanceof ConnectionError && error.reason === 0 /* ConnectionErrorReason.NotAllowed */ ) {\n                    throw new UnexpectedConnectionState('could not reconnect, token might be expired');\n                }\n                if (error instanceof ConnectionError && error.reason === 4 /* ConnectionErrorReason.LeaveRequest */ ) {\n                    throw error;\n                }\n                throw new SignalReconnectError(message);\n            }\n            this.emit(EngineEvent.SignalResumed);\n            if (this.shouldFailNext) {\n                this.shouldFailNext = false;\n                throw new Error('simulated failure');\n            }\n            yield this.pcManager.triggerIceRestart();\n            yield this.waitForPCReconnected();\n            // re-check signal connection state before setting engine as resumed\n            if (this.client.currentState !== SignalConnectionState.CONNECTED) {\n                throw new SignalReconnectError('Signal connection got severed during reconnect');\n            }\n            this.client.setReconnected();\n            // recreate publish datachannel if it's id is null\n            // (for safari https://bugs.webkit.org/show_bug.cgi?id=184688)\n            if (((_a = this.reliableDC) === null || _a === void 0 ? void 0 : _a.readyState) === 'open' && this.reliableDC.id === null) {\n                this.createDataChannels();\n            }\n            // resume success\n            this.emit(EngineEvent.Resumed);\n        });\n    }\n    waitForPCInitialConnection(timeout, abortController) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (!this.pcManager) {\n                throw new UnexpectedConnectionState('PC manager is closed');\n            }\n            yield this.pcManager.ensurePCTransportConnection(abortController, timeout);\n        });\n    }\n    waitForPCReconnected() {\n        return __awaiter(this, void 0, void 0, function*() {\n            this.pcState = PCState.Reconnecting;\n            this.log.debug('waiting for peer connection to reconnect', this.logContext);\n            try {\n                yield sleep(minReconnectWait); // FIXME setTimeout again not ideal for a connection critical path\n                if (!this.pcManager) {\n                    throw new UnexpectedConnectionState('PC manager is closed');\n                }\n                yield this.pcManager.ensurePCTransportConnection(undefined, this.peerConnectionTimeout);\n                this.pcState = PCState.Connected;\n            } catch (e) {\n                // TODO do we need a `failed` state here for the PC?\n                this.pcState = PCState.Disconnected;\n                throw new ConnectionError(\"could not establish PC connection, \".concat(e.message));\n            }\n        });\n    }\n    /* @internal */ sendDataPacket(packet, kind) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const msg = packet.toBinary();\n            // make sure we do have a data connection\n            yield this.ensurePublisherConnected(kind);\n            const dc = this.dataChannelForKind(kind);\n            if (dc) {\n                dc.send(msg);\n            }\n            this.updateAndEmitDCBufferStatus(kind);\n        });\n    }\n    /**\n   * @internal\n   */ ensureDataTransportConnected(kind) {\n        let subscriber = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.subscriberPrimary;\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            if (!this.pcManager) {\n                throw new UnexpectedConnectionState('PC manager is closed');\n            }\n            const transport = subscriber ? this.pcManager.subscriber : this.pcManager.publisher;\n            const transportName = subscriber ? 'Subscriber' : 'Publisher';\n            if (!transport) {\n                throw new ConnectionError(\"\".concat(transportName, \" connection not set\"));\n            }\n            if (!subscriber && !this.pcManager.publisher.isICEConnected && this.pcManager.publisher.getICEConnectionState() !== 'checking') {\n                // start negotiation\n                this.negotiate();\n            }\n            const targetChannel = this.dataChannelForKind(kind, subscriber);\n            if ((targetChannel === null || targetChannel === void 0 ? void 0 : targetChannel.readyState) === 'open') {\n                return;\n            }\n            // wait until ICE connected\n            const endTime = new Date().getTime() + this.peerConnectionTimeout;\n            while(new Date().getTime() < endTime){\n                if (transport.isICEConnected && ((_a = this.dataChannelForKind(kind, subscriber)) === null || _a === void 0 ? void 0 : _a.readyState) === 'open') {\n                    return;\n                }\n                yield sleep(50);\n            }\n            throw new ConnectionError(\"could not establish \".concat(transportName, \" connection, state: \").concat(transport.getICEConnectionState()));\n        });\n    }\n    ensurePublisherConnected(kind) {\n        return __awaiter(this, void 0, void 0, function*() {\n            yield this.ensureDataTransportConnected(kind, false);\n        });\n    }\n    /* @internal */ verifyTransport() {\n        if (!this.pcManager) {\n            return false;\n        }\n        // primary connection\n        if (this.pcManager.currentState !== PCTransportState.CONNECTED) {\n            return false;\n        }\n        // ensure signal is connected\n        if (!this.client.ws || this.client.ws.readyState === WebSocket.CLOSED) {\n            return false;\n        }\n        return true;\n    }\n    /** @internal */ negotiate() {\n        return __awaiter(this, void 0, void 0, function*() {\n            // observe signal state\n            return new Promise((resolve, reject)=>__awaiter(this, void 0, void 0, function*() {\n                    if (!this.pcManager) {\n                        reject(new NegotiationError('PC manager is closed'));\n                        return;\n                    }\n                    this.pcManager.requirePublisher();\n                    const abortController = new AbortController();\n                    const handleClosed = ()=>{\n                        abortController.abort();\n                        this.log.debug('engine disconnected while negotiation was ongoing', this.logContext);\n                        resolve();\n                        return;\n                    };\n                    if (this.isClosed) {\n                        reject('cannot negotiate on closed engine');\n                    }\n                    this.on(EngineEvent.Closing, handleClosed);\n                    this.pcManager.publisher.once(PCEvents.RTPVideoPayloadTypes, (rtpTypes)=>{\n                        const rtpMap = new Map();\n                        rtpTypes.forEach((rtp)=>{\n                            const codec = rtp.codec.toLowerCase();\n                            if (isVideoCodec(codec)) {\n                                rtpMap.set(rtp.payload, codec);\n                            }\n                        });\n                        this.emit(EngineEvent.RTPVideoMapUpdate, rtpMap);\n                    });\n                    try {\n                        yield this.pcManager.negotiate(abortController);\n                        resolve();\n                    } catch (e) {\n                        if (e instanceof NegotiationError) {\n                            this.fullReconnectOnNext = true;\n                        }\n                        this.handleDisconnect('negotiation', ReconnectReason.RR_UNKNOWN);\n                        reject(e);\n                    } finally{\n                        this.off(EngineEvent.Closing, handleClosed);\n                    }\n                }));\n        });\n    }\n    dataChannelForKind(kind, sub) {\n        if (!sub) {\n            if (kind === DataPacket_Kind.LOSSY) {\n                return this.lossyDC;\n            }\n            if (kind === DataPacket_Kind.RELIABLE) {\n                return this.reliableDC;\n            }\n        } else {\n            if (kind === DataPacket_Kind.LOSSY) {\n                return this.lossyDCSub;\n            }\n            if (kind === DataPacket_Kind.RELIABLE) {\n                return this.reliableDCSub;\n            }\n        }\n    }\n    /** @internal */ sendSyncState(remoteTracks, localTracks) {\n        var _a, _b;\n        if (!this.pcManager) {\n            this.log.warn('sync state cannot be sent without peer connection setup', this.logContext);\n            return;\n        }\n        const previousAnswer = this.pcManager.subscriber.getLocalDescription();\n        const previousOffer = this.pcManager.subscriber.getRemoteDescription();\n        /* 1. autosubscribe on, so subscribed tracks = all tracks - unsub tracks,\n          in this case, we send unsub tracks, so server add all tracks to this\n          subscribe pc and unsub special tracks from it.\n       2. autosubscribe off, we send subscribed tracks.\n    */ const autoSubscribe = (_b = (_a = this.signalOpts) === null || _a === void 0 ? void 0 : _a.autoSubscribe) !== null && _b !== void 0 ? _b : true;\n        const trackSids = new Array();\n        remoteTracks.forEach((track)=>{\n            if (track.isDesired !== autoSubscribe) {\n                trackSids.push(track.trackSid);\n            }\n        });\n        this.client.sendSyncState(new SyncState({\n            answer: previousAnswer ? toProtoSessionDescription({\n                sdp: previousAnswer.sdp,\n                type: previousAnswer.type\n            }) : undefined,\n            offer: previousOffer ? toProtoSessionDescription({\n                sdp: previousOffer.sdp,\n                type: previousOffer.type\n            }) : undefined,\n            subscription: new UpdateSubscription({\n                trackSids,\n                subscribe: !autoSubscribe,\n                participantTracks: []\n            }),\n            publishTracks: getTrackPublicationInfo(localTracks),\n            dataChannels: this.dataChannelsInfo()\n        }));\n    }\n    /* @internal */ failNext() {\n        // debugging method to fail the next reconnect/resume attempt\n        this.shouldFailNext = true;\n    }\n    dataChannelsInfo() {\n        const infos = [];\n        const getInfo = (dc, target)=>{\n            if ((dc === null || dc === void 0 ? void 0 : dc.id) !== undefined && dc.id !== null) {\n                infos.push(new DataChannelInfo({\n                    label: dc.label,\n                    id: dc.id,\n                    target\n                }));\n            }\n        };\n        getInfo(this.dataChannelForKind(DataPacket_Kind.LOSSY), SignalTarget.PUBLISHER);\n        getInfo(this.dataChannelForKind(DataPacket_Kind.RELIABLE), SignalTarget.PUBLISHER);\n        getInfo(this.dataChannelForKind(DataPacket_Kind.LOSSY, true), SignalTarget.SUBSCRIBER);\n        getInfo(this.dataChannelForKind(DataPacket_Kind.RELIABLE, true), SignalTarget.SUBSCRIBER);\n        return infos;\n    }\n    clearReconnectTimeout() {\n        if (this.reconnectTimeout) {\n            CriticalTimers.clearTimeout(this.reconnectTimeout);\n        }\n    }\n    clearPendingReconnect() {\n        this.clearReconnectTimeout();\n        this.reconnectAttempts = 0;\n    }\n    registerOnLineListener() {\n        if (isWeb()) {\n            window.addEventListener('online', this.handleBrowserOnLine);\n        }\n    }\n    deregisterOnLineListener() {\n        if (isWeb()) {\n            window.removeEventListener('online', this.handleBrowserOnLine);\n        }\n    }\n}\nclass SignalReconnectError extends Error {\n}\nclass RegionUrlProvider {\n    constructor(url, token){\n        this.lastUpdateAt = 0;\n        this.settingsCacheTime = 3000;\n        this.attemptedRegions = [];\n        this.serverUrl = new URL(url);\n        this.token = token;\n    }\n    updateToken(token) {\n        this.token = token;\n    }\n    isCloud() {\n        return isCloud(this.serverUrl);\n    }\n    getServerUrl() {\n        return this.serverUrl;\n    }\n    getNextBestRegionUrl(abortSignal) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (!this.isCloud()) {\n                throw Error('region availability is only supported for LiveKit Cloud domains');\n            }\n            if (!this.regionSettings || Date.now() - this.lastUpdateAt > this.settingsCacheTime) {\n                this.regionSettings = yield this.fetchRegionSettings(abortSignal);\n            }\n            const regionsLeft = this.regionSettings.regions.filter((region)=>!this.attemptedRegions.find((attempted)=>attempted.url === region.url));\n            if (regionsLeft.length > 0) {\n                const nextRegion = regionsLeft[0];\n                this.attemptedRegions.push(nextRegion);\n                livekitLogger.debug(\"next region: \".concat(nextRegion.region));\n                return nextRegion.url;\n            } else {\n                return null;\n            }\n        });\n    }\n    resetAttempts() {\n        this.attemptedRegions = [];\n    }\n    /* @internal */ fetchRegionSettings(signal) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const regionSettingsResponse = yield fetch(\"\".concat(getCloudConfigUrl(this.serverUrl), \"/regions\"), {\n                headers: {\n                    authorization: \"Bearer \".concat(this.token)\n                },\n                signal\n            });\n            if (regionSettingsResponse.ok) {\n                const regionSettings = yield regionSettingsResponse.json();\n                this.lastUpdateAt = Date.now();\n                return regionSettings;\n            } else {\n                throw new ConnectionError(\"Could not fetch region settings: \".concat(regionSettingsResponse.statusText), regionSettingsResponse.status === 401 ? 0 /* ConnectionErrorReason.NotAllowed */  : undefined, regionSettingsResponse.status);\n            }\n        });\n    }\n}\nfunction getCloudConfigUrl(serverUrl) {\n    return \"\".concat(serverUrl.protocol.replace('ws', 'http'), \"//\").concat(serverUrl.host, \"/settings\");\n}\nconst monitorFrequency = 2000;\nfunction computeBitrate(currentStats, prevStats) {\n    if (!prevStats) {\n        return 0;\n    }\n    let bytesNow;\n    let bytesPrev;\n    if ('bytesReceived' in currentStats) {\n        bytesNow = currentStats.bytesReceived;\n        bytesPrev = prevStats.bytesReceived;\n    } else if ('bytesSent' in currentStats) {\n        bytesNow = currentStats.bytesSent;\n        bytesPrev = prevStats.bytesSent;\n    }\n    if (bytesNow === undefined || bytesPrev === undefined || currentStats.timestamp === undefined || prevStats.timestamp === undefined) {\n        return 0;\n    }\n    return (bytesNow - bytesPrev) * 8 * 1000 / (currentStats.timestamp - prevStats.timestamp);\n}\nclass LocalAudioTrack extends LocalTrack {\n    /**\n   *\n   * @param mediaTrack\n   * @param constraints MediaTrackConstraints that are being used when restarting or reacquiring tracks\n   * @param userProvidedTrack Signals to the SDK whether or not the mediaTrack should be managed (i.e. released and reacquired) internally by the SDK\n   */ constructor(mediaTrack, constraints){\n        let userProvidedTrack = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n        let audioContext = arguments.length > 3 ? arguments[3] : undefined;\n        let loggerOptions = arguments.length > 4 ? arguments[4] : undefined;\n        super(mediaTrack, Track.Kind.Audio, constraints, userProvidedTrack, loggerOptions);\n        /** @internal */ this.stopOnMute = false;\n        this.monitorSender = ()=>__awaiter(this, void 0, void 0, function*() {\n                if (!this.sender) {\n                    this._currentBitrate = 0;\n                    return;\n                }\n                let stats;\n                try {\n                    stats = yield this.getSenderStats();\n                } catch (e) {\n                    this.log.error('could not get audio sender stats', Object.assign(Object.assign({}, this.logContext), {\n                        error: e\n                    }));\n                    return;\n                }\n                if (stats && this.prevStats) {\n                    this._currentBitrate = computeBitrate(stats, this.prevStats);\n                }\n                this.prevStats = stats;\n            });\n        this.audioContext = audioContext;\n        this.checkForSilence();\n    }\n    setDeviceId(deviceId) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (this._constraints.deviceId === deviceId) {\n                return true;\n            }\n            this._constraints.deviceId = deviceId;\n            if (!this.isMuted) {\n                yield this.restartTrack();\n            }\n            return this.isMuted || unwrapConstraint(deviceId) === this.mediaStreamTrack.getSettings().deviceId;\n        });\n    }\n    mute() {\n        const _super = Object.create(null, {\n            mute: {\n                get: ()=>super.mute\n            }\n        });\n        return __awaiter(this, void 0, void 0, function*() {\n            const unlock = yield this.muteLock.lock();\n            try {\n                // disabled special handling as it will cause BT headsets to switch communication modes\n                if (this.source === Track.Source.Microphone && this.stopOnMute && !this.isUserProvided) {\n                    this.log.debug('stopping mic track', this.logContext);\n                    // also stop the track, so that microphone indicator is turned off\n                    this._mediaStreamTrack.stop();\n                }\n                yield _super.mute.call(this);\n                return this;\n            } finally{\n                unlock();\n            }\n        });\n    }\n    unmute() {\n        const _super = Object.create(null, {\n            unmute: {\n                get: ()=>super.unmute\n            }\n        });\n        return __awaiter(this, void 0, void 0, function*() {\n            const unlock = yield this.muteLock.lock();\n            try {\n                const deviceHasChanged = this._constraints.deviceId && this._mediaStreamTrack.getSettings().deviceId !== unwrapConstraint(this._constraints.deviceId);\n                if (this.source === Track.Source.Microphone && (this.stopOnMute || this._mediaStreamTrack.readyState === 'ended' || deviceHasChanged) && !this.isUserProvided) {\n                    this.log.debug('reacquiring mic track', this.logContext);\n                    yield this.restartTrack();\n                }\n                yield _super.unmute.call(this);\n                return this;\n            } finally{\n                unlock();\n            }\n        });\n    }\n    restartTrack(options) {\n        return __awaiter(this, void 0, void 0, function*() {\n            let constraints;\n            if (options) {\n                const streamConstraints = constraintsForOptions({\n                    audio: options\n                });\n                if (typeof streamConstraints.audio !== 'boolean') {\n                    constraints = streamConstraints.audio;\n                }\n            }\n            yield this.restart(constraints);\n        });\n    }\n    restart(constraints) {\n        const _super = Object.create(null, {\n            restart: {\n                get: ()=>super.restart\n            }\n        });\n        return __awaiter(this, void 0, void 0, function*() {\n            const track = yield _super.restart.call(this, constraints);\n            this.checkForSilence();\n            return track;\n        });\n    }\n    /* @internal */ startMonitor() {\n        if (!isWeb()) {\n            return;\n        }\n        if (this.monitorInterval) {\n            return;\n        }\n        this.monitorInterval = setInterval(()=>{\n            this.monitorSender();\n        }, monitorFrequency);\n    }\n    setProcessor(processor) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            const unlock = yield this.processorLock.lock();\n            try {\n                if (!this.audioContext) {\n                    throw Error('Audio context needs to be set on LocalAudioTrack in order to enable processors');\n                }\n                if (this.processor) {\n                    yield this.stopProcessor();\n                }\n                if (this.kind === 'unknown') {\n                    throw TypeError('cannot set processor on track of unknown kind');\n                }\n                const processorOptions = {\n                    kind: this.kind,\n                    track: this._mediaStreamTrack,\n                    audioContext: this.audioContext\n                };\n                this.log.debug(\"setting up audio processor \".concat(processor.name), this.logContext);\n                yield processor.init(processorOptions);\n                this.processor = processor;\n                if (this.processor.processedTrack) {\n                    yield (_a = this.sender) === null || _a === void 0 ? void 0 : _a.replaceTrack(this.processor.processedTrack);\n                }\n            } finally{\n                unlock();\n            }\n        });\n    }\n    /**\n   * @internal\n   * @experimental\n   */ setAudioContext(audioContext) {\n        this.audioContext = audioContext;\n    }\n    getSenderStats() {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            if (!((_a = this.sender) === null || _a === void 0 ? void 0 : _a.getStats)) {\n                return undefined;\n            }\n            const stats = yield this.sender.getStats();\n            let audioStats;\n            stats.forEach((v)=>{\n                if (v.type === 'outbound-rtp') {\n                    audioStats = {\n                        type: 'audio',\n                        streamId: v.id,\n                        packetsSent: v.packetsSent,\n                        packetsLost: v.packetsLost,\n                        bytesSent: v.bytesSent,\n                        timestamp: v.timestamp,\n                        roundTripTime: v.roundTripTime,\n                        jitter: v.jitter\n                    };\n                }\n            });\n            return audioStats;\n        });\n    }\n    checkForSilence() {\n        return __awaiter(this, void 0, void 0, function*() {\n            const trackIsSilent = yield detectSilence(this);\n            if (trackIsSilent) {\n                if (!this.isMuted) {\n                    this.log.warn('silence detected on local audio track', this.logContext);\n                }\n                this.emit(TrackEvent.AudioSilenceDetected);\n            }\n            return trackIsSilent;\n        });\n    }\n}\n/** @internal */ function mediaTrackToLocalTrack(mediaStreamTrack, constraints, loggerOptions) {\n    switch(mediaStreamTrack.kind){\n        case 'audio':\n            return new LocalAudioTrack(mediaStreamTrack, constraints, false, undefined, loggerOptions);\n        case 'video':\n            return new LocalVideoTrack(mediaStreamTrack, constraints, false, loggerOptions);\n        default:\n            throw new TrackInvalidError(\"unsupported track type: \".concat(mediaStreamTrack.kind));\n    }\n}\n/* @internal */ const presets169 = Object.values(VideoPresets);\n/* @internal */ const presets43 = Object.values(VideoPresets43);\n/* @internal */ const presetsScreenShare = Object.values(ScreenSharePresets);\n/* @internal */ const defaultSimulcastPresets169 = [\n    VideoPresets.h180,\n    VideoPresets.h360\n];\n/* @internal */ const defaultSimulcastPresets43 = [\n    VideoPresets43.h180,\n    VideoPresets43.h360\n];\n/* @internal */ const computeDefaultScreenShareSimulcastPresets = (fromPreset)=>{\n    const layers = [\n        {\n            scaleResolutionDownBy: 2,\n            fps: fromPreset.encoding.maxFramerate\n        }\n    ];\n    return layers.map((t)=>{\n        var _a, _b;\n        return new VideoPreset(Math.floor(fromPreset.width / t.scaleResolutionDownBy), Math.floor(fromPreset.height / t.scaleResolutionDownBy), Math.max(150000, Math.floor(fromPreset.encoding.maxBitrate / (Math.pow(t.scaleResolutionDownBy, 2) * (((_a = fromPreset.encoding.maxFramerate) !== null && _a !== void 0 ? _a : 30) / ((_b = t.fps) !== null && _b !== void 0 ? _b : 30))))), t.fps, fromPreset.encoding.priority);\n    });\n};\n// /**\n//  *\n//  * @internal\n//  * @experimental\n//  */\n// const computeDefaultMultiCodecSimulcastEncodings = (width: number, height: number) => {\n//   // use vp8 as a default\n//   const vp8 = determineAppropriateEncoding(false, width, height);\n//   const vp9 = { ...vp8, maxBitrate: vp8.maxBitrate * 0.9 };\n//   const h264 = { ...vp8, maxBitrate: vp8.maxBitrate * 1.1 };\n//   const av1 = { ...vp8, maxBitrate: vp8.maxBitrate * 0.7 };\n//   return {\n//     vp8,\n//     vp9,\n//     h264,\n//     av1,\n//   };\n// };\nconst videoRids = [\n    'q',\n    'h',\n    'f'\n];\n/* @internal */ function computeVideoEncodings(isScreenShare, width, height, options) {\n    var _a, _b;\n    let videoEncoding = options === null || options === void 0 ? void 0 : options.videoEncoding;\n    if (isScreenShare) {\n        videoEncoding = options === null || options === void 0 ? void 0 : options.screenShareEncoding;\n    }\n    const useSimulcast = options === null || options === void 0 ? void 0 : options.simulcast;\n    const scalabilityMode = options === null || options === void 0 ? void 0 : options.scalabilityMode;\n    const videoCodec = options === null || options === void 0 ? void 0 : options.videoCodec;\n    if (!videoEncoding && !useSimulcast && !scalabilityMode || !width || !height) {\n        // when we aren't simulcasting or svc, will need to return a single encoding without\n        // capping bandwidth. we always require a encoding for dynacast\n        return [\n            {}\n        ];\n    }\n    if (!videoEncoding) {\n        // find the right encoding based on width/height\n        videoEncoding = determineAppropriateEncoding(isScreenShare, width, height, videoCodec);\n        livekitLogger.debug('using video encoding', videoEncoding);\n    }\n    const original = new VideoPreset(width, height, videoEncoding.maxBitrate, videoEncoding.maxFramerate, videoEncoding.priority);\n    if (scalabilityMode && isSVCCodec(videoCodec)) {\n        livekitLogger.debug(\"using svc with scalabilityMode \".concat(scalabilityMode));\n        const sm = new ScalabilityMode(scalabilityMode);\n        const encodings = [];\n        if (sm.spatial > 3) {\n            throw new Error(\"unsupported scalabilityMode: \".concat(scalabilityMode));\n        }\n        for(let i = 0; i < sm.spatial; i += 1){\n            encodings.push({\n                rid: videoRids[2 - i],\n                maxBitrate: videoEncoding.maxBitrate / Math.pow(3, i),\n                /* @ts-ignore */ maxFramerate: original.encoding.maxFramerate\n            });\n        }\n        /* @ts-ignore */ encodings[0].scalabilityMode = scalabilityMode;\n        livekitLogger.debug('encodings', encodings);\n        return encodings;\n    }\n    if (!useSimulcast) {\n        return [\n            videoEncoding\n        ];\n    }\n    let presets = [];\n    if (isScreenShare) {\n        presets = (_a = sortPresets(options === null || options === void 0 ? void 0 : options.screenShareSimulcastLayers)) !== null && _a !== void 0 ? _a : defaultSimulcastLayers(isScreenShare, original);\n    } else {\n        presets = (_b = sortPresets(options === null || options === void 0 ? void 0 : options.videoSimulcastLayers)) !== null && _b !== void 0 ? _b : defaultSimulcastLayers(isScreenShare, original);\n    }\n    let midPreset;\n    if (presets.length > 0) {\n        const lowPreset = presets[0];\n        if (presets.length > 1) {\n            [, midPreset] = presets;\n        }\n        // NOTE:\n        //   1. Ordering of these encodings is important. Chrome seems\n        //      to use the index into encodings to decide which layer\n        //      to disable when CPU constrained.\n        //      So encodings should be ordered in increasing spatial\n        //      resolution order.\n        //   2. ion-sfu translates rids into layers. So, all encodings\n        //      should have the base layer `q` and then more added\n        //      based on other conditions.\n        const size = Math.max(width, height);\n        if (size >= 960 && midPreset) {\n            return encodingsFromPresets(width, height, [\n                lowPreset,\n                midPreset,\n                original\n            ]);\n        }\n        if (size >= 480) {\n            return encodingsFromPresets(width, height, [\n                lowPreset,\n                original\n            ]);\n        }\n    }\n    return encodingsFromPresets(width, height, [\n        original\n    ]);\n}\nfunction computeTrackBackupEncodings(track, videoCodec, opts) {\n    var _a, _b, _c, _d;\n    // backupCodec should not be true anymore, default codec is set in LocalParticipant.publish\n    if (!opts.backupCodec || opts.backupCodec === true || opts.backupCodec.codec === opts.videoCodec) {\n        // backup codec publishing is disabled\n        return;\n    }\n    if (videoCodec !== opts.backupCodec.codec) {\n        livekitLogger.warn('requested a different codec than specified as backup', {\n            serverRequested: videoCodec,\n            backup: opts.backupCodec.codec\n        });\n    }\n    opts.videoCodec = videoCodec;\n    // use backup encoding setting as videoEncoding for backup codec publishing\n    opts.videoEncoding = opts.backupCodec.encoding;\n    const settings = track.mediaStreamTrack.getSettings();\n    const width = (_a = settings.width) !== null && _a !== void 0 ? _a : (_b = track.dimensions) === null || _b === void 0 ? void 0 : _b.width;\n    const height = (_c = settings.height) !== null && _c !== void 0 ? _c : (_d = track.dimensions) === null || _d === void 0 ? void 0 : _d.height;\n    const encodings = computeVideoEncodings(track.source === Track.Source.ScreenShare, width, height, opts);\n    return encodings;\n}\n/* @internal */ function determineAppropriateEncoding(isScreenShare, width, height, codec) {\n    const presets = presetsForResolution(isScreenShare, width, height);\n    let { encoding } = presets[0];\n    // handle portrait by swapping dimensions\n    const size = Math.max(width, height);\n    for(let i = 0; i < presets.length; i += 1){\n        const preset = presets[i];\n        encoding = preset.encoding;\n        if (preset.width >= size) {\n            break;\n        }\n    }\n    // presets are based on the assumption of vp8 as a codec\n    // for other codecs we adjust the maxBitrate if no specific videoEncoding has been provided\n    // users should override these with ones that are optimized for their use case\n    // NOTE: SVC codec bitrates are inclusive of all scalability layers. while\n    // bitrate for non-SVC codecs does not include other simulcast layers.\n    if (codec) {\n        switch(codec){\n            case 'av1':\n                encoding = Object.assign({}, encoding);\n                encoding.maxBitrate = encoding.maxBitrate * 0.7;\n                break;\n            case 'vp9':\n                encoding = Object.assign({}, encoding);\n                encoding.maxBitrate = encoding.maxBitrate * 0.85;\n                break;\n        }\n    }\n    return encoding;\n}\n/* @internal */ function presetsForResolution(isScreenShare, width, height) {\n    if (isScreenShare) {\n        return presetsScreenShare;\n    }\n    const aspect = width > height ? width / height : height / width;\n    if (Math.abs(aspect - 16.0 / 9) < Math.abs(aspect - 4.0 / 3)) {\n        return presets169;\n    }\n    return presets43;\n}\n/* @internal */ function defaultSimulcastLayers(isScreenShare, original) {\n    if (isScreenShare) {\n        return computeDefaultScreenShareSimulcastPresets(original);\n    }\n    const { width, height } = original;\n    const aspect = width > height ? width / height : height / width;\n    if (Math.abs(aspect - 16.0 / 9) < Math.abs(aspect - 4.0 / 3)) {\n        return defaultSimulcastPresets169;\n    }\n    return defaultSimulcastPresets43;\n}\n// presets should be ordered by low, medium, high\nfunction encodingsFromPresets(width, height, presets) {\n    const encodings = [];\n    presets.forEach((preset, idx)=>{\n        if (idx >= videoRids.length) {\n            return;\n        }\n        const size = Math.min(width, height);\n        const rid = videoRids[idx];\n        const encoding = {\n            rid,\n            scaleResolutionDownBy: Math.max(1, size / Math.min(preset.width, preset.height)),\n            maxBitrate: preset.encoding.maxBitrate\n        };\n        if (preset.encoding.maxFramerate) {\n            encoding.maxFramerate = preset.encoding.maxFramerate;\n        }\n        const canSetPriority = isFireFox() || idx === 0;\n        if (preset.encoding.priority && canSetPriority) {\n            encoding.priority = preset.encoding.priority;\n            encoding.networkPriority = preset.encoding.priority;\n        }\n        encodings.push(encoding);\n    });\n    // RN ios simulcast requires all same framerates.\n    if (isReactNative() && getReactNativeOs() === 'ios') {\n        let topFramerate = undefined;\n        encodings.forEach((encoding)=>{\n            if (!topFramerate) {\n                topFramerate = encoding.maxFramerate;\n            } else if (encoding.maxFramerate && encoding.maxFramerate > topFramerate) {\n                topFramerate = encoding.maxFramerate;\n            }\n        });\n        let notifyOnce = true;\n        encodings.forEach((encoding)=>{\n            var _a;\n            if (encoding.maxFramerate != topFramerate) {\n                if (notifyOnce) {\n                    notifyOnce = false;\n                    livekitLogger.info(\"Simulcast on iOS React-Native requires all encodings to share the same framerate.\");\n                }\n                livekitLogger.info(\"Setting framerate of encoding \\\"\".concat((_a = encoding.rid) !== null && _a !== void 0 ? _a : '', \"\\\" to \").concat(topFramerate));\n                encoding.maxFramerate = topFramerate;\n            }\n        });\n    }\n    return encodings;\n}\n/** @internal */ function sortPresets(presets) {\n    if (!presets) return;\n    return presets.sort((a, b)=>{\n        const { encoding: aEnc } = a;\n        const { encoding: bEnc } = b;\n        if (aEnc.maxBitrate > bEnc.maxBitrate) {\n            return 1;\n        }\n        if (aEnc.maxBitrate < bEnc.maxBitrate) return -1;\n        if (aEnc.maxBitrate === bEnc.maxBitrate && aEnc.maxFramerate && bEnc.maxFramerate) {\n            return aEnc.maxFramerate > bEnc.maxFramerate ? 1 : -1;\n        }\n        return 0;\n    });\n}\n/** @internal */ class ScalabilityMode {\n    constructor(scalabilityMode){\n        const results = scalabilityMode.match(/^L(\\d)T(\\d)(h|_KEY|_KEY_SHIFT){0,1}$/);\n        if (!results) {\n            throw new Error('invalid scalability mode');\n        }\n        this.spatial = parseInt(results[1]);\n        this.temporal = parseInt(results[2]);\n        if (results.length > 3) {\n            switch(results[3]){\n                case 'h':\n                case '_KEY':\n                case '_KEY_SHIFT':\n                    this.suffix = results[3];\n            }\n        }\n    }\n    toString() {\n        var _a;\n        return \"L\".concat(this.spatial, \"T\").concat(this.temporal).concat((_a = this.suffix) !== null && _a !== void 0 ? _a : '');\n    }\n}\nconst refreshSubscribedCodecAfterNewCodec = 5000;\nclass LocalVideoTrack extends LocalTrack {\n    /**\n   *\n   * @param mediaTrack\n   * @param constraints MediaTrackConstraints that are being used when restarting or reacquiring tracks\n   * @param userProvidedTrack Signals to the SDK whether or not the mediaTrack should be managed (i.e. released and reacquired) internally by the SDK\n   */ constructor(mediaTrack, constraints){\n        let userProvidedTrack = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n        let loggerOptions = arguments.length > 3 ? arguments[3] : undefined;\n        super(mediaTrack, Track.Kind.Video, constraints, userProvidedTrack, loggerOptions);\n        /* @internal */ this.simulcastCodecs = new Map();\n        this.monitorSender = ()=>__awaiter(this, void 0, void 0, function*() {\n                if (!this.sender) {\n                    this._currentBitrate = 0;\n                    return;\n                }\n                let stats;\n                try {\n                    stats = yield this.getSenderStats();\n                } catch (e) {\n                    this.log.error('could not get audio sender stats', Object.assign(Object.assign({}, this.logContext), {\n                        error: e\n                    }));\n                    return;\n                }\n                const statsMap = new Map(stats.map((s)=>[\n                        s.rid,\n                        s\n                    ]));\n                if (this.prevStats) {\n                    let totalBitrate = 0;\n                    statsMap.forEach((s, key)=>{\n                        var _a;\n                        const prev = (_a = this.prevStats) === null || _a === void 0 ? void 0 : _a.get(key);\n                        totalBitrate += computeBitrate(s, prev);\n                    });\n                    this._currentBitrate = totalBitrate;\n                }\n                this.prevStats = statsMap;\n            });\n        this.senderLock = new Mutex();\n    }\n    get isSimulcast() {\n        if (this.sender && this.sender.getParameters().encodings.length > 1) {\n            return true;\n        }\n        return false;\n    }\n    /* @internal */ startMonitor(signalClient) {\n        var _a;\n        this.signalClient = signalClient;\n        if (!isWeb()) {\n            return;\n        }\n        // save original encodings\n        // TODO : merge simulcast tracks stats\n        const params = (_a = this.sender) === null || _a === void 0 ? void 0 : _a.getParameters();\n        if (params) {\n            this.encodings = params.encodings;\n        }\n        if (this.monitorInterval) {\n            return;\n        }\n        this.monitorInterval = setInterval(()=>{\n            this.monitorSender();\n        }, monitorFrequency);\n    }\n    stop() {\n        this._mediaStreamTrack.getConstraints();\n        this.simulcastCodecs.forEach((trackInfo)=>{\n            trackInfo.mediaStreamTrack.stop();\n        });\n        super.stop();\n    }\n    pauseUpstream() {\n        const _super = Object.create(null, {\n            pauseUpstream: {\n                get: ()=>super.pauseUpstream\n            }\n        });\n        var _a, e_1, _b, _c;\n        var _d;\n        return __awaiter(this, void 0, void 0, function*() {\n            yield _super.pauseUpstream.call(this);\n            try {\n                for(var _e = true, _f = __asyncValues(this.simulcastCodecs.values()), _g; _g = yield _f.next(), _a = _g.done, !_a; _e = true){\n                    _c = _g.value;\n                    _e = false;\n                    const sc = _c;\n                    yield (_d = sc.sender) === null || _d === void 0 ? void 0 : _d.replaceTrack(null);\n                }\n            } catch (e_1_1) {\n                e_1 = {\n                    error: e_1_1\n                };\n            } finally{\n                try {\n                    if (!_e && !_a && (_b = _f.return)) yield _b.call(_f);\n                } finally{\n                    if (e_1) throw e_1.error;\n                }\n            }\n        });\n    }\n    resumeUpstream() {\n        const _super = Object.create(null, {\n            resumeUpstream: {\n                get: ()=>super.resumeUpstream\n            }\n        });\n        var _a, e_2, _b, _c;\n        var _d;\n        return __awaiter(this, void 0, void 0, function*() {\n            yield _super.resumeUpstream.call(this);\n            try {\n                for(var _e = true, _f = __asyncValues(this.simulcastCodecs.values()), _g; _g = yield _f.next(), _a = _g.done, !_a; _e = true){\n                    _c = _g.value;\n                    _e = false;\n                    const sc = _c;\n                    yield (_d = sc.sender) === null || _d === void 0 ? void 0 : _d.replaceTrack(sc.mediaStreamTrack);\n                }\n            } catch (e_2_1) {\n                e_2 = {\n                    error: e_2_1\n                };\n            } finally{\n                try {\n                    if (!_e && !_a && (_b = _f.return)) yield _b.call(_f);\n                } finally{\n                    if (e_2) throw e_2.error;\n                }\n            }\n        });\n    }\n    mute() {\n        const _super = Object.create(null, {\n            mute: {\n                get: ()=>super.mute\n            }\n        });\n        return __awaiter(this, void 0, void 0, function*() {\n            const unlock = yield this.muteLock.lock();\n            try {\n                if (this.source === Track.Source.Camera && !this.isUserProvided) {\n                    this.log.debug('stopping camera track', this.logContext);\n                    // also stop the track, so that camera indicator is turned off\n                    this._mediaStreamTrack.stop();\n                }\n                yield _super.mute.call(this);\n                return this;\n            } finally{\n                unlock();\n            }\n        });\n    }\n    unmute() {\n        const _super = Object.create(null, {\n            unmute: {\n                get: ()=>super.unmute\n            }\n        });\n        return __awaiter(this, void 0, void 0, function*() {\n            const unlock = yield this.muteLock.lock();\n            try {\n                if (this.source === Track.Source.Camera && !this.isUserProvided) {\n                    this.log.debug('reacquiring camera track', this.logContext);\n                    yield this.restartTrack();\n                }\n                yield _super.unmute.call(this);\n                return this;\n            } finally{\n                unlock();\n            }\n        });\n    }\n    setTrackMuted(muted) {\n        super.setTrackMuted(muted);\n        for (const sc of this.simulcastCodecs.values()){\n            sc.mediaStreamTrack.enabled = !muted;\n        }\n    }\n    getSenderStats() {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            if (!((_a = this.sender) === null || _a === void 0 ? void 0 : _a.getStats)) {\n                return [];\n            }\n            const items = [];\n            const stats = yield this.sender.getStats();\n            stats.forEach((v)=>{\n                var _a;\n                if (v.type === 'outbound-rtp') {\n                    const vs = {\n                        type: 'video',\n                        streamId: v.id,\n                        frameHeight: v.frameHeight,\n                        frameWidth: v.frameWidth,\n                        firCount: v.firCount,\n                        pliCount: v.pliCount,\n                        nackCount: v.nackCount,\n                        packetsSent: v.packetsSent,\n                        bytesSent: v.bytesSent,\n                        framesSent: v.framesSent,\n                        timestamp: v.timestamp,\n                        rid: (_a = v.rid) !== null && _a !== void 0 ? _a : v.id,\n                        retransmittedPacketsSent: v.retransmittedPacketsSent,\n                        qualityLimitationReason: v.qualityLimitationReason,\n                        qualityLimitationResolutionChanges: v.qualityLimitationResolutionChanges\n                    };\n                    //locate the appropriate remote-inbound-rtp item\n                    const r = stats.get(v.remoteId);\n                    if (r) {\n                        vs.jitter = r.jitter;\n                        vs.packetsLost = r.packetsLost;\n                        vs.roundTripTime = r.roundTripTime;\n                    }\n                    items.push(vs);\n                }\n            });\n            return items;\n        });\n    }\n    setPublishingQuality(maxQuality) {\n        const qualities = [];\n        for(let q = VideoQuality.LOW; q <= VideoQuality.HIGH; q += 1){\n            qualities.push(new SubscribedQuality({\n                quality: q,\n                enabled: q <= maxQuality\n            }));\n        }\n        this.log.debug(\"setting publishing quality. max quality \".concat(maxQuality), this.logContext);\n        this.setPublishingLayers(qualities);\n    }\n    setDeviceId(deviceId) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (this._constraints.deviceId === deviceId && this._mediaStreamTrack.getSettings().deviceId === unwrapConstraint(deviceId)) {\n                return true;\n            }\n            this._constraints.deviceId = deviceId;\n            // when video is muted, underlying media stream track is stopped and\n            // will be restarted later\n            if (!this.isMuted) {\n                yield this.restartTrack();\n            }\n            return this.isMuted || unwrapConstraint(deviceId) === this._mediaStreamTrack.getSettings().deviceId;\n        });\n    }\n    restartTrack(options) {\n        var _a, e_3, _b, _c;\n        return __awaiter(this, void 0, void 0, function*() {\n            let constraints;\n            if (options) {\n                const streamConstraints = constraintsForOptions({\n                    video: options\n                });\n                if (typeof streamConstraints.video !== 'boolean') {\n                    constraints = streamConstraints.video;\n                }\n            }\n            yield this.restart(constraints);\n            try {\n                for(var _d = true, _e = __asyncValues(this.simulcastCodecs.values()), _f; _f = yield _e.next(), _a = _f.done, !_a; _d = true){\n                    _c = _f.value;\n                    _d = false;\n                    const sc = _c;\n                    if (sc.sender) {\n                        sc.mediaStreamTrack = this.mediaStreamTrack.clone();\n                        yield sc.sender.replaceTrack(sc.mediaStreamTrack);\n                    }\n                }\n            } catch (e_3_1) {\n                e_3 = {\n                    error: e_3_1\n                };\n            } finally{\n                try {\n                    if (!_d && !_a && (_b = _e.return)) yield _b.call(_e);\n                } finally{\n                    if (e_3) throw e_3.error;\n                }\n            }\n        });\n    }\n    setProcessor(processor) {\n        let showProcessedStreamLocally = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n        const _super = Object.create(null, {\n            setProcessor: {\n                get: ()=>super.setProcessor\n            }\n        });\n        var _a, e_4, _b, _c;\n        var _d, _e;\n        return __awaiter(this, void 0, void 0, function*() {\n            yield _super.setProcessor.call(this, processor, showProcessedStreamLocally);\n            if ((_d = this.processor) === null || _d === void 0 ? void 0 : _d.processedTrack) {\n                try {\n                    for(var _f = true, _g = __asyncValues(this.simulcastCodecs.values()), _h; _h = yield _g.next(), _a = _h.done, !_a; _f = true){\n                        _c = _h.value;\n                        _f = false;\n                        const sc = _c;\n                        yield (_e = sc.sender) === null || _e === void 0 ? void 0 : _e.replaceTrack(this.processor.processedTrack);\n                    }\n                } catch (e_4_1) {\n                    e_4 = {\n                        error: e_4_1\n                    };\n                } finally{\n                    try {\n                        if (!_f && !_a && (_b = _g.return)) yield _b.call(_g);\n                    } finally{\n                        if (e_4) throw e_4.error;\n                    }\n                }\n            }\n        });\n    }\n    addSimulcastTrack(codec, encodings) {\n        if (this.simulcastCodecs.has(codec)) {\n            throw new Error(\"\".concat(codec, \" already added\"));\n        }\n        const simulcastCodecInfo = {\n            codec,\n            mediaStreamTrack: this.mediaStreamTrack.clone(),\n            sender: undefined,\n            encodings\n        };\n        this.simulcastCodecs.set(codec, simulcastCodecInfo);\n        return simulcastCodecInfo;\n    }\n    setSimulcastTrackSender(codec, sender) {\n        const simulcastCodecInfo = this.simulcastCodecs.get(codec);\n        if (!simulcastCodecInfo) {\n            return;\n        }\n        simulcastCodecInfo.sender = sender;\n        // browser will reenable disabled codec/layers after new codec has been published,\n        // so refresh subscribedCodecs after publish a new codec\n        setTimeout(()=>{\n            if (this.subscribedCodecs) {\n                this.setPublishingCodecs(this.subscribedCodecs);\n            }\n        }, refreshSubscribedCodecAfterNewCodec);\n    }\n    /**\n   * @internal\n   * Sets codecs that should be publishing, returns new codecs that have not yet\n   * been published\n   */ setPublishingCodecs(codecs) {\n        var _a, codecs_1, codecs_1_1;\n        var _b, e_5, _c, _d;\n        return __awaiter(this, void 0, void 0, function*() {\n            this.log.debug('setting publishing codecs', Object.assign(Object.assign({}, this.logContext), {\n                codecs,\n                currentCodec: this.codec\n            }));\n            // only enable simulcast codec for preference codec setted\n            if (!this.codec && codecs.length > 0) {\n                yield this.setPublishingLayers(codecs[0].qualities);\n                return [];\n            }\n            this.subscribedCodecs = codecs;\n            const newCodecs = [];\n            try {\n                for(_a = true, codecs_1 = __asyncValues(codecs); codecs_1_1 = yield codecs_1.next(), _b = codecs_1_1.done, !_b; _a = true){\n                    _d = codecs_1_1.value;\n                    _a = false;\n                    const codec = _d;\n                    if (!this.codec || this.codec === codec.codec) {\n                        yield this.setPublishingLayers(codec.qualities);\n                    } else {\n                        const simulcastCodecInfo = this.simulcastCodecs.get(codec.codec);\n                        this.log.debug(\"try setPublishingCodec for \".concat(codec.codec), Object.assign(Object.assign({}, this.logContext), {\n                            simulcastCodecInfo\n                        }));\n                        if (!simulcastCodecInfo || !simulcastCodecInfo.sender) {\n                            for (const q of codec.qualities){\n                                if (q.enabled) {\n                                    newCodecs.push(codec.codec);\n                                    break;\n                                }\n                            }\n                        } else if (simulcastCodecInfo.encodings) {\n                            this.log.debug(\"try setPublishingLayersForSender \".concat(codec.codec), this.logContext);\n                            yield setPublishingLayersForSender(simulcastCodecInfo.sender, simulcastCodecInfo.encodings, codec.qualities, this.senderLock, this.log, this.logContext);\n                        }\n                    }\n                }\n            } catch (e_5_1) {\n                e_5 = {\n                    error: e_5_1\n                };\n            } finally{\n                try {\n                    if (!_a && !_b && (_c = codecs_1.return)) yield _c.call(codecs_1);\n                } finally{\n                    if (e_5) throw e_5.error;\n                }\n            }\n            return newCodecs;\n        });\n    }\n    /**\n   * @internal\n   * Sets layers that should be publishing\n   */ setPublishingLayers(qualities) {\n        return __awaiter(this, void 0, void 0, function*() {\n            this.log.debug('setting publishing layers', Object.assign(Object.assign({}, this.logContext), {\n                qualities\n            }));\n            if (!this.sender || !this.encodings) {\n                return;\n            }\n            yield setPublishingLayersForSender(this.sender, this.encodings, qualities, this.senderLock, this.log, this.logContext);\n        });\n    }\n    handleAppVisibilityChanged() {\n        const _super = Object.create(null, {\n            handleAppVisibilityChanged: {\n                get: ()=>super.handleAppVisibilityChanged\n            }\n        });\n        return __awaiter(this, void 0, void 0, function*() {\n            yield _super.handleAppVisibilityChanged.call(this);\n            if (!isMobile()) return;\n            if (this.isInBackground && this.source === Track.Source.Camera) {\n                this._mediaStreamTrack.enabled = false;\n            }\n        });\n    }\n}\nfunction setPublishingLayersForSender(sender, senderEncodings, qualities, senderLock, log, logContext) {\n    return __awaiter(this, void 0, void 0, function*() {\n        const unlock = yield senderLock.lock();\n        log.debug('setPublishingLayersForSender', Object.assign(Object.assign({}, logContext), {\n            sender,\n            qualities,\n            senderEncodings\n        }));\n        try {\n            const params = sender.getParameters();\n            const { encodings } = params;\n            if (!encodings) {\n                return;\n            }\n            if (encodings.length !== senderEncodings.length) {\n                log.warn('cannot set publishing layers, encodings mismatch');\n                return;\n            }\n            let hasChanged = false;\n            /* disable closable spatial layer as it has video blur / frozen issue with current server / client\n      1. chrome 113: when switching to up layer with scalability Mode change, it will generate a\n            low resolution frame and recover very quickly, but noticable\n      2. livekit sfu: additional pli request cause video frozen for a few frames, also noticable */ const closableSpatial = false;\n            /* @ts-ignore */ if (closableSpatial && encodings[0].scalabilityMode) ;\n            else {\n                // simulcast dynacast encodings\n                encodings.forEach((encoding, idx)=>{\n                    var _a;\n                    let rid = (_a = encoding.rid) !== null && _a !== void 0 ? _a : '';\n                    if (rid === '') {\n                        rid = 'q';\n                    }\n                    const quality = videoQualityForRid(rid);\n                    const subscribedQuality = qualities.find((q)=>q.quality === quality);\n                    if (!subscribedQuality) {\n                        return;\n                    }\n                    if (encoding.active !== subscribedQuality.enabled) {\n                        hasChanged = true;\n                        encoding.active = subscribedQuality.enabled;\n                        log.debug(\"setting layer \".concat(subscribedQuality.quality, \" to \").concat(encoding.active ? 'enabled' : 'disabled'), logContext);\n                        // FireFox does not support setting encoding.active to false, so we\n                        // have a workaround of lowering its bitrate and resolution to the min.\n                        if (isFireFox()) {\n                            if (subscribedQuality.enabled) {\n                                encoding.scaleResolutionDownBy = senderEncodings[idx].scaleResolutionDownBy;\n                                encoding.maxBitrate = senderEncodings[idx].maxBitrate;\n                                /* @ts-ignore */ encoding.maxFrameRate = senderEncodings[idx].maxFrameRate;\n                            } else {\n                                encoding.scaleResolutionDownBy = 4;\n                                encoding.maxBitrate = 10;\n                                /* @ts-ignore */ encoding.maxFrameRate = 2;\n                            }\n                        }\n                    }\n                });\n            }\n            if (hasChanged) {\n                params.encodings = encodings;\n                log.debug(\"setting encodings\", Object.assign(Object.assign({}, logContext), {\n                    encodings: params.encodings\n                }));\n                yield sender.setParameters(params);\n            }\n        } finally{\n            unlock();\n        }\n    });\n}\nfunction videoQualityForRid(rid) {\n    switch(rid){\n        case 'f':\n            return VideoQuality.HIGH;\n        case 'h':\n            return VideoQuality.MEDIUM;\n        case 'q':\n            return VideoQuality.LOW;\n        default:\n            return VideoQuality.HIGH;\n    }\n}\nfunction videoLayersFromEncodings(width, height, encodings, svc) {\n    // default to a single layer, HQ\n    if (!encodings) {\n        return [\n            new VideoLayer({\n                quality: VideoQuality.HIGH,\n                width,\n                height,\n                bitrate: 0,\n                ssrc: 0\n            })\n        ];\n    }\n    if (svc) {\n        // svc layers\n        /* @ts-ignore */ const encodingSM = encodings[0].scalabilityMode;\n        const sm = new ScalabilityMode(encodingSM);\n        const layers = [];\n        for(let i = 0; i < sm.spatial; i += 1){\n            layers.push(new VideoLayer({\n                quality: VideoQuality.HIGH - i,\n                width: Math.ceil(width / Math.pow(2, i)),\n                height: Math.ceil(height / Math.pow(2, i)),\n                bitrate: encodings[0].maxBitrate ? Math.ceil(encodings[0].maxBitrate / Math.pow(3, i)) : 0,\n                ssrc: 0\n            }));\n        }\n        return layers;\n    }\n    return encodings.map((encoding)=>{\n        var _a, _b, _c;\n        const scale = (_a = encoding.scaleResolutionDownBy) !== null && _a !== void 0 ? _a : 1;\n        let quality = videoQualityForRid((_b = encoding.rid) !== null && _b !== void 0 ? _b : '');\n        return new VideoLayer({\n            quality,\n            width: Math.ceil(width / scale),\n            height: Math.ceil(height / scale),\n            bitrate: (_c = encoding.maxBitrate) !== null && _c !== void 0 ? _c : 0,\n            ssrc: 0\n        });\n    });\n}\nclass RemoteTrack extends Track {\n    constructor(mediaTrack, sid, kind, receiver, loggerOptions){\n        super(mediaTrack, kind, loggerOptions);\n        this.sid = sid;\n        this.receiver = receiver;\n    }\n    /** @internal */ setMuted(muted) {\n        if (this.isMuted !== muted) {\n            this.isMuted = muted;\n            this._mediaStreamTrack.enabled = !muted;\n            this.emit(muted ? TrackEvent.Muted : TrackEvent.Unmuted, this);\n        }\n    }\n    /** @internal */ setMediaStream(stream) {\n        // this is needed to determine when the track is finished\n        this.mediaStream = stream;\n        const onRemoveTrack = (event)=>{\n            if (event.track === this._mediaStreamTrack) {\n                stream.removeEventListener('removetrack', onRemoveTrack);\n                this.receiver = undefined;\n                this._currentBitrate = 0;\n                this.emit(TrackEvent.Ended, this);\n            }\n        };\n        stream.addEventListener('removetrack', onRemoveTrack);\n    }\n    start() {\n        this.startMonitor();\n        // use `enabled` of track to enable re-use of transceiver\n        super.enable();\n    }\n    stop() {\n        this.stopMonitor();\n        // use `enabled` of track to enable re-use of transceiver\n        super.disable();\n    }\n    /**\n   * Gets the RTCStatsReport for the RemoteTrack's underlying RTCRtpReceiver\n   * See https://developer.mozilla.org/en-US/docs/Web/API/RTCStatsReport\n   *\n   * @returns Promise<RTCStatsReport> | undefined\n   */ getRTCStatsReport() {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            if (!((_a = this.receiver) === null || _a === void 0 ? void 0 : _a.getStats)) {\n                return;\n            }\n            const statsReport = yield this.receiver.getStats();\n            return statsReport;\n        });\n    }\n    /* @internal */ startMonitor() {\n        if (!this.monitorInterval) {\n            this.monitorInterval = setInterval(()=>this.monitorReceiver(), monitorFrequency);\n        }\n    }\n}\nclass RemoteAudioTrack extends RemoteTrack {\n    constructor(mediaTrack, sid, receiver, audioContext, audioOutput, loggerOptions){\n        super(mediaTrack, sid, Track.Kind.Audio, receiver, loggerOptions);\n        this.monitorReceiver = ()=>__awaiter(this, void 0, void 0, function*() {\n                if (!this.receiver) {\n                    this._currentBitrate = 0;\n                    return;\n                }\n                const stats = yield this.getReceiverStats();\n                if (stats && this.prevStats && this.receiver) {\n                    this._currentBitrate = computeBitrate(stats, this.prevStats);\n                }\n                this.prevStats = stats;\n            });\n        this.audioContext = audioContext;\n        this.webAudioPluginNodes = [];\n        if (audioOutput) {\n            this.sinkId = audioOutput.deviceId;\n        }\n    }\n    /**\n   * sets the volume for all attached audio elements\n   */ setVolume(volume) {\n        var _a;\n        for (const el of this.attachedElements){\n            if (this.audioContext) {\n                (_a = this.gainNode) === null || _a === void 0 ? void 0 : _a.gain.setTargetAtTime(volume, 0, 0.1);\n            } else {\n                el.volume = volume;\n            }\n        }\n        if (isReactNative()) {\n            // @ts-ignore\n            this._mediaStreamTrack._setVolume(volume);\n        }\n        this.elementVolume = volume;\n    }\n    /**\n   * gets the volume of attached audio elements (loudest)\n   */ getVolume() {\n        if (this.elementVolume) {\n            return this.elementVolume;\n        }\n        if (isReactNative()) {\n            // RN volume value defaults to 1.0 if hasn't been changed.\n            return 1.0;\n        }\n        let highestVolume = 0;\n        this.attachedElements.forEach((element)=>{\n            if (element.volume > highestVolume) {\n                highestVolume = element.volume;\n            }\n        });\n        return highestVolume;\n    }\n    /**\n   * calls setSinkId on all attached elements, if supported\n   * @param deviceId audio output device\n   */ setSinkId(deviceId) {\n        return __awaiter(this, void 0, void 0, function*() {\n            this.sinkId = deviceId;\n            yield Promise.all(this.attachedElements.map((elm)=>{\n                if (!supportsSetSinkId(elm)) {\n                    return;\n                }\n                /* @ts-ignore */ return elm.setSinkId(deviceId);\n            }));\n        });\n    }\n    attach(element) {\n        const needsNewWebAudioConnection = this.attachedElements.length === 0;\n        if (!element) {\n            element = super.attach();\n        } else {\n            super.attach(element);\n        }\n        if (this.sinkId && supportsSetSinkId(element)) {\n            /* @ts-ignore */ element.setSinkId(this.sinkId);\n        }\n        if (this.audioContext && needsNewWebAudioConnection) {\n            this.log.debug('using audio context mapping', this.logContext);\n            this.connectWebAudio(this.audioContext, element);\n            element.volume = 0;\n            element.muted = true;\n        }\n        if (this.elementVolume) {\n            // make sure volume setting is being applied to the newly attached element\n            this.setVolume(this.elementVolume);\n        }\n        return element;\n    }\n    detach(element) {\n        let detached;\n        if (!element) {\n            detached = super.detach();\n            this.disconnectWebAudio();\n        } else {\n            detached = super.detach(element);\n            // if there are still any attached elements after detaching, connect webaudio to the first element that's left\n            // disconnect webaudio otherwise\n            if (this.audioContext) {\n                if (this.attachedElements.length > 0) {\n                    this.connectWebAudio(this.audioContext, this.attachedElements[0]);\n                } else {\n                    this.disconnectWebAudio();\n                }\n            }\n        }\n        return detached;\n    }\n    /**\n   * @internal\n   * @experimental\n   */ setAudioContext(audioContext) {\n        this.audioContext = audioContext;\n        if (audioContext && this.attachedElements.length > 0) {\n            this.connectWebAudio(audioContext, this.attachedElements[0]);\n        } else if (!audioContext) {\n            this.disconnectWebAudio();\n        }\n    }\n    /**\n   * @internal\n   * @experimental\n   * @param {AudioNode[]} nodes - An array of WebAudio nodes. These nodes should not be connected to each other when passed, as the sdk will take care of connecting them in the order of the array.\n   */ setWebAudioPlugins(nodes) {\n        this.webAudioPluginNodes = nodes;\n        if (this.attachedElements.length > 0 && this.audioContext) {\n            this.connectWebAudio(this.audioContext, this.attachedElements[0]);\n        }\n    }\n    connectWebAudio(context, element) {\n        this.disconnectWebAudio();\n        // @ts-ignore attached elements always have a srcObject set\n        this.sourceNode = context.createMediaStreamSource(element.srcObject);\n        let lastNode = this.sourceNode;\n        this.webAudioPluginNodes.forEach((node)=>{\n            lastNode.connect(node);\n            lastNode = node;\n        });\n        this.gainNode = context.createGain();\n        lastNode.connect(this.gainNode);\n        this.gainNode.connect(context.destination);\n        if (this.elementVolume) {\n            this.gainNode.gain.setTargetAtTime(this.elementVolume, 0, 0.1);\n        }\n        // try to resume the context if it isn't running already\n        if (context.state !== 'running') {\n            context.resume().then(()=>{\n                if (context.state !== 'running') {\n                    this.emit(TrackEvent.AudioPlaybackFailed, new Error(\"Audio Context couldn't be started automatically\"));\n                }\n            }).catch((e)=>{\n                this.emit(TrackEvent.AudioPlaybackFailed, e);\n            });\n        }\n    }\n    disconnectWebAudio() {\n        var _a, _b;\n        (_a = this.gainNode) === null || _a === void 0 ? void 0 : _a.disconnect();\n        (_b = this.sourceNode) === null || _b === void 0 ? void 0 : _b.disconnect();\n        this.gainNode = undefined;\n        this.sourceNode = undefined;\n    }\n    getReceiverStats() {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (!this.receiver || !this.receiver.getStats) {\n                return;\n            }\n            const stats = yield this.receiver.getStats();\n            let receiverStats;\n            stats.forEach((v)=>{\n                if (v.type === 'inbound-rtp') {\n                    receiverStats = {\n                        type: 'audio',\n                        timestamp: v.timestamp,\n                        jitter: v.jitter,\n                        bytesReceived: v.bytesReceived,\n                        concealedSamples: v.concealedSamples,\n                        concealmentEvents: v.concealmentEvents,\n                        silentConcealedSamples: v.silentConcealedSamples,\n                        silentConcealmentEvents: v.silentConcealmentEvents,\n                        totalAudioEnergy: v.totalAudioEnergy,\n                        totalSamplesDuration: v.totalSamplesDuration\n                    };\n                }\n            });\n            return receiverStats;\n        });\n    }\n}\nconst REACTION_DELAY = 100;\nclass RemoteVideoTrack extends RemoteTrack {\n    constructor(mediaTrack, sid, receiver, adaptiveStreamSettings, loggerOptions){\n        super(mediaTrack, sid, Track.Kind.Video, receiver, loggerOptions);\n        this.elementInfos = [];\n        this.monitorReceiver = ()=>__awaiter(this, void 0, void 0, function*() {\n                if (!this.receiver) {\n                    this._currentBitrate = 0;\n                    return;\n                }\n                const stats = yield this.getReceiverStats();\n                if (stats && this.prevStats && this.receiver) {\n                    this._currentBitrate = computeBitrate(stats, this.prevStats);\n                }\n                this.prevStats = stats;\n            });\n        this.debouncedHandleResize = r(()=>{\n            this.updateDimensions();\n        }, REACTION_DELAY);\n        this.adaptiveStreamSettings = adaptiveStreamSettings;\n    }\n    get isAdaptiveStream() {\n        return this.adaptiveStreamSettings !== undefined;\n    }\n    /**\n   * Note: When using adaptiveStream, you need to use remoteVideoTrack.attach() to add the track to a HTMLVideoElement, otherwise your video tracks might never start\n   */ get mediaStreamTrack() {\n        return this._mediaStreamTrack;\n    }\n    /** @internal */ setMuted(muted) {\n        super.setMuted(muted);\n        this.attachedElements.forEach((element)=>{\n            // detach or attach\n            if (muted) {\n                detachTrack(this._mediaStreamTrack, element);\n            } else {\n                attachToElement(this._mediaStreamTrack, element);\n            }\n        });\n    }\n    attach(element) {\n        if (!element) {\n            element = super.attach();\n        } else {\n            super.attach(element);\n        }\n        // It's possible attach is called multiple times on an element. When that's\n        // the case, we'd want to avoid adding duplicate elementInfos\n        if (this.adaptiveStreamSettings && this.elementInfos.find((info)=>info.element === element) === undefined) {\n            const elementInfo = new HTMLElementInfo(element);\n            this.observeElementInfo(elementInfo);\n        }\n        return element;\n    }\n    /**\n   * Observe an ElementInfo for changes when adaptive streaming.\n   * @param elementInfo\n   * @internal\n   */ observeElementInfo(elementInfo) {\n        if (this.adaptiveStreamSettings && this.elementInfos.find((info)=>info === elementInfo) === undefined) {\n            elementInfo.handleResize = ()=>{\n                this.debouncedHandleResize();\n            };\n            elementInfo.handleVisibilityChanged = ()=>{\n                this.updateVisibility();\n            };\n            this.elementInfos.push(elementInfo);\n            elementInfo.observe();\n            // trigger the first resize update cycle\n            // if the tab is backgrounded, the initial resize event does not fire until\n            // the tab comes into focus for the first time.\n            this.debouncedHandleResize();\n            this.updateVisibility();\n        } else {\n            this.log.warn('visibility resize observer not triggered', this.logContext);\n        }\n    }\n    /**\n   * Stop observing an ElementInfo for changes.\n   * @param elementInfo\n   * @internal\n   */ stopObservingElementInfo(elementInfo) {\n        if (!this.isAdaptiveStream) {\n            this.log.warn('stopObservingElementInfo ignored', this.logContext);\n            return;\n        }\n        const stopElementInfos = this.elementInfos.filter((info)=>info === elementInfo);\n        for (const info of stopElementInfos){\n            info.stopObserving();\n        }\n        this.elementInfos = this.elementInfos.filter((info)=>info !== elementInfo);\n        this.updateVisibility();\n        this.debouncedHandleResize();\n    }\n    detach(element) {\n        let detachedElements = [];\n        if (element) {\n            this.stopObservingElement(element);\n            return super.detach(element);\n        }\n        detachedElements = super.detach();\n        for (const e of detachedElements){\n            this.stopObservingElement(e);\n        }\n        return detachedElements;\n    }\n    /** @internal */ getDecoderImplementation() {\n        var _a;\n        return (_a = this.prevStats) === null || _a === void 0 ? void 0 : _a.decoderImplementation;\n    }\n    getReceiverStats() {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (!this.receiver || !this.receiver.getStats) {\n                return;\n            }\n            const stats = yield this.receiver.getStats();\n            let receiverStats;\n            let codecID = '';\n            let codecs = new Map();\n            stats.forEach((v)=>{\n                if (v.type === 'inbound-rtp') {\n                    codecID = v.codecId;\n                    receiverStats = {\n                        type: 'video',\n                        framesDecoded: v.framesDecoded,\n                        framesDropped: v.framesDropped,\n                        framesReceived: v.framesReceived,\n                        packetsReceived: v.packetsReceived,\n                        packetsLost: v.packetsLost,\n                        frameWidth: v.frameWidth,\n                        frameHeight: v.frameHeight,\n                        pliCount: v.pliCount,\n                        firCount: v.firCount,\n                        nackCount: v.nackCount,\n                        jitter: v.jitter,\n                        timestamp: v.timestamp,\n                        bytesReceived: v.bytesReceived,\n                        decoderImplementation: v.decoderImplementation\n                    };\n                } else if (v.type === 'codec') {\n                    codecs.set(v.id, v);\n                }\n            });\n            if (receiverStats && codecID !== '' && codecs.get(codecID)) {\n                receiverStats.mimeType = codecs.get(codecID).mimeType;\n            }\n            return receiverStats;\n        });\n    }\n    stopObservingElement(element) {\n        const stopElementInfos = this.elementInfos.filter((info)=>info.element === element);\n        for (const info of stopElementInfos){\n            this.stopObservingElementInfo(info);\n        }\n    }\n    handleAppVisibilityChanged() {\n        const _super = Object.create(null, {\n            handleAppVisibilityChanged: {\n                get: ()=>super.handleAppVisibilityChanged\n            }\n        });\n        return __awaiter(this, void 0, void 0, function*() {\n            yield _super.handleAppVisibilityChanged.call(this);\n            if (!this.isAdaptiveStream) return;\n            this.updateVisibility();\n        });\n    }\n    updateVisibility() {\n        var _a, _b;\n        const lastVisibilityChange = this.elementInfos.reduce((prev, info)=>Math.max(prev, info.visibilityChangedAt || 0), 0);\n        const backgroundPause = ((_b = (_a = this.adaptiveStreamSettings) === null || _a === void 0 ? void 0 : _a.pauseVideoInBackground) !== null && _b !== void 0 ? _b : true // default to true\n        ) ? this.isInBackground : false;\n        const isPiPMode = this.elementInfos.some((info)=>info.pictureInPicture);\n        const isVisible = this.elementInfos.some((info)=>info.visible) && !backgroundPause || isPiPMode;\n        if (this.lastVisible === isVisible) {\n            return;\n        }\n        if (!isVisible && Date.now() - lastVisibilityChange < REACTION_DELAY) {\n            // delay hidden events\n            CriticalTimers.setTimeout(()=>{\n                this.updateVisibility();\n            }, REACTION_DELAY);\n            return;\n        }\n        this.lastVisible = isVisible;\n        this.emit(TrackEvent.VisibilityChanged, isVisible, this);\n    }\n    updateDimensions() {\n        var _a, _b;\n        let maxWidth = 0;\n        let maxHeight = 0;\n        const pixelDensity = this.getPixelDensity();\n        for (const info of this.elementInfos){\n            const currentElementWidth = info.width() * pixelDensity;\n            const currentElementHeight = info.height() * pixelDensity;\n            if (currentElementWidth + currentElementHeight > maxWidth + maxHeight) {\n                maxWidth = currentElementWidth;\n                maxHeight = currentElementHeight;\n            }\n        }\n        if (((_a = this.lastDimensions) === null || _a === void 0 ? void 0 : _a.width) === maxWidth && ((_b = this.lastDimensions) === null || _b === void 0 ? void 0 : _b.height) === maxHeight) {\n            return;\n        }\n        this.lastDimensions = {\n            width: maxWidth,\n            height: maxHeight\n        };\n        this.emit(TrackEvent.VideoDimensionsChanged, this.lastDimensions, this);\n    }\n    getPixelDensity() {\n        var _a;\n        const pixelDensity = (_a = this.adaptiveStreamSettings) === null || _a === void 0 ? void 0 : _a.pixelDensity;\n        if (pixelDensity === 'screen') {\n            return getDevicePixelRatio();\n        } else if (!pixelDensity) {\n            // when unset, we'll pick a sane default here.\n            // for higher pixel density devices (mobile phones, etc), we'll use 2\n            // otherwise it defaults to 1\n            const devicePixelRatio = getDevicePixelRatio();\n            if (devicePixelRatio > 2) {\n                return 2;\n            } else {\n                return 1;\n            }\n        }\n        return pixelDensity;\n    }\n}\nclass HTMLElementInfo {\n    get visible() {\n        return this.isPiP || this.isIntersecting;\n    }\n    get pictureInPicture() {\n        return this.isPiP;\n    }\n    constructor(element, visible){\n        this.onVisibilityChanged = (entry)=>{\n            var _a;\n            const { target, isIntersecting } = entry;\n            if (target === this.element) {\n                this.isIntersecting = isIntersecting;\n                this.visibilityChangedAt = Date.now();\n                (_a = this.handleVisibilityChanged) === null || _a === void 0 ? void 0 : _a.call(this);\n            }\n        };\n        this.onEnterPiP = ()=>{\n            var _a;\n            this.isPiP = true;\n            (_a = this.handleVisibilityChanged) === null || _a === void 0 ? void 0 : _a.call(this);\n        };\n        this.onLeavePiP = ()=>{\n            var _a;\n            this.isPiP = false;\n            (_a = this.handleVisibilityChanged) === null || _a === void 0 ? void 0 : _a.call(this);\n        };\n        this.element = element;\n        this.isIntersecting = visible !== null && visible !== void 0 ? visible : isElementInViewport(element);\n        this.isPiP = isWeb() && document.pictureInPictureElement === element;\n        this.visibilityChangedAt = 0;\n    }\n    width() {\n        return this.element.clientWidth;\n    }\n    height() {\n        return this.element.clientHeight;\n    }\n    observe() {\n        // make sure we update the current visible state once we start to observe\n        this.isIntersecting = isElementInViewport(this.element);\n        this.isPiP = document.pictureInPictureElement === this.element;\n        this.element.handleResize = ()=>{\n            var _a;\n            (_a = this.handleResize) === null || _a === void 0 ? void 0 : _a.call(this);\n        };\n        this.element.handleVisibilityChanged = this.onVisibilityChanged;\n        getIntersectionObserver().observe(this.element);\n        getResizeObserver().observe(this.element);\n        this.element.addEventListener('enterpictureinpicture', this.onEnterPiP);\n        this.element.addEventListener('leavepictureinpicture', this.onLeavePiP);\n    }\n    stopObserving() {\n        var _a, _b;\n        (_a = getIntersectionObserver()) === null || _a === void 0 ? void 0 : _a.unobserve(this.element);\n        (_b = getResizeObserver()) === null || _b === void 0 ? void 0 : _b.unobserve(this.element);\n        this.element.removeEventListener('enterpictureinpicture', this.onEnterPiP);\n        this.element.removeEventListener('leavepictureinpicture', this.onLeavePiP);\n    }\n}\n// does not account for occlusion by other elements\nfunction isElementInViewport(el) {\n    let top = el.offsetTop;\n    let left = el.offsetLeft;\n    const width = el.offsetWidth;\n    const height = el.offsetHeight;\n    const { hidden } = el;\n    const { opacity, display } = getComputedStyle(el);\n    while(el.offsetParent){\n        el = el.offsetParent;\n        top += el.offsetTop;\n        left += el.offsetLeft;\n    }\n    return top < window.pageYOffset + window.innerHeight && left < window.pageXOffset + window.innerWidth && top + height > window.pageYOffset && left + width > window.pageXOffset && !hidden && (opacity !== '' ? parseFloat(opacity) > 0 : true) && display !== 'none';\n}\nclass TrackPublication extends eventsExports.EventEmitter {\n    constructor(kind, id, name, loggerOptions){\n        var _a;\n        super();\n        this.metadataMuted = false;\n        this.encryption = Encryption_Type.NONE;\n        this.log = livekitLogger;\n        this.handleMuted = ()=>{\n            this.emit(TrackEvent.Muted);\n        };\n        this.handleUnmuted = ()=>{\n            this.emit(TrackEvent.Unmuted);\n        };\n        this.log = getLogger((_a = loggerOptions === null || loggerOptions === void 0 ? void 0 : loggerOptions.loggerName) !== null && _a !== void 0 ? _a : LoggerNames.Publication);\n        this.loggerContextCb = this.loggerContextCb;\n        this.setMaxListeners(100);\n        this.kind = kind;\n        this.trackSid = id;\n        this.trackName = name;\n        this.source = Track.Source.Unknown;\n    }\n    /** @internal */ setTrack(track) {\n        if (this.track) {\n            this.track.off(TrackEvent.Muted, this.handleMuted);\n            this.track.off(TrackEvent.Unmuted, this.handleUnmuted);\n        }\n        this.track = track;\n        if (track) {\n            // forward events\n            track.on(TrackEvent.Muted, this.handleMuted);\n            track.on(TrackEvent.Unmuted, this.handleUnmuted);\n        }\n    }\n    get logContext() {\n        var _a;\n        return Object.assign(Object.assign({}, (_a = this.loggerContextCb) === null || _a === void 0 ? void 0 : _a.call(this)), getLogContextFromTrack(this));\n    }\n    get isMuted() {\n        return this.metadataMuted;\n    }\n    get isEnabled() {\n        return true;\n    }\n    get isSubscribed() {\n        return this.track !== undefined;\n    }\n    get isEncrypted() {\n        return this.encryption !== Encryption_Type.NONE;\n    }\n    /**\n   * an [AudioTrack] if this publication holds an audio track\n   */ get audioTrack() {\n        if (this.track instanceof LocalAudioTrack || this.track instanceof RemoteAudioTrack) {\n            return this.track;\n        }\n    }\n    /**\n   * an [VideoTrack] if this publication holds a video track\n   */ get videoTrack() {\n        if (this.track instanceof LocalVideoTrack || this.track instanceof RemoteVideoTrack) {\n            return this.track;\n        }\n    }\n    /** @internal */ updateInfo(info) {\n        this.trackSid = info.sid;\n        this.trackName = info.name;\n        this.source = Track.sourceFromProto(info.source);\n        this.mimeType = info.mimeType;\n        if (this.kind === Track.Kind.Video && info.width > 0) {\n            this.dimensions = {\n                width: info.width,\n                height: info.height\n            };\n            this.simulcasted = info.simulcast;\n        }\n        this.encryption = info.encryption;\n        this.trackInfo = info;\n        this.log.debug('update publication info', Object.assign(Object.assign({}, this.logContext), {\n            info\n        }));\n    }\n}\n(function(TrackPublication) {\n    (function(SubscriptionStatus) {\n        SubscriptionStatus[\"Desired\"] = \"desired\";\n        SubscriptionStatus[\"Subscribed\"] = \"subscribed\";\n        SubscriptionStatus[\"Unsubscribed\"] = \"unsubscribed\";\n    })(TrackPublication.SubscriptionStatus || (TrackPublication.SubscriptionStatus = {}));\n    (function(PermissionStatus) {\n        PermissionStatus[\"Allowed\"] = \"allowed\";\n        PermissionStatus[\"NotAllowed\"] = \"not_allowed\";\n    })(TrackPublication.PermissionStatus || (TrackPublication.PermissionStatus = {}));\n})(TrackPublication || (TrackPublication = {}));\nclass LocalTrackPublication extends TrackPublication {\n    get isUpstreamPaused() {\n        var _a;\n        return (_a = this.track) === null || _a === void 0 ? void 0 : _a.isUpstreamPaused;\n    }\n    constructor(kind, ti, track, loggerOptions){\n        super(kind, ti.sid, ti.name, loggerOptions);\n        this.track = undefined;\n        this.handleTrackEnded = ()=>{\n            this.emit(TrackEvent.Ended);\n        };\n        this.updateInfo(ti);\n        this.setTrack(track);\n    }\n    setTrack(track) {\n        if (this.track) {\n            this.track.off(TrackEvent.Ended, this.handleTrackEnded);\n        }\n        super.setTrack(track);\n        if (track) {\n            track.on(TrackEvent.Ended, this.handleTrackEnded);\n        }\n    }\n    get isMuted() {\n        if (this.track) {\n            return this.track.isMuted;\n        }\n        return super.isMuted;\n    }\n    get audioTrack() {\n        return super.audioTrack;\n    }\n    get videoTrack() {\n        return super.videoTrack;\n    }\n    /**\n   * Mute the track associated with this publication\n   */ mute() {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            return (_a = this.track) === null || _a === void 0 ? void 0 : _a.mute();\n        });\n    }\n    /**\n   * Unmute track associated with this publication\n   */ unmute() {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            return (_a = this.track) === null || _a === void 0 ? void 0 : _a.unmute();\n        });\n    }\n    /**\n   * Pauses the media stream track associated with this publication from being sent to the server\n   * and signals \"muted\" event to other participants\n   * Useful if you want to pause the stream without pausing the local media stream track\n   */ pauseUpstream() {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            yield (_a = this.track) === null || _a === void 0 ? void 0 : _a.pauseUpstream();\n        });\n    }\n    /**\n   * Resumes sending the media stream track associated with this publication to the server after a call to [[pauseUpstream()]]\n   * and signals \"unmuted\" event to other participants (unless the track is explicitly muted)\n   */ resumeUpstream() {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            yield (_a = this.track) === null || _a === void 0 ? void 0 : _a.resumeUpstream();\n        });\n    }\n}\nvar ConnectionQuality;\n(function(ConnectionQuality) {\n    ConnectionQuality[\"Excellent\"] = \"excellent\";\n    ConnectionQuality[\"Good\"] = \"good\";\n    ConnectionQuality[\"Poor\"] = \"poor\";\n    /**\n   * Indicates that a participant has temporarily (or permanently) lost connection to LiveKit.\n   * For permanent disconnection a `ParticipantDisconnected` event will be emitted after a timeout\n   */ ConnectionQuality[\"Lost\"] = \"lost\";\n    ConnectionQuality[\"Unknown\"] = \"unknown\";\n})(ConnectionQuality || (ConnectionQuality = {}));\nfunction qualityFromProto(q) {\n    switch(q){\n        case ConnectionQuality$1.EXCELLENT:\n            return ConnectionQuality.Excellent;\n        case ConnectionQuality$1.GOOD:\n            return ConnectionQuality.Good;\n        case ConnectionQuality$1.POOR:\n            return ConnectionQuality.Poor;\n        case ConnectionQuality$1.LOST:\n            return ConnectionQuality.Lost;\n        default:\n            return ConnectionQuality.Unknown;\n    }\n}\nclass Participant extends eventsExports.EventEmitter {\n    get logContext() {\n        var _a, _b;\n        return Object.assign(Object.assign({}, (_b = (_a = this.loggerOptions) === null || _a === void 0 ? void 0 : _a.loggerContextCb) === null || _b === void 0 ? void 0 : _b.call(_a)), {\n            participantSid: this.sid,\n            participantId: this.identity\n        });\n    }\n    get isEncrypted() {\n        return this.tracks.size > 0 && Array.from(this.tracks.values()).every((tr)=>tr.isEncrypted);\n    }\n    get isAgent() {\n        var _a, _b;\n        return (_b = (_a = this.permissions) === null || _a === void 0 ? void 0 : _a.agent) !== null && _b !== void 0 ? _b : false;\n    }\n    /** @internal */ constructor(sid, identity, name, metadata, loggerOptions){\n        var _a;\n        super();\n        /** audio level between 0-1.0, 1 being loudest, 0 being softest */ this.audioLevel = 0;\n        /** if participant is currently speaking */ this.isSpeaking = false;\n        this._connectionQuality = ConnectionQuality.Unknown;\n        this.log = livekitLogger;\n        this.log = getLogger((_a = loggerOptions === null || loggerOptions === void 0 ? void 0 : loggerOptions.loggerName) !== null && _a !== void 0 ? _a : LoggerNames.Participant);\n        this.loggerOptions = loggerOptions;\n        this.setMaxListeners(100);\n        this.sid = sid;\n        this.identity = identity;\n        this.name = name;\n        this.metadata = metadata;\n        this.audioTracks = new Map();\n        this.videoTracks = new Map();\n        this.tracks = new Map();\n    }\n    getTracks() {\n        return Array.from(this.tracks.values());\n    }\n    /**\n   * Finds the first track that matches the source filter, for example, getting\n   * the user's camera track with getTrackBySource(Track.Source.Camera).\n   * @param source\n   * @returns\n   */ getTrack(source) {\n        for (const [, pub] of this.tracks){\n            if (pub.source === source) {\n                return pub;\n            }\n        }\n    }\n    /**\n   * Finds the first track that matches the track's name.\n   * @param name\n   * @returns\n   */ getTrackByName(name) {\n        for (const [, pub] of this.tracks){\n            if (pub.trackName === name) {\n                return pub;\n            }\n        }\n    }\n    get connectionQuality() {\n        return this._connectionQuality;\n    }\n    get isCameraEnabled() {\n        var _a;\n        const track = this.getTrack(Track.Source.Camera);\n        return !((_a = track === null || track === void 0 ? void 0 : track.isMuted) !== null && _a !== void 0 ? _a : true);\n    }\n    get isMicrophoneEnabled() {\n        var _a;\n        const track = this.getTrack(Track.Source.Microphone);\n        return !((_a = track === null || track === void 0 ? void 0 : track.isMuted) !== null && _a !== void 0 ? _a : true);\n    }\n    get isScreenShareEnabled() {\n        const track = this.getTrack(Track.Source.ScreenShare);\n        return !!track;\n    }\n    get isLocal() {\n        return false;\n    }\n    /** when participant joined the room */ get joinedAt() {\n        if (this.participantInfo) {\n            return new Date(Number.parseInt(this.participantInfo.joinedAt.toString()) * 1000);\n        }\n        return new Date();\n    }\n    /** @internal */ updateInfo(info) {\n        // it's possible the update could be applied out of order due to await\n        // during reconnect sequences. when that happens, it's possible for server\n        // to have sent more recent version of participant info while JS is waiting\n        // to process the existing payload.\n        // when the participant sid remains the same, and we already have a later version\n        // of the payload, they can be safely skipped\n        if (this.participantInfo && this.participantInfo.sid === info.sid && this.participantInfo.version > info.version) {\n            return false;\n        }\n        this.identity = info.identity;\n        this.sid = info.sid;\n        this._setName(info.name);\n        this._setMetadata(info.metadata);\n        if (info.permission) {\n            this.setPermissions(info.permission);\n        }\n        // set this last so setMetadata can detect changes\n        this.participantInfo = info;\n        this.log.trace('update participant info', Object.assign(Object.assign({}, this.logContext), {\n            info\n        }));\n        return true;\n    }\n    /**\n   * Updates metadata from server\n   **/ _setMetadata(md) {\n        const changed = this.metadata !== md;\n        const prevMetadata = this.metadata;\n        this.metadata = md;\n        if (changed) {\n            this.emit(ParticipantEvent.ParticipantMetadataChanged, prevMetadata);\n        }\n    }\n    _setName(name) {\n        const changed = this.name !== name;\n        this.name = name;\n        if (changed) {\n            this.emit(ParticipantEvent.ParticipantNameChanged, name);\n        }\n    }\n    /** @internal */ setPermissions(permissions) {\n        var _a, _b, _c, _d, _e;\n        const prevPermissions = this.permissions;\n        const changed = permissions.canPublish !== ((_a = this.permissions) === null || _a === void 0 ? void 0 : _a.canPublish) || permissions.canSubscribe !== ((_b = this.permissions) === null || _b === void 0 ? void 0 : _b.canSubscribe) || permissions.canPublishData !== ((_c = this.permissions) === null || _c === void 0 ? void 0 : _c.canPublishData) || permissions.hidden !== ((_d = this.permissions) === null || _d === void 0 ? void 0 : _d.hidden) || permissions.recorder !== ((_e = this.permissions) === null || _e === void 0 ? void 0 : _e.recorder) || permissions.canPublishSources.length !== this.permissions.canPublishSources.length || permissions.canPublishSources.some((value, index)=>{\n            var _a;\n            return value !== ((_a = this.permissions) === null || _a === void 0 ? void 0 : _a.canPublishSources[index]);\n        });\n        this.permissions = permissions;\n        if (changed) {\n            this.emit(ParticipantEvent.ParticipantPermissionsChanged, prevPermissions);\n        }\n        return changed;\n    }\n    /** @internal */ setIsSpeaking(speaking) {\n        if (speaking === this.isSpeaking) {\n            return;\n        }\n        this.isSpeaking = speaking;\n        if (speaking) {\n            this.lastSpokeAt = new Date();\n        }\n        this.emit(ParticipantEvent.IsSpeakingChanged, speaking);\n    }\n    /** @internal */ setConnectionQuality(q) {\n        const prevQuality = this._connectionQuality;\n        this._connectionQuality = qualityFromProto(q);\n        if (prevQuality !== this._connectionQuality) {\n            this.emit(ParticipantEvent.ConnectionQualityChanged, this._connectionQuality);\n        }\n    }\n    /**\n   * @internal\n   */ setAudioContext(ctx) {\n        this.audioContext = ctx;\n        this.audioTracks.forEach((track)=>(track.track instanceof RemoteAudioTrack || track.track instanceof LocalAudioTrack) && track.track.setAudioContext(ctx));\n    }\n    addTrackPublication(publication) {\n        // forward publication driven events\n        publication.on(TrackEvent.Muted, ()=>{\n            this.emit(ParticipantEvent.TrackMuted, publication);\n        });\n        publication.on(TrackEvent.Unmuted, ()=>{\n            this.emit(ParticipantEvent.TrackUnmuted, publication);\n        });\n        const pub = publication;\n        if (pub.track) {\n            pub.track.sid = publication.trackSid;\n        }\n        this.tracks.set(publication.trackSid, publication);\n        switch(publication.kind){\n            case Track.Kind.Audio:\n                this.audioTracks.set(publication.trackSid, publication);\n                break;\n            case Track.Kind.Video:\n                this.videoTracks.set(publication.trackSid, publication);\n                break;\n        }\n    }\n}\nfunction trackPermissionToProto(perms) {\n    var _a, _b, _c;\n    if (!perms.participantSid && !perms.participantIdentity) {\n        throw new Error('Invalid track permission, must provide at least one of participantIdentity and participantSid');\n    }\n    return new TrackPermission({\n        participantIdentity: (_a = perms.participantIdentity) !== null && _a !== void 0 ? _a : '',\n        participantSid: (_b = perms.participantSid) !== null && _b !== void 0 ? _b : '',\n        allTracks: (_c = perms.allowAll) !== null && _c !== void 0 ? _c : false,\n        trackSids: perms.allowedTrackSids || []\n    });\n}\nclass RemoteTrackPublication extends TrackPublication {\n    constructor(kind, ti, autoSubscribe, loggerOptions){\n        super(kind, ti.sid, ti.name, loggerOptions);\n        this.track = undefined;\n        /** @internal */ this.allowed = true;\n        this.disabled = false;\n        this.currentVideoQuality = VideoQuality.HIGH;\n        this.handleEnded = (track)=>{\n            this.setTrack(undefined);\n            this.emit(TrackEvent.Ended, track);\n        };\n        this.handleVisibilityChange = (visible)=>{\n            this.log.debug(\"adaptivestream video visibility \".concat(this.trackSid, \", visible=\").concat(visible), this.logContext);\n            this.disabled = !visible;\n            this.emitTrackUpdate();\n        };\n        this.handleVideoDimensionsChange = (dimensions)=>{\n            this.log.debug(\"adaptivestream video dimensions \".concat(dimensions.width, \"x\").concat(dimensions.height), this.logContext);\n            this.videoDimensions = dimensions;\n            this.emitTrackUpdate();\n        };\n        this.subscribed = autoSubscribe;\n        this.updateInfo(ti);\n    }\n    /**\n   * Subscribe or unsubscribe to this remote track\n   * @param subscribed true to subscribe to a track, false to unsubscribe\n   */ setSubscribed(subscribed) {\n        const prevStatus = this.subscriptionStatus;\n        const prevPermission = this.permissionStatus;\n        this.subscribed = subscribed;\n        // reset allowed status when desired subscription state changes\n        // server will notify client via signal message if it's not allowed\n        if (subscribed) {\n            this.allowed = true;\n        }\n        const sub = new UpdateSubscription({\n            trackSids: [\n                this.trackSid\n            ],\n            subscribe: this.subscribed,\n            participantTracks: [\n                new ParticipantTracks({\n                    // sending an empty participant id since TrackPublication doesn't keep it\n                    // this is filled in by the participant that receives this message\n                    participantSid: '',\n                    trackSids: [\n                        this.trackSid\n                    ]\n                })\n            ]\n        });\n        this.emit(TrackEvent.UpdateSubscription, sub);\n        this.emitSubscriptionUpdateIfChanged(prevStatus);\n        this.emitPermissionUpdateIfChanged(prevPermission);\n    }\n    get subscriptionStatus() {\n        if (this.subscribed === false) {\n            return TrackPublication.SubscriptionStatus.Unsubscribed;\n        }\n        if (!super.isSubscribed) {\n            return TrackPublication.SubscriptionStatus.Desired;\n        }\n        return TrackPublication.SubscriptionStatus.Subscribed;\n    }\n    get permissionStatus() {\n        return this.allowed ? TrackPublication.PermissionStatus.Allowed : TrackPublication.PermissionStatus.NotAllowed;\n    }\n    /**\n   * Returns true if track is subscribed, and ready for playback\n   */ get isSubscribed() {\n        if (this.subscribed === false) {\n            return false;\n        }\n        return super.isSubscribed;\n    }\n    // returns client's desire to subscribe to a track, also true if autoSubscribe is enabled\n    get isDesired() {\n        return this.subscribed !== false;\n    }\n    get isEnabled() {\n        return !this.disabled;\n    }\n    /**\n   * disable server from sending down data for this track. this is useful when\n   * the participant is off screen, you may disable streaming down their video\n   * to reduce bandwidth requirements\n   * @param enabled\n   */ setEnabled(enabled) {\n        if (!this.isManualOperationAllowed() || this.disabled === !enabled) {\n            return;\n        }\n        this.disabled = !enabled;\n        this.emitTrackUpdate();\n    }\n    /**\n   * for tracks that support simulcasting, adjust subscribed quality\n   *\n   * This indicates the highest quality the client can accept. if network\n   * bandwidth does not allow, server will automatically reduce quality to\n   * optimize for uninterrupted video\n   */ setVideoQuality(quality) {\n        if (!this.isManualOperationAllowed() || this.currentVideoQuality === quality) {\n            return;\n        }\n        this.currentVideoQuality = quality;\n        this.videoDimensions = undefined;\n        this.emitTrackUpdate();\n    }\n    setVideoDimensions(dimensions) {\n        var _a, _b;\n        if (!this.isManualOperationAllowed()) {\n            return;\n        }\n        if (((_a = this.videoDimensions) === null || _a === void 0 ? void 0 : _a.width) === dimensions.width && ((_b = this.videoDimensions) === null || _b === void 0 ? void 0 : _b.height) === dimensions.height) {\n            return;\n        }\n        if (this.track instanceof RemoteVideoTrack) {\n            this.videoDimensions = dimensions;\n        }\n        this.currentVideoQuality = undefined;\n        this.emitTrackUpdate();\n    }\n    setVideoFPS(fps) {\n        if (!this.isManualOperationAllowed()) {\n            return;\n        }\n        if (!(this.track instanceof RemoteVideoTrack)) {\n            return;\n        }\n        if (this.fps === fps) {\n            return;\n        }\n        this.fps = fps;\n        this.emitTrackUpdate();\n    }\n    get videoQuality() {\n        return this.currentVideoQuality;\n    }\n    /** @internal */ setTrack(track) {\n        const prevStatus = this.subscriptionStatus;\n        const prevPermission = this.permissionStatus;\n        const prevTrack = this.track;\n        if (prevTrack === track) {\n            return;\n        }\n        if (prevTrack) {\n            // unregister listener\n            prevTrack.off(TrackEvent.VideoDimensionsChanged, this.handleVideoDimensionsChange);\n            prevTrack.off(TrackEvent.VisibilityChanged, this.handleVisibilityChange);\n            prevTrack.off(TrackEvent.Ended, this.handleEnded);\n            prevTrack.detach();\n            prevTrack.stopMonitor();\n            this.emit(TrackEvent.Unsubscribed, prevTrack);\n        }\n        super.setTrack(track);\n        if (track) {\n            track.sid = this.trackSid;\n            track.on(TrackEvent.VideoDimensionsChanged, this.handleVideoDimensionsChange);\n            track.on(TrackEvent.VisibilityChanged, this.handleVisibilityChange);\n            track.on(TrackEvent.Ended, this.handleEnded);\n            this.emit(TrackEvent.Subscribed, track);\n        }\n        this.emitPermissionUpdateIfChanged(prevPermission);\n        this.emitSubscriptionUpdateIfChanged(prevStatus);\n    }\n    /** @internal */ setAllowed(allowed) {\n        const prevStatus = this.subscriptionStatus;\n        const prevPermission = this.permissionStatus;\n        this.allowed = allowed;\n        this.emitPermissionUpdateIfChanged(prevPermission);\n        this.emitSubscriptionUpdateIfChanged(prevStatus);\n    }\n    /** @internal */ setSubscriptionError(error) {\n        this.emit(TrackEvent.SubscriptionFailed, error);\n    }\n    /** @internal */ updateInfo(info) {\n        super.updateInfo(info);\n        const prevMetadataMuted = this.metadataMuted;\n        this.metadataMuted = info.muted;\n        if (this.track) {\n            this.track.setMuted(info.muted);\n        } else if (prevMetadataMuted !== info.muted) {\n            this.emit(info.muted ? TrackEvent.Muted : TrackEvent.Unmuted);\n        }\n    }\n    emitSubscriptionUpdateIfChanged(previousStatus) {\n        const currentStatus = this.subscriptionStatus;\n        if (previousStatus === currentStatus) {\n            return;\n        }\n        this.emit(TrackEvent.SubscriptionStatusChanged, currentStatus, previousStatus);\n    }\n    emitPermissionUpdateIfChanged(previousPermissionStatus) {\n        const currentPermissionStatus = this.permissionStatus;\n        if (currentPermissionStatus !== previousPermissionStatus) {\n            this.emit(TrackEvent.SubscriptionPermissionChanged, this.permissionStatus, previousPermissionStatus);\n        }\n    }\n    isManualOperationAllowed() {\n        if (this.kind === Track.Kind.Video && this.isAdaptiveStream) {\n            this.log.warn('adaptive stream is enabled, cannot change video track settings', this.logContext);\n            return false;\n        }\n        if (!this.isDesired) {\n            this.log.warn('cannot update track settings when not subscribed', this.logContext);\n            return false;\n        }\n        return true;\n    }\n    get isAdaptiveStream() {\n        return this.track instanceof RemoteVideoTrack && this.track.isAdaptiveStream;\n    }\n    /* @internal */ emitTrackUpdate() {\n        const settings = new UpdateTrackSettings({\n            trackSids: [\n                this.trackSid\n            ],\n            disabled: this.disabled,\n            fps: this.fps\n        });\n        if (this.videoDimensions) {\n            settings.width = Math.ceil(this.videoDimensions.width);\n            settings.height = Math.ceil(this.videoDimensions.height);\n        } else if (this.currentVideoQuality !== undefined) {\n            settings.quality = this.currentVideoQuality;\n        } else {\n            // defaults to high quality\n            settings.quality = VideoQuality.HIGH;\n        }\n        this.emit(TrackEvent.UpdateSettings, settings);\n    }\n}\nclass RemoteParticipant extends Participant {\n    /** @internal */ static fromParticipantInfo(signalClient, pi) {\n        return new RemoteParticipant(signalClient, pi.sid, pi.identity, pi.name, pi.metadata);\n    }\n    /** @internal */ constructor(signalClient, sid, identity, name, metadata, loggerOptions){\n        super(sid, identity || '', name, metadata, loggerOptions);\n        this.signalClient = signalClient;\n        this.tracks = new Map();\n        this.audioTracks = new Map();\n        this.videoTracks = new Map();\n        this.volumeMap = new Map();\n    }\n    addTrackPublication(publication) {\n        super.addTrackPublication(publication);\n        // register action events\n        publication.on(TrackEvent.UpdateSettings, (settings)=>{\n            this.log.debug('send update settings', Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(publication)));\n            this.signalClient.sendUpdateTrackSettings(settings);\n        });\n        publication.on(TrackEvent.UpdateSubscription, (sub)=>{\n            sub.participantTracks.forEach((pt)=>{\n                pt.participantSid = this.sid;\n            });\n            this.signalClient.sendUpdateSubscription(sub);\n        });\n        publication.on(TrackEvent.SubscriptionPermissionChanged, (status)=>{\n            this.emit(ParticipantEvent.TrackSubscriptionPermissionChanged, publication, status);\n        });\n        publication.on(TrackEvent.SubscriptionStatusChanged, (status)=>{\n            this.emit(ParticipantEvent.TrackSubscriptionStatusChanged, publication, status);\n        });\n        publication.on(TrackEvent.Subscribed, (track)=>{\n            this.emit(ParticipantEvent.TrackSubscribed, track, publication);\n        });\n        publication.on(TrackEvent.Unsubscribed, (previousTrack)=>{\n            this.emit(ParticipantEvent.TrackUnsubscribed, previousTrack, publication);\n        });\n        publication.on(TrackEvent.SubscriptionFailed, (error)=>{\n            this.emit(ParticipantEvent.TrackSubscriptionFailed, publication.trackSid, error);\n        });\n    }\n    getTrack(source) {\n        const track = super.getTrack(source);\n        if (track) {\n            return track;\n        }\n    }\n    getTrackByName(name) {\n        const track = super.getTrackByName(name);\n        if (track) {\n            return track;\n        }\n    }\n    /**\n   * sets the volume on the participant's audio track\n   * by default, this affects the microphone publication\n   * a different source can be passed in as a second argument\n   * if no track exists the volume will be applied when the microphone track is added\n   */ setVolume(volume) {\n        let source = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Track.Source.Microphone;\n        this.volumeMap.set(source, volume);\n        const audioPublication = this.getTrack(source);\n        if (audioPublication && audioPublication.track) {\n            audioPublication.track.setVolume(volume);\n        }\n    }\n    /**\n   * gets the volume on the participant's microphone track\n   */ getVolume() {\n        let source = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Track.Source.Microphone;\n        const audioPublication = this.getTrack(source);\n        if (audioPublication && audioPublication.track) {\n            return audioPublication.track.getVolume();\n        }\n        return this.volumeMap.get(source);\n    }\n    /** @internal */ addSubscribedMediaTrack(mediaTrack, sid, mediaStream, receiver, adaptiveStreamSettings, triesLeft) {\n        // find the track publication\n        // it's possible for the media track to arrive before participant info\n        let publication = this.getTrackPublication(sid);\n        // it's also possible that the browser didn't honor our original track id\n        // FireFox would use its own local uuid instead of server track id\n        if (!publication) {\n            if (!sid.startsWith('TR')) {\n                // find the first track that matches type\n                this.tracks.forEach((p)=>{\n                    if (!publication && mediaTrack.kind === p.kind.toString()) {\n                        publication = p;\n                    }\n                });\n            }\n        }\n        // when we couldn't locate the track, it's possible that the metadata hasn't\n        // yet arrived. Wait a bit longer for it to arrive, or fire an error\n        if (!publication) {\n            if (triesLeft === 0) {\n                this.log.error('could not find published track', Object.assign(Object.assign({}, this.logContext), {\n                    trackSid: sid\n                }));\n                this.emit(ParticipantEvent.TrackSubscriptionFailed, sid);\n                return;\n            }\n            if (triesLeft === undefined) triesLeft = 20;\n            setTimeout(()=>{\n                this.addSubscribedMediaTrack(mediaTrack, sid, mediaStream, receiver, adaptiveStreamSettings, triesLeft - 1);\n            }, 150);\n            return;\n        }\n        if (mediaTrack.readyState === 'ended') {\n            this.log.error('unable to subscribe because MediaStreamTrack is ended. Do not call MediaStreamTrack.stop()', Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(publication)));\n            this.emit(ParticipantEvent.TrackSubscriptionFailed, sid);\n            return;\n        }\n        const isVideo = mediaTrack.kind === 'video';\n        let track;\n        if (isVideo) {\n            track = new RemoteVideoTrack(mediaTrack, sid, receiver, adaptiveStreamSettings);\n        } else {\n            track = new RemoteAudioTrack(mediaTrack, sid, receiver, this.audioContext, this.audioOutput);\n        }\n        // set track info\n        track.source = publication.source;\n        // keep publication's muted status\n        track.isMuted = publication.isMuted;\n        track.setMediaStream(mediaStream);\n        track.start();\n        publication.setTrack(track);\n        // set participant volumes on new audio tracks\n        if (this.volumeMap.has(publication.source) && track instanceof RemoteAudioTrack) {\n            track.setVolume(this.volumeMap.get(publication.source));\n        }\n        return publication;\n    }\n    /** @internal */ get hasMetadata() {\n        return !!this.participantInfo;\n    }\n    getTrackPublication(sid) {\n        return this.tracks.get(sid);\n    }\n    /** @internal */ updateInfo(info) {\n        if (!super.updateInfo(info)) {\n            return false;\n        }\n        // we are getting a list of all available tracks, reconcile in here\n        // and send out events for changes\n        // reconcile track publications, publish events only if metadata is already there\n        // i.e. changes since the local participant has joined\n        const validTracks = new Map();\n        const newTracks = new Map();\n        info.tracks.forEach((ti)=>{\n            var _a, _b;\n            let publication = this.getTrackPublication(ti.sid);\n            if (!publication) {\n                // new publication\n                const kind = Track.kindFromProto(ti.type);\n                if (!kind) {\n                    return;\n                }\n                publication = new RemoteTrackPublication(kind, ti, (_a = this.signalClient.connectOptions) === null || _a === void 0 ? void 0 : _a.autoSubscribe, {\n                    loggerContextCb: ()=>this.logContext,\n                    loggerName: (_b = this.loggerOptions) === null || _b === void 0 ? void 0 : _b.loggerName\n                });\n                publication.updateInfo(ti);\n                newTracks.set(ti.sid, publication);\n                const existingTrackOfSource = Array.from(this.tracks.values()).find((publishedTrack)=>publishedTrack.source === (publication === null || publication === void 0 ? void 0 : publication.source));\n                if (existingTrackOfSource && publication.source !== Track.Source.Unknown) {\n                    this.log.debug(\"received a second track publication for \".concat(this.identity, \" with the same source: \").concat(publication.source), Object.assign(Object.assign({}, this.logContext), {\n                        oldTrack: getLogContextFromTrack(existingTrackOfSource),\n                        newTrack: getLogContextFromTrack(publication)\n                    }));\n                }\n                this.addTrackPublication(publication);\n            } else {\n                publication.updateInfo(ti);\n            }\n            validTracks.set(ti.sid, publication);\n        });\n        // detect removed tracks\n        this.tracks.forEach((publication)=>{\n            if (!validTracks.has(publication.trackSid)) {\n                this.log.trace('detected removed track on remote participant, unpublishing', Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(publication)));\n                this.unpublishTrack(publication.trackSid, true);\n            }\n        });\n        // always emit events for new publications, Room will not forward them unless it's ready\n        newTracks.forEach((publication)=>{\n            this.emit(ParticipantEvent.TrackPublished, publication);\n        });\n        return true;\n    }\n    /** @internal */ unpublishTrack(sid, sendUnpublish) {\n        const publication = this.tracks.get(sid);\n        if (!publication) {\n            return;\n        }\n        // also send unsubscribe, if track is actively subscribed\n        const { track } = publication;\n        if (track) {\n            track.stop();\n            publication.setTrack(undefined);\n        }\n        // remove track from maps only after unsubscribed has been fired\n        this.tracks.delete(sid);\n        // remove from the right type map\n        switch(publication.kind){\n            case Track.Kind.Audio:\n                this.audioTracks.delete(sid);\n                break;\n            case Track.Kind.Video:\n                this.videoTracks.delete(sid);\n                break;\n        }\n        if (sendUnpublish) {\n            this.emit(ParticipantEvent.TrackUnpublished, publication);\n        }\n    }\n    /**\n   * @internal\n   */ setAudioOutput(output) {\n        return __awaiter(this, void 0, void 0, function*() {\n            this.audioOutput = output;\n            const promises = [];\n            this.audioTracks.forEach((pub)=>{\n                var _a;\n                if (pub.track instanceof RemoteAudioTrack) {\n                    promises.push(pub.track.setSinkId((_a = output.deviceId) !== null && _a !== void 0 ? _a : 'default'));\n                }\n            });\n            yield Promise.all(promises);\n        });\n    }\n    /** @internal */ emit(event) {\n        for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n            args[_key - 1] = arguments[_key];\n        }\n        this.log.trace('participant event', Object.assign(Object.assign({}, this.logContext), {\n            event,\n            args\n        }));\n        return super.emit(event, ...args);\n    }\n}\nclass LocalParticipant extends Participant {\n    /** @internal */ constructor(sid, identity, engine, options){\n        super(sid, identity, undefined, undefined, {\n            loggerName: options.loggerName,\n            loggerContextCb: ()=>this.engine.logContext\n        });\n        this.pendingPublishing = new Set();\n        this.pendingPublishPromises = new Map();\n        this.participantTrackPermissions = [];\n        this.allParticipantsAllowedToSubscribe = true;\n        this.encryptionType = Encryption_Type.NONE;\n        this.handleReconnecting = ()=>{\n            if (!this.reconnectFuture) {\n                this.reconnectFuture = new Future();\n            }\n        };\n        this.handleReconnected = ()=>{\n            var _a, _b;\n            (_b = (_a = this.reconnectFuture) === null || _a === void 0 ? void 0 : _a.resolve) === null || _b === void 0 ? void 0 : _b.call(_a);\n            this.reconnectFuture = undefined;\n            this.updateTrackSubscriptionPermissions();\n        };\n        this.handleDisconnected = ()=>{\n            var _a, _b;\n            if (this.reconnectFuture) {\n                this.reconnectFuture.promise.catch((e)=>this.log.warn(e.message, this.logContext));\n                (_b = (_a = this.reconnectFuture) === null || _a === void 0 ? void 0 : _a.reject) === null || _b === void 0 ? void 0 : _b.call(_a, 'Got disconnected during reconnection attempt');\n                this.reconnectFuture = undefined;\n            }\n        };\n        this.updateTrackSubscriptionPermissions = ()=>{\n            this.log.debug('updating track subscription permissions', Object.assign(Object.assign({}, this.logContext), {\n                allParticipantsAllowed: this.allParticipantsAllowedToSubscribe,\n                participantTrackPermissions: this.participantTrackPermissions\n            }));\n            this.engine.client.sendUpdateSubscriptionPermissions(this.allParticipantsAllowedToSubscribe, this.participantTrackPermissions.map((p)=>trackPermissionToProto(p)));\n        };\n        /** @internal */ this.onTrackUnmuted = (track)=>{\n            this.onTrackMuted(track, track.isUpstreamPaused);\n        };\n        // when the local track changes in mute status, we'll notify server as such\n        /** @internal */ this.onTrackMuted = (track, muted)=>{\n            if (muted === undefined) {\n                muted = true;\n            }\n            if (!track.sid) {\n                this.log.error('could not update mute status for unpublished track', Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));\n                return;\n            }\n            this.engine.updateMuteStatus(track.sid, muted);\n        };\n        this.onTrackUpstreamPaused = (track)=>{\n            this.log.debug('upstream paused', Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));\n            this.onTrackMuted(track, true);\n        };\n        this.onTrackUpstreamResumed = (track)=>{\n            this.log.debug('upstream resumed', Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));\n            this.onTrackMuted(track, track.isMuted);\n        };\n        this.handleSubscribedQualityUpdate = (update)=>__awaiter(this, void 0, void 0, function*() {\n                var _a, e_1, _b, _c;\n                var _d, _e;\n                if (!((_d = this.roomOptions) === null || _d === void 0 ? void 0 : _d.dynacast)) {\n                    return;\n                }\n                const pub = this.videoTracks.get(update.trackSid);\n                if (!pub) {\n                    this.log.warn('received subscribed quality update for unknown track', Object.assign(Object.assign({}, this.logContext), {\n                        trackSid: update.trackSid\n                    }));\n                    return;\n                }\n                if (update.subscribedCodecs.length > 0) {\n                    if (!pub.videoTrack) {\n                        return;\n                    }\n                    const newCodecs = yield pub.videoTrack.setPublishingCodecs(update.subscribedCodecs);\n                    try {\n                        for(var _f = true, newCodecs_1 = __asyncValues(newCodecs), newCodecs_1_1; newCodecs_1_1 = yield newCodecs_1.next(), _a = newCodecs_1_1.done, !_a; _f = true){\n                            _c = newCodecs_1_1.value;\n                            _f = false;\n                            const codec = _c;\n                            if (isBackupCodec(codec)) {\n                                this.log.debug(\"publish \".concat(codec, \" for \").concat(pub.videoTrack.sid), Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(pub)));\n                                yield this.publishAdditionalCodecForTrack(pub.videoTrack, codec, pub.options);\n                            }\n                        }\n                    } catch (e_1_1) {\n                        e_1 = {\n                            error: e_1_1\n                        };\n                    } finally{\n                        try {\n                            if (!_f && !_a && (_b = newCodecs_1.return)) yield _b.call(newCodecs_1);\n                        } finally{\n                            if (e_1) throw e_1.error;\n                        }\n                    }\n                } else if (update.subscribedQualities.length > 0) {\n                    yield (_e = pub.videoTrack) === null || _e === void 0 ? void 0 : _e.setPublishingLayers(update.subscribedQualities);\n                }\n            });\n        this.handleLocalTrackUnpublished = (unpublished)=>{\n            const track = this.tracks.get(unpublished.trackSid);\n            if (!track) {\n                this.log.warn('received unpublished event for unknown track', Object.assign(Object.assign({}, this.logContext), {\n                    trackSid: unpublished.trackSid\n                }));\n                return;\n            }\n            this.unpublishTrack(track.track);\n        };\n        this.handleTrackEnded = (track)=>__awaiter(this, void 0, void 0, function*() {\n                if (track.source === Track.Source.ScreenShare || track.source === Track.Source.ScreenShareAudio) {\n                    this.log.debug('unpublishing local track due to TrackEnded', Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));\n                    this.unpublishTrack(track);\n                } else if (track.isUserProvided) {\n                    yield track.mute();\n                } else if (track instanceof LocalAudioTrack || track instanceof LocalVideoTrack) {\n                    try {\n                        if (isWeb()) {\n                            try {\n                                const currentPermissions = yield navigator === null || navigator === void 0 ? void 0 : navigator.permissions.query({\n                                    // the permission query for camera and microphone currently not supported in Safari and Firefox\n                                    // @ts-ignore\n                                    name: track.source === Track.Source.Camera ? 'camera' : 'microphone'\n                                });\n                                if (currentPermissions && currentPermissions.state === 'denied') {\n                                    this.log.warn(\"user has revoked access to \".concat(track.source), Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));\n                                    // detect granted change after permissions were denied to try and resume then\n                                    currentPermissions.onchange = ()=>{\n                                        if (currentPermissions.state !== 'denied') {\n                                            if (!track.isMuted) {\n                                                track.restartTrack();\n                                            }\n                                            currentPermissions.onchange = null;\n                                        }\n                                    };\n                                    throw new Error('GetUserMedia Permission denied');\n                                }\n                            } catch (e) {\n                            // permissions query fails for firefox, we continue and try to restart the track\n                            }\n                        }\n                        if (!track.isMuted) {\n                            this.log.debug('track ended, attempting to use a different device', Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));\n                            yield track.restartTrack();\n                        }\n                    } catch (e) {\n                        this.log.warn(\"could not restart track, muting instead\", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));\n                        yield track.mute();\n                    }\n                }\n            });\n        this.audioTracks = new Map();\n        this.videoTracks = new Map();\n        this.tracks = new Map();\n        this.engine = engine;\n        this.roomOptions = options;\n        this.setupEngine(engine);\n        this.activeDeviceMap = new Map();\n    }\n    get lastCameraError() {\n        return this.cameraError;\n    }\n    get lastMicrophoneError() {\n        return this.microphoneError;\n    }\n    get isE2EEEnabled() {\n        return this.encryptionType !== Encryption_Type.NONE;\n    }\n    getTrack(source) {\n        const track = super.getTrack(source);\n        if (track) {\n            return track;\n        }\n    }\n    getTrackByName(name) {\n        const track = super.getTrackByName(name);\n        if (track) {\n            return track;\n        }\n    }\n    /**\n   * @internal\n   */ setupEngine(engine) {\n        this.engine = engine;\n        this.engine.on(EngineEvent.RemoteMute, (trackSid, muted)=>{\n            const pub = this.tracks.get(trackSid);\n            if (!pub || !pub.track) {\n                return;\n            }\n            if (muted) {\n                pub.mute();\n            } else {\n                pub.unmute();\n            }\n        });\n        this.engine.on(EngineEvent.Connected, this.handleReconnected).on(EngineEvent.SignalRestarted, this.handleReconnected).on(EngineEvent.SignalResumed, this.handleReconnected).on(EngineEvent.Restarting, this.handleReconnecting).on(EngineEvent.Resuming, this.handleReconnecting).on(EngineEvent.LocalTrackUnpublished, this.handleLocalTrackUnpublished).on(EngineEvent.SubscribedQualityUpdate, this.handleSubscribedQualityUpdate).on(EngineEvent.Disconnected, this.handleDisconnected);\n    }\n    /**\n   * Sets and updates the metadata of the local participant.\n   * The change does not take immediate effect.\n   * If successful, a `ParticipantEvent.MetadataChanged` event will be emitted on the local participant.\n   * Note: this requires `canUpdateOwnMetadata` permission.\n   * @param metadata\n   */ setMetadata(metadata) {\n        var _a;\n        this.engine.client.sendUpdateLocalMetadata(metadata, (_a = this.name) !== null && _a !== void 0 ? _a : '');\n    }\n    /**\n   * Sets and updates the name of the local participant.\n   * The change does not take immediate effect.\n   * If successful, a `ParticipantEvent.ParticipantNameChanged` event will be emitted on the local participant.\n   * Note: this requires `canUpdateOwnMetadata` permission.\n   * @param metadata\n   */ setName(name) {\n        var _a;\n        this.engine.client.sendUpdateLocalMetadata((_a = this.metadata) !== null && _a !== void 0 ? _a : '', name);\n    }\n    /**\n   * Enable or disable a participant's camera track.\n   *\n   * If a track has already published, it'll mute or unmute the track.\n   * Resolves with a `LocalTrackPublication` instance if successful and `undefined` otherwise\n   */ setCameraEnabled(enabled, options, publishOptions) {\n        return this.setTrackEnabled(Track.Source.Camera, enabled, options, publishOptions);\n    }\n    /**\n   * Enable or disable a participant's microphone track.\n   *\n   * If a track has already published, it'll mute or unmute the track.\n   * Resolves with a `LocalTrackPublication` instance if successful and `undefined` otherwise\n   */ setMicrophoneEnabled(enabled, options, publishOptions) {\n        return this.setTrackEnabled(Track.Source.Microphone, enabled, options, publishOptions);\n    }\n    /**\n   * Start or stop sharing a participant's screen\n   * Resolves with a `LocalTrackPublication` instance if successful and `undefined` otherwise\n   */ setScreenShareEnabled(enabled, options, publishOptions) {\n        return this.setTrackEnabled(Track.Source.ScreenShare, enabled, options, publishOptions);\n    }\n    /** @internal */ setPermissions(permissions) {\n        const prevPermissions = this.permissions;\n        const changed = super.setPermissions(permissions);\n        if (changed && prevPermissions) {\n            this.emit(ParticipantEvent.ParticipantPermissionsChanged, prevPermissions);\n        }\n        return changed;\n    }\n    /** @internal */ setE2EEEnabled(enabled) {\n        return __awaiter(this, void 0, void 0, function*() {\n            this.encryptionType = enabled ? Encryption_Type.GCM : Encryption_Type.NONE;\n            yield this.republishAllTracks(undefined, false);\n        });\n    }\n    setTrackEnabled(source, enabled, options, publishOptions) {\n        var _a, _b;\n        return __awaiter(this, void 0, void 0, function*() {\n            this.log.debug('setTrackEnabled', Object.assign(Object.assign({}, this.logContext), {\n                source,\n                enabled\n            }));\n            let track = this.getTrack(source);\n            if (enabled) {\n                if (track) {\n                    yield track.unmute();\n                } else {\n                    let localTracks;\n                    if (this.pendingPublishing.has(source)) {\n                        this.log.info('skipping duplicate published source', Object.assign(Object.assign({}, this.logContext), {\n                            source\n                        }));\n                        // no-op it's already been requested\n                        return;\n                    }\n                    this.pendingPublishing.add(source);\n                    try {\n                        switch(source){\n                            case Track.Source.Camera:\n                                localTracks = yield this.createTracks({\n                                    video: (_a = options) !== null && _a !== void 0 ? _a : true\n                                });\n                                break;\n                            case Track.Source.Microphone:\n                                localTracks = yield this.createTracks({\n                                    audio: (_b = options) !== null && _b !== void 0 ? _b : true\n                                });\n                                break;\n                            case Track.Source.ScreenShare:\n                                localTracks = yield this.createScreenTracks(Object.assign({}, options));\n                                break;\n                            default:\n                                throw new TrackInvalidError(source);\n                        }\n                        const publishPromises = [];\n                        for (const localTrack of localTracks){\n                            this.log.info('publishing track', Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(localTrack)));\n                            publishPromises.push(this.publishTrack(localTrack, publishOptions));\n                        }\n                        const publishedTracks = yield Promise.all(publishPromises);\n                        // for screen share publications including audio, this will only return the screen share publication, not the screen share audio one\n                        // revisit if we want to return an array of tracks instead for v2\n                        [track] = publishedTracks;\n                    } catch (e) {\n                        localTracks === null || localTracks === void 0 ? void 0 : localTracks.forEach((tr)=>{\n                            tr.stop();\n                        });\n                        if (e instanceof Error && !(e instanceof TrackInvalidError)) {\n                            this.emit(ParticipantEvent.MediaDevicesError, e);\n                        }\n                        throw e;\n                    } finally{\n                        this.pendingPublishing.delete(source);\n                    }\n                }\n            } else if (track && track.track) {\n                // screenshare cannot be muted, unpublish instead\n                if (source === Track.Source.ScreenShare) {\n                    track = yield this.unpublishTrack(track.track);\n                    const screenAudioTrack = this.getTrack(Track.Source.ScreenShareAudio);\n                    if (screenAudioTrack && screenAudioTrack.track) {\n                        this.unpublishTrack(screenAudioTrack.track);\n                    }\n                } else {\n                    yield track.mute();\n                }\n            }\n            return track;\n        });\n    }\n    /**\n   * Publish both camera and microphone at the same time. This is useful for\n   * displaying a single Permission Dialog box to the end user.\n   */ enableCameraAndMicrophone() {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (this.pendingPublishing.has(Track.Source.Camera) || this.pendingPublishing.has(Track.Source.Microphone)) {\n                // no-op it's already been requested\n                return;\n            }\n            this.pendingPublishing.add(Track.Source.Camera);\n            this.pendingPublishing.add(Track.Source.Microphone);\n            try {\n                const tracks = yield this.createTracks({\n                    audio: true,\n                    video: true\n                });\n                yield Promise.all(tracks.map((track)=>this.publishTrack(track)));\n            } finally{\n                this.pendingPublishing.delete(Track.Source.Camera);\n                this.pendingPublishing.delete(Track.Source.Microphone);\n            }\n        });\n    }\n    /**\n   * Create local camera and/or microphone tracks\n   * @param options\n   * @returns\n   */ createTracks(options) {\n        var _a, _b;\n        return __awaiter(this, void 0, void 0, function*() {\n            const opts = mergeDefaultOptions(options, (_a = this.roomOptions) === null || _a === void 0 ? void 0 : _a.audioCaptureDefaults, (_b = this.roomOptions) === null || _b === void 0 ? void 0 : _b.videoCaptureDefaults);\n            const constraints = constraintsForOptions(opts);\n            let stream;\n            try {\n                stream = yield navigator.mediaDevices.getUserMedia(constraints);\n            } catch (err) {\n                if (err instanceof Error) {\n                    if (constraints.audio) {\n                        this.microphoneError = err;\n                    }\n                    if (constraints.video) {\n                        this.cameraError = err;\n                    }\n                }\n                throw err;\n            }\n            if (constraints.audio) {\n                this.microphoneError = undefined;\n                this.emit(ParticipantEvent.AudioStreamAcquired);\n            }\n            if (constraints.video) {\n                this.cameraError = undefined;\n            }\n            return stream.getTracks().map((mediaStreamTrack)=>{\n                const isAudio = mediaStreamTrack.kind === 'audio';\n                isAudio ? options.audio : options.video;\n                let trackConstraints;\n                const conOrBool = isAudio ? constraints.audio : constraints.video;\n                if (typeof conOrBool !== 'boolean') {\n                    trackConstraints = conOrBool;\n                }\n                const track = mediaTrackToLocalTrack(mediaStreamTrack, trackConstraints, {\n                    loggerName: this.roomOptions.loggerName,\n                    loggerContextCb: ()=>this.logContext\n                });\n                if (track.kind === Track.Kind.Video) {\n                    track.source = Track.Source.Camera;\n                } else if (track.kind === Track.Kind.Audio) {\n                    track.source = Track.Source.Microphone;\n                }\n                track.mediaStream = stream;\n                return track;\n            });\n        });\n    }\n    /**\n   * Creates a screen capture tracks with getDisplayMedia().\n   * A LocalVideoTrack is always created and returned.\n   * If { audio: true }, and the browser supports audio capture, a LocalAudioTrack is also created.\n   */ createScreenTracks(options) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (options === undefined) {\n                options = {};\n            }\n            if (navigator.mediaDevices.getDisplayMedia === undefined) {\n                throw new DeviceUnsupportedError('getDisplayMedia not supported');\n            }\n            if (options.resolution === undefined && !isSafari17()) {\n                // we need to constrain the dimensions, otherwise it could lead to low bitrate\n                // due to encoding a huge video. Encoding such large surfaces is really expensive\n                // unfortunately Safari 17 has a but and cannot be constrained by default\n                options.resolution = ScreenSharePresets.h1080fps30.resolution;\n            }\n            const constraints = screenCaptureToDisplayMediaStreamOptions(options);\n            const stream = yield navigator.mediaDevices.getDisplayMedia(constraints);\n            const tracks = stream.getVideoTracks();\n            if (tracks.length === 0) {\n                throw new TrackInvalidError('no video track found');\n            }\n            const screenVideo = new LocalVideoTrack(tracks[0], undefined, false, {\n                loggerName: this.roomOptions.loggerName,\n                loggerContextCb: ()=>this.logContext\n            });\n            screenVideo.source = Track.Source.ScreenShare;\n            if (options.contentHint) {\n                screenVideo.mediaStreamTrack.contentHint = options.contentHint;\n            }\n            const localTracks = [\n                screenVideo\n            ];\n            if (stream.getAudioTracks().length > 0) {\n                this.emit(ParticipantEvent.AudioStreamAcquired);\n                const screenAudio = new LocalAudioTrack(stream.getAudioTracks()[0], undefined, false, this.audioContext, {\n                    loggerName: this.roomOptions.loggerName,\n                    loggerContextCb: ()=>this.logContext\n                });\n                screenAudio.source = Track.Source.ScreenShareAudio;\n                localTracks.push(screenAudio);\n            }\n            return localTracks;\n        });\n    }\n    /**\n   * Publish a new track to the room\n   * @param track\n   * @param options\n   */ publishTrack(track, options) {\n        var _a, _b, _c, _d;\n        return __awaiter(this, void 0, void 0, function*() {\n            yield (_a = this.reconnectFuture) === null || _a === void 0 ? void 0 : _a.promise;\n            if (track instanceof LocalTrack && this.pendingPublishPromises.has(track)) {\n                yield this.pendingPublishPromises.get(track);\n            }\n            let defaultConstraints;\n            if (track instanceof MediaStreamTrack) {\n                defaultConstraints = track.getConstraints();\n            } else {\n                // we want to access constraints directly as `track.mediaStreamTrack`\n                // might be pointing to a non-device track (e.g. processed track) already\n                defaultConstraints = track.constraints;\n                let deviceKind = undefined;\n                switch(track.source){\n                    case Track.Source.Microphone:\n                        deviceKind = 'audioinput';\n                        break;\n                    case Track.Source.Camera:\n                        deviceKind = 'videoinput';\n                }\n                if (deviceKind && this.activeDeviceMap.has(deviceKind)) {\n                    defaultConstraints = Object.assign(Object.assign({}, defaultConstraints), {\n                        deviceId: this.activeDeviceMap.get(deviceKind)\n                    });\n                }\n            }\n            // convert raw media track into audio or video track\n            if (track instanceof MediaStreamTrack) {\n                switch(track.kind){\n                    case 'audio':\n                        track = new LocalAudioTrack(track, defaultConstraints, true, this.audioContext, {\n                            loggerName: this.roomOptions.loggerName,\n                            loggerContextCb: ()=>this.logContext\n                        });\n                        break;\n                    case 'video':\n                        track = new LocalVideoTrack(track, defaultConstraints, true, {\n                            loggerName: this.roomOptions.loggerName,\n                            loggerContextCb: ()=>this.logContext\n                        });\n                        break;\n                    default:\n                        throw new TrackInvalidError(\"unsupported MediaStreamTrack kind \".concat(track.kind));\n                }\n            } else {\n                track.updateLoggerOptions({\n                    loggerName: this.roomOptions.loggerName,\n                    loggerContextCb: ()=>this.logContext\n                });\n            }\n            if (track instanceof LocalAudioTrack) {\n                track.setAudioContext(this.audioContext);\n            }\n            // is it already published? if so skip\n            let existingPublication;\n            this.tracks.forEach((publication)=>{\n                if (!publication.track) {\n                    return;\n                }\n                if (publication.track === track) {\n                    existingPublication = publication;\n                }\n            });\n            if (existingPublication) {\n                this.log.warn('track has already been published, skipping', Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(existingPublication)));\n                return existingPublication;\n            }\n            const isStereoInput = 'channelCount' in track.mediaStreamTrack.getSettings() && // @ts-ignore `channelCount` on getSettings() is currently only available for Safari, but is generally the best way to determine a stereo track https://developer.mozilla.org/en-US/docs/Web/API/MediaTrackSettings/channelCount\n            track.mediaStreamTrack.getSettings().channelCount === 2 || track.mediaStreamTrack.getConstraints().channelCount === 2;\n            const isStereo = (_b = options === null || options === void 0 ? void 0 : options.forceStereo) !== null && _b !== void 0 ? _b : isStereoInput;\n            // disable dtx for stereo track if not enabled explicitly\n            if (isStereo) {\n                if (!options) {\n                    options = {};\n                }\n                if (options.dtx === undefined) {\n                    this.log.info(\"Opus DTX will be disabled for stereo tracks by default. Enable them explicitly to make it work.\", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));\n                }\n                if (options.red === undefined) {\n                    this.log.info(\"Opus RED will be disabled for stereo tracks by default. Enable them explicitly to make it work.\");\n                }\n                (_c = options.dtx) !== null && _c !== void 0 ? _c : options.dtx = false;\n                (_d = options.red) !== null && _d !== void 0 ? _d : options.red = false;\n            }\n            const opts = Object.assign(Object.assign({}, this.roomOptions.publishDefaults), options);\n            // disable simulcast if e2ee is set on safari\n            if (isSafari() && this.roomOptions.e2ee) {\n                this.log.info(\"End-to-end encryption is set up, simulcast publishing will be disabled on Safari\", Object.assign({}, this.logContext));\n                opts.simulcast = false;\n            }\n            if (opts.source) {\n                track.source = opts.source;\n            }\n            const publishPromise = this.publish(track, opts, isStereo);\n            this.pendingPublishPromises.set(track, publishPromise);\n            try {\n                const publication = yield publishPromise;\n                return publication;\n            } catch (e) {\n                throw e;\n            } finally{\n                this.pendingPublishPromises.delete(track);\n            }\n        });\n    }\n    publish(track, opts, isStereo) {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o;\n        return __awaiter(this, void 0, void 0, function*() {\n            const existingTrackOfSource = Array.from(this.tracks.values()).find((publishedTrack)=>track instanceof LocalTrack && publishedTrack.source === track.source);\n            if (existingTrackOfSource && track.source !== Track.Source.Unknown) {\n                this.log.info(\"publishing a second track with the same source: \".concat(track.source), Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));\n            }\n            if (opts.stopMicTrackOnMute && track instanceof LocalAudioTrack) {\n                track.stopOnMute = true;\n            }\n            if (track.source === Track.Source.ScreenShare && isFireFox()) {\n                // Firefox does not work well with simulcasted screen share\n                // we frequently get no data on layer 0 when enabled\n                opts.simulcast = false;\n            }\n            // require full AV1/VP9 SVC support prior to using it\n            if (opts.videoCodec === 'av1' && !supportsAV1()) {\n                opts.videoCodec = undefined;\n            }\n            if (opts.videoCodec === 'vp9' && !supportsVP9()) {\n                opts.videoCodec = undefined;\n            }\n            if (opts.videoCodec === undefined) {\n                opts.videoCodec = defaultVideoCodec;\n            }\n            const videoCodec = opts.videoCodec;\n            // handle track actions\n            track.on(TrackEvent.Muted, this.onTrackMuted);\n            track.on(TrackEvent.Unmuted, this.onTrackUnmuted);\n            track.on(TrackEvent.Ended, this.handleTrackEnded);\n            track.on(TrackEvent.UpstreamPaused, this.onTrackUpstreamPaused);\n            track.on(TrackEvent.UpstreamResumed, this.onTrackUpstreamResumed);\n            // create track publication from track\n            const req = new AddTrackRequest({\n                // get local track id for use during publishing\n                cid: track.mediaStreamTrack.id,\n                name: opts.name,\n                type: Track.kindToProto(track.kind),\n                muted: track.isMuted,\n                source: Track.sourceToProto(track.source),\n                disableDtx: !((_a = opts.dtx) !== null && _a !== void 0 ? _a : true),\n                encryption: this.encryptionType,\n                stereo: isStereo,\n                disableRed: this.isE2EEEnabled || !((_b = opts.red) !== null && _b !== void 0 ? _b : true),\n                stream: opts === null || opts === void 0 ? void 0 : opts.stream\n            });\n            // compute encodings and layers for video\n            let encodings;\n            if (track.kind === Track.Kind.Video) {\n                let dims = {\n                    width: 0,\n                    height: 0\n                };\n                try {\n                    dims = yield track.waitForDimensions();\n                } catch (e) {\n                    // use defaults, it's quite painful for congestion control without simulcast\n                    // so using default dims according to publish settings\n                    const defaultRes = (_d = (_c = this.roomOptions.videoCaptureDefaults) === null || _c === void 0 ? void 0 : _c.resolution) !== null && _d !== void 0 ? _d : VideoPresets.h720.resolution;\n                    dims = {\n                        width: defaultRes.width,\n                        height: defaultRes.height\n                    };\n                    // log failure\n                    this.log.error('could not determine track dimensions, using defaults', Object.assign(Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)), {\n                        dims\n                    }));\n                }\n                // width and height should be defined for video\n                req.width = dims.width;\n                req.height = dims.height;\n                // for svc codecs, disable simulcast and use vp8 for backup codec\n                if (track instanceof LocalVideoTrack) {\n                    if (isSVCCodec(videoCodec)) {\n                        // vp9 svc with screenshare has problem to encode, always use L1T3 here\n                        if (track.source === Track.Source.ScreenShare && videoCodec === 'vp9') {\n                            opts.scalabilityMode = 'L1T3';\n                        }\n                        // set scalabilityMode to 'L3T3_KEY' by default\n                        opts.scalabilityMode = (_e = opts.scalabilityMode) !== null && _e !== void 0 ? _e : 'L3T3_KEY';\n                    }\n                    req.simulcastCodecs = [\n                        new SimulcastCodec({\n                            codec: videoCodec,\n                            cid: track.mediaStreamTrack.id\n                        })\n                    ];\n                    // set up backup\n                    if (opts.backupCodec === true) {\n                        opts.backupCodec = {\n                            codec: defaultVideoCodec\n                        };\n                    }\n                    if (opts.backupCodec && videoCodec !== opts.backupCodec.codec && // TODO remove this once e2ee is supported for backup codecs\n                    req.encryption === Encryption_Type.NONE) {\n                        // multi-codec simulcast requires dynacast\n                        if (!this.roomOptions.dynacast) {\n                            this.roomOptions.dynacast = true;\n                        }\n                        req.simulcastCodecs.push(new SimulcastCodec({\n                            codec: opts.backupCodec.codec,\n                            cid: ''\n                        }));\n                    }\n                }\n                encodings = computeVideoEncodings(track.source === Track.Source.ScreenShare, req.width, req.height, opts);\n                req.layers = videoLayersFromEncodings(req.width, req.height, encodings, isSVCCodec(opts.videoCodec));\n            } else if (track.kind === Track.Kind.Audio) {\n                encodings = [\n                    {\n                        maxBitrate: (_g = (_f = opts.audioPreset) === null || _f === void 0 ? void 0 : _f.maxBitrate) !== null && _g !== void 0 ? _g : opts.audioBitrate,\n                        priority: (_j = (_h = opts.audioPreset) === null || _h === void 0 ? void 0 : _h.priority) !== null && _j !== void 0 ? _j : 'high',\n                        networkPriority: (_l = (_k = opts.audioPreset) === null || _k === void 0 ? void 0 : _k.priority) !== null && _l !== void 0 ? _l : 'high'\n                    }\n                ];\n            }\n            if (!this.engine || this.engine.isClosed) {\n                throw new UnexpectedConnectionState('cannot publish track when not connected');\n            }\n            const ti = yield this.engine.addTrack(req);\n            // server might not support the codec the client has requested, in that case, fallback\n            // to a supported codec\n            let primaryCodecMime;\n            ti.codecs.forEach((codec)=>{\n                if (primaryCodecMime === undefined) {\n                    primaryCodecMime = codec.mimeType;\n                }\n            });\n            if (primaryCodecMime && track.kind === Track.Kind.Video) {\n                const updatedCodec = mimeTypeToVideoCodecString(primaryCodecMime);\n                if (updatedCodec !== videoCodec) {\n                    this.log.debug('falling back to server selected codec', Object.assign(Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)), {\n                        codec: updatedCodec\n                    }));\n                    /* @ts-ignore */ opts.videoCodec = updatedCodec;\n                    // recompute encodings since bitrates/etc could have changed\n                    encodings = computeVideoEncodings(track.source === Track.Source.ScreenShare, req.width, req.height, opts);\n                }\n            }\n            const publication = new LocalTrackPublication(track.kind, ti, track, {\n                loggerName: this.roomOptions.loggerName,\n                loggerContextCb: ()=>this.logContext\n            });\n            // save options for when it needs to be republished again\n            publication.options = opts;\n            track.sid = ti.sid;\n            if (!this.engine.pcManager) {\n                throw new UnexpectedConnectionState('pcManager is not ready');\n            }\n            this.log.debug(\"publishing \".concat(track.kind, \" with encodings\"), Object.assign(Object.assign({}, this.logContext), {\n                encodings,\n                trackInfo: ti\n            }));\n            track.sender = yield this.engine.createSender(track, opts, encodings);\n            if (encodings) {\n                if (isFireFox() && track.kind === Track.Kind.Audio) {\n                    /* Refer to RFC https://datatracker.ietf.org/doc/html/rfc7587#section-6.1,\n             livekit-server uses maxaveragebitrate=510000 in the answer sdp to permit client to\n             publish high quality audio track. But firefox always uses this value as the actual\n             bitrates, causing the audio bitrates to rise to 510Kbps in any stereo case unexpectedly.\n             So the client need to modify maxaverragebitrates in answer sdp to user provided value to\n             fix the issue.\n           */ let trackTransceiver = undefined;\n                    for (const transceiver of this.engine.pcManager.publisher.getTransceivers()){\n                        if (transceiver.sender === track.sender) {\n                            trackTransceiver = transceiver;\n                            break;\n                        }\n                    }\n                    if (trackTransceiver) {\n                        this.engine.pcManager.publisher.setTrackCodecBitrate({\n                            transceiver: trackTransceiver,\n                            codec: 'opus',\n                            maxbr: ((_m = encodings[0]) === null || _m === void 0 ? void 0 : _m.maxBitrate) ? encodings[0].maxBitrate / 1000 : 0\n                        });\n                    }\n                } else if (track.codec && isSVCCodec(track.codec) && ((_o = encodings[0]) === null || _o === void 0 ? void 0 : _o.maxBitrate)) {\n                    this.engine.pcManager.publisher.setTrackCodecBitrate({\n                        cid: req.cid,\n                        codec: track.codec,\n                        maxbr: encodings[0].maxBitrate / 1000\n                    });\n                }\n            }\n            yield this.engine.negotiate();\n            if (track instanceof LocalVideoTrack) {\n                track.startMonitor(this.engine.client);\n            } else if (track instanceof LocalAudioTrack) {\n                track.startMonitor();\n            }\n            this.addTrackPublication(publication);\n            // send event for publication\n            this.emit(ParticipantEvent.LocalTrackPublished, publication);\n            return publication;\n        });\n    }\n    get isLocal() {\n        return true;\n    }\n    /** @internal\n   * publish additional codec to existing track\n   */ publishAdditionalCodecForTrack(track, videoCodec, options) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            // TODO remove once e2ee is supported for backup tracks\n            if (this.encryptionType !== Encryption_Type.NONE) {\n                return;\n            }\n            // is it not published? if so skip\n            let existingPublication;\n            this.tracks.forEach((publication)=>{\n                if (!publication.track) {\n                    return;\n                }\n                if (publication.track === track) {\n                    existingPublication = publication;\n                }\n            });\n            if (!existingPublication) {\n                throw new TrackInvalidError('track is not published');\n            }\n            if (!(track instanceof LocalVideoTrack)) {\n                throw new TrackInvalidError('track is not a video track');\n            }\n            const opts = Object.assign(Object.assign({}, (_a = this.roomOptions) === null || _a === void 0 ? void 0 : _a.publishDefaults), options);\n            const encodings = computeTrackBackupEncodings(track, videoCodec, opts);\n            if (!encodings) {\n                this.log.info(\"backup codec has been disabled, ignoring request to add additional codec for track\", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));\n                return;\n            }\n            const simulcastTrack = track.addSimulcastTrack(videoCodec, encodings);\n            const req = new AddTrackRequest({\n                cid: simulcastTrack.mediaStreamTrack.id,\n                type: Track.kindToProto(track.kind),\n                muted: track.isMuted,\n                source: Track.sourceToProto(track.source),\n                sid: track.sid,\n                simulcastCodecs: [\n                    {\n                        codec: opts.videoCodec,\n                        cid: simulcastTrack.mediaStreamTrack.id\n                    }\n                ]\n            });\n            req.layers = videoLayersFromEncodings(req.width, req.height, encodings);\n            if (!this.engine || this.engine.isClosed) {\n                throw new UnexpectedConnectionState('cannot publish track when not connected');\n            }\n            const ti = yield this.engine.addTrack(req);\n            yield this.engine.createSimulcastSender(track, simulcastTrack, opts, encodings);\n            yield this.engine.negotiate();\n            this.log.debug(\"published \".concat(videoCodec, \" for track \").concat(track.sid), Object.assign(Object.assign({}, this.logContext), {\n                encodings,\n                trackInfo: ti\n            }));\n        });\n    }\n    unpublishTrack(track, stopOnUnpublish) {\n        var _a, _b;\n        return __awaiter(this, void 0, void 0, function*() {\n            // look through all published tracks to find the right ones\n            const publication = this.getPublicationForTrack(track);\n            const pubLogContext = publication ? getLogContextFromTrack(publication) : undefined;\n            this.log.debug('unpublishing track', Object.assign(Object.assign({}, this.logContext), pubLogContext));\n            if (!publication || !publication.track) {\n                this.log.warn('track was not unpublished because no publication was found', Object.assign(Object.assign({}, this.logContext), pubLogContext));\n                return undefined;\n            }\n            track = publication.track;\n            track.off(TrackEvent.Muted, this.onTrackMuted);\n            track.off(TrackEvent.Unmuted, this.onTrackUnmuted);\n            track.off(TrackEvent.Ended, this.handleTrackEnded);\n            track.off(TrackEvent.UpstreamPaused, this.onTrackUpstreamPaused);\n            track.off(TrackEvent.UpstreamResumed, this.onTrackUpstreamResumed);\n            if (stopOnUnpublish === undefined) {\n                stopOnUnpublish = (_b = (_a = this.roomOptions) === null || _a === void 0 ? void 0 : _a.stopLocalTrackOnUnpublish) !== null && _b !== void 0 ? _b : true;\n            }\n            if (stopOnUnpublish) {\n                track.stop();\n            }\n            let negotiationNeeded = false;\n            const trackSender = track.sender;\n            track.sender = undefined;\n            if (this.engine.pcManager && this.engine.pcManager.currentState < PCTransportState.FAILED && trackSender) {\n                try {\n                    for (const transceiver of this.engine.pcManager.publisher.getTransceivers()){\n                        // if sender is not currently sending (after replaceTrack(null))\n                        // removeTrack would have no effect.\n                        // to ensure we end up successfully removing the track, manually set\n                        // the transceiver to inactive\n                        if (transceiver.sender === trackSender) {\n                            transceiver.direction = 'inactive';\n                            negotiationNeeded = true;\n                        }\n                    }\n                    if (this.engine.removeTrack(trackSender)) {\n                        negotiationNeeded = true;\n                    }\n                    if (track instanceof LocalVideoTrack) {\n                        for (const [, trackInfo] of track.simulcastCodecs){\n                            if (trackInfo.sender) {\n                                if (this.engine.removeTrack(trackInfo.sender)) {\n                                    negotiationNeeded = true;\n                                }\n                                trackInfo.sender = undefined;\n                            }\n                        }\n                        track.simulcastCodecs.clear();\n                    }\n                } catch (e) {\n                    this.log.warn('failed to unpublish track', Object.assign(Object.assign(Object.assign({}, this.logContext), pubLogContext), {\n                        error: e\n                    }));\n                }\n            }\n            // remove from our maps\n            this.tracks.delete(publication.trackSid);\n            switch(publication.kind){\n                case Track.Kind.Audio:\n                    this.audioTracks.delete(publication.trackSid);\n                    break;\n                case Track.Kind.Video:\n                    this.videoTracks.delete(publication.trackSid);\n                    break;\n            }\n            this.emit(ParticipantEvent.LocalTrackUnpublished, publication);\n            publication.setTrack(undefined);\n            if (negotiationNeeded) {\n                yield this.engine.negotiate();\n            }\n            return publication;\n        });\n    }\n    unpublishTracks(tracks) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const results = yield Promise.all(tracks.map((track)=>this.unpublishTrack(track)));\n            return results.filter((track)=>track instanceof LocalTrackPublication);\n        });\n    }\n    republishAllTracks(options) {\n        let restartTracks = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n        return __awaiter(this, void 0, void 0, function*() {\n            const localPubs = [];\n            this.tracks.forEach((pub)=>{\n                if (pub.track) {\n                    if (options) {\n                        pub.options = Object.assign(Object.assign({}, pub.options), options);\n                    }\n                    localPubs.push(pub);\n                }\n            });\n            yield Promise.all(localPubs.map((pub)=>__awaiter(this, void 0, void 0, function*() {\n                    const track = pub.track;\n                    yield this.unpublishTrack(track, false);\n                    if (restartTracks && !track.isMuted && track.source !== Track.Source.ScreenShare && track.source !== Track.Source.ScreenShareAudio && (track instanceof LocalAudioTrack || track instanceof LocalVideoTrack) && !track.isUserProvided) {\n                        // generally we need to restart the track before publishing, often a full reconnect\n                        // is necessary because computer had gone to sleep.\n                        this.log.debug('restarting existing track', Object.assign(Object.assign({}, this.logContext), {\n                            track: pub.trackSid\n                        }));\n                        yield track.restartTrack();\n                    }\n                    yield this.publishTrack(track, pub.options);\n                })));\n        });\n    }\n    publishData(data, kind) {\n        let publishOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        return __awaiter(this, void 0, void 0, function*() {\n            const destination = Array.isArray(publishOptions) ? publishOptions : publishOptions === null || publishOptions === void 0 ? void 0 : publishOptions.destination;\n            const destinationSids = [];\n            const topic = !Array.isArray(publishOptions) ? publishOptions.topic : undefined;\n            if (destination !== undefined) {\n                destination.forEach((val)=>{\n                    if (val instanceof RemoteParticipant) {\n                        destinationSids.push(val.sid);\n                    } else {\n                        destinationSids.push(val);\n                    }\n                });\n            }\n            const packet = new DataPacket({\n                kind,\n                value: {\n                    case: 'user',\n                    value: new UserPacket({\n                        participantSid: this.sid,\n                        payload: data,\n                        destinationSids: destinationSids,\n                        topic\n                    })\n                }\n            });\n            yield this.engine.sendDataPacket(packet, kind);\n        });\n    }\n    /**\n   * Control who can subscribe to LocalParticipant's published tracks.\n   *\n   * By default, all participants can subscribe. This allows fine-grained control over\n   * who is able to subscribe at a participant and track level.\n   *\n   * Note: if access is given at a track-level (i.e. both [allParticipantsAllowed] and\n   * [ParticipantTrackPermission.allTracksAllowed] are false), any newer published tracks\n   * will not grant permissions to any participants and will require a subsequent\n   * permissions update to allow subscription.\n   *\n   * @param allParticipantsAllowed Allows all participants to subscribe all tracks.\n   *  Takes precedence over [[participantTrackPermissions]] if set to true.\n   *  By default this is set to true.\n   * @param participantTrackPermissions Full list of individual permissions per\n   *  participant/track. Any omitted participants will not receive any permissions.\n   */ setTrackSubscriptionPermissions(allParticipantsAllowed) {\n        let participantTrackPermissions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n        this.participantTrackPermissions = participantTrackPermissions;\n        this.allParticipantsAllowedToSubscribe = allParticipantsAllowed;\n        if (!this.engine.client.isDisconnected) {\n            this.updateTrackSubscriptionPermissions();\n        }\n    }\n    /** @internal */ updateInfo(info) {\n        if (info.sid !== this.sid) {\n            // drop updates that specify a wrong sid.\n            // the sid for local participant is only explicitly set on join and full reconnect\n            return false;\n        }\n        if (!super.updateInfo(info)) {\n            return false;\n        }\n        // reconcile track mute status.\n        // if server's track mute status doesn't match actual, we'll have to update\n        // the server's copy\n        info.tracks.forEach((ti)=>{\n            var _a, _b;\n            const pub = this.tracks.get(ti.sid);\n            if (pub) {\n                const mutedOnServer = pub.isMuted || ((_b = (_a = pub.track) === null || _a === void 0 ? void 0 : _a.isUpstreamPaused) !== null && _b !== void 0 ? _b : false);\n                if (mutedOnServer !== ti.muted) {\n                    this.log.debug('updating server mute state after reconcile', Object.assign(Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(pub)), {\n                        mutedOnServer\n                    }));\n                    this.engine.client.sendMuteTrack(ti.sid, mutedOnServer);\n                }\n            }\n        });\n        return true;\n    }\n    getPublicationForTrack(track) {\n        let publication;\n        this.tracks.forEach((pub)=>{\n            const localTrack = pub.track;\n            if (!localTrack) {\n                return;\n            }\n            // this looks overly complicated due to this object tree\n            if (track instanceof MediaStreamTrack) {\n                if (localTrack instanceof LocalAudioTrack || localTrack instanceof LocalVideoTrack) {\n                    if (localTrack.mediaStreamTrack === track) {\n                        publication = pub;\n                    }\n                }\n            } else if (track === localTrack) {\n                publication = pub;\n            }\n        });\n        return publication;\n    }\n}\nvar ConnectionState;\n(function(ConnectionState) {\n    ConnectionState[\"Disconnected\"] = \"disconnected\";\n    ConnectionState[\"Connecting\"] = \"connecting\";\n    ConnectionState[\"Connected\"] = \"connected\";\n    ConnectionState[\"Reconnecting\"] = \"reconnecting\";\n})(ConnectionState || (ConnectionState = {}));\nconst connectionReconcileFrequency = 2 * 1000;\n/** @deprecated RoomState has been renamed to [[ConnectionState]] */ const RoomState = ConnectionState;\n/**\n * In LiveKit, a room is the logical grouping for a list of participants.\n * Participants in a room can publish tracks, and subscribe to others' tracks.\n *\n * a Room fires [[RoomEvent | RoomEvents]].\n *\n * @noInheritDoc\n */ class Room extends eventsExports.EventEmitter {\n    /**\n   * Creates a new Room, the primary construct for a LiveKit session.\n   * @param options\n   */ constructor(options){\n        var _this;\n        var _a, _b;\n        super();\n        _this = this;\n        this.state = ConnectionState.Disconnected;\n        /**\n     * list of participants that are actively speaking. when this changes\n     * a [[RoomEvent.ActiveSpeakersChanged]] event is fired\n     */ this.activeSpeakers = [];\n        /** reflects the sender encryption status of the local participant */ this.isE2EEEnabled = false;\n        this.audioEnabled = true;\n        this.isVideoPlaybackBlocked = false;\n        this.log = livekitLogger;\n        this.bufferedEvents = [];\n        this.connect = (url, token, opts)=>__awaiter(this, void 0, void 0, function*() {\n                var _c;\n                // In case a disconnect called happened right before the connect call, make sure the disconnect is completed first by awaiting its lock\n                const unlockDisconnect = yield this.disconnectLock.lock();\n                if (this.state === ConnectionState.Connected) {\n                    // when the state is reconnecting or connected, this function returns immediately\n                    this.log.info(\"already connected to room \".concat(this.name), this.logContext);\n                    unlockDisconnect();\n                    return Promise.resolve();\n                }\n                if (this.connectFuture) {\n                    unlockDisconnect();\n                    return this.connectFuture.promise;\n                }\n                this.setAndEmitConnectionState(ConnectionState.Connecting);\n                if (((_c = this.regionUrlProvider) === null || _c === void 0 ? void 0 : _c.getServerUrl().toString()) !== url) {\n                    this.regionUrl = undefined;\n                    this.regionUrlProvider = undefined;\n                }\n                if (isCloud(new URL(url))) {\n                    if (this.regionUrlProvider === undefined) {\n                        this.regionUrlProvider = new RegionUrlProvider(url, token);\n                    } else {\n                        this.regionUrlProvider.updateToken(token);\n                    }\n                    // trigger the first fetch without waiting for a response\n                    // if initial connection fails, this will speed up picking regional url\n                    // on subsequent runs\n                    this.regionUrlProvider.fetchRegionSettings().catch((e)=>{\n                        this.log.warn('could not fetch region settings', Object.assign(Object.assign({}, this.logContext), {\n                            error: e\n                        }));\n                    });\n                }\n                const connectFn = (resolve, reject, regionUrl)=>__awaiter(this, void 0, void 0, function*() {\n                        var _d;\n                        if (this.abortController) {\n                            this.abortController.abort();\n                        }\n                        // explicit creation as local var needed to satisfy TS compiler when passing it to `attemptConnection` further down\n                        const abortController = new AbortController();\n                        this.abortController = abortController;\n                        // at this point the intention to connect has been signalled so we can allow cancelling of the connection via disconnect() again\n                        unlockDisconnect === null || unlockDisconnect === void 0 ? void 0 : unlockDisconnect();\n                        try {\n                            yield this.attemptConnection(regionUrl !== null && regionUrl !== void 0 ? regionUrl : url, token, opts, abortController);\n                            this.abortController = undefined;\n                            resolve();\n                        } catch (e) {\n                            if (this.regionUrlProvider && e instanceof ConnectionError && e.reason !== 3 /* ConnectionErrorReason.Cancelled */  && e.reason !== 0 /* ConnectionErrorReason.NotAllowed */ ) {\n                                let nextUrl = null;\n                                try {\n                                    nextUrl = yield this.regionUrlProvider.getNextBestRegionUrl((_d = this.abortController) === null || _d === void 0 ? void 0 : _d.signal);\n                                } catch (error) {\n                                    if (error instanceof ConnectionError && (error.status === 401 || error.reason === 3 /* ConnectionErrorReason.Cancelled */ )) {\n                                        this.handleDisconnect(this.options.stopLocalTrackOnUnpublish);\n                                        reject(error);\n                                        return;\n                                    }\n                                }\n                                if (nextUrl) {\n                                    this.log.info(\"Initial connection failed with ConnectionError: \".concat(e.message, \". Retrying with another region: \").concat(nextUrl), this.logContext);\n                                    yield connectFn(resolve, reject, nextUrl);\n                                } else {\n                                    this.handleDisconnect(this.options.stopLocalTrackOnUnpublish);\n                                    reject(e);\n                                }\n                            } else {\n                                this.handleDisconnect(this.options.stopLocalTrackOnUnpublish);\n                                reject(e);\n                            }\n                        }\n                    });\n                const regionUrl = this.regionUrl;\n                this.regionUrl = undefined;\n                this.connectFuture = new Future((resolve, reject)=>{\n                    connectFn(resolve, reject, regionUrl);\n                }, ()=>{\n                    this.clearConnectionFutures();\n                });\n                return this.connectFuture.promise;\n            });\n        this.connectSignal = (url, token, engine, connectOptions, roomOptions, abortController)=>__awaiter(this, void 0, void 0, function*() {\n                var _e, _f, _g;\n                const joinResponse = yield engine.join(url, token, {\n                    autoSubscribe: connectOptions.autoSubscribe,\n                    publishOnly: connectOptions.publishOnly,\n                    adaptiveStream: typeof roomOptions.adaptiveStream === 'object' ? true : roomOptions.adaptiveStream,\n                    maxRetries: connectOptions.maxRetries,\n                    e2eeEnabled: !!this.e2eeManager,\n                    websocketTimeout: connectOptions.websocketTimeout\n                }, abortController.signal);\n                let serverInfo = joinResponse.serverInfo;\n                if (!serverInfo) {\n                    serverInfo = {\n                        version: joinResponse.serverVersion,\n                        region: joinResponse.serverRegion\n                    };\n                }\n                this.log.debug(\"connected to Livekit Server \".concat(Object.entries(serverInfo).map((_ref)=>{\n                    let [key, value] = _ref;\n                    return \"\".concat(key, \": \").concat(value);\n                }).join(', ')), {\n                    room: (_e = joinResponse.room) === null || _e === void 0 ? void 0 : _e.name,\n                    roomSid: (_f = joinResponse.room) === null || _f === void 0 ? void 0 : _f.sid,\n                    identity: (_g = joinResponse.participant) === null || _g === void 0 ? void 0 : _g.identity\n                });\n                if (!joinResponse.serverVersion) {\n                    throw new UnsupportedServer('unknown server version');\n                }\n                if (joinResponse.serverVersion === '0.15.1' && this.options.dynacast) {\n                    this.log.debug('disabling dynacast due to server version', this.logContext);\n                    // dynacast has a bug in 0.15.1, so we cannot use it then\n                    roomOptions.dynacast = false;\n                }\n                return joinResponse;\n            });\n        this.applyJoinResponse = (joinResponse)=>{\n            const pi = joinResponse.participant;\n            this.localParticipant.sid = pi.sid;\n            this.localParticipant.identity = pi.identity;\n            // populate remote participants, these should not trigger new events\n            this.handleParticipantUpdates([\n                pi,\n                ...joinResponse.otherParticipants\n            ]);\n            if (joinResponse.room) {\n                this.handleRoomUpdate(joinResponse.room);\n            }\n            if (this.options.e2ee && this.e2eeManager) {\n                this.e2eeManager.setSifTrailer(joinResponse.sifTrailer);\n            }\n        };\n        this.attemptConnection = (url, token, opts, abortController)=>__awaiter(this, void 0, void 0, function*() {\n                var _h, _j;\n                if (this.state === ConnectionState.Reconnecting) {\n                    this.log.info('Reconnection attempt replaced by new connection attempt', this.logContext);\n                    // make sure we close and recreate the existing engine in order to get rid of any potentially ongoing reconnection attempts\n                    this.recreateEngine();\n                } else {\n                    // create engine if previously disconnected\n                    this.maybeCreateEngine();\n                }\n                if ((_h = this.regionUrlProvider) === null || _h === void 0 ? void 0 : _h.isCloud()) {\n                    this.engine.setRegionUrlProvider(this.regionUrlProvider);\n                }\n                this.acquireAudioContext();\n                this.connOptions = Object.assign(Object.assign({}, roomConnectOptionDefaults), opts);\n                if (this.connOptions.rtcConfig) {\n                    this.engine.rtcConfig = this.connOptions.rtcConfig;\n                }\n                if (this.connOptions.peerConnectionTimeout) {\n                    this.engine.peerConnectionTimeout = this.connOptions.peerConnectionTimeout;\n                }\n                try {\n                    const joinResponse = yield this.connectSignal(url, token, this.engine, this.connOptions, this.options, abortController);\n                    this.applyJoinResponse(joinResponse);\n                    // forward metadata changed for the local participant\n                    this.setupLocalParticipantEvents();\n                    this.emit(RoomEvent.SignalConnected);\n                } catch (err) {\n                    yield this.engine.close();\n                    this.recreateEngine();\n                    const resultingError = new ConnectionError(\"could not establish signal connection\");\n                    if (err instanceof Error) {\n                        resultingError.message = \"\".concat(resultingError.message, \": \").concat(err.message);\n                    }\n                    if (err instanceof ConnectionError) {\n                        resultingError.reason = err.reason;\n                        resultingError.status = err.status;\n                    }\n                    this.log.debug(\"error trying to establish signal connection\", Object.assign(Object.assign({}, this.logContext), {\n                        error: err\n                    }));\n                    throw resultingError;\n                }\n                if (abortController.signal.aborted) {\n                    yield this.engine.close();\n                    this.recreateEngine();\n                    throw new ConnectionError(\"Connection attempt aborted\");\n                }\n                try {\n                    yield this.engine.waitForPCInitialConnection(this.connOptions.peerConnectionTimeout, abortController);\n                } catch (e) {\n                    yield this.engine.close();\n                    this.recreateEngine();\n                    throw e;\n                }\n                // also hook unload event\n                if (isWeb() && this.options.disconnectOnPageLeave) {\n                    // capturing both 'pagehide' and 'beforeunload' to capture broadest set of browser behaviors\n                    window.addEventListener('pagehide', this.onPageLeave);\n                    window.addEventListener('beforeunload', this.onPageLeave);\n                }\n                if (isWeb()) {\n                    document.addEventListener('freeze', this.onPageLeave);\n                    (_j = navigator.mediaDevices) === null || _j === void 0 ? void 0 : _j.addEventListener('devicechange', this.handleDeviceChange);\n                }\n                this.setAndEmitConnectionState(ConnectionState.Connected);\n                this.emit(RoomEvent.Connected);\n                this.registerConnectionReconcile();\n            });\n        /**\n     * disconnects the room, emits [[RoomEvent.Disconnected]]\n     */ this.disconnect = function() {\n            let stopTracks = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n            return __awaiter(_this, void 0, void 0, function*() {\n                var _k, _l, _m, _o;\n                const unlock = yield this.disconnectLock.lock();\n                try {\n                    if (this.state === ConnectionState.Disconnected) {\n                        this.log.debug('already disconnected', this.logContext);\n                        return;\n                    }\n                    this.log.info('disconnect from room', Object.assign({}, this.logContext));\n                    if (this.state === ConnectionState.Connecting || this.state === ConnectionState.Reconnecting) {\n                        // try aborting pending connection attempt\n                        this.log.warn('abort connection attempt', this.logContext);\n                        (_k = this.abortController) === null || _k === void 0 ? void 0 : _k.abort();\n                        // in case the abort controller didn't manage to cancel the connection attempt, reject the connect promise explicitly\n                        (_m = (_l = this.connectFuture) === null || _l === void 0 ? void 0 : _l.reject) === null || _m === void 0 ? void 0 : _m.call(_l, new ConnectionError('Client initiated disconnect'));\n                        this.connectFuture = undefined;\n                    }\n                    // send leave\n                    if (!((_o = this.engine) === null || _o === void 0 ? void 0 : _o.client.isDisconnected)) {\n                        yield this.engine.client.sendLeave();\n                    }\n                    // close engine (also closes client)\n                    if (this.engine) {\n                        yield this.engine.close();\n                    }\n                    this.handleDisconnect(stopTracks, DisconnectReason.CLIENT_INITIATED);\n                    /* @ts-ignore */ this.engine = undefined;\n                } finally{\n                    unlock();\n                }\n            });\n        };\n        this.onPageLeave = ()=>__awaiter(this, void 0, void 0, function*() {\n                yield this.disconnect();\n            });\n        /**\n     * Browsers have different policies regarding audio playback. Most requiring\n     * some form of user interaction (click/tap/etc).\n     * In those cases, audio will be silent until a click/tap triggering one of the following\n     * - `startAudio`\n     * - `getUserMedia`\n     */ this.startAudio = ()=>__awaiter(this, void 0, void 0, function*() {\n                const elements = [];\n                const browser = getBrowser();\n                if (browser && browser.os === 'iOS') {\n                    /**\n         * iOS blocks audio element playback if\n         * - user is not publishing audio themselves and\n         * - no other audio source is playing\n         *\n         * as a workaround, we create an audio element with an empty track, so that\n         * silent audio is always playing\n         */ const audioId = 'livekit-dummy-audio-el';\n                    let dummyAudioEl = document.getElementById(audioId);\n                    if (!dummyAudioEl) {\n                        dummyAudioEl = document.createElement('audio');\n                        dummyAudioEl.id = audioId;\n                        dummyAudioEl.autoplay = true;\n                        dummyAudioEl.hidden = true;\n                        const track = getEmptyAudioStreamTrack();\n                        track.enabled = true;\n                        const stream = new MediaStream([\n                            track\n                        ]);\n                        dummyAudioEl.srcObject = stream;\n                        document.addEventListener('visibilitychange', ()=>{\n                            if (!dummyAudioEl) {\n                                return;\n                            }\n                            // set the srcObject to null on page hide in order to prevent lock screen controls to show up for it\n                            dummyAudioEl.srcObject = document.hidden ? null : stream;\n                            if (!document.hidden) {\n                                this.log.debug('page visible again, triggering startAudio to resume playback and update playback status', this.logContext);\n                                this.startAudio();\n                            }\n                        });\n                        document.body.append(dummyAudioEl);\n                        this.once(RoomEvent.Disconnected, ()=>{\n                            dummyAudioEl === null || dummyAudioEl === void 0 ? void 0 : dummyAudioEl.remove();\n                            dummyAudioEl = null;\n                        });\n                    }\n                    elements.push(dummyAudioEl);\n                }\n                this.participants.forEach((p)=>{\n                    p.audioTracks.forEach((t)=>{\n                        if (t.track) {\n                            t.track.attachedElements.forEach((e)=>{\n                                elements.push(e);\n                            });\n                        }\n                    });\n                });\n                try {\n                    yield Promise.all([\n                        this.acquireAudioContext(),\n                        ...elements.map((e)=>{\n                            e.muted = false;\n                            return e.play();\n                        })\n                    ]);\n                    this.handleAudioPlaybackStarted();\n                } catch (err) {\n                    this.handleAudioPlaybackFailed(err);\n                    throw err;\n                }\n            });\n        this.startVideo = ()=>__awaiter(this, void 0, void 0, function*() {\n                const elements = [];\n                for (const p of this.participants.values()){\n                    p.videoTracks.forEach((tr)=>{\n                        var _a;\n                        (_a = tr.track) === null || _a === void 0 ? void 0 : _a.attachedElements.forEach((el)=>{\n                            if (!elements.includes(el)) {\n                                elements.push(el);\n                            }\n                        });\n                    });\n                }\n                yield Promise.all(elements.map((el)=>el.play())).then(()=>{\n                    this.handleVideoPlaybackStarted();\n                }).catch((e)=>{\n                    if (e.name === 'NotAllowedError') {\n                        this.handleVideoPlaybackFailed();\n                    } else {\n                        this.log.warn('Resuming video playback failed, make sure you call `startVideo` directly in a user gesture handler', this.logContext);\n                    }\n                });\n            });\n        this.handleRestarting = ()=>{\n            this.clearConnectionReconcile();\n            // also unwind existing participants & existing subscriptions\n            for (const p of this.participants.values()){\n                this.handleParticipantDisconnected(p.sid, p);\n            }\n            if (this.setAndEmitConnectionState(ConnectionState.Reconnecting)) {\n                this.emit(RoomEvent.Reconnecting);\n            }\n        };\n        this.handleSignalRestarted = (joinResponse)=>__awaiter(this, void 0, void 0, function*() {\n                this.log.debug(\"signal reconnected to server, region \".concat(joinResponse.serverRegion), Object.assign(Object.assign({}, this.logContext), {\n                    region: joinResponse.serverRegion\n                }));\n                this.bufferedEvents = [];\n                this.applyJoinResponse(joinResponse);\n                try {\n                    // unpublish & republish tracks\n                    yield this.localParticipant.republishAllTracks(undefined, true);\n                } catch (error) {\n                    this.log.error('error trying to re-publish tracks after reconnection', Object.assign(Object.assign({}, this.logContext), {\n                        error\n                    }));\n                }\n                try {\n                    yield this.engine.waitForRestarted();\n                    this.log.debug(\"fully reconnected to server\", Object.assign(Object.assign({}, this.logContext), {\n                        region: joinResponse.serverRegion\n                    }));\n                } catch (_p) {\n                    // reconnection failed, handleDisconnect is being invoked already, just return here\n                    return;\n                }\n                this.setAndEmitConnectionState(ConnectionState.Connected);\n                this.emit(RoomEvent.Reconnected);\n                this.registerConnectionReconcile();\n                this.emitBufferedEvents();\n            });\n        this.handleParticipantUpdates = (participantInfos)=>{\n            // handle changes to participant state, and send events\n            participantInfos.forEach((info)=>{\n                if (info.identity === this.localParticipant.identity) {\n                    this.localParticipant.updateInfo(info);\n                    return;\n                }\n                // ensure identity <=> sid mapping\n                const sid = this.identityToSid.get(info.identity);\n                if (sid && sid !== info.sid) {\n                    // sid had changed, need to remove previous participant\n                    this.handleParticipantDisconnected(sid, this.participants.get(sid));\n                }\n                let remoteParticipant = this.participants.get(info.sid);\n                const isNewParticipant = !remoteParticipant;\n                // when it's disconnected, send updates\n                if (info.state === ParticipantInfo_State.DISCONNECTED) {\n                    this.handleParticipantDisconnected(info.sid, remoteParticipant);\n                } else {\n                    // create participant if doesn't exist\n                    remoteParticipant = this.getOrCreateParticipant(info.sid, info);\n                    if (!isNewParticipant) {\n                        // just update, no events\n                        remoteParticipant.updateInfo(info);\n                    }\n                }\n            });\n        };\n        // updates are sent only when there's a change to speaker ordering\n        this.handleActiveSpeakersUpdate = (speakers)=>{\n            const activeSpeakers = [];\n            const seenSids = {};\n            speakers.forEach((speaker)=>{\n                seenSids[speaker.sid] = true;\n                if (speaker.sid === this.localParticipant.sid) {\n                    this.localParticipant.audioLevel = speaker.level;\n                    this.localParticipant.setIsSpeaking(true);\n                    activeSpeakers.push(this.localParticipant);\n                } else {\n                    const p = this.participants.get(speaker.sid);\n                    if (p) {\n                        p.audioLevel = speaker.level;\n                        p.setIsSpeaking(true);\n                        activeSpeakers.push(p);\n                    }\n                }\n            });\n            if (!seenSids[this.localParticipant.sid]) {\n                this.localParticipant.audioLevel = 0;\n                this.localParticipant.setIsSpeaking(false);\n            }\n            this.participants.forEach((p)=>{\n                if (!seenSids[p.sid]) {\n                    p.audioLevel = 0;\n                    p.setIsSpeaking(false);\n                }\n            });\n            this.activeSpeakers = activeSpeakers;\n            this.emitWhenConnected(RoomEvent.ActiveSpeakersChanged, activeSpeakers);\n        };\n        // process list of changed speakers\n        this.handleSpeakersChanged = (speakerUpdates)=>{\n            const lastSpeakers = new Map();\n            this.activeSpeakers.forEach((p)=>{\n                lastSpeakers.set(p.sid, p);\n            });\n            speakerUpdates.forEach((speaker)=>{\n                let p = this.participants.get(speaker.sid);\n                if (speaker.sid === this.localParticipant.sid) {\n                    p = this.localParticipant;\n                }\n                if (!p) {\n                    return;\n                }\n                p.audioLevel = speaker.level;\n                p.setIsSpeaking(speaker.active);\n                if (speaker.active) {\n                    lastSpeakers.set(speaker.sid, p);\n                } else {\n                    lastSpeakers.delete(speaker.sid);\n                }\n            });\n            const activeSpeakers = Array.from(lastSpeakers.values());\n            activeSpeakers.sort((a, b)=>b.audioLevel - a.audioLevel);\n            this.activeSpeakers = activeSpeakers;\n            this.emitWhenConnected(RoomEvent.ActiveSpeakersChanged, activeSpeakers);\n        };\n        this.handleStreamStateUpdate = (streamStateUpdate)=>{\n            streamStateUpdate.streamStates.forEach((streamState)=>{\n                const participant = this.participants.get(streamState.participantSid);\n                if (!participant) {\n                    return;\n                }\n                const pub = participant.getTrackPublication(streamState.trackSid);\n                if (!pub || !pub.track) {\n                    return;\n                }\n                pub.track.streamState = Track.streamStateFromProto(streamState.state);\n                participant.emit(ParticipantEvent.TrackStreamStateChanged, pub, pub.track.streamState);\n                this.emitWhenConnected(RoomEvent.TrackStreamStateChanged, pub, pub.track.streamState, participant);\n            });\n        };\n        this.handleSubscriptionPermissionUpdate = (update)=>{\n            const participant = this.participants.get(update.participantSid);\n            if (!participant) {\n                return;\n            }\n            const pub = participant.getTrackPublication(update.trackSid);\n            if (!pub) {\n                return;\n            }\n            pub.setAllowed(update.allowed);\n        };\n        this.handleSubscriptionError = (update)=>{\n            const participant = Array.from(this.participants.values()).find((p)=>p.tracks.has(update.trackSid));\n            if (!participant) {\n                return;\n            }\n            const pub = participant.getTrackPublication(update.trackSid);\n            if (!pub) {\n                return;\n            }\n            pub.setSubscriptionError(update.err);\n        };\n        this.handleDataPacket = (userPacket, kind)=>{\n            // find the participant\n            const participant = this.participants.get(userPacket.participantSid);\n            this.emit(RoomEvent.DataReceived, userPacket.payload, participant, kind, userPacket.topic);\n            // also emit on the participant\n            participant === null || participant === void 0 ? void 0 : participant.emit(ParticipantEvent.DataReceived, userPacket.payload, kind);\n        };\n        this.handleAudioPlaybackStarted = ()=>{\n            if (this.canPlaybackAudio) {\n                return;\n            }\n            this.audioEnabled = true;\n            this.emit(RoomEvent.AudioPlaybackStatusChanged, true);\n        };\n        this.handleAudioPlaybackFailed = (e)=>{\n            this.log.warn('could not playback audio', Object.assign(Object.assign({}, this.logContext), {\n                error: e\n            }));\n            if (!this.canPlaybackAudio) {\n                return;\n            }\n            this.audioEnabled = false;\n            this.emit(RoomEvent.AudioPlaybackStatusChanged, false);\n        };\n        this.handleVideoPlaybackStarted = ()=>{\n            if (this.isVideoPlaybackBlocked) {\n                this.isVideoPlaybackBlocked = false;\n                this.emit(RoomEvent.VideoPlaybackStatusChanged, true);\n            }\n        };\n        this.handleVideoPlaybackFailed = ()=>{\n            if (!this.isVideoPlaybackBlocked) {\n                this.isVideoPlaybackBlocked = true;\n                this.emit(RoomEvent.VideoPlaybackStatusChanged, false);\n            }\n        };\n        this.handleDeviceChange = ()=>__awaiter(this, void 0, void 0, function*() {\n                this.emit(RoomEvent.MediaDevicesChanged);\n            });\n        this.handleRoomUpdate = (room)=>{\n            const oldRoom = this.roomInfo;\n            this.roomInfo = room;\n            if (oldRoom && oldRoom.metadata !== room.metadata) {\n                this.emitWhenConnected(RoomEvent.RoomMetadataChanged, room.metadata);\n            }\n            if ((oldRoom === null || oldRoom === void 0 ? void 0 : oldRoom.activeRecording) !== room.activeRecording) {\n                this.emitWhenConnected(RoomEvent.RecordingStatusChanged, room.activeRecording);\n            }\n        };\n        this.handleConnectionQualityUpdate = (update)=>{\n            update.updates.forEach((info)=>{\n                if (info.participantSid === this.localParticipant.sid) {\n                    this.localParticipant.setConnectionQuality(info.quality);\n                    return;\n                }\n                const participant = this.participants.get(info.participantSid);\n                if (participant) {\n                    participant.setConnectionQuality(info.quality);\n                }\n            });\n        };\n        this.onLocalParticipantMetadataChanged = (metadata)=>{\n            this.emit(RoomEvent.ParticipantMetadataChanged, metadata, this.localParticipant);\n        };\n        this.onLocalParticipantNameChanged = (name)=>{\n            this.emit(RoomEvent.ParticipantNameChanged, name, this.localParticipant);\n        };\n        this.onLocalTrackMuted = (pub)=>{\n            this.emit(RoomEvent.TrackMuted, pub, this.localParticipant);\n        };\n        this.onLocalTrackUnmuted = (pub)=>{\n            this.emit(RoomEvent.TrackUnmuted, pub, this.localParticipant);\n        };\n        this.onLocalTrackPublished = (pub)=>__awaiter(this, void 0, void 0, function*() {\n                var _q;\n                this.emit(RoomEvent.LocalTrackPublished, pub, this.localParticipant);\n                if (pub.track instanceof LocalAudioTrack) {\n                    const trackIsSilent = yield pub.track.checkForSilence();\n                    if (trackIsSilent) {\n                        this.emit(RoomEvent.LocalAudioSilenceDetected, pub);\n                    }\n                }\n                const deviceId = yield (_q = pub.track) === null || _q === void 0 ? void 0 : _q.getDeviceId();\n                const deviceKind = sourceToKind(pub.source);\n                if (deviceKind && deviceId && deviceId !== this.localParticipant.activeDeviceMap.get(deviceKind)) {\n                    this.localParticipant.activeDeviceMap.set(deviceKind, deviceId);\n                    this.emit(RoomEvent.ActiveDeviceChanged, deviceKind, deviceId);\n                }\n            });\n        this.onLocalTrackUnpublished = (pub)=>{\n            this.emit(RoomEvent.LocalTrackUnpublished, pub, this.localParticipant);\n        };\n        this.onLocalConnectionQualityChanged = (quality)=>{\n            this.emit(RoomEvent.ConnectionQualityChanged, quality, this.localParticipant);\n        };\n        this.onMediaDevicesError = (e)=>{\n            this.emit(RoomEvent.MediaDevicesError, e);\n        };\n        this.onLocalParticipantPermissionsChanged = (prevPermissions)=>{\n            this.emit(RoomEvent.ParticipantPermissionsChanged, prevPermissions, this.localParticipant);\n        };\n        this.setMaxListeners(100);\n        this.participants = new Map();\n        this.identityToSid = new Map();\n        this.options = Object.assign(Object.assign({}, roomOptionDefaults), options);\n        this.log = getLogger((_a = this.options.loggerName) !== null && _a !== void 0 ? _a : LoggerNames.Room);\n        this.options.audioCaptureDefaults = Object.assign(Object.assign({}, audioDefaults), options === null || options === void 0 ? void 0 : options.audioCaptureDefaults);\n        this.options.videoCaptureDefaults = Object.assign(Object.assign({}, videoDefaults), options === null || options === void 0 ? void 0 : options.videoCaptureDefaults);\n        this.options.publishDefaults = Object.assign(Object.assign({}, publishDefaults), options === null || options === void 0 ? void 0 : options.publishDefaults);\n        this.maybeCreateEngine();\n        this.disconnectLock = new Mutex();\n        this.localParticipant = new LocalParticipant('', '', this.engine, this.options);\n        if (this.options.videoCaptureDefaults.deviceId) {\n            this.localParticipant.activeDeviceMap.set('videoinput', unwrapConstraint(this.options.videoCaptureDefaults.deviceId));\n        }\n        if (this.options.audioCaptureDefaults.deviceId) {\n            this.localParticipant.activeDeviceMap.set('audioinput', unwrapConstraint(this.options.audioCaptureDefaults.deviceId));\n        }\n        if ((_b = this.options.audioOutput) === null || _b === void 0 ? void 0 : _b.deviceId) {\n            this.switchActiveDevice('audiooutput', unwrapConstraint(this.options.audioOutput.deviceId)).catch((e)=>this.log.warn(\"Could not set audio output: \".concat(e.message), this.logContext));\n        }\n        if (this.options.e2ee) {\n            this.setupE2EE();\n        }\n    }\n    /**\n   * @experimental\n   */ setE2EEEnabled(enabled) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (this.e2eeManager) {\n                yield Promise.all([\n                    this.localParticipant.setE2EEEnabled(enabled)\n                ]);\n                if (this.localParticipant.identity !== '') {\n                    this.e2eeManager.setParticipantCryptorEnabled(enabled, this.localParticipant.identity);\n                }\n            } else {\n                throw Error('e2ee not configured, please set e2ee settings within the room options');\n            }\n        });\n    }\n    setupE2EE() {\n        var _a;\n        if (this.options.e2ee) {\n            this.e2eeManager = new E2EEManager(this.options.e2ee);\n            this.e2eeManager.on(EncryptionEvent.ParticipantEncryptionStatusChanged, (enabled, participant)=>{\n                if (participant instanceof LocalParticipant) {\n                    this.isE2EEEnabled = enabled;\n                }\n                this.emit(RoomEvent.ParticipantEncryptionStatusChanged, enabled, participant);\n            });\n            this.e2eeManager.on(EncryptionEvent.EncryptionError, (error)=>this.emit(RoomEvent.EncryptionError, error));\n            (_a = this.e2eeManager) === null || _a === void 0 ? void 0 : _a.setup(this);\n        }\n    }\n    get logContext() {\n        return {\n            room: this.name,\n            roomSid: this.sid,\n            identity: this.localParticipant.identity\n        };\n    }\n    /**\n   * if the current room has a participant with `recorder: true` in its JWT grant\n   **/ get isRecording() {\n        var _a, _b;\n        return (_b = (_a = this.roomInfo) === null || _a === void 0 ? void 0 : _a.activeRecording) !== null && _b !== void 0 ? _b : false;\n    }\n    /** server assigned unique room id */ get sid() {\n        var _a, _b;\n        return (_b = (_a = this.roomInfo) === null || _a === void 0 ? void 0 : _a.sid) !== null && _b !== void 0 ? _b : '';\n    }\n    /** user assigned name, derived from JWT token */ get name() {\n        var _a, _b;\n        return (_b = (_a = this.roomInfo) === null || _a === void 0 ? void 0 : _a.name) !== null && _b !== void 0 ? _b : '';\n    }\n    /** room metadata */ get metadata() {\n        var _a;\n        return (_a = this.roomInfo) === null || _a === void 0 ? void 0 : _a.metadata;\n    }\n    get numParticipants() {\n        var _a, _b;\n        return (_b = (_a = this.roomInfo) === null || _a === void 0 ? void 0 : _a.numParticipants) !== null && _b !== void 0 ? _b : 0;\n    }\n    get numPublishers() {\n        var _a, _b;\n        return (_b = (_a = this.roomInfo) === null || _a === void 0 ? void 0 : _a.numPublishers) !== null && _b !== void 0 ? _b : 0;\n    }\n    maybeCreateEngine() {\n        if (this.engine && !this.engine.isClosed) {\n            return;\n        }\n        this.engine = new RTCEngine(this.options);\n        this.engine.on(EngineEvent.ParticipantUpdate, this.handleParticipantUpdates).on(EngineEvent.RoomUpdate, this.handleRoomUpdate).on(EngineEvent.SpeakersChanged, this.handleSpeakersChanged).on(EngineEvent.StreamStateChanged, this.handleStreamStateUpdate).on(EngineEvent.ConnectionQualityUpdate, this.handleConnectionQualityUpdate).on(EngineEvent.SubscriptionError, this.handleSubscriptionError).on(EngineEvent.SubscriptionPermissionUpdate, this.handleSubscriptionPermissionUpdate).on(EngineEvent.MediaTrackAdded, (mediaTrack, stream, receiver)=>{\n            this.onTrackAdded(mediaTrack, stream, receiver);\n        }).on(EngineEvent.Disconnected, (reason)=>{\n            this.handleDisconnect(this.options.stopLocalTrackOnUnpublish, reason);\n        }).on(EngineEvent.ActiveSpeakersUpdate, this.handleActiveSpeakersUpdate).on(EngineEvent.DataPacketReceived, this.handleDataPacket).on(EngineEvent.Resuming, ()=>{\n            this.clearConnectionReconcile();\n            if (this.setAndEmitConnectionState(ConnectionState.Reconnecting)) {\n                this.emit(RoomEvent.Reconnecting);\n            }\n        }).on(EngineEvent.Resumed, ()=>{\n            this.setAndEmitConnectionState(ConnectionState.Connected);\n            this.emit(RoomEvent.Reconnected);\n            this.registerConnectionReconcile();\n            this.updateSubscriptions();\n            this.emitBufferedEvents();\n        }).on(EngineEvent.SignalResumed, ()=>{\n            this.bufferedEvents = [];\n            if (this.state === ConnectionState.Reconnecting) {\n                this.sendSyncState();\n            }\n        }).on(EngineEvent.Restarting, this.handleRestarting).on(EngineEvent.SignalRestarted, this.handleSignalRestarted).on(EngineEvent.DCBufferStatusChanged, (status, kind)=>{\n            this.emit(RoomEvent.DCBufferStatusChanged, status, kind);\n        });\n        if (this.localParticipant) {\n            this.localParticipant.setupEngine(this.engine);\n        }\n        if (this.e2eeManager) {\n            this.e2eeManager.setupEngine(this.engine);\n        }\n    }\n    /**\n   * getLocalDevices abstracts navigator.mediaDevices.enumerateDevices.\n   * In particular, it handles Chrome's unique behavior of creating `default`\n   * devices. When encountered, it'll be removed from the list of devices.\n   * The actual default device will be placed at top.\n   * @param kind\n   * @returns a list of available local devices\n   */ static getLocalDevices(kind) {\n        let requestPermissions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n        return DeviceManager.getInstance().getDevices(kind, requestPermissions);\n    }\n    /**\n   * prepareConnection should be called as soon as the page is loaded, in order\n   * to speed up the connection attempt. This function will\n   * - perform DNS resolution and pre-warm the DNS cache\n   * - establish TLS connection and cache TLS keys\n   *\n   * With LiveKit Cloud, it will also determine the best edge data center for\n   * the current client to connect to if a token is provided.\n   */ prepareConnection(url, token) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (this.state !== ConnectionState.Disconnected) {\n                return;\n            }\n            this.log.debug(\"prepareConnection to \".concat(url), this.logContext);\n            try {\n                if (isCloud(new URL(url)) && token) {\n                    this.regionUrlProvider = new RegionUrlProvider(url, token);\n                    const regionUrl = yield this.regionUrlProvider.getNextBestRegionUrl();\n                    // we will not replace the regionUrl if an attempt had already started\n                    // to avoid overriding regionUrl after a new connection attempt had started\n                    if (regionUrl && this.state === ConnectionState.Disconnected) {\n                        this.regionUrl = regionUrl;\n                        yield fetch(toHttpUrl(regionUrl), {\n                            method: 'HEAD'\n                        });\n                        this.log.debug(\"prepared connection to \".concat(regionUrl), this.logContext);\n                    }\n                } else {\n                    yield fetch(toHttpUrl(url), {\n                        method: 'HEAD'\n                    });\n                }\n            } catch (e) {\n                this.log.warn('could not prepare connection', Object.assign(Object.assign({}, this.logContext), {\n                    error: e\n                }));\n            }\n        });\n    }\n    /**\n   * retrieves a participant by identity\n   * @param identity\n   * @returns\n   */ getParticipantByIdentity(identity) {\n        if (this.localParticipant.identity === identity) {\n            return this.localParticipant;\n        }\n        const sid = this.identityToSid.get(identity);\n        if (sid) {\n            return this.participants.get(sid);\n        }\n    }\n    clearConnectionFutures() {\n        this.connectFuture = undefined;\n    }\n    /**\n   * @internal for testing\n   */ simulateScenario(scenario, arg) {\n        return __awaiter(this, void 0, void 0, function*() {\n            let postAction = ()=>{};\n            let req;\n            switch(scenario){\n                case 'signal-reconnect':\n                    // @ts-expect-error function is private\n                    yield this.engine.client.handleOnClose('simulate disconnect');\n                    break;\n                case 'speaker':\n                    req = new SimulateScenario({\n                        scenario: {\n                            case: 'speakerUpdate',\n                            value: 3\n                        }\n                    });\n                    break;\n                case 'node-failure':\n                    req = new SimulateScenario({\n                        scenario: {\n                            case: 'nodeFailure',\n                            value: true\n                        }\n                    });\n                    break;\n                case 'server-leave':\n                    req = new SimulateScenario({\n                        scenario: {\n                            case: 'serverLeave',\n                            value: true\n                        }\n                    });\n                    break;\n                case 'migration':\n                    req = new SimulateScenario({\n                        scenario: {\n                            case: 'migration',\n                            value: true\n                        }\n                    });\n                    break;\n                case 'resume-reconnect':\n                    this.engine.failNext();\n                    // @ts-expect-error function is private\n                    yield this.engine.client.handleOnClose('simulate resume-disconnect');\n                    break;\n                case 'disconnect-signal-on-resume':\n                    postAction = ()=>__awaiter(this, void 0, void 0, function*() {\n                            // @ts-expect-error function is private\n                            yield this.engine.client.handleOnClose('simulate resume-disconnect');\n                        });\n                    req = new SimulateScenario({\n                        scenario: {\n                            case: 'disconnectSignalOnResume',\n                            value: true\n                        }\n                    });\n                    break;\n                case 'disconnect-signal-on-resume-no-messages':\n                    postAction = ()=>__awaiter(this, void 0, void 0, function*() {\n                            // @ts-expect-error function is private\n                            yield this.engine.client.handleOnClose('simulate resume-disconnect');\n                        });\n                    req = new SimulateScenario({\n                        scenario: {\n                            case: 'disconnectSignalOnResumeNoMessages',\n                            value: true\n                        }\n                    });\n                    break;\n                case 'full-reconnect':\n                    this.engine.fullReconnectOnNext = true;\n                    // @ts-expect-error function is private\n                    yield this.engine.client.handleOnClose('simulate full-reconnect');\n                    break;\n                case 'force-tcp':\n                case 'force-tls':\n                    req = new SimulateScenario({\n                        scenario: {\n                            case: 'switchCandidateProtocol',\n                            value: scenario === 'force-tls' ? 2 : 1\n                        }\n                    });\n                    postAction = ()=>__awaiter(this, void 0, void 0, function*() {\n                            const onLeave = this.engine.client.onLeave;\n                            if (onLeave) {\n                                onLeave(new LeaveRequest({\n                                    reason: DisconnectReason.CLIENT_INITIATED,\n                                    canReconnect: true\n                                }));\n                            }\n                        });\n                    break;\n                case 'subscriber-bandwidth':\n                    if (arg === undefined || typeof arg !== 'number') {\n                        throw new Error('subscriber-bandwidth requires a number as argument');\n                    }\n                    req = new SimulateScenario({\n                        scenario: {\n                            case: 'subscriberBandwidth',\n                            value: BigInt(arg)\n                        }\n                    });\n                    break;\n            }\n            if (req) {\n                yield this.engine.client.sendSimulateScenario(req);\n                yield postAction();\n            }\n        });\n    }\n    /**\n   * Returns true if audio playback is enabled\n   */ get canPlaybackAudio() {\n        return this.audioEnabled;\n    }\n    /**\n   * Returns true if video playback is enabled\n   */ get canPlaybackVideo() {\n        return !this.isVideoPlaybackBlocked;\n    }\n    /**\n   * Returns the active audio output device used in this room.\n   * @return the previously successfully set audio output device ID or an empty string if the default device is used.\n   * @deprecated use `getActiveDevice('audiooutput')` instead\n   */ getActiveAudioOutputDevice() {\n        var _a, _b;\n        return (_b = (_a = this.options.audioOutput) === null || _a === void 0 ? void 0 : _a.deviceId) !== null && _b !== void 0 ? _b : '';\n    }\n    getActiveDevice(kind) {\n        return this.localParticipant.activeDeviceMap.get(kind);\n    }\n    /**\n   * Switches all active devices used in this room to the given device.\n   *\n   * Note: setting AudioOutput is not supported on some browsers. See [setSinkId](https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/setSinkId#browser_compatibility)\n   *\n   * @param kind use `videoinput` for camera track,\n   *  `audioinput` for microphone track,\n   *  `audiooutput` to set speaker for all incoming audio tracks\n   * @param deviceId\n   */ switchActiveDevice(kind, deviceId) {\n        let exact = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n        var _a, _b;\n        var _c;\n        return __awaiter(this, void 0, void 0, function*() {\n            let deviceHasChanged = false;\n            let success = true;\n            const deviceConstraint = exact ? {\n                exact: deviceId\n            } : deviceId;\n            if (kind === 'audioinput') {\n                const prevDeviceId = this.options.audioCaptureDefaults.deviceId;\n                this.options.audioCaptureDefaults.deviceId = deviceConstraint;\n                deviceHasChanged = prevDeviceId !== deviceConstraint;\n                const tracks = Array.from(this.localParticipant.audioTracks.values()).filter((track)=>track.source === Track.Source.Microphone);\n                try {\n                    success = (yield Promise.all(tracks.map((t)=>{\n                        var _a;\n                        return (_a = t.audioTrack) === null || _a === void 0 ? void 0 : _a.setDeviceId(deviceConstraint);\n                    }))).every((val)=>val === true);\n                } catch (e) {\n                    this.options.audioCaptureDefaults.deviceId = prevDeviceId;\n                    throw e;\n                }\n            } else if (kind === 'videoinput') {\n                const prevDeviceId = this.options.videoCaptureDefaults.deviceId;\n                this.options.videoCaptureDefaults.deviceId = deviceConstraint;\n                deviceHasChanged = prevDeviceId !== deviceConstraint;\n                const tracks = Array.from(this.localParticipant.videoTracks.values()).filter((track)=>track.source === Track.Source.Camera);\n                try {\n                    success = (yield Promise.all(tracks.map((t)=>{\n                        var _a;\n                        return (_a = t.videoTrack) === null || _a === void 0 ? void 0 : _a.setDeviceId(deviceConstraint);\n                    }))).every((val)=>val === true);\n                } catch (e) {\n                    this.options.videoCaptureDefaults.deviceId = prevDeviceId;\n                    throw e;\n                }\n            } else if (kind === 'audiooutput') {\n                if (!supportsSetSinkId() && !this.options.expWebAudioMix || this.options.expWebAudioMix && this.audioContext && !('setSinkId' in this.audioContext)) {\n                    throw new Error('cannot switch audio output, setSinkId not supported');\n                }\n                (_a = (_c = this.options).audioOutput) !== null && _a !== void 0 ? _a : _c.audioOutput = {};\n                const prevDeviceId = this.options.audioOutput.deviceId;\n                this.options.audioOutput.deviceId = deviceId;\n                deviceHasChanged = prevDeviceId !== deviceConstraint;\n                try {\n                    if (this.options.expWebAudioMix) {\n                        // @ts-expect-error setSinkId is not yet in the typescript type of AudioContext\n                        (_b = this.audioContext) === null || _b === void 0 ? void 0 : _b.setSinkId(deviceId);\n                    } else {\n                        yield Promise.all(Array.from(this.participants.values()).map((p)=>p.setAudioOutput({\n                                deviceId\n                            })));\n                    }\n                } catch (e) {\n                    this.options.audioOutput.deviceId = prevDeviceId;\n                    throw e;\n                }\n            }\n            if (deviceHasChanged && success) {\n                this.localParticipant.activeDeviceMap.set(kind, deviceId);\n                this.emit(RoomEvent.ActiveDeviceChanged, kind, deviceId);\n            }\n            return success;\n        });\n    }\n    setupLocalParticipantEvents() {\n        this.localParticipant.on(ParticipantEvent.ParticipantMetadataChanged, this.onLocalParticipantMetadataChanged).on(ParticipantEvent.ParticipantNameChanged, this.onLocalParticipantNameChanged).on(ParticipantEvent.TrackMuted, this.onLocalTrackMuted).on(ParticipantEvent.TrackUnmuted, this.onLocalTrackUnmuted).on(ParticipantEvent.LocalTrackPublished, this.onLocalTrackPublished).on(ParticipantEvent.LocalTrackUnpublished, this.onLocalTrackUnpublished).on(ParticipantEvent.ConnectionQualityChanged, this.onLocalConnectionQualityChanged).on(ParticipantEvent.MediaDevicesError, this.onMediaDevicesError).on(ParticipantEvent.AudioStreamAcquired, this.startAudio).on(ParticipantEvent.ParticipantPermissionsChanged, this.onLocalParticipantPermissionsChanged);\n    }\n    recreateEngine() {\n        var _a;\n        (_a = this.engine) === null || _a === void 0 ? void 0 : _a.close();\n        /* @ts-ignore */ this.engine = undefined;\n        // clear out existing remote participants, since they may have attached\n        // the old engine\n        this.participants.clear();\n        this.bufferedEvents = [];\n        this.maybeCreateEngine();\n    }\n    onTrackAdded(mediaTrack, stream, receiver) {\n        // don't fire onSubscribed when connecting\n        // WebRTC fires onTrack as soon as setRemoteDescription is called on the offer\n        // at that time, ICE connectivity has not been established so the track is not\n        // technically subscribed.\n        // We'll defer these events until when the room is connected or eventually disconnected.\n        if (this.state === ConnectionState.Connecting || this.state === ConnectionState.Reconnecting) {\n            const reconnectedHandler = ()=>{\n                this.onTrackAdded(mediaTrack, stream, receiver);\n                cleanup();\n            };\n            const cleanup = ()=>{\n                this.off(RoomEvent.Reconnected, reconnectedHandler);\n                this.off(RoomEvent.Connected, reconnectedHandler);\n                this.off(RoomEvent.Disconnected, cleanup);\n            };\n            this.once(RoomEvent.Reconnected, reconnectedHandler);\n            this.once(RoomEvent.Connected, reconnectedHandler);\n            this.once(RoomEvent.Disconnected, cleanup);\n            return;\n        }\n        if (this.state === ConnectionState.Disconnected) {\n            this.log.warn('skipping incoming track after Room disconnected', this.logContext);\n            return;\n        }\n        const parts = unpackStreamId(stream.id);\n        const participantId = parts[0];\n        let streamId = parts[1];\n        let trackId = mediaTrack.id;\n        // firefox will get streamId (pID|trackId) instead of (pID|streamId) as it doesn't support sync tracks by stream\n        // and generates its own track id instead of infer from sdp track id.\n        if (streamId && streamId.startsWith('TR')) trackId = streamId;\n        if (participantId === this.localParticipant.sid) {\n            this.log.warn('tried to create RemoteParticipant for local participant', this.logContext);\n            return;\n        }\n        const participant = this.participants.get(participantId);\n        if (!participant) {\n            this.log.error(\"Tried to add a track for a participant, that's not present. Sid: \".concat(participantId), this.logContext);\n            return;\n        }\n        let adaptiveStreamSettings;\n        if (this.options.adaptiveStream) {\n            if (typeof this.options.adaptiveStream === 'object') {\n                adaptiveStreamSettings = this.options.adaptiveStream;\n            } else {\n                adaptiveStreamSettings = {};\n            }\n        }\n        participant.addSubscribedMediaTrack(mediaTrack, trackId, stream, receiver, adaptiveStreamSettings);\n    }\n    handleDisconnect() {\n        let shouldStopTracks = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n        let reason = arguments.length > 1 ? arguments[1] : undefined;\n        var _a;\n        this.clearConnectionReconcile();\n        this.bufferedEvents = [];\n        if (this.state === ConnectionState.Disconnected) {\n            return;\n        }\n        this.regionUrl = undefined;\n        try {\n            this.participants.forEach((p)=>{\n                p.tracks.forEach((pub)=>{\n                    p.unpublishTrack(pub.trackSid);\n                });\n            });\n            this.localParticipant.tracks.forEach((pub)=>{\n                var _a, _b;\n                if (pub.track) {\n                    this.localParticipant.unpublishTrack(pub.track, shouldStopTracks);\n                }\n                if (shouldStopTracks) {\n                    (_a = pub.track) === null || _a === void 0 ? void 0 : _a.detach();\n                    (_b = pub.track) === null || _b === void 0 ? void 0 : _b.stop();\n                }\n            });\n            this.localParticipant.off(ParticipantEvent.ParticipantMetadataChanged, this.onLocalParticipantMetadataChanged).off(ParticipantEvent.ParticipantNameChanged, this.onLocalParticipantNameChanged).off(ParticipantEvent.TrackMuted, this.onLocalTrackMuted).off(ParticipantEvent.TrackUnmuted, this.onLocalTrackUnmuted).off(ParticipantEvent.LocalTrackPublished, this.onLocalTrackPublished).off(ParticipantEvent.LocalTrackUnpublished, this.onLocalTrackUnpublished).off(ParticipantEvent.ConnectionQualityChanged, this.onLocalConnectionQualityChanged).off(ParticipantEvent.MediaDevicesError, this.onMediaDevicesError).off(ParticipantEvent.AudioStreamAcquired, this.startAudio).off(ParticipantEvent.ParticipantPermissionsChanged, this.onLocalParticipantPermissionsChanged);\n            this.localParticipant.tracks.clear();\n            this.localParticipant.videoTracks.clear();\n            this.localParticipant.audioTracks.clear();\n            this.participants.clear();\n            this.activeSpeakers = [];\n            if (this.audioContext && typeof this.options.expWebAudioMix === 'boolean') {\n                this.audioContext.close();\n                this.audioContext = undefined;\n            }\n            if (isWeb()) {\n                window.removeEventListener('beforeunload', this.onPageLeave);\n                window.removeEventListener('pagehide', this.onPageLeave);\n                window.removeEventListener('freeze', this.onPageLeave);\n                (_a = navigator.mediaDevices) === null || _a === void 0 ? void 0 : _a.removeEventListener('devicechange', this.handleDeviceChange);\n            }\n        } finally{\n            this.setAndEmitConnectionState(ConnectionState.Disconnected);\n            this.emit(RoomEvent.Disconnected, reason);\n        }\n    }\n    handleParticipantDisconnected(sid, participant) {\n        // remove and send event\n        this.participants.delete(sid);\n        if (!participant) {\n            return;\n        }\n        this.identityToSid.delete(participant.identity);\n        participant.tracks.forEach((publication)=>{\n            participant.unpublishTrack(publication.trackSid, true);\n        });\n        this.emit(RoomEvent.ParticipantDisconnected, participant);\n    }\n    acquireAudioContext() {\n        var _a, _b;\n        return __awaiter(this, void 0, void 0, function*() {\n            if (typeof this.options.expWebAudioMix !== 'boolean' && this.options.expWebAudioMix.audioContext) {\n                // override audio context with custom audio context if supplied by user\n                this.audioContext = this.options.expWebAudioMix.audioContext;\n            } else if (!this.audioContext || this.audioContext.state === 'closed') {\n                // by using an AudioContext, it reduces lag on audio elements\n                // https://stackoverflow.com/questions/9811429/html5-audio-tag-on-safari-has-a-delay/54119854#54119854\n                this.audioContext = (_a = getNewAudioContext()) !== null && _a !== void 0 ? _a : undefined;\n            }\n            if (this.audioContext && this.audioContext.state === 'suspended') {\n                // for iOS a newly created AudioContext is always in `suspended` state.\n                // we try our best to resume the context here, if that doesn't work, we just continue with regular processing\n                try {\n                    yield this.audioContext.resume();\n                } catch (e) {\n                    this.log.warn('Could not resume audio context', Object.assign(Object.assign({}, this.logContext), {\n                        error: e\n                    }));\n                }\n            }\n            if (this.options.expWebAudioMix) {\n                this.participants.forEach((participant)=>participant.setAudioContext(this.audioContext));\n            }\n            this.localParticipant.setAudioContext(this.audioContext);\n            const newContextIsRunning = ((_b = this.audioContext) === null || _b === void 0 ? void 0 : _b.state) === 'running';\n            if (newContextIsRunning !== this.canPlaybackAudio) {\n                this.audioEnabled = newContextIsRunning;\n                this.emit(RoomEvent.AudioPlaybackStatusChanged, newContextIsRunning);\n            }\n        });\n    }\n    createParticipant(id, info) {\n        var _a;\n        let participant;\n        if (info) {\n            participant = RemoteParticipant.fromParticipantInfo(this.engine.client, info);\n        } else {\n            participant = new RemoteParticipant(this.engine.client, id, '', undefined, undefined, {\n                loggerContextCb: ()=>this.logContext,\n                loggerName: this.options.loggerName\n            });\n        }\n        if (this.options.expWebAudioMix) {\n            participant.setAudioContext(this.audioContext);\n        }\n        if ((_a = this.options.audioOutput) === null || _a === void 0 ? void 0 : _a.deviceId) {\n            participant.setAudioOutput(this.options.audioOutput).catch((e)=>this.log.warn(\"Could not set audio output: \".concat(e.message), this.logContext));\n        }\n        return participant;\n    }\n    getOrCreateParticipant(id, info) {\n        if (this.participants.has(id)) {\n            return this.participants.get(id);\n        }\n        const participant = this.createParticipant(id, info);\n        this.participants.set(id, participant);\n        this.identityToSid.set(info.identity, info.sid);\n        // if we have valid info and the participant wasn't in the map before, we can assume the participant is new\n        // firing here to make sure that `ParticipantConnected` fires before the initial track events\n        this.emitWhenConnected(RoomEvent.ParticipantConnected, participant);\n        // also forward events\n        // trackPublished is only fired for tracks added after both local participant\n        // and remote participant joined the room\n        participant.on(ParticipantEvent.TrackPublished, (trackPublication)=>{\n            this.emitWhenConnected(RoomEvent.TrackPublished, trackPublication, participant);\n        }).on(ParticipantEvent.TrackSubscribed, (track, publication)=>{\n            // monitor playback status\n            if (track.kind === Track.Kind.Audio) {\n                track.on(TrackEvent.AudioPlaybackStarted, this.handleAudioPlaybackStarted);\n                track.on(TrackEvent.AudioPlaybackFailed, this.handleAudioPlaybackFailed);\n            } else if (track.kind === Track.Kind.Video) {\n                track.on(TrackEvent.VideoPlaybackFailed, this.handleVideoPlaybackFailed);\n                track.on(TrackEvent.VideoPlaybackStarted, this.handleVideoPlaybackStarted);\n            }\n            this.emit(RoomEvent.TrackSubscribed, track, publication, participant);\n        }).on(ParticipantEvent.TrackUnpublished, (publication)=>{\n            this.emit(RoomEvent.TrackUnpublished, publication, participant);\n        }).on(ParticipantEvent.TrackUnsubscribed, (track, publication)=>{\n            this.emit(RoomEvent.TrackUnsubscribed, track, publication, participant);\n        }).on(ParticipantEvent.TrackSubscriptionFailed, (sid)=>{\n            this.emit(RoomEvent.TrackSubscriptionFailed, sid, participant);\n        }).on(ParticipantEvent.TrackMuted, (pub)=>{\n            this.emitWhenConnected(RoomEvent.TrackMuted, pub, participant);\n        }).on(ParticipantEvent.TrackUnmuted, (pub)=>{\n            this.emitWhenConnected(RoomEvent.TrackUnmuted, pub, participant);\n        }).on(ParticipantEvent.ParticipantMetadataChanged, (metadata)=>{\n            this.emitWhenConnected(RoomEvent.ParticipantMetadataChanged, metadata, participant);\n        }).on(ParticipantEvent.ParticipantNameChanged, (name)=>{\n            this.emitWhenConnected(RoomEvent.ParticipantNameChanged, name, participant);\n        }).on(ParticipantEvent.ConnectionQualityChanged, (quality)=>{\n            this.emitWhenConnected(RoomEvent.ConnectionQualityChanged, quality, participant);\n        }).on(ParticipantEvent.ParticipantPermissionsChanged, (prevPermissions)=>{\n            this.emitWhenConnected(RoomEvent.ParticipantPermissionsChanged, prevPermissions, participant);\n        }).on(ParticipantEvent.TrackSubscriptionStatusChanged, (pub, status)=>{\n            this.emitWhenConnected(RoomEvent.TrackSubscriptionStatusChanged, pub, status, participant);\n        }).on(ParticipantEvent.TrackSubscriptionFailed, (trackSid, error)=>{\n            this.emit(RoomEvent.TrackSubscriptionFailed, trackSid, participant, error);\n        }).on(ParticipantEvent.TrackSubscriptionPermissionChanged, (pub, status)=>{\n            this.emitWhenConnected(RoomEvent.TrackSubscriptionPermissionChanged, pub, status, participant);\n        });\n        // update info at the end after callbacks have been set up\n        if (info) {\n            participant.updateInfo(info);\n        }\n        return participant;\n    }\n    sendSyncState() {\n        const remoteTracks = Array.from(this.participants.values()).reduce((acc, participant)=>{\n            acc.push(...participant.getTracks()); // FIXME would be nice to have this return RemoteTrackPublications directly instead of the type cast\n            return acc;\n        }, []);\n        const localTracks = this.localParticipant.getTracks(); // FIXME would be nice to have this return LocalTrackPublications directly instead of the type cast\n        this.engine.sendSyncState(remoteTracks, localTracks);\n    }\n    /**\n   * After resuming, we'll need to notify the server of the current\n   * subscription settings.\n   */ updateSubscriptions() {\n        for (const p of this.participants.values()){\n            for (const pub of p.videoTracks.values()){\n                if (pub.isSubscribed && pub instanceof RemoteTrackPublication) {\n                    pub.emitTrackUpdate();\n                }\n            }\n        }\n    }\n    registerConnectionReconcile() {\n        this.clearConnectionReconcile();\n        let consecutiveFailures = 0;\n        this.connectionReconcileInterval = CriticalTimers.setInterval(()=>{\n            if (// ensure we didn't tear it down\n            !this.engine || // engine detected close, but Room missed it\n            this.engine.isClosed || // transports failed without notifying engine\n            !this.engine.verifyTransport()) {\n                consecutiveFailures++;\n                this.log.warn('detected connection state mismatch', Object.assign(Object.assign({}, this.logContext), {\n                    numFailures: consecutiveFailures,\n                    engine: {\n                        closed: this.engine.isClosed,\n                        transportsConnected: this.engine.verifyTransport()\n                    }\n                }));\n                if (consecutiveFailures >= 3) {\n                    this.recreateEngine();\n                    this.handleDisconnect(this.options.stopLocalTrackOnUnpublish, DisconnectReason.STATE_MISMATCH);\n                }\n            } else {\n                consecutiveFailures = 0;\n            }\n        }, connectionReconcileFrequency);\n    }\n    clearConnectionReconcile() {\n        if (this.connectionReconcileInterval) {\n            CriticalTimers.clearInterval(this.connectionReconcileInterval);\n        }\n    }\n    setAndEmitConnectionState(state) {\n        if (state === this.state) {\n            // unchanged\n            return false;\n        }\n        this.state = state;\n        this.emit(RoomEvent.ConnectionStateChanged, this.state);\n        return true;\n    }\n    emitBufferedEvents() {\n        this.bufferedEvents.forEach((_ref2)=>{\n            let [ev, args] = _ref2;\n            this.emit(ev, ...args);\n        });\n        this.bufferedEvents = [];\n    }\n    emitWhenConnected(event) {\n        for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n            args[_key - 1] = arguments[_key];\n        }\n        if (this.state === ConnectionState.Connected) {\n            return this.emit(event, ...args);\n        } else if (this.state === ConnectionState.Reconnecting) {\n            // in case the room is reconnecting, buffer the events by firing them later after emitting RoomEvent.Reconnected\n            this.bufferedEvents.push([\n                event,\n                args\n            ]);\n        }\n        return false;\n    }\n    /**\n   * Allows to populate a room with simulated participants.\n   * No actual connection to a server will be established, all state is\n   * @experimental\n   */ simulateParticipants(options) {\n        var _a, _b;\n        return __awaiter(this, void 0, void 0, function*() {\n            const publishOptions = Object.assign({\n                audio: true,\n                video: true,\n                useRealTracks: false\n            }, options.publish);\n            const participantOptions = Object.assign({\n                count: 9,\n                audio: false,\n                video: true,\n                aspectRatios: [\n                    1.66,\n                    1.7,\n                    1.3\n                ]\n            }, options.participants);\n            this.handleDisconnect();\n            this.roomInfo = new Room$1({\n                sid: 'RM_SIMULATED',\n                name: 'simulated-room',\n                emptyTimeout: 0,\n                maxParticipants: 0,\n                creationTime: protoInt64.parse(new Date().getTime()),\n                metadata: '',\n                numParticipants: 1,\n                numPublishers: 1,\n                turnPassword: '',\n                enabledCodecs: [],\n                activeRecording: false\n            });\n            this.localParticipant.updateInfo(new ParticipantInfo({\n                identity: 'simulated-local',\n                name: 'local-name'\n            }));\n            this.setupLocalParticipantEvents();\n            this.emit(RoomEvent.SignalConnected);\n            this.emit(RoomEvent.Connected);\n            this.setAndEmitConnectionState(ConnectionState.Connected);\n            if (publishOptions.video) {\n                const camPub = new LocalTrackPublication(Track.Kind.Video, new TrackInfo({\n                    source: TrackSource.CAMERA,\n                    sid: Math.floor(Math.random() * 10000).toString(),\n                    type: TrackType.AUDIO,\n                    name: 'video-dummy'\n                }), new LocalVideoTrack(publishOptions.useRealTracks ? (yield window.navigator.mediaDevices.getUserMedia({\n                    video: true\n                })).getVideoTracks()[0] : createDummyVideoStreamTrack(160 * ((_a = participantOptions.aspectRatios[0]) !== null && _a !== void 0 ? _a : 1), 160, true, true), undefined, false, {\n                    loggerName: this.options.loggerName,\n                    loggerContextCb: ()=>this.logContext\n                }), {\n                    loggerName: this.options.loggerName,\n                    loggerContextCb: ()=>this.logContext\n                });\n                // @ts-ignore\n                this.localParticipant.addTrackPublication(camPub);\n                this.localParticipant.emit(ParticipantEvent.LocalTrackPublished, camPub);\n            }\n            if (publishOptions.audio) {\n                const audioPub = new LocalTrackPublication(Track.Kind.Audio, new TrackInfo({\n                    source: TrackSource.MICROPHONE,\n                    sid: Math.floor(Math.random() * 10000).toString(),\n                    type: TrackType.AUDIO\n                }), new LocalAudioTrack(publishOptions.useRealTracks ? (yield navigator.mediaDevices.getUserMedia({\n                    audio: true\n                })).getAudioTracks()[0] : getEmptyAudioStreamTrack(), undefined, false, this.audioContext, {\n                    loggerName: this.options.loggerName,\n                    loggerContextCb: ()=>this.logContext\n                }), {\n                    loggerName: this.options.loggerName,\n                    loggerContextCb: ()=>this.logContext\n                });\n                // @ts-ignore\n                this.localParticipant.addTrackPublication(audioPub);\n                this.localParticipant.emit(ParticipantEvent.LocalTrackPublished, audioPub);\n            }\n            for(let i = 0; i < participantOptions.count - 1; i += 1){\n                let info = new ParticipantInfo({\n                    sid: Math.floor(Math.random() * 10000).toString(),\n                    identity: \"simulated-\".concat(i),\n                    state: ParticipantInfo_State.ACTIVE,\n                    tracks: [],\n                    joinedAt: protoInt64.parse(Date.now())\n                });\n                const p = this.getOrCreateParticipant(info.identity, info);\n                if (participantOptions.video) {\n                    const dummyVideo = createDummyVideoStreamTrack(160 * ((_b = participantOptions.aspectRatios[i % participantOptions.aspectRatios.length]) !== null && _b !== void 0 ? _b : 1), 160, false, true);\n                    const videoTrack = new TrackInfo({\n                        source: TrackSource.CAMERA,\n                        sid: Math.floor(Math.random() * 10000).toString(),\n                        type: TrackType.AUDIO\n                    });\n                    p.addSubscribedMediaTrack(dummyVideo, videoTrack.sid, new MediaStream([\n                        dummyVideo\n                    ]));\n                    info.tracks = [\n                        ...info.tracks,\n                        videoTrack\n                    ];\n                }\n                if (participantOptions.audio) {\n                    const dummyTrack = getEmptyAudioStreamTrack();\n                    const audioTrack = new TrackInfo({\n                        source: TrackSource.MICROPHONE,\n                        sid: Math.floor(Math.random() * 10000).toString(),\n                        type: TrackType.AUDIO\n                    });\n                    p.addSubscribedMediaTrack(dummyTrack, audioTrack.sid, new MediaStream([\n                        dummyTrack\n                    ]));\n                    info.tracks = [\n                        ...info.tracks,\n                        audioTrack\n                    ];\n                }\n                p.updateInfo(info);\n            }\n        });\n    }\n    // /** @internal */\n    emit(event) {\n        for(var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++){\n            args[_key2 - 1] = arguments[_key2];\n        }\n        // active speaker updates are too spammy\n        if (event !== RoomEvent.ActiveSpeakersChanged) {\n            // only extract logContext from arguments in order to avoid logging the whole object tree\n            const minimizedArgs = mapArgs(args).filter((arg)=>arg !== undefined);\n            this.log.debug(\"room event \".concat(event), Object.assign(Object.assign({}, this.logContext), {\n                event,\n                args: minimizedArgs\n            }));\n        }\n        return super.emit(event, ...args);\n    }\n}\nfunction mapArgs(args) {\n    return args.map((arg)=>{\n        if (!arg) {\n            return;\n        }\n        if (Array.isArray(arg)) {\n            return mapArgs(arg);\n        }\n        if (typeof arg === 'object') {\n            return 'logContext' in arg && arg.logContext;\n        }\n        return arg;\n    });\n}\nvar CheckStatus;\n(function(CheckStatus) {\n    CheckStatus[CheckStatus[\"IDLE\"] = 0] = \"IDLE\";\n    CheckStatus[CheckStatus[\"RUNNING\"] = 1] = \"RUNNING\";\n    CheckStatus[CheckStatus[\"SKIPPED\"] = 2] = \"SKIPPED\";\n    CheckStatus[CheckStatus[\"SUCCESS\"] = 3] = \"SUCCESS\";\n    CheckStatus[CheckStatus[\"FAILED\"] = 4] = \"FAILED\";\n})(CheckStatus || (CheckStatus = {}));\nclass Checker extends eventsExports.EventEmitter {\n    constructor(url, token){\n        let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        super();\n        this.status = CheckStatus.IDLE;\n        this.logs = [];\n        this.errorsAsWarnings = false;\n        this.url = url;\n        this.token = token;\n        this.name = this.constructor.name;\n        this.room = new Room(options.roomOptions);\n        this.connectOptions = options.connectOptions;\n        if (options.errorsAsWarnings) {\n            this.errorsAsWarnings = options.errorsAsWarnings;\n        }\n    }\n    run(onComplete) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (this.status !== CheckStatus.IDLE) {\n                throw Error('check is running already');\n            }\n            this.setStatus(CheckStatus.RUNNING);\n            try {\n                yield this.perform();\n            } catch (err) {\n                if (err instanceof Error) {\n                    if (this.errorsAsWarnings) {\n                        this.appendWarning(err.message);\n                    } else {\n                        this.appendError(err.message);\n                    }\n                }\n            }\n            yield this.disconnect();\n            // sleep for a bit to ensure disconnect\n            yield new Promise((resolve)=>setTimeout(resolve, 500));\n            // @ts-ignore\n            if (this.status !== CheckStatus.SKIPPED) {\n                this.setStatus(this.isSuccess() ? CheckStatus.SUCCESS : CheckStatus.FAILED);\n            }\n            if (onComplete) {\n                onComplete();\n            }\n            return this.getInfo();\n        });\n    }\n    isSuccess() {\n        return !this.logs.some((l)=>l.level === 'error');\n    }\n    connect() {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (this.room.state === ConnectionState.Connected) {\n                return this.room;\n            }\n            yield this.room.connect(this.url, this.token);\n            return this.room;\n        });\n    }\n    disconnect() {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (this.room && this.room.state !== ConnectionState.Disconnected) {\n                yield this.room.disconnect();\n                // wait for it to go through\n                yield new Promise((resolve)=>setTimeout(resolve, 500));\n            }\n        });\n    }\n    skip() {\n        this.setStatus(CheckStatus.SKIPPED);\n    }\n    appendMessage(message) {\n        this.logs.push({\n            level: 'info',\n            message\n        });\n        this.emit('update', this.getInfo());\n    }\n    appendWarning(message) {\n        this.logs.push({\n            level: 'warning',\n            message\n        });\n        this.emit('update', this.getInfo());\n    }\n    appendError(message) {\n        this.logs.push({\n            level: 'error',\n            message\n        });\n        this.emit('update', this.getInfo());\n    }\n    setStatus(status) {\n        this.status = status;\n        this.emit('update', this.getInfo());\n    }\n    get engine() {\n        var _a;\n        return (_a = this.room) === null || _a === void 0 ? void 0 : _a.engine;\n    }\n    getInfo() {\n        return {\n            logs: this.logs,\n            name: this.name,\n            status: this.status,\n            description: this.description\n        };\n    }\n}\n/**\n * Creates a local video and audio track at the same time. When acquiring both\n * audio and video tracks together, it'll display a single permission prompt to\n * the user instead of two separate ones.\n * @param options\n */ function createLocalTracks(options) {\n    var _a, _b;\n    return __awaiter(this, void 0, void 0, function*() {\n        // set default options to true\n        options !== null && options !== void 0 ? options : options = {};\n        (_a = options.audio) !== null && _a !== void 0 ? _a : options.audio = true;\n        (_b = options.video) !== null && _b !== void 0 ? _b : options.video = true;\n        const opts = mergeDefaultOptions(options, audioDefaults, videoDefaults);\n        const constraints = constraintsForOptions(opts);\n        // Keep a reference to the promise on DeviceManager and await it in getLocalDevices()\n        // works around iOS Safari Bug https://bugs.webkit.org/show_bug.cgi?id=179363\n        const mediaPromise = navigator.mediaDevices.getUserMedia(constraints);\n        if (options.audio) {\n            DeviceManager.userMediaPromiseMap.set('audioinput', mediaPromise);\n            mediaPromise.catch(()=>DeviceManager.userMediaPromiseMap.delete('audioinput'));\n        }\n        if (options.video) {\n            DeviceManager.userMediaPromiseMap.set('videoinput', mediaPromise);\n            mediaPromise.catch(()=>DeviceManager.userMediaPromiseMap.delete('videoinput'));\n        }\n        const stream = yield mediaPromise;\n        return stream.getTracks().map((mediaStreamTrack)=>{\n            const isAudio = mediaStreamTrack.kind === 'audio';\n            isAudio ? options.audio : options.video;\n            let trackConstraints;\n            const conOrBool = isAudio ? constraints.audio : constraints.video;\n            if (typeof conOrBool !== 'boolean') {\n                trackConstraints = conOrBool;\n            }\n            // update the constraints with the device id the user gave permissions to in the permission prompt\n            // otherwise each track restart (e.g. mute - unmute) will try to initialize the device again -> causing additional permission prompts\n            if (trackConstraints) {\n                trackConstraints.deviceId = mediaStreamTrack.getSettings().deviceId;\n            } else {\n                trackConstraints = {\n                    deviceId: mediaStreamTrack.getSettings().deviceId\n                };\n            }\n            const track = mediaTrackToLocalTrack(mediaStreamTrack, trackConstraints);\n            if (track.kind === Track.Kind.Video) {\n                track.source = Track.Source.Camera;\n            } else if (track.kind === Track.Kind.Audio) {\n                track.source = Track.Source.Microphone;\n            }\n            track.mediaStream = stream;\n            return track;\n        });\n    });\n}\n/**\n * Creates a [[LocalVideoTrack]] with getUserMedia()\n * @param options\n */ function createLocalVideoTrack(options) {\n    return __awaiter(this, void 0, void 0, function*() {\n        const tracks = yield createLocalTracks({\n            audio: false,\n            video: options\n        });\n        return tracks[0];\n    });\n}\nfunction createLocalAudioTrack(options) {\n    return __awaiter(this, void 0, void 0, function*() {\n        const tracks = yield createLocalTracks({\n            audio: options,\n            video: false\n        });\n        return tracks[0];\n    });\n}\n/**\n * Creates a screen capture tracks with getDisplayMedia().\n * A LocalVideoTrack is always created and returned.\n * If { audio: true }, and the browser supports audio capture, a LocalAudioTrack is also created.\n */ function createLocalScreenTracks(options) {\n    return __awaiter(this, void 0, void 0, function*() {\n        if (options === undefined) {\n            options = {};\n        }\n        if (options.resolution === undefined && !isSafari17()) {\n            options.resolution = ScreenSharePresets.h1080fps30.resolution;\n        }\n        if (navigator.mediaDevices.getDisplayMedia === undefined) {\n            throw new DeviceUnsupportedError('getDisplayMedia not supported');\n        }\n        const constraints = screenCaptureToDisplayMediaStreamOptions(options);\n        const stream = yield navigator.mediaDevices.getDisplayMedia(constraints);\n        const tracks = stream.getVideoTracks();\n        if (tracks.length === 0) {\n            throw new TrackInvalidError('no video track found');\n        }\n        const screenVideo = new LocalVideoTrack(tracks[0], undefined, false);\n        screenVideo.source = Track.Source.ScreenShare;\n        const localTracks = [\n            screenVideo\n        ];\n        if (stream.getAudioTracks().length > 0) {\n            const screenAudio = new LocalAudioTrack(stream.getAudioTracks()[0], undefined, false);\n            screenAudio.source = Track.Source.ScreenShareAudio;\n            localTracks.push(screenAudio);\n        }\n        return localTracks;\n    });\n}\nclass PublishAudioCheck extends Checker {\n    get description() {\n        return 'Can publish audio';\n    }\n    perform() {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            const room = yield this.connect();\n            const track = yield createLocalAudioTrack();\n            room.localParticipant.publishTrack(track);\n            // wait for a few seconds to publish\n            yield new Promise((resolve)=>setTimeout(resolve, 3000));\n            // verify RTC stats that it's publishing\n            const stats = yield (_a = track.sender) === null || _a === void 0 ? void 0 : _a.getStats();\n            if (!stats) {\n                throw new Error('Could not get RTCStats');\n            }\n            let numPackets = 0;\n            stats.forEach((stat)=>{\n                if (stat.type === 'outbound-rtp' && stat.mediaType === 'audio') {\n                    numPackets = stat.packetsSent;\n                }\n            });\n            if (numPackets === 0) {\n                throw new Error('Could not determine packets are sent');\n            }\n            this.appendMessage(\"published \".concat(numPackets, \" audio packets\"));\n        });\n    }\n}\nclass PublishVideoCheck extends Checker {\n    get description() {\n        return 'Can publish video';\n    }\n    perform() {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            const room = yield this.connect();\n            const track = yield createLocalVideoTrack();\n            room.localParticipant.publishTrack(track);\n            // wait for a few seconds to publish\n            yield new Promise((resolve)=>setTimeout(resolve, 3000));\n            // verify RTC stats that it's publishing\n            const stats = yield (_a = track.sender) === null || _a === void 0 ? void 0 : _a.getStats();\n            if (!stats) {\n                throw new Error('Could not get RTCStats');\n            }\n            let numPackets = 0;\n            stats.forEach((stat)=>{\n                if (stat.type === 'outbound-rtp' && stat.mediaType === 'video') {\n                    numPackets = stat.packetsSent;\n                }\n            });\n            if (numPackets === 0) {\n                throw new Error('Could not determine packets are sent');\n            }\n            this.appendMessage(\"published \".concat(numPackets, \" video packets\"));\n        });\n    }\n}\nclass ReconnectCheck extends Checker {\n    get description() {\n        return 'Resuming connection after interruption';\n    }\n    perform() {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            const room = yield this.connect();\n            let reconnectingTriggered = false;\n            let reconnected = false;\n            let reconnectResolver;\n            const reconnectTimeout = new Promise((resolve)=>{\n                setTimeout(resolve, 5000);\n                reconnectResolver = resolve;\n            });\n            room.on(RoomEvent.Reconnecting, ()=>{\n                reconnectingTriggered = true;\n            }).on(RoomEvent.Reconnected, ()=>{\n                reconnected = true;\n                reconnectResolver(true);\n            });\n            (_a = room.engine.client.ws) === null || _a === void 0 ? void 0 : _a.close();\n            const onClose = room.engine.client.onClose;\n            if (onClose) {\n                onClose('');\n            }\n            yield reconnectTimeout;\n            if (!reconnectingTriggered) {\n                throw new Error('Did not attempt to reconnect');\n            } else if (!reconnected || room.state !== ConnectionState.Connected) {\n                this.appendWarning('reconnection is only possible in Redis-based configurations');\n                throw new Error('Not able to reconnect');\n            }\n        });\n    }\n}\nclass TURNCheck extends Checker {\n    get description() {\n        return 'Can connect via TURN';\n    }\n    perform() {\n        var _a, _b;\n        return __awaiter(this, void 0, void 0, function*() {\n            const signalClient = new SignalClient();\n            const joinRes = yield signalClient.join(this.url, this.token, {\n                autoSubscribe: true,\n                maxRetries: 0,\n                e2eeEnabled: false,\n                websocketTimeout: 15000\n            });\n            let hasTLS = false;\n            let hasTURN = false;\n            let hasSTUN = false;\n            for (let iceServer of joinRes.iceServers){\n                for (let url of iceServer.urls){\n                    if (url.startsWith('turn:')) {\n                        hasTURN = true;\n                        hasSTUN = true;\n                    } else if (url.startsWith('turns:')) {\n                        hasTURN = true;\n                        hasSTUN = true;\n                        hasTLS = true;\n                    }\n                    if (url.startsWith('stun:')) {\n                        hasSTUN = true;\n                    }\n                }\n            }\n            if (!hasSTUN) {\n                this.appendWarning('No STUN servers configured on server side.');\n            } else if (hasTURN && !hasTLS) {\n                this.appendWarning('TURN is configured server side, but TURN/TLS is unavailable.');\n            }\n            yield signalClient.close();\n            if (((_b = (_a = this.connectOptions) === null || _a === void 0 ? void 0 : _a.rtcConfig) === null || _b === void 0 ? void 0 : _b.iceServers) || hasTURN) {\n                yield this.room.connect(this.url, this.token, {\n                    rtcConfig: {\n                        iceTransportPolicy: 'relay'\n                    }\n                });\n            } else {\n                this.appendWarning('No TURN servers configured.');\n                this.skip();\n                yield new Promise((resolve)=>setTimeout(resolve, 0));\n            }\n        });\n    }\n}\nclass WebRTCCheck extends Checker {\n    get description() {\n        return 'Establishing WebRTC connection';\n    }\n    perform() {\n        return __awaiter(this, void 0, void 0, function*() {\n            let hasTcp = false;\n            let hasIpv4Udp = false;\n            this.room.on(RoomEvent.SignalConnected, ()=>{\n                const prevTrickle = this.room.engine.client.onTrickle;\n                this.room.engine.client.onTrickle = (sd, target)=>{\n                    if (sd.candidate) {\n                        const candidate = new RTCIceCandidate(sd);\n                        let str = \"\".concat(candidate.protocol, \" \").concat(candidate.address, \":\").concat(candidate.port, \" \").concat(candidate.type);\n                        if (candidate.address) {\n                            if (isIPPrivate(candidate.address)) {\n                                str += ' (private)';\n                            } else {\n                                if (candidate.protocol === 'tcp' && candidate.tcpType === 'passive') {\n                                    hasTcp = true;\n                                    str += ' (passive)';\n                                } else if (candidate.protocol === 'udp') {\n                                    hasIpv4Udp = true;\n                                }\n                            }\n                        }\n                        this.appendMessage(str);\n                    }\n                    if (prevTrickle) {\n                        prevTrickle(sd, target);\n                    }\n                };\n                if (this.room.engine.pcManager) {\n                    this.room.engine.pcManager.subscriber.onIceCandidateError = (ev)=>{\n                        if (ev instanceof RTCPeerConnectionIceErrorEvent) {\n                            this.appendWarning(\"error with ICE candidate: \".concat(ev.errorCode, \" \").concat(ev.errorText, \" \").concat(ev.url));\n                        }\n                    };\n                }\n            });\n            try {\n                yield this.connect();\n                livekitLogger.info('now the room is connected');\n            } catch (err) {\n                this.appendWarning('ports need to be open on firewall in order to connect.');\n                throw err;\n            }\n            if (!hasTcp) {\n                this.appendWarning('Server is not configured for ICE/TCP');\n            }\n            if (!hasIpv4Udp) {\n                this.appendWarning('No public IPv4 UDP candidates were found. Your server is likely not configured correctly');\n            }\n        });\n    }\n}\nfunction isIPPrivate(address) {\n    const parts = address.split('.');\n    if (parts.length === 4) {\n        if (parts[0] === '10') {\n            return true;\n        } else if (parts[0] === '192' && parts[1] === '168') {\n            return true;\n        } else if (parts[0] === '172') {\n            const second = parseInt(parts[1], 10);\n            if (second >= 16 && second <= 31) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\nclass WebSocketCheck extends Checker {\n    get description() {\n        return 'Connecting to signal connection via WebSocket';\n    }\n    perform() {\n        var _a, _b, _c;\n        return __awaiter(this, void 0, void 0, function*() {\n            if (this.url.startsWith('ws:') || this.url.startsWith('http:')) {\n                this.appendWarning('Server is insecure, clients may block connections to it');\n            }\n            let signalClient = new SignalClient();\n            const joinRes = yield signalClient.join(this.url, this.token, {\n                autoSubscribe: true,\n                maxRetries: 0,\n                e2eeEnabled: false,\n                websocketTimeout: 15000\n            });\n            this.appendMessage(\"Connected to server, version \".concat(joinRes.serverVersion, \".\"));\n            if (((_a = joinRes.serverInfo) === null || _a === void 0 ? void 0 : _a.edition) === ServerInfo_Edition.Cloud && ((_b = joinRes.serverInfo) === null || _b === void 0 ? void 0 : _b.region)) {\n                this.appendMessage(\"LiveKit Cloud: \".concat((_c = joinRes.serverInfo) === null || _c === void 0 ? void 0 : _c.region));\n            }\n            yield signalClient.close();\n        });\n    }\n}\nclass ConnectionCheck extends eventsExports.EventEmitter {\n    constructor(url, token){\n        super();\n        this.checkResults = new Map();\n        this.url = url;\n        this.token = token;\n    }\n    getNextCheckId() {\n        const nextId = this.checkResults.size;\n        this.checkResults.set(nextId, {\n            logs: [],\n            status: CheckStatus.IDLE,\n            name: '',\n            description: ''\n        });\n        return nextId;\n    }\n    updateCheck(checkId, info) {\n        this.checkResults.set(checkId, info);\n        this.emit('checkUpdate', checkId, info);\n    }\n    isSuccess() {\n        return Array.from(this.checkResults.values()).every((r)=>r.status !== CheckStatus.FAILED);\n    }\n    getResults() {\n        return Array.from(this.checkResults.values());\n    }\n    createAndRunCheck(check) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const checkId = this.getNextCheckId();\n            const test = new check(this.url, this.token);\n            const handleUpdate = (info)=>{\n                this.updateCheck(checkId, info);\n            };\n            test.on('update', handleUpdate);\n            const result = yield test.run();\n            test.off('update', handleUpdate);\n            return result;\n        });\n    }\n    checkWebsocket() {\n        return __awaiter(this, void 0, void 0, function*() {\n            return this.createAndRunCheck(WebSocketCheck);\n        });\n    }\n    checkWebRTC() {\n        return __awaiter(this, void 0, void 0, function*() {\n            return this.createAndRunCheck(WebRTCCheck);\n        });\n    }\n    checkTURN() {\n        return __awaiter(this, void 0, void 0, function*() {\n            return this.createAndRunCheck(TURNCheck);\n        });\n    }\n    checkReconnect() {\n        return __awaiter(this, void 0, void 0, function*() {\n            return this.createAndRunCheck(ReconnectCheck);\n        });\n    }\n    checkPublishAudio() {\n        return __awaiter(this, void 0, void 0, function*() {\n            return this.createAndRunCheck(PublishAudioCheck);\n        });\n    }\n    checkPublishVideo() {\n        return __awaiter(this, void 0, void 0, function*() {\n            return this.createAndRunCheck(PublishVideoCheck);\n        });\n    }\n}\n/**\n * Try to analyze the local track to determine the facing mode of a track.\n *\n * @remarks\n * There is no property supported by all browsers to detect whether a video track originated from a user- or environment-facing camera device.\n * For this reason, we use the `facingMode` property when available, but will fall back on a string-based analysis of the device label to determine the facing mode.\n * If both methods fail, the default facing mode will be used.\n *\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/MediaTrackConstraints/facingMode | MDN docs on facingMode}\n * @experimental\n */ function facingModeFromLocalTrack(localTrack) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var _a;\n    const track = localTrack instanceof LocalTrack ? localTrack.mediaStreamTrack : localTrack;\n    const trackSettings = track.getSettings();\n    let result = {\n        facingMode: (_a = options.defaultFacingMode) !== null && _a !== void 0 ? _a : 'user',\n        confidence: 'low'\n    };\n    // 1. Try to get facingMode from track settings.\n    if ('facingMode' in trackSettings) {\n        const rawFacingMode = trackSettings.facingMode;\n        livekitLogger.debug('rawFacingMode', {\n            rawFacingMode\n        });\n        if (rawFacingMode && typeof rawFacingMode === 'string' && isFacingModeValue(rawFacingMode)) {\n            result = {\n                facingMode: rawFacingMode,\n                confidence: 'high'\n            };\n        }\n    }\n    // 2. If we don't have a high confidence we try to get the facing mode from the device label.\n    if ([\n        'low',\n        'medium'\n    ].includes(result.confidence)) {\n        livekitLogger.debug(\"Try to get facing mode from device label: (\".concat(track.label, \")\"));\n        const labelAnalysisResult = facingModeFromDeviceLabel(track.label);\n        if (labelAnalysisResult !== undefined) {\n            result = labelAnalysisResult;\n        }\n    }\n    return result;\n}\nconst knownDeviceLabels = new Map([\n    [\n        'obs virtual camera',\n        {\n            facingMode: 'environment',\n            confidence: 'medium'\n        }\n    ]\n]);\nconst knownDeviceLabelSections = new Map([\n    [\n        'iphone',\n        {\n            facingMode: 'environment',\n            confidence: 'medium'\n        }\n    ],\n    [\n        'ipad',\n        {\n            facingMode: 'environment',\n            confidence: 'medium'\n        }\n    ]\n]);\n/**\n * Attempt to analyze the device label to determine the facing mode.\n *\n * @experimental\n */ function facingModeFromDeviceLabel(deviceLabel) {\n    var _a;\n    const label = deviceLabel.trim().toLowerCase();\n    // Empty string is a valid device label but we can't infer anything from it.\n    if (label === '') {\n        return undefined;\n    }\n    // Can we match against widely known device labels.\n    if (knownDeviceLabels.has(label)) {\n        return knownDeviceLabels.get(label);\n    }\n    // Can we match against sections of the device label.\n    return (_a = Array.from(knownDeviceLabelSections.entries()).find((_ref)=>{\n        let [section] = _ref;\n        return label.includes(section);\n    })) === null || _a === void 0 ? void 0 : _a[1];\n}\nfunction isFacingModeValue(item) {\n    const allowedValues = [\n        'user',\n        'environment',\n        'left',\n        'right'\n    ];\n    return item === undefined || allowedValues.includes(item);\n}\n //# sourceMappingURL=livekit-client.esm.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbGl2ZWtpdC1jbGllbnQvZGlzdC9saXZla2l0LWNsaWVudC5lc20ubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0tBTVdBLFNBQUFBLElBQUksRUFBRUMsVUFBVSxFQUFFO1FBSWxCLElBQWtDQyxNQUFNLENBQUNDLE9BQU8sRUFBRTtZQUNyREQsTUFBQSxDQUFBQyxPQUFBLEdBQWlCRixVQUFVLEVBQUU7UUFDckMsQ0FBSyxNQUFNO1lBQ0hELElBQUksQ0FBQ0ksR0FBRyxHQUFHSCxVQUFVLEVBQUU7UUFDMUI7SUFDTCxDQUFDLEVBQUNJLGNBQUksRUFBRSxZQUFZO1FBR3BCO1FBQ0ksSUFBSUMsSUFBSSxHQUFHLFlBQVcsQ0FBRTtRQUN4QixJQUFJQyxhQUFhLEdBQUcsV0FBVztRQUMvQixJQUFJQyxJQUFJLEdBQUksT0FBT0MsTUFBTSxHQUFLRixhQUFhLElBQU0sT0FBT0UsTUFBTSxDQUFDQyxTQUFTLEtBQUtILGFBQWMsSUFDdkYsaUJBQWlCLENBQUNJLElBQUksQ0FBQ0YsTUFBTSxDQUFDQyxTQUFTLENBQUNFLFNBQVMsQ0FDcEQ7UUFFRCxJQUFJQyxVQUFVLEdBQUc7WUFDYixPQUFPO1lBQ1AsT0FBTztZQUNQLE1BQU07WUFDTixNQUFNO1lBQ04sT0FBTztTQUNWO1FBRUw7UUFDSSxTQUFTQyxVQUFVQSxDQUFDQyxHQUFHLEVBQUVDLFVBQVUsRUFBRTtZQUNqQyxJQUFJQyxNQUFNLEdBQUdGLEdBQUcsQ0FBQ0MsVUFBVSxDQUFDO1lBQzVCLElBQUksT0FBT0MsTUFBTSxDQUFDQyxJQUFJLEtBQUssVUFBVSxFQUFFO2dCQUNuQyxPQUFPRCxNQUFNLENBQUNDLElBQUksQ0FBQ0gsR0FBRyxDQUFDO1lBQ25DLENBQVMsTUFBTTtn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WyJEOlxcbm9kZV9tb2R1bGVzXFwucG5wbVxcbG9nbGV2ZWxAMS44LjFcXG5vZGVfbW9kdWxlc1xcbG9nbGV2ZWxcXGxpYlxcbG9nbGV2ZWwuanMiLCJEOlxcc3JjXFxsb2dnZXIudHMiLCJEOlxcbm9kZV9tb2R1bGVzXFwucG5wbVxcQGJ1ZmJ1aWxkK3Byb3RvYnVmQDEuNC4yXFxub2RlX21vZHVsZXNcXEBidWZidWlsZFxccHJvdG9idWZcXGRpc3RcXGVzbVxccHJpdmF0ZVxcYXNzZXJ0LmpzIiwiRDpcXG5vZGVfbW9kdWxlc1xcLnBucG1cXEBidWZidWlsZCtwcm90b2J1ZkAxLjQuMlxcbm9kZV9tb2R1bGVzXFxAYnVmYnVpbGRcXHByb3RvYnVmXFxkaXN0XFxlc21cXHByaXZhdGVcXGVudW0uanMiLCJEOlxcbm9kZV9tb2R1bGVzXFwucG5wbVxcQGJ1ZmJ1aWxkK3Byb3RvYnVmQDEuNC4yXFxub2RlX21vZHVsZXNcXEBidWZidWlsZFxccHJvdG9idWZcXGRpc3RcXGVzbVxcbWVzc2FnZS5qcyIsIkQ6XFxub2RlX21vZHVsZXNcXC5wbnBtXFxAYnVmYnVpbGQrcHJvdG9idWZAMS40LjJcXG5vZGVfbW9kdWxlc1xcQGJ1ZmJ1aWxkXFxwcm90b2J1ZlxcZGlzdFxcZXNtXFxwcml2YXRlXFxtZXNzYWdlLXR5cGUuanMiLCJEOlxcbm9kZV9tb2R1bGVzXFwucG5wbVxcQGJ1ZmJ1aWxkK3Byb3RvYnVmQDEuNC4yXFxub2RlX21vZHVsZXNcXEBidWZidWlsZFxccHJvdG9idWZcXGRpc3RcXGVzbVxccHJpdmF0ZVxccHJvdG8tcnVudGltZS5qcyIsIkQ6XFxub2RlX21vZHVsZXNcXC5wbnBtXFxAYnVmYnVpbGQrcHJvdG9idWZAMS40LjJcXG5vZGVfbW9kdWxlc1xcQGJ1ZmJ1aWxkXFxwcm90b2J1ZlxcZGlzdFxcZXNtXFxmaWVsZC5qcyIsIkQ6XFxub2RlX21vZHVsZXNcXC5wbnBtXFxAYnVmYnVpbGQrcHJvdG9idWZAMS40LjJcXG5vZGVfbW9kdWxlc1xcQGJ1ZmJ1aWxkXFxwcm90b2J1ZlxcZGlzdFxcZXNtXFxnb29nbGVcXHZhcmludC5qcyIsIkQ6XFxub2RlX21vZHVsZXNcXC5wbnBtXFxAYnVmYnVpbGQrcHJvdG9idWZAMS40LjJcXG5vZGVfbW9kdWxlc1xcQGJ1ZmJ1aWxkXFxwcm90b2J1ZlxcZGlzdFxcZXNtXFxwcm90by1pbnQ2NC5qcyIsIkQ6XFxub2RlX21vZHVsZXNcXC5wbnBtXFxAYnVmYnVpbGQrcHJvdG9idWZAMS40LjJcXG5vZGVfbW9kdWxlc1xcQGJ1ZmJ1aWxkXFxwcm90b2J1ZlxcZGlzdFxcZXNtXFxiaW5hcnktZW5jb2RpbmcuanMiLCJEOlxcbm9kZV9tb2R1bGVzXFwucG5wbVxcQGJ1ZmJ1aWxkK3Byb3RvYnVmQDEuNC4yXFxub2RlX21vZHVsZXNcXEBidWZidWlsZFxccHJvdG9idWZcXGRpc3RcXGVzbVxccHJpdmF0ZVxcZmllbGQtd3JhcHBlci5qcyIsIkQ6XFxub2RlX21vZHVsZXNcXC5wbnBtXFxAYnVmYnVpbGQrcHJvdG9idWZAMS40LjJcXG5vZGVfbW9kdWxlc1xcQGJ1ZmJ1aWxkXFxwcm90b2J1ZlxcZGlzdFxcZXNtXFxwcml2YXRlXFxzY2FsYXJzLmpzIiwiRDpcXG5vZGVfbW9kdWxlc1xcLnBucG1cXEBidWZidWlsZCtwcm90b2J1ZkAxLjQuMlxcbm9kZV9tb2R1bGVzXFxAYnVmYnVpbGRcXHByb3RvYnVmXFxkaXN0XFxlc21cXHByaXZhdGVcXGJpbmFyeS1mb3JtYXQtY29tbW9uLmpzIiwiRDpcXG5vZGVfbW9kdWxlc1xcLnBucG1cXEBidWZidWlsZCtwcm90b2J1ZkAxLjQuMlxcbm9kZV9tb2R1bGVzXFxAYnVmYnVpbGRcXHByb3RvYnVmXFxkaXN0XFxlc21cXHByaXZhdGVcXGJpbmFyeS1mb3JtYXQtcHJvdG8zLmpzIiwiRDpcXG5vZGVfbW9kdWxlc1xcLnBucG1cXEBidWZidWlsZCtwcm90b2J1ZkAxLjQuMlxcbm9kZV9tb2R1bGVzXFxAYnVmYnVpbGRcXHByb3RvYnVmXFxkaXN0XFxlc21cXHByb3RvLWJhc2U2NC5qcyIsIkQ6XFxub2RlX21vZHVsZXNcXC5wbnBtXFxAYnVmYnVpbGQrcHJvdG9idWZAMS40LjJcXG5vZGVfbW9kdWxlc1xcQGJ1ZmJ1aWxkXFxwcm90b2J1ZlxcZGlzdFxcZXNtXFxwcml2YXRlXFxqc29uLWZvcm1hdC1jb21tb24uanMiLCJEOlxcbm9kZV9tb2R1bGVzXFwucG5wbVxcQGJ1ZmJ1aWxkK3Byb3RvYnVmQDEuNC4yXFxub2RlX21vZHVsZXNcXEBidWZidWlsZFxccHJvdG9idWZcXGRpc3RcXGVzbVxccHJpdmF0ZVxcanNvbi1mb3JtYXQtcHJvdG8zLmpzIiwiRDpcXG5vZGVfbW9kdWxlc1xcLnBucG1cXEBidWZidWlsZCtwcm90b2J1ZkAxLjQuMlxcbm9kZV9tb2R1bGVzXFxAYnVmYnVpbGRcXHByb3RvYnVmXFxkaXN0XFxlc21cXHByaXZhdGVcXHV0aWwtY29tbW9uLmpzIiwiRDpcXG5vZGVfbW9kdWxlc1xcLnBucG1cXEBidWZidWlsZCtwcm90b2J1ZkAxLjQuMlxcbm9kZV9tb2R1bGVzXFxAYnVmYnVpbGRcXHByb3RvYnVmXFxkaXN0XFxlc21cXHByaXZhdGVcXGZpZWxkLWxpc3QuanMiLCJEOlxcbm9kZV9tb2R1bGVzXFwucG5wbVxcQGJ1ZmJ1aWxkK3Byb3RvYnVmQDEuNC4yXFxub2RlX21vZHVsZXNcXEBidWZidWlsZFxccHJvdG9idWZcXGRpc3RcXGVzbVxccHJpdmF0ZVxcbmFtZXMuanMiLCJEOlxcbm9kZV9tb2R1bGVzXFwucG5wbVxcQGJ1ZmJ1aWxkK3Byb3RvYnVmQDEuNC4yXFxub2RlX21vZHVsZXNcXEBidWZidWlsZFxccHJvdG9idWZcXGRpc3RcXGVzbVxccHJpdmF0ZVxcZmllbGQuanMiLCJEOlxcbm9kZV9tb2R1bGVzXFwucG5wbVxcQGJ1ZmJ1aWxkK3Byb3RvYnVmQDEuNC4yXFxub2RlX21vZHVsZXNcXEBidWZidWlsZFxccHJvdG9idWZcXGRpc3RcXGVzbVxccHJvdG8zLmpzIiwiRDpcXG5vZGVfbW9kdWxlc1xcLnBucG1cXEBidWZidWlsZCtwcm90b2J1ZkAxLjQuMlxcbm9kZV9tb2R1bGVzXFxAYnVmYnVpbGRcXHByb3RvYnVmXFxkaXN0XFxlc21cXGdvb2dsZVxccHJvdG9idWZcXHRpbWVzdGFtcF9wYi5qcyIsIkQ6XFxzcmNcXHByb3RvXFxsaXZla2l0X21vZGVsc19wYi50cyIsIkQ6XFxzcmNcXHJvb21cXERlZmF1bHRSZWNvbm5lY3RQb2xpY3kudHMiLCJEOlxcbm9kZV9tb2R1bGVzXFwucG5wbVxcZXZlbnRzQDMuMy4wXFxub2RlX21vZHVsZXNcXGV2ZW50c1xcZXZlbnRzLmpzIiwiRDpcXG5vZGVfbW9kdWxlc1xcLnBucG1cXHdlYnJ0Yy1hZGFwdGVyQDguMi4zXFxub2RlX21vZHVsZXNcXHdlYnJ0Yy1hZGFwdGVyXFxzcmNcXGpzXFx1dGlscy5qcyIsIkQ6XFxub2RlX21vZHVsZXNcXC5wbnBtXFx3ZWJydGMtYWRhcHRlckA4LjIuM1xcbm9kZV9tb2R1bGVzXFx3ZWJydGMtYWRhcHRlclxcc3JjXFxqc1xcY2hyb21lXFxnZXR1c2VybWVkaWEuanMiLCJEOlxcbm9kZV9tb2R1bGVzXFwucG5wbVxcd2VicnRjLWFkYXB0ZXJAOC4yLjNcXG5vZGVfbW9kdWxlc1xcd2VicnRjLWFkYXB0ZXJcXHNyY1xcanNcXGNocm9tZVxcZ2V0ZGlzcGxheW1lZGlhLmpzIiwiRDpcXG5vZGVfbW9kdWxlc1xcLnBucG1cXHdlYnJ0Yy1hZGFwdGVyQDguMi4zXFxub2RlX21vZHVsZXNcXHdlYnJ0Yy1hZGFwdGVyXFxzcmNcXGpzXFxjaHJvbWVcXGNocm9tZV9zaGltLmpzIiwiRDpcXG5vZGVfbW9kdWxlc1xcLnBucG1cXHdlYnJ0Yy1hZGFwdGVyQDguMi4zXFxub2RlX21vZHVsZXNcXHdlYnJ0Yy1hZGFwdGVyXFxzcmNcXGpzXFxmaXJlZm94XFxnZXR1c2VybWVkaWEuanMiLCJEOlxcbm9kZV9tb2R1bGVzXFwucG5wbVxcd2VicnRjLWFkYXB0ZXJAOC4yLjNcXG5vZGVfbW9kdWxlc1xcd2VicnRjLWFkYXB0ZXJcXHNyY1xcanNcXGZpcmVmb3hcXGdldGRpc3BsYXltZWRpYS5qcyIsIkQ6XFxub2RlX21vZHVsZXNcXC5wbnBtXFx3ZWJydGMtYWRhcHRlckA4LjIuM1xcbm9kZV9tb2R1bGVzXFx3ZWJydGMtYWRhcHRlclxcc3JjXFxqc1xcZmlyZWZveFxcZmlyZWZveF9zaGltLmpzIiwiRDpcXG5vZGVfbW9kdWxlc1xcLnBucG1cXHdlYnJ0Yy1hZGFwdGVyQDguMi4zXFxub2RlX21vZHVsZXNcXHdlYnJ0Yy1hZGFwdGVyXFxzcmNcXGpzXFxzYWZhcmlcXHNhZmFyaV9zaGltLmpzIiwiRDpcXG5vZGVfbW9kdWxlc1xcLnBucG1cXHNkcEAzLjIuMFxcbm9kZV9tb2R1bGVzXFxzZHBcXHNkcC5qcyIsIkQ6XFxub2RlX21vZHVsZXNcXC5wbnBtXFx3ZWJydGMtYWRhcHRlckA4LjIuM1xcbm9kZV9tb2R1bGVzXFx3ZWJydGMtYWRhcHRlclxcc3JjXFxqc1xcY29tbW9uX3NoaW0uanMiLCJEOlxcbm9kZV9tb2R1bGVzXFwucG5wbVxcd2VicnRjLWFkYXB0ZXJAOC4yLjNcXG5vZGVfbW9kdWxlc1xcd2VicnRjLWFkYXB0ZXJcXHNyY1xcanNcXGFkYXB0ZXJfZmFjdG9yeS5qcyIsIkQ6XFxub2RlX21vZHVsZXNcXC5wbnBtXFx3ZWJydGMtYWRhcHRlckA4LjIuM1xcbm9kZV9tb2R1bGVzXFx3ZWJydGMtYWRhcHRlclxcc3JjXFxqc1xcYWRhcHRlcl9jb3JlLmpzIiwiRDpcXHNyY1xcZTJlZVxcY29uc3RhbnRzLnRzIiwiRDpcXHNyY1xcZTJlZVxcZXZlbnRzLnRzIiwiRDpcXHNyY1xcZTJlZVxcdXRpbHMudHMiLCJEOlxcc3JjXFxlMmVlXFxLZXlQcm92aWRlci50cyIsIkQ6XFxzcmNcXHJvb21cXGVycm9ycy50cyIsIkQ6XFxzcmNcXHJvb21cXGV2ZW50cy50cyIsIkQ6XFxub2RlX21vZHVsZXNcXC5wbnBtXFx0cy1kZWJvdW5jZUA0LjAuMFxcbm9kZV9tb2R1bGVzXFx0cy1kZWJvdW5jZVxcZGlzdFxcc3JjXFxpbmRleC5lc20uanMiLCJEOlxcc3JjXFx1dGlsc1xcYnJvd3NlclBhcnNlci50cyIsIkQ6XFxzcmNcXHZlcnNpb24udHMiLCJEOlxcc3JjXFxyb29tXFx0aW1lcnMudHMiLCJEOlxcc3JjXFxyb29tXFx0cmFja1xcb3B0aW9ucy50cyIsIkQ6XFxzcmNcXHByb3RvXFxsaXZla2l0X3J0Y19wYi50cyIsIkQ6XFxzcmNcXHV0aWxzXFxjbG9uZURlZXAudHMiLCJEOlxcc3JjXFxyb29tXFx0cmFja1xcVHJhY2sudHMiLCJEOlxcc3JjXFxyb29tXFx0cmFja1xcdXRpbHMudHMiLCJEOlxcc3JjXFxyb29tXFx1dGlscy50cyIsIkQ6XFxzcmNcXHJvb21cXERldmljZU1hbmFnZXIudHMiLCJEOlxcc3JjXFxyb29tXFx0cmFja1xcTG9jYWxUcmFjay50cyIsIkQ6XFxzcmNcXGUyZWVcXEUyZWVNYW5hZ2VyLnRzIiwiRDpcXHNyY1xcdXRpbHNcXEFzeW5jUXVldWUudHMiLCJEOlxcc3JjXFxhcGlcXFNpZ25hbENsaWVudC50cyIsIkQ6XFxub2RlX21vZHVsZXNcXC5wbnBtXFxzZHAtdHJhbnNmb3JtQDIuMTQuMVxcbm9kZV9tb2R1bGVzXFxzZHAtdHJhbnNmb3JtXFxsaWJcXGdyYW1tYXIuanMiLCJEOlxcbm9kZV9tb2R1bGVzXFwucG5wbVxcc2RwLXRyYW5zZm9ybUAyLjE0LjFcXG5vZGVfbW9kdWxlc1xcc2RwLXRyYW5zZm9ybVxcbGliXFxwYXJzZXIuanMiLCJEOlxcbm9kZV9tb2R1bGVzXFwucG5wbVxcc2RwLXRyYW5zZm9ybUAyLjE0LjFcXG5vZGVfbW9kdWxlc1xcc2RwLXRyYW5zZm9ybVxcbGliXFx3cml0ZXIuanMiLCJEOlxcbm9kZV9tb2R1bGVzXFwucG5wbVxcc2RwLXRyYW5zZm9ybUAyLjE0LjFcXG5vZGVfbW9kdWxlc1xcc2RwLXRyYW5zZm9ybVxcbGliXFxpbmRleC5qcyIsIkQ6XFxzcmNcXHJvb21cXFBDVHJhbnNwb3J0LnRzIiwiRDpcXHNyY1xccm9vbVxcZGVmYXVsdHMudHMiLCJEOlxcc3JjXFxyb29tXFxQQ1RyYW5zcG9ydE1hbmFnZXIudHMiLCJEOlxcc3JjXFxyb29tXFxSVENFbmdpbmUudHMiLCJEOlxcc3JjXFxyb29tXFxSZWdpb25VcmxQcm92aWRlci50cyIsIkQ6XFxzcmNcXHJvb21cXHN0YXRzLnRzIiwiRDpcXHNyY1xccm9vbVxcdHJhY2tcXExvY2FsQXVkaW9UcmFjay50cyIsIkQ6XFxzcmNcXHJvb21cXHBhcnRpY2lwYW50XFxwdWJsaXNoVXRpbHMudHMiLCJEOlxcc3JjXFxyb29tXFx0cmFja1xcTG9jYWxWaWRlb1RyYWNrLnRzIiwiRDpcXHNyY1xccm9vbVxcdHJhY2tcXFJlbW90ZVRyYWNrLnRzIiwiRDpcXHNyY1xccm9vbVxcdHJhY2tcXFJlbW90ZUF1ZGlvVHJhY2sudHMiLCJEOlxcc3JjXFxyb29tXFx0cmFja1xcUmVtb3RlVmlkZW9UcmFjay50cyIsIkQ6XFxzcmNcXHJvb21cXHRyYWNrXFxUcmFja1B1YmxpY2F0aW9uLnRzIiwiRDpcXHNyY1xccm9vbVxcdHJhY2tcXExvY2FsVHJhY2tQdWJsaWNhdGlvbi50cyIsIkQ6XFxzcmNcXHJvb21cXHBhcnRpY2lwYW50XFxQYXJ0aWNpcGFudC50cyIsIkQ6XFxzcmNcXHJvb21cXHBhcnRpY2lwYW50XFxQYXJ0aWNpcGFudFRyYWNrUGVybWlzc2lvbi50cyIsIkQ6XFxzcmNcXHJvb21cXHRyYWNrXFxSZW1vdGVUcmFja1B1YmxpY2F0aW9uLnRzIiwiRDpcXHNyY1xccm9vbVxccGFydGljaXBhbnRcXFJlbW90ZVBhcnRpY2lwYW50LnRzIiwiRDpcXHNyY1xccm9vbVxccGFydGljaXBhbnRcXExvY2FsUGFydGljaXBhbnQudHMiLCJEOlxcc3JjXFxyb29tXFxSb29tLnRzIiwiRDpcXHNyY1xcY29ubmVjdGlvbkhlbHBlclxcY2hlY2tzXFxDaGVja2VyLnRzIiwiRDpcXHNyY1xccm9vbVxcdHJhY2tcXGNyZWF0ZS50cyIsIkQ6XFxzcmNcXGNvbm5lY3Rpb25IZWxwZXJcXGNoZWNrc1xccHVibGlzaEF1ZGlvLnRzIiwiRDpcXHNyY1xcY29ubmVjdGlvbkhlbHBlclxcY2hlY2tzXFxwdWJsaXNoVmlkZW8udHMiLCJEOlxcc3JjXFxjb25uZWN0aW9uSGVscGVyXFxjaGVja3NcXHJlY29ubmVjdC50cyIsIkQ6XFxzcmNcXGNvbm5lY3Rpb25IZWxwZXJcXGNoZWNrc1xcdHVybi50cyIsIkQ6XFxzcmNcXGNvbm5lY3Rpb25IZWxwZXJcXGNoZWNrc1xcd2VicnRjLnRzIiwiRDpcXHNyY1xcY29ubmVjdGlvbkhlbHBlclxcY2hlY2tzXFx3ZWJzb2NrZXQudHMiLCJEOlxcc3JjXFxjb25uZWN0aW9uSGVscGVyXFxDb25uZWN0aW9uQ2hlY2sudHMiLCJEOlxcc3JjXFxyb29tXFx0cmFja1xcZmFjaW5nTW9kZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuKiBsb2dsZXZlbCAtIGh0dHBzOi8vZ2l0aHViLmNvbS9waW10ZXJyeS9sb2dsZXZlbFxuKlxuKiBDb3B5cmlnaHQgKGMpIDIwMTMgVGltIFBlcnJ5XG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbiovXG4oZnVuY3Rpb24gKHJvb3QsIGRlZmluaXRpb24pIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICAgIGRlZmluZShkZWZpbml0aW9uKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gZGVmaW5pdGlvbigpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJvb3QubG9nID0gZGVmaW5pdGlvbigpO1xuICAgIH1cbn0odGhpcywgZnVuY3Rpb24gKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgLy8gU2xpZ2h0bHkgZHViaW91cyB0cmlja3MgdG8gY3V0IGRvd24gbWluaW1pemVkIGZpbGUgc2l6ZVxuICAgIHZhciBub29wID0gZnVuY3Rpb24oKSB7fTtcbiAgICB2YXIgdW5kZWZpbmVkVHlwZSA9IFwidW5kZWZpbmVkXCI7XG4gICAgdmFyIGlzSUUgPSAodHlwZW9mIHdpbmRvdyAhPT0gdW5kZWZpbmVkVHlwZSkgJiYgKHR5cGVvZiB3aW5kb3cubmF2aWdhdG9yICE9PSB1bmRlZmluZWRUeXBlKSAmJiAoXG4gICAgICAgIC9UcmlkZW50XFwvfE1TSUUgLy50ZXN0KHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50KVxuICAgICk7XG5cbiAgICB2YXIgbG9nTWV0aG9kcyA9IFtcbiAgICAgICAgXCJ0cmFjZVwiLFxuICAgICAgICBcImRlYnVnXCIsXG4gICAgICAgIFwiaW5mb1wiLFxuICAgICAgICBcIndhcm5cIixcbiAgICAgICAgXCJlcnJvclwiXG4gICAgXTtcblxuICAgIC8vIENyb3NzLWJyb3dzZXIgYmluZCBlcXVpdmFsZW50IHRoYXQgd29ya3MgYXQgbGVhc3QgYmFjayB0byBJRTZcbiAgICBmdW5jdGlvbiBiaW5kTWV0aG9kKG9iaiwgbWV0aG9kTmFtZSkge1xuICAgICAgICB2YXIgbWV0aG9kID0gb2JqW21ldGhvZE5hbWVdO1xuICAgICAgICBpZiAodHlwZW9mIG1ldGhvZC5iaW5kID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXR1cm4gbWV0aG9kLmJpbmQob2JqKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLmNhbGwobWV0aG9kLCBvYmopO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIC8vIE1pc3NpbmcgYmluZCBzaGltIG9yIElFOCArIE1vZGVybml6ciwgZmFsbGJhY2sgdG8gd3JhcHBpbmdcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuYXBwbHkobWV0aG9kLCBbb2JqLCBhcmd1bWVudHNdKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gVHJhY2UoKSBkb2Vzbid0IHByaW50IHRoZSBtZXNzYWdlIGluIElFLCBzbyBmb3IgdGhhdCBjYXNlIHdlIG5lZWQgdG8gd3JhcCBpdFxuICAgIGZ1bmN0aW9uIHRyYWNlRm9ySUUoKSB7XG4gICAgICAgIGlmIChjb25zb2xlLmxvZykge1xuICAgICAgICAgICAgaWYgKGNvbnNvbGUubG9nLmFwcGx5KSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2cuYXBwbHkoY29uc29sZSwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gSW4gb2xkIElFLCBuYXRpdmUgY29uc29sZSBtZXRob2RzIHRoZW1zZWx2ZXMgZG9uJ3QgaGF2ZSBhcHBseSgpLlxuICAgICAgICAgICAgICAgIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5hcHBseShjb25zb2xlLmxvZywgW2NvbnNvbGUsIGFyZ3VtZW50c10pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjb25zb2xlLnRyYWNlKSBjb25zb2xlLnRyYWNlKCk7XG4gICAgfVxuXG4gICAgLy8gQnVpbGQgdGhlIGJlc3QgbG9nZ2luZyBtZXRob2QgcG9zc2libGUgZm9yIHRoaXMgZW52XG4gICAgLy8gV2hlcmV2ZXIgcG9zc2libGUgd2Ugd2FudCB0byBiaW5kLCBub3Qgd3JhcCwgdG8gcHJlc2VydmUgc3RhY2sgdHJhY2VzXG4gICAgZnVuY3Rpb24gcmVhbE1ldGhvZChtZXRob2ROYW1lKSB7XG4gICAgICAgIGlmIChtZXRob2ROYW1lID09PSAnZGVidWcnKSB7XG4gICAgICAgICAgICBtZXRob2ROYW1lID0gJ2xvZyc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgPT09IHVuZGVmaW5lZFR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gTm8gbWV0aG9kIHBvc3NpYmxlLCBmb3Igbm93IC0gZml4ZWQgbGF0ZXIgYnkgZW5hYmxlTG9nZ2luZ1doZW5Db25zb2xlQXJyaXZlc1xuICAgICAgICB9IGVsc2UgaWYgKG1ldGhvZE5hbWUgPT09ICd0cmFjZScgJiYgaXNJRSkge1xuICAgICAgICAgICAgcmV0dXJuIHRyYWNlRm9ySUU7XG4gICAgICAgIH0gZWxzZSBpZiAoY29uc29sZVttZXRob2ROYW1lXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gYmluZE1ldGhvZChjb25zb2xlLCBtZXRob2ROYW1lKTtcbiAgICAgICAgfSBlbHNlIGlmIChjb25zb2xlLmxvZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gYmluZE1ldGhvZChjb25zb2xlLCAnbG9nJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbm9vcDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRoZXNlIHByaXZhdGUgZnVuY3Rpb25zIGFsd2F5cyBuZWVkIGB0aGlzYCB0byBiZSBzZXQgcHJvcGVybHlcblxuICAgIGZ1bmN0aW9uIHJlcGxhY2VMb2dnaW5nTWV0aG9kcyhsZXZlbCwgbG9nZ2VyTmFtZSkge1xuICAgICAgICAvKmpzaGludCB2YWxpZHRoaXM6dHJ1ZSAqL1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxvZ01ldGhvZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBtZXRob2ROYW1lID0gbG9nTWV0aG9kc1tpXTtcbiAgICAgICAgICAgIHRoaXNbbWV0aG9kTmFtZV0gPSAoaSA8IGxldmVsKSA/XG4gICAgICAgICAgICAgICAgbm9vcCA6XG4gICAgICAgICAgICAgICAgdGhpcy5tZXRob2RGYWN0b3J5KG1ldGhvZE5hbWUsIGxldmVsLCBsb2dnZXJOYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERlZmluZSBsb2cubG9nIGFzIGFuIGFsaWFzIGZvciBsb2cuZGVidWdcbiAgICAgICAgdGhpcy5sb2cgPSB0aGlzLmRlYnVnO1xuICAgIH1cblxuICAgIC8vIEluIG9sZCBJRSB2ZXJzaW9ucywgdGhlIGNvbnNvbGUgaXNuJ3QgcHJlc2VudCB1bnRpbCB5b3UgZmlyc3Qgb3BlbiBpdC5cbiAgICAvLyBXZSBidWlsZCByZWFsTWV0aG9kKCkgcmVwbGFjZW1lbnRzIGhlcmUgdGhhdCByZWdlbmVyYXRlIGxvZ2dpbmcgbWV0aG9kc1xuICAgIGZ1bmN0aW9uIGVuYWJsZUxvZ2dpbmdXaGVuQ29uc29sZUFycml2ZXMobWV0aG9kTmFtZSwgbGV2ZWwsIGxvZ2dlck5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gdW5kZWZpbmVkVHlwZSkge1xuICAgICAgICAgICAgICAgIHJlcGxhY2VMb2dnaW5nTWV0aG9kcy5jYWxsKHRoaXMsIGxldmVsLCBsb2dnZXJOYW1lKTtcbiAgICAgICAgICAgICAgICB0aGlzW21ldGhvZE5hbWVdLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gQnkgZGVmYXVsdCwgd2UgdXNlIGNsb3NlbHkgYm91bmQgcmVhbCBtZXRob2RzIHdoZXJldmVyIHBvc3NpYmxlLCBhbmRcbiAgICAvLyBvdGhlcndpc2Ugd2Ugd2FpdCBmb3IgYSBjb25zb2xlIHRvIGFwcGVhciwgYW5kIHRoZW4gdHJ5IGFnYWluLlxuICAgIGZ1bmN0aW9uIGRlZmF1bHRNZXRob2RGYWN0b3J5KG1ldGhvZE5hbWUsIGxldmVsLCBsb2dnZXJOYW1lKSB7XG4gICAgICAgIC8qanNoaW50IHZhbGlkdGhpczp0cnVlICovXG4gICAgICAgIHJldHVybiByZWFsTWV0aG9kKG1ldGhvZE5hbWUpIHx8XG4gICAgICAgICAgICAgICBlbmFibGVMb2dnaW5nV2hlbkNvbnNvbGVBcnJpdmVzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gTG9nZ2VyKG5hbWUsIGRlZmF1bHRMZXZlbCwgZmFjdG9yeSkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIGN1cnJlbnRMZXZlbDtcbiAgICAgIGRlZmF1bHRMZXZlbCA9IGRlZmF1bHRMZXZlbCA9PSBudWxsID8gXCJXQVJOXCIgOiBkZWZhdWx0TGV2ZWw7XG5cbiAgICAgIHZhciBzdG9yYWdlS2V5ID0gXCJsb2dsZXZlbFwiO1xuICAgICAgaWYgKHR5cGVvZiBuYW1lID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHN0b3JhZ2VLZXkgKz0gXCI6XCIgKyBuYW1lO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbmFtZSA9PT0gXCJzeW1ib2xcIikge1xuICAgICAgICBzdG9yYWdlS2V5ID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBwZXJzaXN0TGV2ZWxJZlBvc3NpYmxlKGxldmVsTnVtKSB7XG4gICAgICAgICAgdmFyIGxldmVsTmFtZSA9IChsb2dNZXRob2RzW2xldmVsTnVtXSB8fCAnc2lsZW50JykudG9VcHBlckNhc2UoKTtcblxuICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSB1bmRlZmluZWRUeXBlIHx8ICFzdG9yYWdlS2V5KSByZXR1cm47XG5cbiAgICAgICAgICAvLyBVc2UgbG9jYWxTdG9yYWdlIGlmIGF2YWlsYWJsZVxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHdpbmRvdy5sb2NhbFN0b3JhZ2Vbc3RvcmFnZUtleV0gPSBsZXZlbE5hbWU7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9IGNhdGNoIChpZ25vcmUpIHt9XG5cbiAgICAgICAgICAvLyBVc2Ugc2Vzc2lvbiBjb29raWUgYXMgZmFsbGJhY2tcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICB3aW5kb3cuZG9jdW1lbnQuY29va2llID1cbiAgICAgICAgICAgICAgICBlbmNvZGVVUklDb21wb25lbnQoc3RvcmFnZUtleSkgKyBcIj1cIiArIGxldmVsTmFtZSArIFwiO1wiO1xuICAgICAgICAgIH0gY2F0Y2ggKGlnbm9yZSkge31cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZ2V0UGVyc2lzdGVkTGV2ZWwoKSB7XG4gICAgICAgICAgdmFyIHN0b3JlZExldmVsO1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IHVuZGVmaW5lZFR5cGUgfHwgIXN0b3JhZ2VLZXkpIHJldHVybjtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHN0b3JlZExldmVsID0gd2luZG93LmxvY2FsU3RvcmFnZVtzdG9yYWdlS2V5XTtcbiAgICAgICAgICB9IGNhdGNoIChpZ25vcmUpIHt9XG5cbiAgICAgICAgICAvLyBGYWxsYmFjayB0byBjb29raWVzIGlmIGxvY2FsIHN0b3JhZ2UgZ2l2ZXMgdXMgbm90aGluZ1xuICAgICAgICAgIGlmICh0eXBlb2Ygc3RvcmVkTGV2ZWwgPT09IHVuZGVmaW5lZFR5cGUpIHtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIHZhciBjb29raWUgPSB3aW5kb3cuZG9jdW1lbnQuY29va2llO1xuICAgICAgICAgICAgICAgICAgdmFyIGxvY2F0aW9uID0gY29va2llLmluZGV4T2YoXG4gICAgICAgICAgICAgICAgICAgICAgZW5jb2RlVVJJQ29tcG9uZW50KHN0b3JhZ2VLZXkpICsgXCI9XCIpO1xuICAgICAgICAgICAgICAgICAgaWYgKGxvY2F0aW9uICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgIHN0b3JlZExldmVsID0gL14oW147XSspLy5leGVjKGNvb2tpZS5zbGljZShsb2NhdGlvbikpWzFdO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGNhdGNoIChpZ25vcmUpIHt9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gSWYgdGhlIHN0b3JlZCBsZXZlbCBpcyBub3QgdmFsaWQsIHRyZWF0IGl0IGFzIGlmIG5vdGhpbmcgd2FzIHN0b3JlZC5cbiAgICAgICAgICBpZiAoc2VsZi5sZXZlbHNbc3RvcmVkTGV2ZWxdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgc3RvcmVkTGV2ZWwgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHN0b3JlZExldmVsO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBjbGVhclBlcnNpc3RlZExldmVsKCkge1xuICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSB1bmRlZmluZWRUeXBlIHx8ICFzdG9yYWdlS2V5KSByZXR1cm47XG5cbiAgICAgICAgICAvLyBVc2UgbG9jYWxTdG9yYWdlIGlmIGF2YWlsYWJsZVxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHdpbmRvdy5sb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShzdG9yYWdlS2V5KTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH0gY2F0Y2ggKGlnbm9yZSkge31cblxuICAgICAgICAgIC8vIFVzZSBzZXNzaW9uIGNvb2tpZSBhcyBmYWxsYmFja1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHdpbmRvdy5kb2N1bWVudC5jb29raWUgPVxuICAgICAgICAgICAgICAgIGVuY29kZVVSSUNvbXBvbmVudChzdG9yYWdlS2V5KSArIFwiPTsgZXhwaXJlcz1UaHUsIDAxIEphbiAxOTcwIDAwOjAwOjAwIFVUQ1wiO1xuICAgICAgICAgIH0gY2F0Y2ggKGlnbm9yZSkge31cbiAgICAgIH1cblxuICAgICAgLypcbiAgICAgICAqXG4gICAgICAgKiBQdWJsaWMgbG9nZ2VyIEFQSSAtIHNlZSBodHRwczovL2dpdGh1Yi5jb20vcGltdGVycnkvbG9nbGV2ZWwgZm9yIGRldGFpbHNcbiAgICAgICAqXG4gICAgICAgKi9cblxuICAgICAgc2VsZi5uYW1lID0gbmFtZTtcblxuICAgICAgc2VsZi5sZXZlbHMgPSB7IFwiVFJBQ0VcIjogMCwgXCJERUJVR1wiOiAxLCBcIklORk9cIjogMiwgXCJXQVJOXCI6IDMsXG4gICAgICAgICAgXCJFUlJPUlwiOiA0LCBcIlNJTEVOVFwiOiA1fTtcblxuICAgICAgc2VsZi5tZXRob2RGYWN0b3J5ID0gZmFjdG9yeSB8fCBkZWZhdWx0TWV0aG9kRmFjdG9yeTtcblxuICAgICAgc2VsZi5nZXRMZXZlbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gY3VycmVudExldmVsO1xuICAgICAgfTtcblxuICAgICAgc2VsZi5zZXRMZXZlbCA9IGZ1bmN0aW9uIChsZXZlbCwgcGVyc2lzdCkge1xuICAgICAgICAgIGlmICh0eXBlb2YgbGV2ZWwgPT09IFwic3RyaW5nXCIgJiYgc2VsZi5sZXZlbHNbbGV2ZWwudG9VcHBlckNhc2UoKV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBsZXZlbCA9IHNlbGYubGV2ZWxzW2xldmVsLnRvVXBwZXJDYXNlKCldO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodHlwZW9mIGxldmVsID09PSBcIm51bWJlclwiICYmIGxldmVsID49IDAgJiYgbGV2ZWwgPD0gc2VsZi5sZXZlbHMuU0lMRU5UKSB7XG4gICAgICAgICAgICAgIGN1cnJlbnRMZXZlbCA9IGxldmVsO1xuICAgICAgICAgICAgICBpZiAocGVyc2lzdCAhPT0gZmFsc2UpIHsgIC8vIGRlZmF1bHRzIHRvIHRydWVcbiAgICAgICAgICAgICAgICAgIHBlcnNpc3RMZXZlbElmUG9zc2libGUobGV2ZWwpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJlcGxhY2VMb2dnaW5nTWV0aG9kcy5jYWxsKHNlbGYsIGxldmVsLCBuYW1lKTtcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlID09PSB1bmRlZmluZWRUeXBlICYmIGxldmVsIDwgc2VsZi5sZXZlbHMuU0lMRU5UKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gXCJObyBjb25zb2xlIGF2YWlsYWJsZSBmb3IgbG9nZ2luZ1wiO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhyb3cgXCJsb2cuc2V0TGV2ZWwoKSBjYWxsZWQgd2l0aCBpbnZhbGlkIGxldmVsOiBcIiArIGxldmVsO1xuICAgICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHNlbGYuc2V0RGVmYXVsdExldmVsID0gZnVuY3Rpb24gKGxldmVsKSB7XG4gICAgICAgICAgZGVmYXVsdExldmVsID0gbGV2ZWw7XG4gICAgICAgICAgaWYgKCFnZXRQZXJzaXN0ZWRMZXZlbCgpKSB7XG4gICAgICAgICAgICAgIHNlbGYuc2V0TGV2ZWwobGV2ZWwsIGZhbHNlKTtcbiAgICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBzZWxmLnJlc2V0TGV2ZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgc2VsZi5zZXRMZXZlbChkZWZhdWx0TGV2ZWwsIGZhbHNlKTtcbiAgICAgICAgICBjbGVhclBlcnNpc3RlZExldmVsKCk7XG4gICAgICB9O1xuXG4gICAgICBzZWxmLmVuYWJsZUFsbCA9IGZ1bmN0aW9uKHBlcnNpc3QpIHtcbiAgICAgICAgICBzZWxmLnNldExldmVsKHNlbGYubGV2ZWxzLlRSQUNFLCBwZXJzaXN0KTtcbiAgICAgIH07XG5cbiAgICAgIHNlbGYuZGlzYWJsZUFsbCA9IGZ1bmN0aW9uKHBlcnNpc3QpIHtcbiAgICAgICAgICBzZWxmLnNldExldmVsKHNlbGYubGV2ZWxzLlNJTEVOVCwgcGVyc2lzdCk7XG4gICAgICB9O1xuXG4gICAgICAvLyBJbml0aWFsaXplIHdpdGggdGhlIHJpZ2h0IGxldmVsXG4gICAgICB2YXIgaW5pdGlhbExldmVsID0gZ2V0UGVyc2lzdGVkTGV2ZWwoKTtcbiAgICAgIGlmIChpbml0aWFsTGV2ZWwgPT0gbnVsbCkge1xuICAgICAgICAgIGluaXRpYWxMZXZlbCA9IGRlZmF1bHRMZXZlbDtcbiAgICAgIH1cbiAgICAgIHNlbGYuc2V0TGV2ZWwoaW5pdGlhbExldmVsLCBmYWxzZSk7XG4gICAgfVxuXG4gICAgLypcbiAgICAgKlxuICAgICAqIFRvcC1sZXZlbCBBUElcbiAgICAgKlxuICAgICAqL1xuXG4gICAgdmFyIGRlZmF1bHRMb2dnZXIgPSBuZXcgTG9nZ2VyKCk7XG5cbiAgICB2YXIgX2xvZ2dlcnNCeU5hbWUgPSB7fTtcbiAgICBkZWZhdWx0TG9nZ2VyLmdldExvZ2dlciA9IGZ1bmN0aW9uIGdldExvZ2dlcihuYW1lKSB7XG4gICAgICAgIGlmICgodHlwZW9mIG5hbWUgIT09IFwic3ltYm9sXCIgJiYgdHlwZW9mIG5hbWUgIT09IFwic3RyaW5nXCIpIHx8IG5hbWUgPT09IFwiXCIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiWW91IG11c3Qgc3VwcGx5IGEgbmFtZSB3aGVuIGNyZWF0aW5nIGEgbG9nZ2VyLlwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsb2dnZXIgPSBfbG9nZ2Vyc0J5TmFtZVtuYW1lXTtcbiAgICAgICAgaWYgKCFsb2dnZXIpIHtcbiAgICAgICAgICBsb2dnZXIgPSBfbG9nZ2Vyc0J5TmFtZVtuYW1lXSA9IG5ldyBMb2dnZXIoXG4gICAgICAgICAgICBuYW1lLCBkZWZhdWx0TG9nZ2VyLmdldExldmVsKCksIGRlZmF1bHRMb2dnZXIubWV0aG9kRmFjdG9yeSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxvZ2dlcjtcbiAgICB9O1xuXG4gICAgLy8gR3JhYiB0aGUgY3VycmVudCBnbG9iYWwgbG9nIHZhcmlhYmxlIGluIGNhc2Ugb2Ygb3ZlcndyaXRlXG4gICAgdmFyIF9sb2cgPSAodHlwZW9mIHdpbmRvdyAhPT0gdW5kZWZpbmVkVHlwZSkgPyB3aW5kb3cubG9nIDogdW5kZWZpbmVkO1xuICAgIGRlZmF1bHRMb2dnZXIubm9Db25mbGljdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gdW5kZWZpbmVkVHlwZSAmJlxuICAgICAgICAgICAgICAgd2luZG93LmxvZyA9PT0gZGVmYXVsdExvZ2dlcikge1xuICAgICAgICAgICAgd2luZG93LmxvZyA9IF9sb2c7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGVmYXVsdExvZ2dlcjtcbiAgICB9O1xuXG4gICAgZGVmYXVsdExvZ2dlci5nZXRMb2dnZXJzID0gZnVuY3Rpb24gZ2V0TG9nZ2VycygpIHtcbiAgICAgICAgcmV0dXJuIF9sb2dnZXJzQnlOYW1lO1xuICAgIH07XG5cbiAgICAvLyBFUzYgZGVmYXVsdCBleHBvcnQsIGZvciBjb21wYXRpYmlsaXR5XG4gICAgZGVmYXVsdExvZ2dlclsnZGVmYXVsdCddID0gZGVmYXVsdExvZ2dlcjtcblxuICAgIHJldHVybiBkZWZhdWx0TG9nZ2VyO1xufSkpO1xuIiwiaW1wb3J0ICogYXMgbG9nIGZyb20gJ2xvZ2xldmVsJztcblxuZXhwb3J0IGVudW0gTG9nTGV2ZWwge1xuICB0cmFjZSA9IDAsXG4gIGRlYnVnID0gMSxcbiAgaW5mbyA9IDIsXG4gIHdhcm4gPSAzLFxuICBlcnJvciA9IDQsXG4gIHNpbGVudCA9IDUsXG59XG5cbmV4cG9ydCBlbnVtIExvZ2dlck5hbWVzIHtcbiAgRGVmYXVsdCA9ICdsaXZla2l0JyxcbiAgUm9vbSA9ICdsaXZla2l0LXJvb20nLFxuICBQYXJ0aWNpcGFudCA9ICdsaXZla2l0LXBhcnRpY2lwYW50JyxcbiAgVHJhY2sgPSAnbGl2ZWtpdC10cmFjaycsXG4gIFB1YmxpY2F0aW9uID0gJ2xpdmVraXQtdHJhY2stcHVibGljYXRpb24nLFxuICBFbmdpbmUgPSAnbGl2ZWtpdC1lbmdpbmUnLFxuICBTaWduYWwgPSAnbGl2ZWtpdC1zaWduYWwnLFxuICBQQ01hbmFnZXIgPSAnbGl2ZWtpdC1wYy1tYW5hZ2VyJyxcbiAgUENUcmFuc3BvcnQgPSAnbGl2ZWtpdC1wYy10cmFuc3BvcnQnLFxuICBFMkVFID0gJ2xrLWUyZWUnLFxufVxuXG50eXBlIExvZ0xldmVsU3RyaW5nID0ga2V5b2YgdHlwZW9mIExvZ0xldmVsO1xuXG5leHBvcnQgdHlwZSBTdHJ1Y3R1cmVkTG9nZ2VyID0ge1xuICB0cmFjZTogKG1zZzogc3RyaW5nLCBjb250ZXh0Pzogb2JqZWN0KSA9PiB2b2lkO1xuICBkZWJ1ZzogKG1zZzogc3RyaW5nLCBjb250ZXh0Pzogb2JqZWN0KSA9PiB2b2lkO1xuICBpbmZvOiAobXNnOiBzdHJpbmcsIGNvbnRleHQ/OiBvYmplY3QpID0+IHZvaWQ7XG4gIHdhcm46IChtc2c6IHN0cmluZywgY29udGV4dD86IG9iamVjdCkgPT4gdm9pZDtcbiAgZXJyb3I6IChtc2c6IHN0cmluZywgY29udGV4dD86IG9iamVjdCkgPT4gdm9pZDtcbiAgc2V0RGVmYXVsdExldmVsOiAobGV2ZWw6IGxvZy5Mb2dMZXZlbERlc2MpID0+IHZvaWQ7XG59O1xuXG5sZXQgbGl2ZWtpdExvZ2dlciA9IGxvZy5nZXRMb2dnZXIoJ2xpdmVraXQnKTtcblxubGl2ZWtpdExvZ2dlci5zZXREZWZhdWx0TGV2ZWwoTG9nTGV2ZWwuaW5mbyk7XG5cbmV4cG9ydCBkZWZhdWx0IGxpdmVraXRMb2dnZXIgYXMgU3RydWN0dXJlZExvZ2dlcjtcblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldExvZ2dlcihuYW1lOiBzdHJpbmcpIHtcbiAgY29uc3QgbG9nZ2VyID0gbG9nLmdldExvZ2dlcihuYW1lKTtcbiAgbG9nZ2VyLnNldERlZmF1bHRMZXZlbChsaXZla2l0TG9nZ2VyLmdldExldmVsKCkpO1xuICByZXR1cm4gbG9nZ2VyIGFzIFN0cnVjdHVyZWRMb2dnZXI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXRMb2dMZXZlbChsZXZlbDogTG9nTGV2ZWwgfCBMb2dMZXZlbFN0cmluZywgbG9nZ2VyTmFtZT86IExvZ2dlck5hbWVzKSB7XG4gIGlmIChsb2dnZXJOYW1lKSB7XG4gICAgbG9nLmdldExvZ2dlcihsb2dnZXJOYW1lKS5zZXRMZXZlbChsZXZlbCk7XG4gIH1cbiAgZm9yIChjb25zdCBsb2dnZXIgb2YgT2JqZWN0LmVudHJpZXMobG9nLmdldExvZ2dlcnMoKSlcbiAgICAuZmlsdGVyKChbbG9nck5hbWVdKSA9PiBsb2dyTmFtZS5zdGFydHNXaXRoKCdsaXZla2l0JykpXG4gICAgLm1hcCgoWywgbG9ncl0pID0+IGxvZ3IpKSB7XG4gICAgbG9nZ2VyLnNldExldmVsKGxldmVsKTtcbiAgfVxufVxuXG5leHBvcnQgdHlwZSBMb2dFeHRlbnNpb24gPSAobGV2ZWw6IExvZ0xldmVsLCBtc2c6IHN0cmluZywgY29udGV4dD86IG9iamVjdCkgPT4gdm9pZDtcblxuLyoqXG4gKiB1c2UgdGhpcyB0byBob29rIGludG8gdGhlIGxvZ2dpbmcgZnVuY3Rpb24gdG8gYWxsb3cgc2VuZGluZyBpbnRlcm5hbCBsaXZla2l0IGxvZ3MgdG8gdGhpcmQgcGFydHkgc2VydmljZXNcbiAqIGlmIHNldCwgdGhlIGJyb3dzZXIgbG9ncyB3aWxsIGxvc2UgdGhlaXIgc3RhY2t0cmFjZSBpbmZvcm1hdGlvbiAoc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9waW10ZXJyeS9sb2dsZXZlbCN3cml0aW5nLXBsdWdpbnMpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRMb2dFeHRlbnNpb24oZXh0ZW5zaW9uOiBMb2dFeHRlbnNpb24sIGxvZ2dlciA9IGxpdmVraXRMb2dnZXIpIHtcbiAgY29uc3Qgb3JpZ2luYWxGYWN0b3J5ID0gbG9nZ2VyLm1ldGhvZEZhY3Rvcnk7XG5cbiAgbG9nZ2VyLm1ldGhvZEZhY3RvcnkgPSAobWV0aG9kTmFtZSwgY29uZmlnTGV2ZWwsIGxvZ2dlck5hbWUpID0+IHtcbiAgICBjb25zdCByYXdNZXRob2QgPSBvcmlnaW5hbEZhY3RvcnkobWV0aG9kTmFtZSwgY29uZmlnTGV2ZWwsIGxvZ2dlck5hbWUpO1xuXG4gICAgY29uc3QgbG9nTGV2ZWwgPSBMb2dMZXZlbFttZXRob2ROYW1lIGFzIExvZ0xldmVsU3RyaW5nXTtcbiAgICBjb25zdCBuZWVkTG9nID0gbG9nTGV2ZWwgPj0gY29uZmlnTGV2ZWwgJiYgbG9nTGV2ZWwgPCBMb2dMZXZlbC5zaWxlbnQ7XG5cbiAgICByZXR1cm4gKG1zZywgY29udGV4dD86IFttc2c6IHN0cmluZywgY29udGV4dDogb2JqZWN0XSkgPT4ge1xuICAgICAgaWYgKGNvbnRleHQpIHJhd01ldGhvZChtc2csIGNvbnRleHQpO1xuICAgICAgZWxzZSByYXdNZXRob2QobXNnKTtcbiAgICAgIGlmIChuZWVkTG9nKSB7XG4gICAgICAgIGV4dGVuc2lvbihsb2dMZXZlbCwgbXNnLCBjb250ZXh0KTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xuICBsb2dnZXIuc2V0TGV2ZWwobG9nZ2VyLmdldExldmVsKCkpOyAvLyBCZSBzdXJlIHRvIGNhbGwgc2V0TGV2ZWwgbWV0aG9kIGluIG9yZGVyIHRvIGFwcGx5IHBsdWdpblxufVxuXG5leHBvcnQgY29uc3Qgd29ya2VyTG9nZ2VyID0gbG9nLmdldExvZ2dlcignbGstZTJlZScpIGFzIFN0cnVjdHVyZWRMb2dnZXI7XG4iLCIvLyBDb3B5cmlnaHQgMjAyMS0yMDIzIEJ1ZiBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuLyoqXG4gKiBBc3NlcnQgdGhhdCBjb25kaXRpb24gaXMgdHJ1dGh5IG9yIHRocm93IGVycm9yICh3aXRoIG1lc3NhZ2UpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnQoY29uZGl0aW9uLCBtc2cpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3N0cmljdC1ib29sZWFuLWV4cHJlc3Npb25zIC0tIHdlIHdhbnQgdGhlIGltcGxpY2l0IGNvbnZlcnNpb24gdG8gYm9vbGVhblxuICAgIGlmICghY29uZGl0aW9uKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgIH1cbn1cbmNvbnN0IEZMT0FUMzJfTUFYID0gMy40MDI4MjM0NjYzODUyODg2ZTM4LCBGTE9BVDMyX01JTiA9IC0zLjQwMjgyMzQ2NjM4NTI4ODZlMzgsIFVJTlQzMl9NQVggPSAweGZmZmZmZmZmLCBJTlQzMl9NQVggPSAweDdmZmZmZmZmLCBJTlQzMl9NSU4gPSAtMHg4MDAwMDAwMDtcbi8qKlxuICogQXNzZXJ0IGEgdmFsaWQgc2lnbmVkIHByb3RvYnVmIDMyLWJpdCBpbnRlZ2VyLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0SW50MzIoYXJnKSB7XG4gICAgaWYgKHR5cGVvZiBhcmcgIT09IFwibnVtYmVyXCIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgaW50IDMyOiBcIiArIHR5cGVvZiBhcmcpO1xuICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihhcmcpIHx8IGFyZyA+IElOVDMyX01BWCB8fCBhcmcgPCBJTlQzMl9NSU4pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgaW50IDMyOiBcIiArIGFyZyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3Jlc3RyaWN0LXBsdXMtb3BlcmFuZHMgLS0gd2Ugd2FudCB0aGUgaW1wbGljaXQgY29udmVyc2lvbiB0byBzdHJpbmdcbn1cbi8qKlxuICogQXNzZXJ0IGEgdmFsaWQgdW5zaWduZWQgcHJvdG9idWYgMzItYml0IGludGVnZXIuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnRVSW50MzIoYXJnKSB7XG4gICAgaWYgKHR5cGVvZiBhcmcgIT09IFwibnVtYmVyXCIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgdWludCAzMjogXCIgKyB0eXBlb2YgYXJnKTtcbiAgICBpZiAoIU51bWJlci5pc0ludGVnZXIoYXJnKSB8fCBhcmcgPiBVSU5UMzJfTUFYIHx8IGFyZyA8IDApXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgdWludCAzMjogXCIgKyBhcmcpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9yZXN0cmljdC1wbHVzLW9wZXJhbmRzIC0tIHdlIHdhbnQgdGhlIGltcGxpY2l0IGNvbnZlcnNpb24gdG8gc3RyaW5nXG59XG4vKipcbiAqIEFzc2VydCBhIHZhbGlkIHByb3RvYnVmIGZsb2F0IHZhbHVlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0RmxvYXQzMihhcmcpIHtcbiAgICBpZiAodHlwZW9mIGFyZyAhPT0gXCJudW1iZXJcIilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBmbG9hdCAzMjogXCIgKyB0eXBlb2YgYXJnKTtcbiAgICBpZiAoIU51bWJlci5pc0Zpbml0ZShhcmcpKVxuICAgICAgICByZXR1cm47XG4gICAgaWYgKGFyZyA+IEZMT0FUMzJfTUFYIHx8IGFyZyA8IEZMT0FUMzJfTUlOKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGZsb2F0IDMyOiBcIiArIGFyZyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3Jlc3RyaWN0LXBsdXMtb3BlcmFuZHMgLS0gd2Ugd2FudCB0aGUgaW1wbGljaXQgY29udmVyc2lvbiB0byBzdHJpbmdcbn1cbiIsIi8vIENvcHlyaWdodCAyMDIxLTIwMjMgQnVmIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5pbXBvcnQgeyBhc3NlcnQgfSBmcm9tIFwiLi9hc3NlcnQuanNcIjtcbmNvbnN0IGVudW1UeXBlU3ltYm9sID0gU3ltYm9sKFwiQGJ1ZmJ1aWxkL3Byb3RvYnVmL2VudW0tdHlwZVwiKTtcbi8qKlxuICogR2V0IHJlZmxlY3Rpb24gaW5mb3JtYXRpb24gZnJvbSBhIGdlbmVyYXRlZCBlbnVtLlxuICogSWYgdGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgb24gc29tZXRoaW5nIG90aGVyIHRoYW4gYSBnZW5lcmF0ZWRcbiAqIGVudW0sIGl0IHJhaXNlcyBhbiBlcnJvci5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEVudW1UeXBlKGVudW1PYmplY3QpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1tZW1iZXItYWNjZXNzLEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXNzaWdubWVudCxAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgY29uc3QgdCA9IGVudW1PYmplY3RbZW51bVR5cGVTeW1ib2xdO1xuICAgIGFzc2VydCh0LCBcIm1pc3NpbmcgZW51bSB0eXBlIG9uIGVudW0gb2JqZWN0XCIpO1xuICAgIHJldHVybiB0OyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtcmV0dXJuXG59XG4vKipcbiAqIFNldHMgcmVmbGVjdGlvbiBpbmZvcm1hdGlvbiBvbiBhIGdlbmVyYXRlZCBlbnVtLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0RW51bVR5cGUoZW51bU9iamVjdCwgdHlwZU5hbWUsIHZhbHVlcywgb3B0KSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtbWVtYmVyLWFjY2VzcywgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIGVudW1PYmplY3RbZW51bVR5cGVTeW1ib2xdID0gbWFrZUVudW1UeXBlKHR5cGVOYW1lLCB2YWx1ZXMubWFwKCh2KSA9PiAoe1xuICAgICAgICBubzogdi5ubyxcbiAgICAgICAgbmFtZTogdi5uYW1lLFxuICAgICAgICBsb2NhbE5hbWU6IGVudW1PYmplY3Rbdi5ub10sXG4gICAgfSkpLCBvcHQpO1xufVxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgRW51bVR5cGUgd2l0aCB0aGUgZ2l2ZW4gdmFsdWVzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbWFrZUVudW1UeXBlKHR5cGVOYW1lLCB2YWx1ZXMsIFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuX29wdCkge1xuICAgIGNvbnN0IG5hbWVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBjb25zdCBudW1iZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBjb25zdCBub3JtYWxWYWx1ZXMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIHZhbHVlcykge1xuICAgICAgICAvLyBXZSBkbyBub3Qgc3VyZmFjZSBvcHRpb25zIGF0IHRoaXMgdGltZVxuICAgICAgICAvLyBjb25zdCB2YWx1ZTogRW51bVZhbHVlSW5mbyA9IHsuLi52LCBvcHRpb25zOiB2Lm9wdGlvbnMgPz8gZW1wdHlSZWFkb25seU9iamVjdH07XG4gICAgICAgIGNvbnN0IG4gPSBub3JtYWxpemVFbnVtVmFsdWUodmFsdWUpO1xuICAgICAgICBub3JtYWxWYWx1ZXMucHVzaChuKTtcbiAgICAgICAgbmFtZXNbdmFsdWUubmFtZV0gPSBuO1xuICAgICAgICBudW1iZXJzW3ZhbHVlLm5vXSA9IG47XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGVOYW1lLFxuICAgICAgICB2YWx1ZXM6IG5vcm1hbFZhbHVlcyxcbiAgICAgICAgLy8gV2UgZG8gbm90IHN1cmZhY2Ugb3B0aW9ucyBhdCB0aGlzIHRpbWVcbiAgICAgICAgLy8gb3B0aW9uczogb3B0Py5vcHRpb25zID8/IE9iamVjdC5jcmVhdGUobnVsbCksXG4gICAgICAgIGZpbmROYW1lKG5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBuYW1lc1tuYW1lXTtcbiAgICAgICAgfSxcbiAgICAgICAgZmluZE51bWJlcihubykge1xuICAgICAgICAgICAgcmV0dXJuIG51bWJlcnNbbm9dO1xuICAgICAgICB9LFxuICAgIH07XG59XG4vKipcbiAqIENyZWF0ZSBhIG5ldyBlbnVtIG9iamVjdCB3aXRoIHRoZSBnaXZlbiB2YWx1ZXMuXG4gKiBTZXRzIHJlZmxlY3Rpb24gaW5mb3JtYXRpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYWtlRW51bSh0eXBlTmFtZSwgdmFsdWVzLCBvcHQpIHtcbiAgICBjb25zdCBlbnVtT2JqZWN0ID0ge307XG4gICAgZm9yIChjb25zdCB2YWx1ZSBvZiB2YWx1ZXMpIHtcbiAgICAgICAgY29uc3QgbiA9IG5vcm1hbGl6ZUVudW1WYWx1ZSh2YWx1ZSk7XG4gICAgICAgIGVudW1PYmplY3Rbbi5sb2NhbE5hbWVdID0gbi5ubztcbiAgICAgICAgZW51bU9iamVjdFtuLm5vXSA9IG4ubG9jYWxOYW1lO1xuICAgIH1cbiAgICBzZXRFbnVtVHlwZShlbnVtT2JqZWN0LCB0eXBlTmFtZSwgdmFsdWVzLCBvcHQpO1xuICAgIHJldHVybiBlbnVtT2JqZWN0O1xufVxuZnVuY3Rpb24gbm9ybWFsaXplRW51bVZhbHVlKHZhbHVlKSB7XG4gICAgaWYgKFwibG9jYWxOYW1lXCIgaW4gdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB2YWx1ZSksIHsgbG9jYWxOYW1lOiB2YWx1ZS5uYW1lIH0pO1xufVxuIiwiLy8gQ29weXJpZ2h0IDIwMjEtMjAyMyBCdWYgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbi8qKlxuICogTWVzc2FnZSBpcyB0aGUgYmFzZSBjbGFzcyBvZiBldmVyeSBtZXNzYWdlLCBnZW5lcmF0ZWQsIG9yIGNyZWF0ZWQgYXRcbiAqIHJ1bnRpbWUuXG4gKlxuICogSXQgaXMgX25vdF8gc2FmZSB0byBleHRlbmQgdGhpcyBjbGFzcy4gSWYgeW91IHdhbnQgdG8gY3JlYXRlIGEgbWVzc2FnZSBhdFxuICogcnVuIHRpbWUsIHVzZSBwcm90bzMubWFrZU1lc3NhZ2VUeXBlKCkuXG4gKi9cbmV4cG9ydCBjbGFzcyBNZXNzYWdlIHtcbiAgICAvKipcbiAgICAgKiBDb21wYXJlIHdpdGggYSBtZXNzYWdlIG9mIHRoZSBzYW1lIHR5cGUuXG4gICAgICovXG4gICAgZXF1YWxzKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFR5cGUoKS5ydW50aW1lLnV0aWwuZXF1YWxzKHRoaXMuZ2V0VHlwZSgpLCB0aGlzLCBvdGhlcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIGRlZXAgY29weS5cbiAgICAgKi9cbiAgICBjbG9uZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VHlwZSgpLnJ1bnRpbWUudXRpbC5jbG9uZSh0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGFyc2UgZnJvbSBiaW5hcnkgZGF0YSwgbWVyZ2luZyBmaWVsZHMuXG4gICAgICpcbiAgICAgKiBSZXBlYXRlZCBmaWVsZHMgYXJlIGFwcGVuZGVkLiBNYXAgZW50cmllcyBhcmUgYWRkZWQsIG92ZXJ3cml0aW5nXG4gICAgICogZXhpc3Rpbmcga2V5cy5cbiAgICAgKlxuICAgICAqIElmIGEgbWVzc2FnZSBmaWVsZCBpcyBhbHJlYWR5IHByZXNlbnQsIGl0IHdpbGwgYmUgbWVyZ2VkIHdpdGggdGhlXG4gICAgICogbmV3IGRhdGEuXG4gICAgICovXG4gICAgZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCB0eXBlID0gdGhpcy5nZXRUeXBlKCksIGZvcm1hdCA9IHR5cGUucnVudGltZS5iaW4sIG9wdCA9IGZvcm1hdC5tYWtlUmVhZE9wdGlvbnMob3B0aW9ucyk7XG4gICAgICAgIGZvcm1hdC5yZWFkTWVzc2FnZSh0aGlzLCBvcHQucmVhZGVyRmFjdG9yeShieXRlcyksIGJ5dGVzLmJ5dGVMZW5ndGgsIG9wdCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQYXJzZSBhIG1lc3NhZ2UgZnJvbSBhIEpTT04gdmFsdWUuXG4gICAgICovXG4gICAgZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHR5cGUgPSB0aGlzLmdldFR5cGUoKSwgZm9ybWF0ID0gdHlwZS5ydW50aW1lLmpzb24sIG9wdCA9IGZvcm1hdC5tYWtlUmVhZE9wdGlvbnMob3B0aW9ucyk7XG4gICAgICAgIGZvcm1hdC5yZWFkTWVzc2FnZSh0eXBlLCBqc29uVmFsdWUsIG9wdCwgdGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQYXJzZSBhIG1lc3NhZ2UgZnJvbSBhIEpTT04gc3RyaW5nLlxuICAgICAqL1xuICAgIGZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpIHtcbiAgICAgICAgbGV0IGpzb247XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBqc29uID0gSlNPTi5wYXJzZShqc29uU3RyaW5nKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjYW5ub3QgZGVjb2RlICR7dGhpcy5nZXRUeXBlKCkudHlwZU5hbWV9IGZyb20gSlNPTjogJHtlIGluc3RhbmNlb2YgRXJyb3IgPyBlLm1lc3NhZ2UgOiBTdHJpbmcoZSl9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZnJvbUpzb24oanNvbiwgb3B0aW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlcmlhbGl6ZSB0aGUgbWVzc2FnZSB0byBiaW5hcnkgZGF0YS5cbiAgICAgKi9cbiAgICB0b0JpbmFyeShvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHR5cGUgPSB0aGlzLmdldFR5cGUoKSwgYmluID0gdHlwZS5ydW50aW1lLmJpbiwgb3B0ID0gYmluLm1ha2VXcml0ZU9wdGlvbnMob3B0aW9ucyksIHdyaXRlciA9IG9wdC53cml0ZXJGYWN0b3J5KCk7XG4gICAgICAgIGJpbi53cml0ZU1lc3NhZ2UodGhpcywgd3JpdGVyLCBvcHQpO1xuICAgICAgICByZXR1cm4gd3JpdGVyLmZpbmlzaCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXJpYWxpemUgdGhlIG1lc3NhZ2UgdG8gYSBKU09OIHZhbHVlLCBhIEphdmFTY3JpcHQgdmFsdWUgdGhhdCBjYW4gYmVcbiAgICAgKiBwYXNzZWQgdG8gSlNPTi5zdHJpbmdpZnkoKS5cbiAgICAgKi9cbiAgICB0b0pzb24ob3B0aW9ucykge1xuICAgICAgICBjb25zdCB0eXBlID0gdGhpcy5nZXRUeXBlKCksIGpzb24gPSB0eXBlLnJ1bnRpbWUuanNvbiwgb3B0ID0ganNvbi5tYWtlV3JpdGVPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4ganNvbi53cml0ZU1lc3NhZ2UodGhpcywgb3B0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VyaWFsaXplIHRoZSBtZXNzYWdlIHRvIGEgSlNPTiBzdHJpbmcuXG4gICAgICovXG4gICAgdG9Kc29uU3RyaW5nKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMudG9Kc29uKG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodmFsdWUsIG51bGwsIChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5wcmV0dHlTcGFjZXMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZSBmb3Igc2VyaWFsaXphdGlvbiBiZWhhdmlvci4gVGhpcyB3aWxsIGJlIGludm9rZWQgd2hlbiBjYWxsaW5nXG4gICAgICogSlNPTi5zdHJpbmdpZnkgb24gdGhpcyBtZXNzYWdlIChpLmUuIEpTT04uc3RyaW5naWZ5KG1zZykpLlxuICAgICAqXG4gICAgICogTm90ZSB0aGF0IHRoaXMgd2lsbCBub3Qgc2VyaWFsaXplIGdvb2dsZS5wcm90b2J1Zi5Bbnkgd2l0aCBhIHBhY2tlZFxuICAgICAqIG1lc3NhZ2UgYmVjYXVzZSB0aGUgcHJvdG9idWYgSlNPTiBmb3JtYXQgc3BlY2lmaWVzIHRoYXQgaXQgbmVlZHMgdG8gYmVcbiAgICAgKiB1bnBhY2tlZCwgYW5kIHRoaXMgaXMgb25seSBwb3NzaWJsZSB3aXRoIGEgdHlwZSByZWdpc3RyeSB0byBsb29rIHVwIHRoZVxuICAgICAqIG1lc3NhZ2UgdHlwZS4gIEFzIGEgcmVzdWx0LCBhdHRlbXB0aW5nIHRvIHNlcmlhbGl6ZSBhIG1lc3NhZ2Ugd2l0aCB0aGlzXG4gICAgICogdHlwZSB3aWxsIHRocm93IGFuIEVycm9yLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgaXMgcHJvdGVjdGVkIGJlY2F1c2UgeW91IHNob3VsZCBub3QgbmVlZCB0byBpbnZva2UgaXRcbiAgICAgKiBkaXJlY3RseSAtLSBpbnN0ZWFkIHVzZSBKU09OLnN0cmluZ2lmeSBvciB0b0pzb25TdHJpbmcgZm9yXG4gICAgICogc3RyaW5naWZpZWQgSlNPTi4gIEFsdGVybmF0aXZlbHksIGlmIGFjdHVhbCBKU09OIGlzIGRlc2lyZWQsIHlvdSBzaG91bGRcbiAgICAgKiB1c2UgdG9Kc29uLlxuICAgICAqL1xuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9Kc29uKHtcbiAgICAgICAgICAgIGVtaXREZWZhdWx0VmFsdWVzOiB0cnVlLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0cmlldmUgdGhlIE1lc3NhZ2VUeXBlIG9mIHRoaXMgbWVzc2FnZSAtIGEgc2luZ2xldG9uIHRoYXQgcmVwcmVzZW50c1xuICAgICAqIHRoZSBwcm90b2J1ZiBtZXNzYWdlIGRlY2xhcmF0aW9uIGFuZCBwcm92aWRlcyBtZXRhZGF0YSBmb3IgcmVmbGVjdGlvbi1cbiAgICAgKiBiYXNlZCBvcGVyYXRpb25zLlxuICAgICAqL1xuICAgIGdldFR5cGUoKSB7XG4gICAgICAgIC8vIEFueSBjbGFzcyB0aGF0IGV4dGVuZHMgTWVzc2FnZSBfbXVzdF8gcHJvdmlkZSBhIGNvbXBsZXRlIHN0YXRpY1xuICAgICAgICAvLyBpbXBsZW1lbnRhdGlvbiBvZiBNZXNzYWdlVHlwZS5cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtbWVtYmVyLWFjY2VzcyxAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLXJldHVyblxuICAgICAgICByZXR1cm4gT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yO1xuICAgIH1cbn1cbiIsIi8vIENvcHlyaWdodCAyMDIxLTIwMjMgQnVmIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5pbXBvcnQgeyBNZXNzYWdlIH0gZnJvbSBcIi4uL21lc3NhZ2UuanNcIjtcbi8qKlxuICogQ3JlYXRlIGEgbmV3IG1lc3NhZ2UgdHlwZSB1c2luZyB0aGUgZ2l2ZW4gcnVudGltZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1ha2VNZXNzYWdlVHlwZShydW50aW1lLCB0eXBlTmFtZSwgZmllbGRzLCBvcHQpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgbG9jYWxOYW1lID0gKF9hID0gb3B0ID09PSBudWxsIHx8IG9wdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0LmxvY2FsTmFtZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdHlwZU5hbWUuc3Vic3RyaW5nKHR5cGVOYW1lLmxhc3RJbmRleE9mKFwiLlwiKSArIDEpO1xuICAgIGNvbnN0IHR5cGUgPSB7XG4gICAgICAgIFtsb2NhbE5hbWVdOiBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgcnVudGltZS51dGlsLmluaXRGaWVsZHModGhpcyk7XG4gICAgICAgICAgICBydW50aW1lLnV0aWwuaW5pdFBhcnRpYWwoZGF0YSwgdGhpcyk7XG4gICAgICAgIH0sXG4gICAgfVtsb2NhbE5hbWVdO1xuICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0eXBlLnByb3RvdHlwZSwgbmV3IE1lc3NhZ2UoKSk7XG4gICAgT2JqZWN0LmFzc2lnbih0eXBlLCB7XG4gICAgICAgIHJ1bnRpbWUsXG4gICAgICAgIHR5cGVOYW1lLFxuICAgICAgICBmaWVsZHM6IHJ1bnRpbWUudXRpbC5uZXdGaWVsZExpc3QoZmllbGRzKSxcbiAgICAgICAgZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyB0eXBlKCkuZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucyk7XG4gICAgICAgIH0sXG4gICAgICAgIGZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyB0eXBlKCkuZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKTtcbiAgICAgICAgfSxcbiAgICAgICAgZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyB0eXBlKCkuZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucyk7XG4gICAgICAgIH0sXG4gICAgICAgIGVxdWFscyhhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gcnVudGltZS51dGlsLmVxdWFscyh0eXBlLCBhLCBiKTtcbiAgICAgICAgfSxcbiAgICB9KTtcbiAgICByZXR1cm4gdHlwZTtcbn1cbiIsIi8vIENvcHlyaWdodCAyMDIxLTIwMjMgQnVmIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5pbXBvcnQgeyBnZXRFbnVtVHlwZSwgbWFrZUVudW0sIG1ha2VFbnVtVHlwZSB9IGZyb20gXCIuL2VudW0uanNcIjtcbmltcG9ydCB7IG1ha2VNZXNzYWdlVHlwZSB9IGZyb20gXCIuL21lc3NhZ2UtdHlwZS5qc1wiO1xuZXhwb3J0IGZ1bmN0aW9uIG1ha2VQcm90b1J1bnRpbWUoc3ludGF4LCBqc29uLCBiaW4sIHV0aWwpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBzeW50YXgsXG4gICAgICAgIGpzb24sXG4gICAgICAgIGJpbixcbiAgICAgICAgdXRpbCxcbiAgICAgICAgbWFrZU1lc3NhZ2VUeXBlKHR5cGVOYW1lLCBmaWVsZHMsIG9wdCkge1xuICAgICAgICAgICAgcmV0dXJuIG1ha2VNZXNzYWdlVHlwZSh0aGlzLCB0eXBlTmFtZSwgZmllbGRzLCBvcHQpO1xuICAgICAgICB9LFxuICAgICAgICBtYWtlRW51bSxcbiAgICAgICAgbWFrZUVudW1UeXBlLFxuICAgICAgICBnZXRFbnVtVHlwZSxcbiAgICB9O1xufVxuIiwiLy8gQ29weXJpZ2h0IDIwMjEtMjAyMyBCdWYgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbi8qKlxuICogU2NhbGFyIHZhbHVlIHR5cGVzLiBUaGlzIGlzIGEgc3Vic2V0IG9mIGZpZWxkIHR5cGVzIGRlY2xhcmVkIGJ5IHByb3RvYnVmXG4gKiBlbnVtIGdvb2dsZS5wcm90b2J1Zi5GaWVsZERlc2NyaXB0b3JQcm90by5UeXBlIFRoZSB0eXBlcyBHUk9VUCBhbmQgTUVTU0FHRVxuICogYXJlIG9taXR0ZWQsIGJ1dCB0aGUgbnVtZXJpY2FsIHZhbHVlcyBhcmUgaWRlbnRpY2FsLlxuICovXG5leHBvcnQgdmFyIFNjYWxhclR5cGU7XG4oZnVuY3Rpb24gKFNjYWxhclR5cGUpIHtcbiAgICAvLyAwIGlzIHJlc2VydmVkIGZvciBlcnJvcnMuXG4gICAgLy8gT3JkZXIgaXMgd2VpcmQgZm9yIGhpc3RvcmljYWwgcmVhc29ucy5cbiAgICBTY2FsYXJUeXBlW1NjYWxhclR5cGVbXCJET1VCTEVcIl0gPSAxXSA9IFwiRE9VQkxFXCI7XG4gICAgU2NhbGFyVHlwZVtTY2FsYXJUeXBlW1wiRkxPQVRcIl0gPSAyXSA9IFwiRkxPQVRcIjtcbiAgICAvLyBOb3QgWmlnWmFnIGVuY29kZWQuICBOZWdhdGl2ZSBudW1iZXJzIHRha2UgMTAgYnl0ZXMuICBVc2UgVFlQRV9TSU5UNjQgaWZcbiAgICAvLyBuZWdhdGl2ZSB2YWx1ZXMgYXJlIGxpa2VseS5cbiAgICBTY2FsYXJUeXBlW1NjYWxhclR5cGVbXCJJTlQ2NFwiXSA9IDNdID0gXCJJTlQ2NFwiO1xuICAgIFNjYWxhclR5cGVbU2NhbGFyVHlwZVtcIlVJTlQ2NFwiXSA9IDRdID0gXCJVSU5UNjRcIjtcbiAgICAvLyBOb3QgWmlnWmFnIGVuY29kZWQuICBOZWdhdGl2ZSBudW1iZXJzIHRha2UgMTAgYnl0ZXMuICBVc2UgVFlQRV9TSU5UMzIgaWZcbiAgICAvLyBuZWdhdGl2ZSB2YWx1ZXMgYXJlIGxpa2VseS5cbiAgICBTY2FsYXJUeXBlW1NjYWxhclR5cGVbXCJJTlQzMlwiXSA9IDVdID0gXCJJTlQzMlwiO1xuICAgIFNjYWxhclR5cGVbU2NhbGFyVHlwZVtcIkZJWEVENjRcIl0gPSA2XSA9IFwiRklYRUQ2NFwiO1xuICAgIFNjYWxhclR5cGVbU2NhbGFyVHlwZVtcIkZJWEVEMzJcIl0gPSA3XSA9IFwiRklYRUQzMlwiO1xuICAgIFNjYWxhclR5cGVbU2NhbGFyVHlwZVtcIkJPT0xcIl0gPSA4XSA9IFwiQk9PTFwiO1xuICAgIFNjYWxhclR5cGVbU2NhbGFyVHlwZVtcIlNUUklOR1wiXSA9IDldID0gXCJTVFJJTkdcIjtcbiAgICAvLyBUYWctZGVsaW1pdGVkIGFnZ3JlZ2F0ZS5cbiAgICAvLyBHcm91cCB0eXBlIGlzIGRlcHJlY2F0ZWQgYW5kIG5vdCBzdXBwb3J0ZWQgaW4gcHJvdG8zLiBIb3dldmVyLCBQcm90bzNcbiAgICAvLyBpbXBsZW1lbnRhdGlvbnMgc2hvdWxkIHN0aWxsIGJlIGFibGUgdG8gcGFyc2UgdGhlIGdyb3VwIHdpcmUgZm9ybWF0IGFuZFxuICAgIC8vIHRyZWF0IGdyb3VwIGZpZWxkcyBhcyB1bmtub3duIGZpZWxkcy5cbiAgICAvLyBUWVBFX0dST1VQID0gMTAsXG4gICAgLy8gVFlQRV9NRVNTQUdFID0gMTEsICAvLyBMZW5ndGgtZGVsaW1pdGVkIGFnZ3JlZ2F0ZS5cbiAgICAvLyBOZXcgaW4gdmVyc2lvbiAyLlxuICAgIFNjYWxhclR5cGVbU2NhbGFyVHlwZVtcIkJZVEVTXCJdID0gMTJdID0gXCJCWVRFU1wiO1xuICAgIFNjYWxhclR5cGVbU2NhbGFyVHlwZVtcIlVJTlQzMlwiXSA9IDEzXSA9IFwiVUlOVDMyXCI7XG4gICAgLy8gVFlQRV9FTlVNID0gMTQsXG4gICAgU2NhbGFyVHlwZVtTY2FsYXJUeXBlW1wiU0ZJWEVEMzJcIl0gPSAxNV0gPSBcIlNGSVhFRDMyXCI7XG4gICAgU2NhbGFyVHlwZVtTY2FsYXJUeXBlW1wiU0ZJWEVENjRcIl0gPSAxNl0gPSBcIlNGSVhFRDY0XCI7XG4gICAgU2NhbGFyVHlwZVtTY2FsYXJUeXBlW1wiU0lOVDMyXCJdID0gMTddID0gXCJTSU5UMzJcIjtcbiAgICBTY2FsYXJUeXBlW1NjYWxhclR5cGVbXCJTSU5UNjRcIl0gPSAxOF0gPSBcIlNJTlQ2NFwiO1xufSkoU2NhbGFyVHlwZSB8fCAoU2NhbGFyVHlwZSA9IHt9KSk7XG4vKipcbiAqIEphdmFTY3JpcHQgcmVwcmVzZW50YXRpb24gb2YgZmllbGRzIHdpdGggNjQgYml0IGludGVncmFsIHR5cGVzIChpbnQ2NCwgdWludDY0LFxuICogc2ludDY0LCBmaXhlZDY0LCBzZml4ZWQ2NCkuXG4gKlxuICogVGhpcyBpcyBhIHN1YnNldCBvZiBnb29nbGUucHJvdG9idWYuRmllbGRPcHRpb25zLkpTVHlwZSwgd2hpY2ggZGVmaW5lcyBKU19OT1JNQUwsXG4gKiBKU19TVFJJTkcsIGFuZCBKU19OVU1CRVIuIFByb3RvYnVmLUVTIHVzZXMgQmlnSW50IGJ5IGRlZmF1bHQsIGJ1dCB3aWxsIHVzZVxuICogU3RyaW5nIGlmIGBbanN0eXBlID0gSlNfU1RSSU5HXWAgaXMgc3BlY2lmaWVkLlxuICpcbiAqIGBgYHByb3RvYnVmXG4gKiB1aW50NjQgZmllbGRfYSA9IDE7IC8vIEJpZ0ludFxuICogdWludDY0IGZpZWxkX2IgPSAyIFtqc3R5cGUgPSBKU19OT1JNQUxdOyAvLyBCaWdJbnRcbiAqIHVpbnQ2NCBmaWVsZF9iID0gMiBbanN0eXBlID0gSlNfTlVNQkVSXTsgLy8gQmlnSW50XG4gKiB1aW50NjQgZmllbGRfYiA9IDIgW2pzdHlwZSA9IEpTX1NUUklOR107IC8vIFN0cmluZ1xuICogYGBgXG4gKi9cbmV4cG9ydCB2YXIgTG9uZ1R5cGU7XG4oZnVuY3Rpb24gKExvbmdUeXBlKSB7XG4gICAgLyoqXG4gICAgICogVXNlIEphdmFTY3JpcHQgQmlnSW50LlxuICAgICAqL1xuICAgIExvbmdUeXBlW0xvbmdUeXBlW1wiQklHSU5UXCJdID0gMF0gPSBcIkJJR0lOVFwiO1xuICAgIC8qKlxuICAgICAqIFVzZSBKYXZhU2NyaXB0IFN0cmluZy5cbiAgICAgKlxuICAgICAqIEZpZWxkIG9wdGlvbiBgW2pzdHlwZSA9IEpTX1NUUklOR11gLlxuICAgICAqL1xuICAgIExvbmdUeXBlW0xvbmdUeXBlW1wiU1RSSU5HXCJdID0gMV0gPSBcIlNUUklOR1wiO1xufSkoTG9uZ1R5cGUgfHwgKExvbmdUeXBlID0ge30pKTtcbiIsIi8vIENvcHlyaWdodCAyMDA4IEdvb2dsZSBJbmMuICBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy9cbi8vIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuLy8gbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZVxuLy8gbWV0OlxuLy9cbi8vICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHRcbi8vIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbi8vICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZVxuLy8gY29weXJpZ2h0IG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lclxuLy8gaW4gdGhlIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZVxuLy8gZGlzdHJpYnV0aW9uLlxuLy8gKiBOZWl0aGVyIHRoZSBuYW1lIG9mIEdvb2dsZSBJbmMuIG5vciB0aGUgbmFtZXMgb2YgaXRzXG4vLyBjb250cmlidXRvcnMgbWF5IGJlIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzIGRlcml2ZWQgZnJvbVxuLy8gdGhpcyBzb2Z0d2FyZSB3aXRob3V0IHNwZWNpZmljIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cbi8vXG4vLyBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTXG4vLyBcIkFTIElTXCIgQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UXG4vLyBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1Jcbi8vIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUXG4vLyBPV05FUiBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCxcbi8vIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1Rcbi8vIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLFxuLy8gREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZXG4vLyBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUXG4vLyAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0Vcbi8vIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4vL1xuLy8gQ29kZSBnZW5lcmF0ZWQgYnkgdGhlIFByb3RvY29sIEJ1ZmZlciBjb21waWxlciBpcyBvd25lZCBieSB0aGUgb3duZXJcbi8vIG9mIHRoZSBpbnB1dCBmaWxlIHVzZWQgd2hlbiBnZW5lcmF0aW5nIGl0LiAgVGhpcyBjb2RlIGlzIG5vdFxuLy8gc3RhbmRhbG9uZSBhbmQgcmVxdWlyZXMgYSBzdXBwb3J0IGxpYnJhcnkgdG8gYmUgbGlua2VkIHdpdGggaXQuICBUaGlzXG4vLyBzdXBwb3J0IGxpYnJhcnkgaXMgaXRzZWxmIGNvdmVyZWQgYnkgdGhlIGFib3ZlIGxpY2Vuc2UuXG4vKiBlc2xpbnQtZGlzYWJsZSBwcmVmZXItY29uc3QsQHR5cGVzY3JpcHQtZXNsaW50L3Jlc3RyaWN0LXBsdXMtb3BlcmFuZHMgKi9cbi8qKlxuICogUmVhZCBhIDY0IGJpdCB2YXJpbnQgYXMgdHdvIEpTIG51bWJlcnMuXG4gKlxuICogUmV0dXJucyB0dXBsZTpcbiAqIFswXTogbG93IGJpdHNcbiAqIFsxXTogaGlnaCBiaXRzXG4gKlxuICogQ29weXJpZ2h0IDIwMDggR29vZ2xlIEluYy4gIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9wcm90b2NvbGJ1ZmZlcnMvcHJvdG9idWYvYmxvYi84YTcxOTI3ZDc0YTRjZTM0ZWZlMmQ4NzY5ZmRhMTk4ZjUyZDIwZDEyL2pzL2V4cGVyaW1lbnRhbC9ydW50aW1lL2tlcm5lbC9idWZmZXJfZGVjb2Rlci5qcyNMMTc1XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2YXJpbnQ2NHJlYWQoKSB7XG4gICAgbGV0IGxvd0JpdHMgPSAwO1xuICAgIGxldCBoaWdoQml0cyA9IDA7XG4gICAgZm9yIChsZXQgc2hpZnQgPSAwOyBzaGlmdCA8IDI4OyBzaGlmdCArPSA3KSB7XG4gICAgICAgIGxldCBiID0gdGhpcy5idWZbdGhpcy5wb3MrK107XG4gICAgICAgIGxvd0JpdHMgfD0gKGIgJiAweDdmKSA8PCBzaGlmdDtcbiAgICAgICAgaWYgKChiICYgMHg4MCkgPT0gMCkge1xuICAgICAgICAgICAgdGhpcy5hc3NlcnRCb3VuZHMoKTtcbiAgICAgICAgICAgIHJldHVybiBbbG93Qml0cywgaGlnaEJpdHNdO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxldCBtaWRkbGVCeXRlID0gdGhpcy5idWZbdGhpcy5wb3MrK107XG4gICAgLy8gbGFzdCBmb3VyIGJpdHMgb2YgdGhlIGZpcnN0IDMyIGJpdCBudW1iZXJcbiAgICBsb3dCaXRzIHw9IChtaWRkbGVCeXRlICYgMHgwZikgPDwgMjg7XG4gICAgLy8gMyB1cHBlciBiaXRzIGFyZSBwYXJ0IG9mIHRoZSBuZXh0IDMyIGJpdCBudW1iZXJcbiAgICBoaWdoQml0cyA9IChtaWRkbGVCeXRlICYgMHg3MCkgPj4gNDtcbiAgICBpZiAoKG1pZGRsZUJ5dGUgJiAweDgwKSA9PSAwKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0Qm91bmRzKCk7XG4gICAgICAgIHJldHVybiBbbG93Qml0cywgaGlnaEJpdHNdO1xuICAgIH1cbiAgICBmb3IgKGxldCBzaGlmdCA9IDM7IHNoaWZ0IDw9IDMxOyBzaGlmdCArPSA3KSB7XG4gICAgICAgIGxldCBiID0gdGhpcy5idWZbdGhpcy5wb3MrK107XG4gICAgICAgIGhpZ2hCaXRzIHw9IChiICYgMHg3ZikgPDwgc2hpZnQ7XG4gICAgICAgIGlmICgoYiAmIDB4ODApID09IDApIHtcbiAgICAgICAgICAgIHRoaXMuYXNzZXJ0Qm91bmRzKCk7XG4gICAgICAgICAgICByZXR1cm4gW2xvd0JpdHMsIGhpZ2hCaXRzXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHZhcmludFwiKTtcbn1cbi8qKlxuICogV3JpdGUgYSA2NCBiaXQgdmFyaW50LCBnaXZlbiBhcyB0d28gSlMgbnVtYmVycywgdG8gdGhlIGdpdmVuIGJ5dGVzIGFycmF5LlxuICpcbiAqIENvcHlyaWdodCAyMDA4IEdvb2dsZSBJbmMuICBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vcHJvdG9jb2xidWZmZXJzL3Byb3RvYnVmL2Jsb2IvOGE3MTkyN2Q3NGE0Y2UzNGVmZTJkODc2OWZkYTE5OGY1MmQyMGQxMi9qcy9leHBlcmltZW50YWwvcnVudGltZS9rZXJuZWwvd3JpdGVyLmpzI0wzNDRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZhcmludDY0d3JpdGUobG8sIGhpLCBieXRlcykge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMjg7IGkgPSBpICsgNykge1xuICAgICAgICBjb25zdCBzaGlmdCA9IGxvID4+PiBpO1xuICAgICAgICBjb25zdCBoYXNOZXh0ID0gIShzaGlmdCA+Pj4gNyA9PSAwICYmIGhpID09IDApO1xuICAgICAgICBjb25zdCBieXRlID0gKGhhc05leHQgPyBzaGlmdCB8IDB4ODAgOiBzaGlmdCkgJiAweGZmO1xuICAgICAgICBieXRlcy5wdXNoKGJ5dGUpO1xuICAgICAgICBpZiAoIWhhc05leHQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBzcGxpdEJpdHMgPSAoKGxvID4+PiAyOCkgJiAweDBmKSB8ICgoaGkgJiAweDA3KSA8PCA0KTtcbiAgICBjb25zdCBoYXNNb3JlQml0cyA9ICEoaGkgPj4gMyA9PSAwKTtcbiAgICBieXRlcy5wdXNoKChoYXNNb3JlQml0cyA/IHNwbGl0Qml0cyB8IDB4ODAgOiBzcGxpdEJpdHMpICYgMHhmZik7XG4gICAgaWYgKCFoYXNNb3JlQml0cykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAzOyBpIDwgMzE7IGkgPSBpICsgNykge1xuICAgICAgICBjb25zdCBzaGlmdCA9IGhpID4+PiBpO1xuICAgICAgICBjb25zdCBoYXNOZXh0ID0gIShzaGlmdCA+Pj4gNyA9PSAwKTtcbiAgICAgICAgY29uc3QgYnl0ZSA9IChoYXNOZXh0ID8gc2hpZnQgfCAweDgwIDogc2hpZnQpICYgMHhmZjtcbiAgICAgICAgYnl0ZXMucHVzaChieXRlKTtcbiAgICAgICAgaWYgKCFoYXNOZXh0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG4gICAgYnl0ZXMucHVzaCgoaGkgPj4+IDMxKSAmIDB4MDEpO1xufVxuLy8gY29uc3RhbnRzIGZvciBiaW5hcnkgbWF0aFxuY29uc3QgVFdPX1BXUl8zMl9EQkwgPSAweDEwMDAwMDAwMDtcbi8qKlxuICogUGFyc2UgZGVjaW1hbCBzdHJpbmcgb2YgNjQgYml0IGludGVnZXIgdmFsdWUgYXMgdHdvIEpTIG51bWJlcnMuXG4gKlxuICogQ29weXJpZ2h0IDIwMDggR29vZ2xlIEluYy4gIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9wcm90b2NvbGJ1ZmZlcnMvcHJvdG9idWYtamF2YXNjcmlwdC9ibG9iL2E0MjhjNTgyNzNhYmFkMDdjNjYwNzFkOTc1M2JjNGQxMjg5ZGU0MjYvZXhwZXJpbWVudGFsL3J1bnRpbWUvaW50NjQuanMjTDEwXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbnQ2NEZyb21TdHJpbmcoZGVjKSB7XG4gICAgLy8gQ2hlY2sgZm9yIG1pbnVzIHNpZ24uXG4gICAgY29uc3QgbWludXMgPSBkZWNbMF0gPT09IFwiLVwiO1xuICAgIGlmIChtaW51cykge1xuICAgICAgICBkZWMgPSBkZWMuc2xpY2UoMSk7XG4gICAgfVxuICAgIC8vIFdvcmsgNiBkZWNpbWFsIGRpZ2l0cyBhdCBhIHRpbWUsIGFjdGluZyBsaWtlIHdlJ3JlIGNvbnZlcnRpbmcgYmFzZSAxZTZcbiAgICAvLyBkaWdpdHMgdG8gYmluYXJ5LiBUaGlzIGlzIHNhZmUgdG8gZG8gd2l0aCBmbG9hdGluZyBwb2ludCBtYXRoIGJlY2F1c2VcbiAgICAvLyBOdW1iZXIuaXNTYWZlSW50ZWdlcihBTExfMzJfQklUUyAqIDFlNikgPT0gdHJ1ZS5cbiAgICBjb25zdCBiYXNlID0gMWU2O1xuICAgIGxldCBsb3dCaXRzID0gMDtcbiAgICBsZXQgaGlnaEJpdHMgPSAwO1xuICAgIGZ1bmN0aW9uIGFkZDFlNmRpZ2l0KGJlZ2luLCBlbmQpIHtcbiAgICAgICAgLy8gTm90ZTogTnVtYmVyKCcnKSBpcyAwLlxuICAgICAgICBjb25zdCBkaWdpdDFlNiA9IE51bWJlcihkZWMuc2xpY2UoYmVnaW4sIGVuZCkpO1xuICAgICAgICBoaWdoQml0cyAqPSBiYXNlO1xuICAgICAgICBsb3dCaXRzID0gbG93Qml0cyAqIGJhc2UgKyBkaWdpdDFlNjtcbiAgICAgICAgLy8gQ2FycnkgYml0cyBmcm9tIGxvd0JpdHMgdG9cbiAgICAgICAgaWYgKGxvd0JpdHMgPj0gVFdPX1BXUl8zMl9EQkwpIHtcbiAgICAgICAgICAgIGhpZ2hCaXRzID0gaGlnaEJpdHMgKyAoKGxvd0JpdHMgLyBUV09fUFdSXzMyX0RCTCkgfCAwKTtcbiAgICAgICAgICAgIGxvd0JpdHMgPSBsb3dCaXRzICUgVFdPX1BXUl8zMl9EQkw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWRkMWU2ZGlnaXQoLTI0LCAtMTgpO1xuICAgIGFkZDFlNmRpZ2l0KC0xOCwgLTEyKTtcbiAgICBhZGQxZTZkaWdpdCgtMTIsIC02KTtcbiAgICBhZGQxZTZkaWdpdCgtNik7XG4gICAgcmV0dXJuIG1pbnVzID8gbmVnYXRlKGxvd0JpdHMsIGhpZ2hCaXRzKSA6IG5ld0JpdHMobG93Qml0cywgaGlnaEJpdHMpO1xufVxuLyoqXG4gKiBMb3NzbGVzc2x5IGNvbnZlcnRzIGEgNjQtYml0IHNpZ25lZCBpbnRlZ2VyIGluIDMyOjMyIHNwbGl0IHJlcHJlc2VudGF0aW9uXG4gKiBpbnRvIGEgZGVjaW1hbCBzdHJpbmcuXG4gKlxuICogQ29weXJpZ2h0IDIwMDggR29vZ2xlIEluYy4gIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9wcm90b2NvbGJ1ZmZlcnMvcHJvdG9idWYtamF2YXNjcmlwdC9ibG9iL2E0MjhjNTgyNzNhYmFkMDdjNjYwNzFkOTc1M2JjNGQxMjg5ZGU0MjYvZXhwZXJpbWVudGFsL3J1bnRpbWUvaW50NjQuanMjTDEwXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbnQ2NFRvU3RyaW5nKGxvLCBoaSkge1xuICAgIGxldCBiaXRzID0gbmV3Qml0cyhsbywgaGkpO1xuICAgIC8vIElmIHdlJ3JlIHRyZWF0aW5nIHRoZSBpbnB1dCBhcyBhIHNpZ25lZCB2YWx1ZSBhbmQgdGhlIGhpZ2ggYml0IGlzIHNldCwgZG9cbiAgICAvLyBhIG1hbnVhbCB0d28ncyBjb21wbGVtZW50IGNvbnZlcnNpb24gYmVmb3JlIHRoZSBkZWNpbWFsIGNvbnZlcnNpb24uXG4gICAgY29uc3QgbmVnYXRpdmUgPSAoYml0cy5oaSAmIDB4ODAwMDAwMDApO1xuICAgIGlmIChuZWdhdGl2ZSkge1xuICAgICAgICBiaXRzID0gbmVnYXRlKGJpdHMubG8sIGJpdHMuaGkpO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSB1SW50NjRUb1N0cmluZyhiaXRzLmxvLCBiaXRzLmhpKTtcbiAgICByZXR1cm4gbmVnYXRpdmUgPyBcIi1cIiArIHJlc3VsdCA6IHJlc3VsdDtcbn1cbi8qKlxuICogTG9zc2xlc3NseSBjb252ZXJ0cyBhIDY0LWJpdCB1bnNpZ25lZCBpbnRlZ2VyIGluIDMyOjMyIHNwbGl0IHJlcHJlc2VudGF0aW9uXG4gKiBpbnRvIGEgZGVjaW1hbCBzdHJpbmcuXG4gKlxuICogQ29weXJpZ2h0IDIwMDggR29vZ2xlIEluYy4gIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9wcm90b2NvbGJ1ZmZlcnMvcHJvdG9idWYtamF2YXNjcmlwdC9ibG9iL2E0MjhjNTgyNzNhYmFkMDdjNjYwNzFkOTc1M2JjNGQxMjg5ZGU0MjYvZXhwZXJpbWVudGFsL3J1bnRpbWUvaW50NjQuanMjTDEwXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1SW50NjRUb1N0cmluZyhsbywgaGkpIHtcbiAgICAoeyBsbywgaGkgfSA9IHRvVW5zaWduZWQobG8sIGhpKSk7XG4gICAgLy8gU2tpcCB0aGUgZXhwZW5zaXZlIGNvbnZlcnNpb24gaWYgdGhlIG51bWJlciBpcyBzbWFsbCBlbm91Z2ggdG8gdXNlIHRoZVxuICAgIC8vIGJ1aWx0LWluIGNvbnZlcnNpb25zLlxuICAgIC8vIE51bWJlci5NQVhfU0FGRV9JTlRFR0VSID0gMHgwMDFGRkZGRiBGRkZGRkZGRiwgdGh1cyBhbnkgbnVtYmVyIHdpdGhcbiAgICAvLyBoaWdoQml0cyA8PSAweDFGRkZGRiBjYW4gYmUgc2FmZWx5IGV4cHJlc3NlZCB3aXRoIGEgZG91YmxlIGFuZCByZXRhaW5cbiAgICAvLyBpbnRlZ2VyIHByZWNpc2lvbi5cbiAgICAvLyBQcm92ZW4gYnk6IE51bWJlci5pc1NhZmVJbnRlZ2VyKDB4MUZGRkZGICogMioqMzIgKyAweEZGRkZGRkZGKSA9PSB0cnVlLlxuICAgIGlmIChoaSA8PSAweDFGRkZGRikge1xuICAgICAgICByZXR1cm4gU3RyaW5nKFRXT19QV1JfMzJfREJMICogaGkgKyBsbyk7XG4gICAgfVxuICAgIC8vIFdoYXQgdGhpcyBjb2RlIGlzIGRvaW5nIGlzIGVzc2VudGlhbGx5IGNvbnZlcnRpbmcgdGhlIGlucHV0IG51bWJlciBmcm9tXG4gICAgLy8gYmFzZS0yIHRvIGJhc2UtMWU3LCB3aGljaCBhbGxvd3MgdXMgdG8gcmVwcmVzZW50IHRoZSA2NC1iaXQgcmFuZ2Ugd2l0aFxuICAgIC8vIG9ubHkgMyAodmVyeSBsYXJnZSkgZGlnaXRzLiBUaG9zZSBkaWdpdHMgYXJlIHRoZW4gdHJpdmlhbCB0byBjb252ZXJ0IHRvXG4gICAgLy8gYSBiYXNlLTEwIHN0cmluZy5cbiAgICAvLyBUaGUgbWFnaWMgbnVtYmVycyB1c2VkIGhlcmUgYXJlIC1cbiAgICAvLyAyXjI0ID0gMTY3NzcyMTYgPSAoMSw2Nzc3MjE2KSBpbiBiYXNlLTFlNy5cbiAgICAvLyAyXjQ4ID0gMjgxNDc0OTc2NzEwNjU2ID0gKDIsODE0NzQ5Nyw2NzEwNjU2KSBpbiBiYXNlLTFlNy5cbiAgICAvLyBTcGxpdCAzMjozMiByZXByZXNlbnRhdGlvbiBpbnRvIDE2OjI0OjI0IHJlcHJlc2VudGF0aW9uIHNvIG91clxuICAgIC8vIGludGVybWVkaWF0ZSBkaWdpdHMgZG9uJ3Qgb3ZlcmZsb3cuXG4gICAgY29uc3QgbG93ID0gbG8gJiAweEZGRkZGRjtcbiAgICBjb25zdCBtaWQgPSAoKGxvID4+PiAyNCkgfCAoaGkgPDwgOCkpICYgMHhGRkZGRkY7XG4gICAgY29uc3QgaGlnaCA9IChoaSA+PiAxNikgJiAweEZGRkY7XG4gICAgLy8gQXNzZW1ibGUgb3VyIHRocmVlIGJhc2UtMWU3IGRpZ2l0cywgaWdub3JpbmcgY2Fycmllcy4gVGhlIG1heGltdW1cbiAgICAvLyB2YWx1ZSBpbiBhIGRpZ2l0IGF0IHRoaXMgc3RlcCBpcyByZXByZXNlbnRhYmxlIGFzIGEgNDgtYml0IGludGVnZXIsIHdoaWNoXG4gICAgLy8gY2FuIGJlIHN0b3JlZCBpbiBhIDY0LWJpdCBmbG9hdGluZyBwb2ludCBudW1iZXIuXG4gICAgbGV0IGRpZ2l0QSA9IGxvdyArIChtaWQgKiA2Nzc3MjE2KSArIChoaWdoICogNjcxMDY1Nik7XG4gICAgbGV0IGRpZ2l0QiA9IG1pZCArIChoaWdoICogODE0NzQ5Nyk7XG4gICAgbGV0IGRpZ2l0QyA9IChoaWdoICogMik7XG4gICAgLy8gQXBwbHkgY2FycmllcyBmcm9tIEEgdG8gQiBhbmQgZnJvbSBCIHRvIEMuXG4gICAgY29uc3QgYmFzZSA9IDEwMDAwMDAwO1xuICAgIGlmIChkaWdpdEEgPj0gYmFzZSkge1xuICAgICAgICBkaWdpdEIgKz0gTWF0aC5mbG9vcihkaWdpdEEgLyBiYXNlKTtcbiAgICAgICAgZGlnaXRBICU9IGJhc2U7XG4gICAgfVxuICAgIGlmIChkaWdpdEIgPj0gYmFzZSkge1xuICAgICAgICBkaWdpdEMgKz0gTWF0aC5mbG9vcihkaWdpdEIgLyBiYXNlKTtcbiAgICAgICAgZGlnaXRCICU9IGJhc2U7XG4gICAgfVxuICAgIC8vIElmIGRpZ2l0QyBpcyAwLCB0aGVuIHdlIHNob3VsZCBoYXZlIHJldHVybmVkIGluIHRoZSB0cml2aWFsIGNvZGUgcGF0aFxuICAgIC8vIGF0IHRoZSB0b3AgZm9yIG5vbi1zYWZlIGludGVnZXJzLiBHaXZlbiB0aGlzLCB3ZSBjYW4gYXNzdW1lIGJvdGggZGlnaXRCXG4gICAgLy8gYW5kIGRpZ2l0QSBuZWVkIGxlYWRpbmcgemVyb3MuXG4gICAgcmV0dXJuIGRpZ2l0Qy50b1N0cmluZygpICsgZGVjaW1hbEZyb20xZTdXaXRoTGVhZGluZ1plcm9zKGRpZ2l0QikgK1xuICAgICAgICBkZWNpbWFsRnJvbTFlN1dpdGhMZWFkaW5nWmVyb3MoZGlnaXRBKTtcbn1cbmZ1bmN0aW9uIHRvVW5zaWduZWQobG8sIGhpKSB7XG4gICAgcmV0dXJuIHsgbG86IGxvID4+PiAwLCBoaTogaGkgPj4+IDAgfTtcbn1cbmZ1bmN0aW9uIG5ld0JpdHMobG8sIGhpKSB7XG4gICAgcmV0dXJuIHsgbG86IGxvIHwgMCwgaGk6IGhpIHwgMCB9O1xufVxuLyoqXG4gKiBSZXR1cm5zIHR3bydzIGNvbXBsaW1lbnQgbmVnYXRpb24gb2YgaW5wdXQuXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL09wZXJhdG9ycy9CaXR3aXNlX09wZXJhdG9ycyNTaWduZWRfMzItYml0X2ludGVnZXJzXG4gKi9cbmZ1bmN0aW9uIG5lZ2F0ZShsb3dCaXRzLCBoaWdoQml0cykge1xuICAgIGhpZ2hCaXRzID0gfmhpZ2hCaXRzO1xuICAgIGlmIChsb3dCaXRzKSB7XG4gICAgICAgIGxvd0JpdHMgPSB+bG93Qml0cyArIDE7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBJZiBsb3dCaXRzIGlzIDAsIHRoZW4gYml0d2lzZS1ub3QgaXMgMHhGRkZGRkZGRixcbiAgICAgICAgLy8gYWRkaW5nIDEgdG8gdGhhdCwgcmVzdWx0cyBpbiAweDEwMDAwMDAwMCwgd2hpY2ggbGVhdmVzXG4gICAgICAgIC8vIHRoZSBsb3cgYml0cyAweDAgYW5kIHNpbXBseSBhZGRzIG9uZSB0byB0aGUgaGlnaCBiaXRzLlxuICAgICAgICBoaWdoQml0cyArPSAxO1xuICAgIH1cbiAgICByZXR1cm4gbmV3Qml0cyhsb3dCaXRzLCBoaWdoQml0cyk7XG59XG4vKipcbiAqIFJldHVybnMgZGVjaW1hbCByZXByZXNlbnRhdGlvbiBvZiBkaWdpdDFlNyB3aXRoIGxlYWRpbmcgemVyb3MuXG4gKi9cbmNvbnN0IGRlY2ltYWxGcm9tMWU3V2l0aExlYWRpbmdaZXJvcyA9IChkaWdpdDFlNykgPT4ge1xuICAgIGNvbnN0IHBhcnRpYWwgPSBTdHJpbmcoZGlnaXQxZTcpO1xuICAgIHJldHVybiBcIjAwMDAwMDBcIi5zbGljZShwYXJ0aWFsLmxlbmd0aCkgKyBwYXJ0aWFsO1xufTtcbi8qKlxuICogV3JpdGUgYSAzMiBiaXQgdmFyaW50LCBzaWduZWQgb3IgdW5zaWduZWQuIFNhbWUgYXMgYHZhcmludDY0d3JpdGUoMCwgdmFsdWUsIGJ5dGVzKWBcbiAqXG4gKiBDb3B5cmlnaHQgMjAwOCBHb29nbGUgSW5jLiAgQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3Byb3RvY29sYnVmZmVycy9wcm90b2J1Zi9ibG9iLzFiMTg4MzNmNGYyYTJmNjgxZjRlNGEyNWNkZjNiMGE0MzExNWVjMjYvanMvYmluYXJ5L2VuY29kZXIuanMjTDE0NFxuICovXG5leHBvcnQgZnVuY3Rpb24gdmFyaW50MzJ3cml0ZSh2YWx1ZSwgYnl0ZXMpIHtcbiAgICBpZiAodmFsdWUgPj0gMCkge1xuICAgICAgICAvLyB3cml0ZSB2YWx1ZSBhcyB2YXJpbnQgMzJcbiAgICAgICAgd2hpbGUgKHZhbHVlID4gMHg3Zikge1xuICAgICAgICAgICAgYnl0ZXMucHVzaCgodmFsdWUgJiAweDdmKSB8IDB4ODApO1xuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZSA+Pj4gNztcbiAgICAgICAgfVxuICAgICAgICBieXRlcy5wdXNoKHZhbHVlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgOTsgaSsrKSB7XG4gICAgICAgICAgICBieXRlcy5wdXNoKCh2YWx1ZSAmIDEyNykgfCAxMjgpO1xuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZSA+PiA3O1xuICAgICAgICB9XG4gICAgICAgIGJ5dGVzLnB1c2goMSk7XG4gICAgfVxufVxuLyoqXG4gKiBSZWFkIGFuIHVuc2lnbmVkIDMyIGJpdCB2YXJpbnQuXG4gKlxuICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9wcm90b2NvbGJ1ZmZlcnMvcHJvdG9idWYvYmxvYi84YTcxOTI3ZDc0YTRjZTM0ZWZlMmQ4NzY5ZmRhMTk4ZjUyZDIwZDEyL2pzL2V4cGVyaW1lbnRhbC9ydW50aW1lL2tlcm5lbC9idWZmZXJfZGVjb2Rlci5qcyNMMjIwXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2YXJpbnQzMnJlYWQoKSB7XG4gICAgbGV0IGIgPSB0aGlzLmJ1Zlt0aGlzLnBvcysrXTtcbiAgICBsZXQgcmVzdWx0ID0gYiAmIDB4N2Y7XG4gICAgaWYgKChiICYgMHg4MCkgPT0gMCkge1xuICAgICAgICB0aGlzLmFzc2VydEJvdW5kcygpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBiID0gdGhpcy5idWZbdGhpcy5wb3MrK107XG4gICAgcmVzdWx0IHw9IChiICYgMHg3ZikgPDwgNztcbiAgICBpZiAoKGIgJiAweDgwKSA9PSAwKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0Qm91bmRzKCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGIgPSB0aGlzLmJ1Zlt0aGlzLnBvcysrXTtcbiAgICByZXN1bHQgfD0gKGIgJiAweDdmKSA8PCAxNDtcbiAgICBpZiAoKGIgJiAweDgwKSA9PSAwKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0Qm91bmRzKCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGIgPSB0aGlzLmJ1Zlt0aGlzLnBvcysrXTtcbiAgICByZXN1bHQgfD0gKGIgJiAweDdmKSA8PCAyMTtcbiAgICBpZiAoKGIgJiAweDgwKSA9PSAwKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0Qm91bmRzKCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8vIEV4dHJhY3Qgb25seSBsYXN0IDQgYml0c1xuICAgIGIgPSB0aGlzLmJ1Zlt0aGlzLnBvcysrXTtcbiAgICByZXN1bHQgfD0gKGIgJiAweDBmKSA8PCAyODtcbiAgICBmb3IgKGxldCByZWFkQnl0ZXMgPSA1OyAoYiAmIDB4ODApICE9PSAwICYmIHJlYWRCeXRlcyA8IDEwOyByZWFkQnl0ZXMrKylcbiAgICAgICAgYiA9IHRoaXMuYnVmW3RoaXMucG9zKytdO1xuICAgIGlmICgoYiAmIDB4ODApICE9IDApXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgdmFyaW50XCIpO1xuICAgIHRoaXMuYXNzZXJ0Qm91bmRzKCk7XG4gICAgLy8gUmVzdWx0IGNhbiBoYXZlIDMyIGJpdHMsIGNvbnZlcnQgaXQgdG8gdW5zaWduZWRcbiAgICByZXR1cm4gcmVzdWx0ID4+PiAwO1xufVxuIiwiLy8gQ29weXJpZ2h0IDIwMjEtMjAyMyBCdWYgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbmltcG9ydCB7IGFzc2VydCB9IGZyb20gXCIuL3ByaXZhdGUvYXNzZXJ0LmpzXCI7XG5pbXBvcnQgeyBpbnQ2NEZyb21TdHJpbmcsIGludDY0VG9TdHJpbmcsIHVJbnQ2NFRvU3RyaW5nLCB9IGZyb20gXCIuL2dvb2dsZS92YXJpbnQuanNcIjtcbmZ1bmN0aW9uIG1ha2VJbnQ2NFN1cHBvcnQoKSB7XG4gICAgY29uc3QgZHYgPSBuZXcgRGF0YVZpZXcobmV3IEFycmF5QnVmZmVyKDgpKTtcbiAgICAvLyBub3RlIHRoYXQgU2FmYXJpIDE0IGltcGxlbWVudHMgQmlnSW50LCBidXQgbm90IHRoZSBEYXRhVmlldyBtZXRob2RzXG4gICAgY29uc3Qgb2sgPSB0eXBlb2YgQmlnSW50ID09PSBcImZ1bmN0aW9uXCIgJiZcbiAgICAgICAgdHlwZW9mIGR2LmdldEJpZ0ludDY0ID09PSBcImZ1bmN0aW9uXCIgJiZcbiAgICAgICAgdHlwZW9mIGR2LmdldEJpZ1VpbnQ2NCA9PT0gXCJmdW5jdGlvblwiICYmXG4gICAgICAgIHR5cGVvZiBkdi5zZXRCaWdJbnQ2NCA9PT0gXCJmdW5jdGlvblwiICYmXG4gICAgICAgIHR5cGVvZiBkdi5zZXRCaWdVaW50NjQgPT09IFwiZnVuY3Rpb25cIiAmJlxuICAgICAgICAodHlwZW9mIHByb2Nlc3MgIT0gXCJvYmplY3RcIiB8fFxuICAgICAgICAgICAgdHlwZW9mIHByb2Nlc3MuZW52ICE9IFwib2JqZWN0XCIgfHxcbiAgICAgICAgICAgIHByb2Nlc3MuZW52LkJVRl9CSUdJTlRfRElTQUJMRSAhPT0gXCIxXCIpO1xuICAgIGlmIChvaykge1xuICAgICAgICBjb25zdCBNSU4gPSBCaWdJbnQoXCItOTIyMzM3MjAzNjg1NDc3NTgwOFwiKSwgTUFYID0gQmlnSW50KFwiOTIyMzM3MjAzNjg1NDc3NTgwN1wiKSwgVU1JTiA9IEJpZ0ludChcIjBcIiksIFVNQVggPSBCaWdJbnQoXCIxODQ0Njc0NDA3MzcwOTU1MTYxNVwiKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHplcm86IEJpZ0ludCgwKSxcbiAgICAgICAgICAgIHN1cHBvcnRlZDogdHJ1ZSxcbiAgICAgICAgICAgIHBhcnNlKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYmkgPSB0eXBlb2YgdmFsdWUgPT0gXCJiaWdpbnRcIiA/IHZhbHVlIDogQmlnSW50KHZhbHVlKTtcbiAgICAgICAgICAgICAgICBpZiAoYmkgPiBNQVggfHwgYmkgPCBNSU4pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnQ2NCBpbnZhbGlkOiAke3ZhbHVlfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYmk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdVBhcnNlKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYmkgPSB0eXBlb2YgdmFsdWUgPT0gXCJiaWdpbnRcIiA/IHZhbHVlIDogQmlnSW50KHZhbHVlKTtcbiAgICAgICAgICAgICAgICBpZiAoYmkgPiBVTUFYIHx8IGJpIDwgVU1JTikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHVpbnQ2NCBpbnZhbGlkOiAke3ZhbHVlfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYmk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW5jKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgZHYuc2V0QmlnSW50NjQoMCwgdGhpcy5wYXJzZSh2YWx1ZSksIHRydWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGxvOiBkdi5nZXRJbnQzMigwLCB0cnVlKSxcbiAgICAgICAgICAgICAgICAgICAgaGk6IGR2LmdldEludDMyKDQsIHRydWUpLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdUVuYyh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGR2LnNldEJpZ0ludDY0KDAsIHRoaXMudVBhcnNlKHZhbHVlKSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgbG86IGR2LmdldEludDMyKDAsIHRydWUpLFxuICAgICAgICAgICAgICAgICAgICBoaTogZHYuZ2V0SW50MzIoNCwgdHJ1ZSksXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkZWMobG8sIGhpKSB7XG4gICAgICAgICAgICAgICAgZHYuc2V0SW50MzIoMCwgbG8sIHRydWUpO1xuICAgICAgICAgICAgICAgIGR2LnNldEludDMyKDQsIGhpLCB0cnVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZHYuZ2V0QmlnSW50NjQoMCwgdHJ1ZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdURlYyhsbywgaGkpIHtcbiAgICAgICAgICAgICAgICBkdi5zZXRJbnQzMigwLCBsbywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgZHYuc2V0SW50MzIoNCwgaGksIHRydWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBkdi5nZXRCaWdVaW50NjQoMCwgdHJ1ZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBhc3NlcnRJbnQ2NFN0cmluZyA9ICh2YWx1ZSkgPT4gYXNzZXJ0KC9eLT9bMC05XSskLy50ZXN0KHZhbHVlKSwgYGludDY0IGludmFsaWQ6ICR7dmFsdWV9YCk7XG4gICAgY29uc3QgYXNzZXJ0VUludDY0U3RyaW5nID0gKHZhbHVlKSA9PiBhc3NlcnQoL15bMC05XSskLy50ZXN0KHZhbHVlKSwgYHVpbnQ2NCBpbnZhbGlkOiAke3ZhbHVlfWApO1xuICAgIHJldHVybiB7XG4gICAgICAgIHplcm86IFwiMFwiLFxuICAgICAgICBzdXBwb3J0ZWQ6IGZhbHNlLFxuICAgICAgICBwYXJzZSh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS50b1N0cmluZygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXNzZXJ0SW50NjRTdHJpbmcodmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICB1UGFyc2UodmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFzc2VydFVJbnQ2NFN0cmluZyh2YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIGVuYyh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS50b1N0cmluZygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXNzZXJ0SW50NjRTdHJpbmcodmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIGludDY0RnJvbVN0cmluZyh2YWx1ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIHVFbmModmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFzc2VydFVJbnQ2NFN0cmluZyh2YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gaW50NjRGcm9tU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgZGVjKGxvLCBoaSkge1xuICAgICAgICAgICAgcmV0dXJuIGludDY0VG9TdHJpbmcobG8sIGhpKTtcbiAgICAgICAgfSxcbiAgICAgICAgdURlYyhsbywgaGkpIHtcbiAgICAgICAgICAgIHJldHVybiB1SW50NjRUb1N0cmluZyhsbywgaGkpO1xuICAgICAgICB9LFxuICAgIH07XG59XG5leHBvcnQgY29uc3QgcHJvdG9JbnQ2NCA9IG1ha2VJbnQ2NFN1cHBvcnQoKTtcbiIsIi8vIENvcHlyaWdodCAyMDIxLTIwMjMgQnVmIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5pbXBvcnQgeyB2YXJpbnQzMnJlYWQsIHZhcmludDMyd3JpdGUsIHZhcmludDY0cmVhZCwgdmFyaW50NjR3cml0ZSwgfSBmcm9tIFwiLi9nb29nbGUvdmFyaW50LmpzXCI7XG5pbXBvcnQgeyBhc3NlcnRGbG9hdDMyLCBhc3NlcnRJbnQzMiwgYXNzZXJ0VUludDMyIH0gZnJvbSBcIi4vcHJpdmF0ZS9hc3NlcnQuanNcIjtcbmltcG9ydCB7IHByb3RvSW50NjQgfSBmcm9tIFwiLi9wcm90by1pbnQ2NC5qc1wiO1xuLyogZXNsaW50LWRpc2FibGUgcHJlZmVyLWNvbnN0LG5vLWNhc2UtZGVjbGFyYXRpb25zLEB0eXBlc2NyaXB0LWVzbGludC9yZXN0cmljdC1wbHVzLW9wZXJhbmRzICovXG4vKipcbiAqIFByb3RvYnVmIGJpbmFyeSBmb3JtYXQgd2lyZSB0eXBlcy5cbiAqXG4gKiBBIHdpcmUgdHlwZSBwcm92aWRlcyBqdXN0IGVub3VnaCBpbmZvcm1hdGlvbiB0byBmaW5kIHRoZSBsZW5ndGggb2YgdGhlXG4gKiBmb2xsb3dpbmcgdmFsdWUuXG4gKlxuICogU2VlIGh0dHBzOi8vZGV2ZWxvcGVycy5nb29nbGUuY29tL3Byb3RvY29sLWJ1ZmZlcnMvZG9jcy9lbmNvZGluZyNzdHJ1Y3R1cmVcbiAqL1xuZXhwb3J0IHZhciBXaXJlVHlwZTtcbihmdW5jdGlvbiAoV2lyZVR5cGUpIHtcbiAgICAvKipcbiAgICAgKiBVc2VkIGZvciBpbnQzMiwgaW50NjQsIHVpbnQzMiwgdWludDY0LCBzaW50MzIsIHNpbnQ2NCwgYm9vbCwgZW51bVxuICAgICAqL1xuICAgIFdpcmVUeXBlW1dpcmVUeXBlW1wiVmFyaW50XCJdID0gMF0gPSBcIlZhcmludFwiO1xuICAgIC8qKlxuICAgICAqIFVzZWQgZm9yIGZpeGVkNjQsIHNmaXhlZDY0LCBkb3VibGUuXG4gICAgICogQWx3YXlzIDggYnl0ZXMgd2l0aCBsaXR0bGUtZW5kaWFuIGJ5dGUgb3JkZXIuXG4gICAgICovXG4gICAgV2lyZVR5cGVbV2lyZVR5cGVbXCJCaXQ2NFwiXSA9IDFdID0gXCJCaXQ2NFwiO1xuICAgIC8qKlxuICAgICAqIFVzZWQgZm9yIHN0cmluZywgYnl0ZXMsIGVtYmVkZGVkIG1lc3NhZ2VzLCBwYWNrZWQgcmVwZWF0ZWQgZmllbGRzXG4gICAgICpcbiAgICAgKiBPbmx5IHJlcGVhdGVkIG51bWVyaWMgdHlwZXMgKHR5cGVzIHdoaWNoIHVzZSB0aGUgdmFyaW50LCAzMi1iaXQsXG4gICAgICogb3IgNjQtYml0IHdpcmUgdHlwZXMpIGNhbiBiZSBwYWNrZWQuIEluIHByb3RvMywgc3VjaCBmaWVsZHMgYXJlXG4gICAgICogcGFja2VkIGJ5IGRlZmF1bHQuXG4gICAgICovXG4gICAgV2lyZVR5cGVbV2lyZVR5cGVbXCJMZW5ndGhEZWxpbWl0ZWRcIl0gPSAyXSA9IFwiTGVuZ3RoRGVsaW1pdGVkXCI7XG4gICAgLyoqXG4gICAgICogVXNlZCBmb3IgZ3JvdXBzXG4gICAgICogQGRlcHJlY2F0ZWRcbiAgICAgKi9cbiAgICBXaXJlVHlwZVtXaXJlVHlwZVtcIlN0YXJ0R3JvdXBcIl0gPSAzXSA9IFwiU3RhcnRHcm91cFwiO1xuICAgIC8qKlxuICAgICAqIFVzZWQgZm9yIGdyb3Vwc1xuICAgICAqIEBkZXByZWNhdGVkXG4gICAgICovXG4gICAgV2lyZVR5cGVbV2lyZVR5cGVbXCJFbmRHcm91cFwiXSA9IDRdID0gXCJFbmRHcm91cFwiO1xuICAgIC8qKlxuICAgICAqIFVzZWQgZm9yIGZpeGVkMzIsIHNmaXhlZDMyLCBmbG9hdC5cbiAgICAgKiBBbHdheXMgNCBieXRlcyB3aXRoIGxpdHRsZS1lbmRpYW4gYnl0ZSBvcmRlci5cbiAgICAgKi9cbiAgICBXaXJlVHlwZVtXaXJlVHlwZVtcIkJpdDMyXCJdID0gNV0gPSBcIkJpdDMyXCI7XG59KShXaXJlVHlwZSB8fCAoV2lyZVR5cGUgPSB7fSkpO1xuZXhwb3J0IGNsYXNzIEJpbmFyeVdyaXRlciB7XG4gICAgY29uc3RydWN0b3IodGV4dEVuY29kZXIpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFByZXZpb3VzIGZvcmsgc3RhdGVzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdGFjayA9IFtdO1xuICAgICAgICB0aGlzLnRleHRFbmNvZGVyID0gdGV4dEVuY29kZXIgIT09IG51bGwgJiYgdGV4dEVuY29kZXIgIT09IHZvaWQgMCA/IHRleHRFbmNvZGVyIDogbmV3IFRleHRFbmNvZGVyKCk7XG4gICAgICAgIHRoaXMuY2h1bmtzID0gW107XG4gICAgICAgIHRoaXMuYnVmID0gW107XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiBhbGwgYnl0ZXMgd3JpdHRlbiBhbmQgcmVzZXQgdGhpcyB3cml0ZXIuXG4gICAgICovXG4gICAgZmluaXNoKCkge1xuICAgICAgICB0aGlzLmNodW5rcy5wdXNoKG5ldyBVaW50OEFycmF5KHRoaXMuYnVmKSk7IC8vIGZsdXNoIHRoZSBidWZmZXJcbiAgICAgICAgbGV0IGxlbiA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jaHVua3MubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBsZW4gKz0gdGhpcy5jaHVua3NbaV0ubGVuZ3RoO1xuICAgICAgICBsZXQgYnl0ZXMgPSBuZXcgVWludDhBcnJheShsZW4pO1xuICAgICAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNodW5rcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYnl0ZXMuc2V0KHRoaXMuY2h1bmtzW2ldLCBvZmZzZXQpO1xuICAgICAgICAgICAgb2Zmc2V0ICs9IHRoaXMuY2h1bmtzW2ldLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNodW5rcyA9IFtdO1xuICAgICAgICByZXR1cm4gYnl0ZXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0YXJ0IGEgbmV3IGZvcmsgZm9yIGxlbmd0aC1kZWxpbWl0ZWQgZGF0YSBsaWtlIGEgbWVzc2FnZVxuICAgICAqIG9yIGEgcGFja2VkIHJlcGVhdGVkIGZpZWxkLlxuICAgICAqXG4gICAgICogTXVzdCBiZSBqb2luZWQgbGF0ZXIgd2l0aCBgam9pbigpYC5cbiAgICAgKi9cbiAgICBmb3JrKCkge1xuICAgICAgICB0aGlzLnN0YWNrLnB1c2goeyBjaHVua3M6IHRoaXMuY2h1bmtzLCBidWY6IHRoaXMuYnVmIH0pO1xuICAgICAgICB0aGlzLmNodW5rcyA9IFtdO1xuICAgICAgICB0aGlzLmJ1ZiA9IFtdO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogSm9pbiB0aGUgbGFzdCBmb3JrLiBXcml0ZSBpdHMgbGVuZ3RoIGFuZCBieXRlcywgdGhlblxuICAgICAqIHJldHVybiB0byB0aGUgcHJldmlvdXMgc3RhdGUuXG4gICAgICovXG4gICAgam9pbigpIHtcbiAgICAgICAgLy8gZ2V0IGNodW5rIG9mIGZvcmtcbiAgICAgICAgbGV0IGNodW5rID0gdGhpcy5maW5pc2goKTtcbiAgICAgICAgLy8gcmVzdG9yZSBwcmV2aW91cyBzdGF0ZVxuICAgICAgICBsZXQgcHJldiA9IHRoaXMuc3RhY2sucG9wKCk7XG4gICAgICAgIGlmICghcHJldilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgc3RhdGUsIGZvcmsgc3RhY2sgZW1wdHlcIik7XG4gICAgICAgIHRoaXMuY2h1bmtzID0gcHJldi5jaHVua3M7XG4gICAgICAgIHRoaXMuYnVmID0gcHJldi5idWY7XG4gICAgICAgIC8vIHdyaXRlIGxlbmd0aCBvZiBjaHVuayBhcyB2YXJpbnRcbiAgICAgICAgdGhpcy51aW50MzIoY2h1bmsuYnl0ZUxlbmd0aCk7XG4gICAgICAgIHJldHVybiB0aGlzLnJhdyhjaHVuayk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdyaXRlcyBhIHRhZyAoZmllbGQgbnVtYmVyIGFuZCB3aXJlIHR5cGUpLlxuICAgICAqXG4gICAgICogRXF1aXZhbGVudCB0byBgdWludDMyKCAoZmllbGRObyA8PCAzIHwgdHlwZSkgPj4+IDAgKWAuXG4gICAgICpcbiAgICAgKiBHZW5lcmF0ZWQgY29kZSBzaG91bGQgY29tcHV0ZSB0aGUgdGFnIGFoZWFkIG9mIHRpbWUgYW5kIGNhbGwgYHVpbnQzMigpYC5cbiAgICAgKi9cbiAgICB0YWcoZmllbGRObywgdHlwZSkge1xuICAgICAgICByZXR1cm4gdGhpcy51aW50MzIoKChmaWVsZE5vIDw8IDMpIHwgdHlwZSkgPj4+IDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXcml0ZSBhIGNodW5rIG9mIHJhdyBieXRlcy5cbiAgICAgKi9cbiAgICByYXcoY2h1bmspIHtcbiAgICAgICAgaWYgKHRoaXMuYnVmLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5jaHVua3MucHVzaChuZXcgVWludDhBcnJheSh0aGlzLmJ1ZikpO1xuICAgICAgICAgICAgdGhpcy5idWYgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNodW5rcy5wdXNoKGNodW5rKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdyaXRlIGEgYHVpbnQzMmAgdmFsdWUsIGFuIHVuc2lnbmVkIDMyIGJpdCB2YXJpbnQuXG4gICAgICovXG4gICAgdWludDMyKHZhbHVlKSB7XG4gICAgICAgIGFzc2VydFVJbnQzMih2YWx1ZSk7XG4gICAgICAgIC8vIHdyaXRlIHZhbHVlIGFzIHZhcmludCAzMiwgaW5saW5lZCBmb3Igc3BlZWRcbiAgICAgICAgd2hpbGUgKHZhbHVlID4gMHg3Zikge1xuICAgICAgICAgICAgdGhpcy5idWYucHVzaCgodmFsdWUgJiAweDdmKSB8IDB4ODApO1xuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZSA+Pj4gNztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmJ1Zi5wdXNoKHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdyaXRlIGEgYGludDMyYCB2YWx1ZSwgYSBzaWduZWQgMzIgYml0IHZhcmludC5cbiAgICAgKi9cbiAgICBpbnQzMih2YWx1ZSkge1xuICAgICAgICBhc3NlcnRJbnQzMih2YWx1ZSk7XG4gICAgICAgIHZhcmludDMyd3JpdGUodmFsdWUsIHRoaXMuYnVmKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdyaXRlIGEgYGJvb2xgIHZhbHVlLCBhIHZhcmlhbnQuXG4gICAgICovXG4gICAgYm9vbCh2YWx1ZSkge1xuICAgICAgICB0aGlzLmJ1Zi5wdXNoKHZhbHVlID8gMSA6IDApO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JpdGUgYSBgYnl0ZXNgIHZhbHVlLCBsZW5ndGgtZGVsaW1pdGVkIGFyYml0cmFyeSBkYXRhLlxuICAgICAqL1xuICAgIGJ5dGVzKHZhbHVlKSB7XG4gICAgICAgIHRoaXMudWludDMyKHZhbHVlLmJ5dGVMZW5ndGgpOyAvLyB3cml0ZSBsZW5ndGggb2YgY2h1bmsgYXMgdmFyaW50XG4gICAgICAgIHJldHVybiB0aGlzLnJhdyh2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdyaXRlIGEgYHN0cmluZ2AgdmFsdWUsIGxlbmd0aC1kZWxpbWl0ZWQgZGF0YSBjb252ZXJ0ZWQgdG8gVVRGLTggdGV4dC5cbiAgICAgKi9cbiAgICBzdHJpbmcodmFsdWUpIHtcbiAgICAgICAgbGV0IGNodW5rID0gdGhpcy50ZXh0RW5jb2Rlci5lbmNvZGUodmFsdWUpO1xuICAgICAgICB0aGlzLnVpbnQzMihjaHVuay5ieXRlTGVuZ3RoKTsgLy8gd3JpdGUgbGVuZ3RoIG9mIGNodW5rIGFzIHZhcmludFxuICAgICAgICByZXR1cm4gdGhpcy5yYXcoY2h1bmspO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXcml0ZSBhIGBmbG9hdGAgdmFsdWUsIDMyLWJpdCBmbG9hdGluZyBwb2ludCBudW1iZXIuXG4gICAgICovXG4gICAgZmxvYXQodmFsdWUpIHtcbiAgICAgICAgYXNzZXJ0RmxvYXQzMih2YWx1ZSk7XG4gICAgICAgIGxldCBjaHVuayA9IG5ldyBVaW50OEFycmF5KDQpO1xuICAgICAgICBuZXcgRGF0YVZpZXcoY2h1bmsuYnVmZmVyKS5zZXRGbG9hdDMyKDAsIHZhbHVlLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucmF3KGNodW5rKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JpdGUgYSBgZG91YmxlYCB2YWx1ZSwgYSA2NC1iaXQgZmxvYXRpbmcgcG9pbnQgbnVtYmVyLlxuICAgICAqL1xuICAgIGRvdWJsZSh2YWx1ZSkge1xuICAgICAgICBsZXQgY2h1bmsgPSBuZXcgVWludDhBcnJheSg4KTtcbiAgICAgICAgbmV3IERhdGFWaWV3KGNodW5rLmJ1ZmZlcikuc2V0RmxvYXQ2NCgwLCB2YWx1ZSwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiB0aGlzLnJhdyhjaHVuayk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdyaXRlIGEgYGZpeGVkMzJgIHZhbHVlLCBhbiB1bnNpZ25lZCwgZml4ZWQtbGVuZ3RoIDMyLWJpdCBpbnRlZ2VyLlxuICAgICAqL1xuICAgIGZpeGVkMzIodmFsdWUpIHtcbiAgICAgICAgYXNzZXJ0VUludDMyKHZhbHVlKTtcbiAgICAgICAgbGV0IGNodW5rID0gbmV3IFVpbnQ4QXJyYXkoNCk7XG4gICAgICAgIG5ldyBEYXRhVmlldyhjaHVuay5idWZmZXIpLnNldFVpbnQzMigwLCB2YWx1ZSwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiB0aGlzLnJhdyhjaHVuayk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdyaXRlIGEgYHNmaXhlZDMyYCB2YWx1ZSwgYSBzaWduZWQsIGZpeGVkLWxlbmd0aCAzMi1iaXQgaW50ZWdlci5cbiAgICAgKi9cbiAgICBzZml4ZWQzMih2YWx1ZSkge1xuICAgICAgICBhc3NlcnRJbnQzMih2YWx1ZSk7XG4gICAgICAgIGxldCBjaHVuayA9IG5ldyBVaW50OEFycmF5KDQpO1xuICAgICAgICBuZXcgRGF0YVZpZXcoY2h1bmsuYnVmZmVyKS5zZXRJbnQzMigwLCB2YWx1ZSwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiB0aGlzLnJhdyhjaHVuayk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdyaXRlIGEgYHNpbnQzMmAgdmFsdWUsIGEgc2lnbmVkLCB6aWd6YWctZW5jb2RlZCAzMi1iaXQgdmFyaW50LlxuICAgICAqL1xuICAgIHNpbnQzMih2YWx1ZSkge1xuICAgICAgICBhc3NlcnRJbnQzMih2YWx1ZSk7XG4gICAgICAgIC8vIHppZ3phZyBlbmNvZGVcbiAgICAgICAgdmFsdWUgPSAoKHZhbHVlIDw8IDEpIF4gKHZhbHVlID4+IDMxKSkgPj4+IDA7XG4gICAgICAgIHZhcmludDMyd3JpdGUodmFsdWUsIHRoaXMuYnVmKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdyaXRlIGEgYGZpeGVkNjRgIHZhbHVlLCBhIHNpZ25lZCwgZml4ZWQtbGVuZ3RoIDY0LWJpdCBpbnRlZ2VyLlxuICAgICAqL1xuICAgIHNmaXhlZDY0KHZhbHVlKSB7XG4gICAgICAgIGxldCBjaHVuayA9IG5ldyBVaW50OEFycmF5KDgpLCB2aWV3ID0gbmV3IERhdGFWaWV3KGNodW5rLmJ1ZmZlciksIHRjID0gcHJvdG9JbnQ2NC5lbmModmFsdWUpO1xuICAgICAgICB2aWV3LnNldEludDMyKDAsIHRjLmxvLCB0cnVlKTtcbiAgICAgICAgdmlldy5zZXRJbnQzMig0LCB0Yy5oaSwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiB0aGlzLnJhdyhjaHVuayk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdyaXRlIGEgYGZpeGVkNjRgIHZhbHVlLCBhbiB1bnNpZ25lZCwgZml4ZWQtbGVuZ3RoIDY0IGJpdCBpbnRlZ2VyLlxuICAgICAqL1xuICAgIGZpeGVkNjQodmFsdWUpIHtcbiAgICAgICAgbGV0IGNodW5rID0gbmV3IFVpbnQ4QXJyYXkoOCksIHZpZXcgPSBuZXcgRGF0YVZpZXcoY2h1bmsuYnVmZmVyKSwgdGMgPSBwcm90b0ludDY0LnVFbmModmFsdWUpO1xuICAgICAgICB2aWV3LnNldEludDMyKDAsIHRjLmxvLCB0cnVlKTtcbiAgICAgICAgdmlldy5zZXRJbnQzMig0LCB0Yy5oaSwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiB0aGlzLnJhdyhjaHVuayk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdyaXRlIGEgYGludDY0YCB2YWx1ZSwgYSBzaWduZWQgNjQtYml0IHZhcmludC5cbiAgICAgKi9cbiAgICBpbnQ2NCh2YWx1ZSkge1xuICAgICAgICBsZXQgdGMgPSBwcm90b0ludDY0LmVuYyh2YWx1ZSk7XG4gICAgICAgIHZhcmludDY0d3JpdGUodGMubG8sIHRjLmhpLCB0aGlzLmJ1Zik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXcml0ZSBhIGBzaW50NjRgIHZhbHVlLCBhIHNpZ25lZCwgemlnLXphZy1lbmNvZGVkIDY0LWJpdCB2YXJpbnQuXG4gICAgICovXG4gICAgc2ludDY0KHZhbHVlKSB7XG4gICAgICAgIGxldCB0YyA9IHByb3RvSW50NjQuZW5jKHZhbHVlKSwgXG4gICAgICAgIC8vIHppZ3phZyBlbmNvZGVcbiAgICAgICAgc2lnbiA9IHRjLmhpID4+IDMxLCBsbyA9ICh0Yy5sbyA8PCAxKSBeIHNpZ24sIGhpID0gKCh0Yy5oaSA8PCAxKSB8ICh0Yy5sbyA+Pj4gMzEpKSBeIHNpZ247XG4gICAgICAgIHZhcmludDY0d3JpdGUobG8sIGhpLCB0aGlzLmJ1Zik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXcml0ZSBhIGB1aW50NjRgIHZhbHVlLCBhbiB1bnNpZ25lZCA2NC1iaXQgdmFyaW50LlxuICAgICAqL1xuICAgIHVpbnQ2NCh2YWx1ZSkge1xuICAgICAgICBsZXQgdGMgPSBwcm90b0ludDY0LnVFbmModmFsdWUpO1xuICAgICAgICB2YXJpbnQ2NHdyaXRlKHRjLmxvLCB0Yy5oaSwgdGhpcy5idWYpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgQmluYXJ5UmVhZGVyIHtcbiAgICBjb25zdHJ1Y3RvcihidWYsIHRleHREZWNvZGVyKSB7XG4gICAgICAgIHRoaXMudmFyaW50NjQgPSB2YXJpbnQ2NHJlYWQ7IC8vIGRpcnR5IGNhc3QgZm9yIGB0aGlzYFxuICAgICAgICAvKipcbiAgICAgICAgICogUmVhZCBhIGB1aW50MzJgIGZpZWxkLCBhbiB1bnNpZ25lZCAzMiBiaXQgdmFyaW50LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy51aW50MzIgPSB2YXJpbnQzMnJlYWQ7IC8vIGRpcnR5IGNhc3QgZm9yIGB0aGlzYCBhbmQgYWNjZXNzIHRvIHByb3RlY3RlZCBgYnVmYFxuICAgICAgICB0aGlzLmJ1ZiA9IGJ1ZjtcbiAgICAgICAgdGhpcy5sZW4gPSBidWYubGVuZ3RoO1xuICAgICAgICB0aGlzLnBvcyA9IDA7XG4gICAgICAgIHRoaXMudmlldyA9IG5ldyBEYXRhVmlldyhidWYuYnVmZmVyLCBidWYuYnl0ZU9mZnNldCwgYnVmLmJ5dGVMZW5ndGgpO1xuICAgICAgICB0aGlzLnRleHREZWNvZGVyID0gdGV4dERlY29kZXIgIT09IG51bGwgJiYgdGV4dERlY29kZXIgIT09IHZvaWQgMCA/IHRleHREZWNvZGVyIDogbmV3IFRleHREZWNvZGVyKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlYWRzIGEgdGFnIC0gZmllbGQgbnVtYmVyIGFuZCB3aXJlIHR5cGUuXG4gICAgICovXG4gICAgdGFnKCkge1xuICAgICAgICBsZXQgdGFnID0gdGhpcy51aW50MzIoKSwgZmllbGRObyA9IHRhZyA+Pj4gMywgd2lyZVR5cGUgPSB0YWcgJiA3O1xuICAgICAgICBpZiAoZmllbGRObyA8PSAwIHx8IHdpcmVUeXBlIDwgMCB8fCB3aXJlVHlwZSA+IDUpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbGxlZ2FsIHRhZzogZmllbGQgbm8gXCIgKyBmaWVsZE5vICsgXCIgd2lyZSB0eXBlIFwiICsgd2lyZVR5cGUpO1xuICAgICAgICByZXR1cm4gW2ZpZWxkTm8sIHdpcmVUeXBlXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2tpcCBvbmUgZWxlbWVudCBvbiB0aGUgd2lyZSBhbmQgcmV0dXJuIHRoZSBza2lwcGVkIGRhdGEuXG4gICAgICogU3VwcG9ydHMgV2lyZVR5cGUuU3RhcnRHcm91cCBzaW5jZSB2Mi4wLjAtYWxwaGEuMjMuXG4gICAgICovXG4gICAgc2tpcCh3aXJlVHlwZSkge1xuICAgICAgICBsZXQgc3RhcnQgPSB0aGlzLnBvcztcbiAgICAgICAgc3dpdGNoICh3aXJlVHlwZSkge1xuICAgICAgICAgICAgY2FzZSBXaXJlVHlwZS5WYXJpbnQ6XG4gICAgICAgICAgICAgICAgd2hpbGUgKHRoaXMuYnVmW3RoaXMucG9zKytdICYgMHg4MCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBpZ25vcmVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmUgVFM3MDI5OiBGYWxsdGhyb3VnaCBjYXNlIGluIHN3aXRjaFxuICAgICAgICAgICAgY2FzZSBXaXJlVHlwZS5CaXQ2NDpcbiAgICAgICAgICAgICAgICB0aGlzLnBvcyArPSA0O1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlIFRTNzAyOTogRmFsbHRocm91Z2ggY2FzZSBpbiBzd2l0Y2hcbiAgICAgICAgICAgIGNhc2UgV2lyZVR5cGUuQml0MzI6XG4gICAgICAgICAgICAgICAgdGhpcy5wb3MgKz0gNDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkOlxuICAgICAgICAgICAgICAgIGxldCBsZW4gPSB0aGlzLnVpbnQzMigpO1xuICAgICAgICAgICAgICAgIHRoaXMucG9zICs9IGxlbjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgV2lyZVR5cGUuU3RhcnRHcm91cDpcbiAgICAgICAgICAgICAgICAvLyBGcm9tIGRlc2NyaXB0b3IucHJvdG86IEdyb3VwIHR5cGUgaXMgZGVwcmVjYXRlZCwgbm90IHN1cHBvcnRlZCBpbiBwcm90bzMuXG4gICAgICAgICAgICAgICAgLy8gQnV0IHdlIG11c3Qgc3RpbGwgYmUgYWJsZSB0byBwYXJzZSBhbmQgdHJlYXQgYXMgdW5rbm93bi5cbiAgICAgICAgICAgICAgICBsZXQgdDtcbiAgICAgICAgICAgICAgICB3aGlsZSAoKHQgPSB0aGlzLnRhZygpWzFdKSAhPT0gV2lyZVR5cGUuRW5kR3JvdXApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5za2lwKHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY2FudCBza2lwIHdpcmUgdHlwZSBcIiArIHdpcmVUeXBlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFzc2VydEJvdW5kcygpO1xuICAgICAgICByZXR1cm4gdGhpcy5idWYuc3ViYXJyYXkoc3RhcnQsIHRoaXMucG9zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhyb3dzIGVycm9yIGlmIHBvc2l0aW9uIGluIGJ5dGUgYXJyYXkgaXMgb3V0IG9mIHJhbmdlLlxuICAgICAqL1xuICAgIGFzc2VydEJvdW5kcygpIHtcbiAgICAgICAgaWYgKHRoaXMucG9zID4gdGhpcy5sZW4pXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcInByZW1hdHVyZSBFT0ZcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlYWQgYSBgaW50MzJgIGZpZWxkLCBhIHNpZ25lZCAzMiBiaXQgdmFyaW50LlxuICAgICAqL1xuICAgIGludDMyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy51aW50MzIoKSB8IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlYWQgYSBgc2ludDMyYCBmaWVsZCwgYSBzaWduZWQsIHppZ3phZy1lbmNvZGVkIDMyLWJpdCB2YXJpbnQuXG4gICAgICovXG4gICAgc2ludDMyKCkge1xuICAgICAgICBsZXQgenplID0gdGhpcy51aW50MzIoKTtcbiAgICAgICAgLy8gZGVjb2RlIHppZ3phZ1xuICAgICAgICByZXR1cm4gKHp6ZSA+Pj4gMSkgXiAtKHp6ZSAmIDEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWFkIGEgYGludDY0YCBmaWVsZCwgYSBzaWduZWQgNjQtYml0IHZhcmludC5cbiAgICAgKi9cbiAgICBpbnQ2NCgpIHtcbiAgICAgICAgcmV0dXJuIHByb3RvSW50NjQuZGVjKC4uLnRoaXMudmFyaW50NjQoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlYWQgYSBgdWludDY0YCBmaWVsZCwgYW4gdW5zaWduZWQgNjQtYml0IHZhcmludC5cbiAgICAgKi9cbiAgICB1aW50NjQoKSB7XG4gICAgICAgIHJldHVybiBwcm90b0ludDY0LnVEZWMoLi4udGhpcy52YXJpbnQ2NCgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVhZCBhIGBzaW50NjRgIGZpZWxkLCBhIHNpZ25lZCwgemlnLXphZy1lbmNvZGVkIDY0LWJpdCB2YXJpbnQuXG4gICAgICovXG4gICAgc2ludDY0KCkge1xuICAgICAgICBsZXQgW2xvLCBoaV0gPSB0aGlzLnZhcmludDY0KCk7XG4gICAgICAgIC8vIGRlY29kZSB6aWcgemFnXG4gICAgICAgIGxldCBzID0gLShsbyAmIDEpO1xuICAgICAgICBsbyA9ICgobG8gPj4+IDEpIHwgKChoaSAmIDEpIDw8IDMxKSkgXiBzO1xuICAgICAgICBoaSA9IChoaSA+Pj4gMSkgXiBzO1xuICAgICAgICByZXR1cm4gcHJvdG9JbnQ2NC5kZWMobG8sIGhpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVhZCBhIGBib29sYCBmaWVsZCwgYSB2YXJpYW50LlxuICAgICAqL1xuICAgIGJvb2woKSB7XG4gICAgICAgIGxldCBbbG8sIGhpXSA9IHRoaXMudmFyaW50NjQoKTtcbiAgICAgICAgcmV0dXJuIGxvICE9PSAwIHx8IGhpICE9PSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWFkIGEgYGZpeGVkMzJgIGZpZWxkLCBhbiB1bnNpZ25lZCwgZml4ZWQtbGVuZ3RoIDMyLWJpdCBpbnRlZ2VyLlxuICAgICAqL1xuICAgIGZpeGVkMzIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXcuZ2V0VWludDMyKCh0aGlzLnBvcyArPSA0KSAtIDQsIHRydWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWFkIGEgYHNmaXhlZDMyYCBmaWVsZCwgYSBzaWduZWQsIGZpeGVkLWxlbmd0aCAzMi1iaXQgaW50ZWdlci5cbiAgICAgKi9cbiAgICBzZml4ZWQzMigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlldy5nZXRJbnQzMigodGhpcy5wb3MgKz0gNCkgLSA0LCB0cnVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVhZCBhIGBmaXhlZDY0YCBmaWVsZCwgYW4gdW5zaWduZWQsIGZpeGVkLWxlbmd0aCA2NCBiaXQgaW50ZWdlci5cbiAgICAgKi9cbiAgICBmaXhlZDY0KCkge1xuICAgICAgICByZXR1cm4gcHJvdG9JbnQ2NC51RGVjKHRoaXMuc2ZpeGVkMzIoKSwgdGhpcy5zZml4ZWQzMigpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVhZCBhIGBmaXhlZDY0YCBmaWVsZCwgYSBzaWduZWQsIGZpeGVkLWxlbmd0aCA2NC1iaXQgaW50ZWdlci5cbiAgICAgKi9cbiAgICBzZml4ZWQ2NCgpIHtcbiAgICAgICAgcmV0dXJuIHByb3RvSW50NjQuZGVjKHRoaXMuc2ZpeGVkMzIoKSwgdGhpcy5zZml4ZWQzMigpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVhZCBhIGBmbG9hdGAgZmllbGQsIDMyLWJpdCBmbG9hdGluZyBwb2ludCBudW1iZXIuXG4gICAgICovXG4gICAgZmxvYXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXcuZ2V0RmxvYXQzMigodGhpcy5wb3MgKz0gNCkgLSA0LCB0cnVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVhZCBhIGBkb3VibGVgIGZpZWxkLCBhIDY0LWJpdCBmbG9hdGluZyBwb2ludCBudW1iZXIuXG4gICAgICovXG4gICAgZG91YmxlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3LmdldEZsb2F0NjQoKHRoaXMucG9zICs9IDgpIC0gOCwgdHJ1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlYWQgYSBgYnl0ZXNgIGZpZWxkLCBsZW5ndGgtZGVsaW1pdGVkIGFyYml0cmFyeSBkYXRhLlxuICAgICAqL1xuICAgIGJ5dGVzKCkge1xuICAgICAgICBsZXQgbGVuID0gdGhpcy51aW50MzIoKSwgc3RhcnQgPSB0aGlzLnBvcztcbiAgICAgICAgdGhpcy5wb3MgKz0gbGVuO1xuICAgICAgICB0aGlzLmFzc2VydEJvdW5kcygpO1xuICAgICAgICByZXR1cm4gdGhpcy5idWYuc3ViYXJyYXkoc3RhcnQsIHN0YXJ0ICsgbGVuKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVhZCBhIGBzdHJpbmdgIGZpZWxkLCBsZW5ndGgtZGVsaW1pdGVkIGRhdGEgY29udmVydGVkIHRvIFVURi04IHRleHQuXG4gICAgICovXG4gICAgc3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50ZXh0RGVjb2Rlci5kZWNvZGUodGhpcy5ieXRlcygpKTtcbiAgICB9XG59XG4iLCIvLyBDb3B5cmlnaHQgMjAyMS0yMDIzIEJ1ZiBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuaW1wb3J0IHsgTWVzc2FnZSB9IGZyb20gXCIuLi9tZXNzYWdlLmpzXCI7XG5pbXBvcnQgeyBTY2FsYXJUeXBlIH0gZnJvbSBcIi4uL2ZpZWxkLmpzXCI7XG4vKipcbiAqIFdyYXAgYSBwcmltaXRpdmUgbWVzc2FnZSBmaWVsZCB2YWx1ZSBpbiBpdHMgY29ycmVzcG9uZGluZyB3cmFwcGVyXG4gKiBtZXNzYWdlLiBUaGlzIGZ1bmN0aW9uIGlzIGlkZW1wb3RlbnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB3cmFwRmllbGQodHlwZSwgdmFsdWUpIHtcbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBNZXNzYWdlIHx8ICF0eXBlLmZpZWxkV3JhcHBlcikge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiB0eXBlLmZpZWxkV3JhcHBlci53cmFwRmllbGQodmFsdWUpO1xufVxuLyoqXG4gKiBJZiB0aGUgZ2l2ZW4gZmllbGQgdXNlcyBvbmUgb2YgdGhlIHdlbGwta25vd24gd3JhcHBlciB0eXBlcywgcmV0dXJuXG4gKiB0aGUgcHJpbWl0aXZlIHR5cGUgaXQgd3JhcHMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRVbndyYXBwZWRGaWVsZFR5cGUoZmllbGQpIHtcbiAgICBpZiAoZmllbGQuZmllbGRLaW5kICE9PSBcIm1lc3NhZ2VcIikge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBpZiAoZmllbGQucmVwZWF0ZWQpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaWYgKGZpZWxkLm9uZW9mICE9IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICByZXR1cm4gd2t0V3JhcHBlclRvU2NhbGFyVHlwZVtmaWVsZC5tZXNzYWdlLnR5cGVOYW1lXTtcbn1cbmNvbnN0IHdrdFdyYXBwZXJUb1NjYWxhclR5cGUgPSB7XG4gICAgXCJnb29nbGUucHJvdG9idWYuRG91YmxlVmFsdWVcIjogU2NhbGFyVHlwZS5ET1VCTEUsXG4gICAgXCJnb29nbGUucHJvdG9idWYuRmxvYXRWYWx1ZVwiOiBTY2FsYXJUeXBlLkZMT0FULFxuICAgIFwiZ29vZ2xlLnByb3RvYnVmLkludDY0VmFsdWVcIjogU2NhbGFyVHlwZS5JTlQ2NCxcbiAgICBcImdvb2dsZS5wcm90b2J1Zi5VSW50NjRWYWx1ZVwiOiBTY2FsYXJUeXBlLlVJTlQ2NCxcbiAgICBcImdvb2dsZS5wcm90b2J1Zi5JbnQzMlZhbHVlXCI6IFNjYWxhclR5cGUuSU5UMzIsXG4gICAgXCJnb29nbGUucHJvdG9idWYuVUludDMyVmFsdWVcIjogU2NhbGFyVHlwZS5VSU5UMzIsXG4gICAgXCJnb29nbGUucHJvdG9idWYuQm9vbFZhbHVlXCI6IFNjYWxhclR5cGUuQk9PTCxcbiAgICBcImdvb2dsZS5wcm90b2J1Zi5TdHJpbmdWYWx1ZVwiOiBTY2FsYXJUeXBlLlNUUklORyxcbiAgICBcImdvb2dsZS5wcm90b2J1Zi5CeXRlc1ZhbHVlXCI6IFNjYWxhclR5cGUuQllURVMsXG59O1xuIiwiLy8gQ29weXJpZ2h0IDIwMjEtMjAyMyBCdWYgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbmltcG9ydCB7IExvbmdUeXBlLCBTY2FsYXJUeXBlIH0gZnJvbSBcIi4uL2ZpZWxkLmpzXCI7XG5pbXBvcnQgeyBXaXJlVHlwZSB9IGZyb20gXCIuLi9iaW5hcnktZW5jb2RpbmcuanNcIjtcbmltcG9ydCB7IHByb3RvSW50NjQgfSBmcm9tIFwiLi4vcHJvdG8taW50NjQuanNcIjtcbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnkgKi9cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIGJvdGggc2NhbGFyIHZhbHVlcyBhcmUgZXF1YWwuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzY2FsYXJFcXVhbHModHlwZSwgYSwgYikge1xuICAgIGlmIChhID09PSBiKSB7XG4gICAgICAgIC8vIFRoaXMgY29ycmVjdGx5IG1hdGNoZXMgZXF1YWwgdmFsdWVzIGV4Y2VwdCBCWVRFUyBhbmQgKHBvc3NpYmx5KSA2NC1iaXQgaW50ZWdlcnMuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvLyBTcGVjaWFsIGNhc2UgQllURVMgLSB3ZSBuZWVkIHRvIGNvbXBhcmUgZWFjaCBieXRlIGluZGl2aWR1YWxseVxuICAgIGlmICh0eXBlID09IFNjYWxhclR5cGUuQllURVMpIHtcbiAgICAgICAgaWYgKCEoYSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHx8ICEoYiBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8vIFNwZWNpYWwgY2FzZSA2NC1iaXQgaW50ZWdlcnMgLSB3ZSBzdXBwb3J0IG51bWJlciwgc3RyaW5nIGFuZCBiaWdpbnQgcmVwcmVzZW50YXRpb24uXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9zd2l0Y2gtZXhoYXVzdGl2ZW5lc3MtY2hlY2tcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBTY2FsYXJUeXBlLlVJTlQ2NDpcbiAgICAgICAgY2FzZSBTY2FsYXJUeXBlLkZJWEVENjQ6XG4gICAgICAgIGNhc2UgU2NhbGFyVHlwZS5JTlQ2NDpcbiAgICAgICAgY2FzZSBTY2FsYXJUeXBlLlNGSVhFRDY0OlxuICAgICAgICBjYXNlIFNjYWxhclR5cGUuU0lOVDY0OlxuICAgICAgICAgICAgLy8gTG9vc2UgY29tcGFyaXNvbiB3aWxsIG1hdGNoIGJldHdlZW4gMG4sIDAgYW5kIFwiMFwiLlxuICAgICAgICAgICAgcmV0dXJuIGEgPT0gYjtcbiAgICB9XG4gICAgLy8gQW55dGhpbmcgdGhhdCBoYXNuJ3QgYmVlbiBjYXVnaHQgYnkgc3RyaWN0IGNvbXBhcmlzb24gb3Igc3BlY2lhbCBjYXNlZFxuICAgIC8vIEJZVEVTIGFuZCA2NC1iaXQgaW50ZWdlcnMgaXMgbm90IGVxdWFsLlxuICAgIHJldHVybiBmYWxzZTtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgZGVmYXVsdCB2YWx1ZSBmb3IgdGhlIGdpdmVuIHNjYWxhciB0eXBlLCBmb2xsb3dpbmdcbiAqIHByb3RvMyBzZW1hbnRpY3MuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzY2FsYXJEZWZhdWx0VmFsdWUodHlwZSwgbG9uZ1R5cGUpIHtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBTY2FsYXJUeXBlLkJPT0w6XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGNhc2UgU2NhbGFyVHlwZS5VSU5UNjQ6XG4gICAgICAgIGNhc2UgU2NhbGFyVHlwZS5GSVhFRDY0OlxuICAgICAgICBjYXNlIFNjYWxhclR5cGUuSU5UNjQ6XG4gICAgICAgIGNhc2UgU2NhbGFyVHlwZS5TRklYRUQ2NDpcbiAgICAgICAgY2FzZSBTY2FsYXJUeXBlLlNJTlQ2NDpcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWVudW0tY29tcGFyaXNvbiAtLSBhY2NlcHRhYmxlIHNpbmNlIGl0J3MgY292ZXJlZCBieSB0ZXN0c1xuICAgICAgICAgICAgcmV0dXJuIGxvbmdUeXBlID09IDAgPyBwcm90b0ludDY0Lnplcm8gOiBcIjBcIjtcbiAgICAgICAgY2FzZSBTY2FsYXJUeXBlLkRPVUJMRTpcbiAgICAgICAgY2FzZSBTY2FsYXJUeXBlLkZMT0FUOlxuICAgICAgICAgICAgcmV0dXJuIDAuMDtcbiAgICAgICAgY2FzZSBTY2FsYXJUeXBlLkJZVEVTOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KDApO1xuICAgICAgICBjYXNlIFNjYWxhclR5cGUuU1RSSU5HOlxuICAgICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAvLyBIYW5kbGVzIElOVDMyLCBVSU5UMzIsIFNJTlQzMiwgRklYRUQzMiwgU0ZJWEVEMzIuXG4gICAgICAgICAgICAvLyBXZSBkbyBub3QgdXNlIGluZGl2aWR1YWwgY2FzZXMgdG8gc2F2ZSBhIGZldyBieXRlcyBjb2RlIHNpemUuXG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICB9XG59XG4vKipcbiAqIEdldCBpbmZvcm1hdGlvbiBmb3Igd3JpdGluZyBhIHNjYWxhciB2YWx1ZS5cbiAqXG4gKiBSZXR1cm5zIHR1cGxlOlxuICogWzBdOiBhcHByb3ByaWF0ZSBXaXJlVHlwZVxuICogWzFdOiBuYW1lIG9mIHRoZSBhcHByb3ByaWF0ZSBtZXRob2Qgb2YgSUJpbmFyeVdyaXRlclxuICogWzJdOiB3aGV0aGVyIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIGRlZmF1bHQgdmFsdWUgZm9yIHByb3RvMyBzZW1hbnRpY3NcbiAqXG4gKiBJZiBhcmd1bWVudCBgdmFsdWVgIGlzIG9taXR0ZWQsIFsyXSBpcyBhbHdheXMgZmFsc2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzY2FsYXJUeXBlSW5mbyh0eXBlLCB2YWx1ZSkge1xuICAgIGNvbnN0IGlzVW5kZWZpbmVkID0gdmFsdWUgPT09IHVuZGVmaW5lZDtcbiAgICBsZXQgd2lyZVR5cGUgPSBXaXJlVHlwZS5WYXJpbnQ7XG4gICAgbGV0IGlzSW50cmluc2ljRGVmYXVsdCA9IHZhbHVlID09PSAwO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvc3dpdGNoLWV4aGF1c3RpdmVuZXNzLWNoZWNrIC0tIElOVDMyLCBVSU5UMzIsIFNJTlQzMiBhcmUgY292ZXJlZCBieSB0aGUgZGVmYXVsdHNcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBTY2FsYXJUeXBlLlNUUklORzpcbiAgICAgICAgICAgIGlzSW50cmluc2ljRGVmYXVsdCA9IGlzVW5kZWZpbmVkIHx8ICF2YWx1ZS5sZW5ndGg7XG4gICAgICAgICAgICB3aXJlVHlwZSA9IFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFNjYWxhclR5cGUuQk9PTDpcbiAgICAgICAgICAgIGlzSW50cmluc2ljRGVmYXVsdCA9IHZhbHVlID09PSBmYWxzZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFNjYWxhclR5cGUuRE9VQkxFOlxuICAgICAgICAgICAgd2lyZVR5cGUgPSBXaXJlVHlwZS5CaXQ2NDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFNjYWxhclR5cGUuRkxPQVQ6XG4gICAgICAgICAgICB3aXJlVHlwZSA9IFdpcmVUeXBlLkJpdDMyO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgU2NhbGFyVHlwZS5JTlQ2NDpcbiAgICAgICAgICAgIGlzSW50cmluc2ljRGVmYXVsdCA9IGlzVW5kZWZpbmVkIHx8IHZhbHVlID09IDA7IC8vIExvb3NlIGNvbXBhcmlzb24gbWF0Y2hlcyAwbiwgMCBhbmQgXCIwXCJcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFNjYWxhclR5cGUuVUlOVDY0OlxuICAgICAgICAgICAgaXNJbnRyaW5zaWNEZWZhdWx0ID0gaXNVbmRlZmluZWQgfHwgdmFsdWUgPT0gMDsgLy8gTG9vc2UgY29tcGFyaXNvbiBtYXRjaGVzIDBuLCAwIGFuZCBcIjBcIlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgU2NhbGFyVHlwZS5GSVhFRDY0OlxuICAgICAgICAgICAgaXNJbnRyaW5zaWNEZWZhdWx0ID0gaXNVbmRlZmluZWQgfHwgdmFsdWUgPT0gMDsgLy8gTG9vc2UgY29tcGFyaXNvbiBtYXRjaGVzIDBuLCAwIGFuZCBcIjBcIlxuICAgICAgICAgICAgd2lyZVR5cGUgPSBXaXJlVHlwZS5CaXQ2NDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFNjYWxhclR5cGUuQllURVM6XG4gICAgICAgICAgICBpc0ludHJpbnNpY0RlZmF1bHQgPSBpc1VuZGVmaW5lZCB8fCAhdmFsdWUuYnl0ZUxlbmd0aDtcbiAgICAgICAgICAgIHdpcmVUeXBlID0gV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgU2NhbGFyVHlwZS5GSVhFRDMyOlxuICAgICAgICAgICAgd2lyZVR5cGUgPSBXaXJlVHlwZS5CaXQzMjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFNjYWxhclR5cGUuU0ZJWEVEMzI6XG4gICAgICAgICAgICB3aXJlVHlwZSA9IFdpcmVUeXBlLkJpdDMyO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgU2NhbGFyVHlwZS5TRklYRUQ2NDpcbiAgICAgICAgICAgIGlzSW50cmluc2ljRGVmYXVsdCA9IGlzVW5kZWZpbmVkIHx8IHZhbHVlID09IDA7XG4gICAgICAgICAgICB3aXJlVHlwZSA9IFdpcmVUeXBlLkJpdDY0O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgU2NhbGFyVHlwZS5TSU5UNjQ6XG4gICAgICAgICAgICBpc0ludHJpbnNpY0RlZmF1bHQgPSBpc1VuZGVmaW5lZCB8fCB2YWx1ZSA9PSAwO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNvbnN0IG1ldGhvZCA9IFNjYWxhclR5cGVbdHlwZV0udG9Mb3dlckNhc2UoKTtcbiAgICByZXR1cm4gW3dpcmVUeXBlLCBtZXRob2QsIGlzVW5kZWZpbmVkIHx8IGlzSW50cmluc2ljRGVmYXVsdF07XG59XG4iLCIvLyBDb3B5cmlnaHQgMjAyMS0yMDIzIEJ1ZiBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuaW1wb3J0IHsgQmluYXJ5UmVhZGVyLCBCaW5hcnlXcml0ZXIsIFdpcmVUeXBlIH0gZnJvbSBcIi4uL2JpbmFyeS1lbmNvZGluZy5qc1wiO1xuaW1wb3J0IHsgTWVzc2FnZSB9IGZyb20gXCIuLi9tZXNzYWdlLmpzXCI7XG5pbXBvcnQgeyBMb25nVHlwZSwgU2NhbGFyVHlwZSB9IGZyb20gXCIuLi9maWVsZC5qc1wiO1xuaW1wb3J0IHsgd3JhcEZpZWxkIH0gZnJvbSBcIi4vZmllbGQtd3JhcHBlci5qc1wiO1xuaW1wb3J0IHsgc2NhbGFyRGVmYXVsdFZhbHVlLCBzY2FsYXJUeXBlSW5mbyB9IGZyb20gXCIuL3NjYWxhcnMuanNcIjtcbmltcG9ydCB7IGFzc2VydCB9IGZyb20gXCIuL2Fzc2VydC5qc1wiO1xuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1yZXR1cm4sIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtbWVtYmVyLWFjY2VzcywgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSwgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hcmd1bWVudCwgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hc3NpZ25tZW50LCBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWNhbGwsIEB0eXBlc2NyaXB0LWVzbGludC9uby11bm5lY2Vzc2FyeS1jb25kaXRpb24sIG5vLWNhc2UtZGVjbGFyYXRpb25zLCBwcmVmZXItY29uc3QgKi9cbmNvbnN0IHVua25vd25GaWVsZHNTeW1ib2wgPSBTeW1ib2woXCJAYnVmYnVpbGQvcHJvdG9idWYvdW5rbm93bi1maWVsZHNcIik7XG4vLyBEZWZhdWx0IG9wdGlvbnMgZm9yIHBhcnNpbmcgYmluYXJ5IGRhdGEuXG5jb25zdCByZWFkRGVmYXVsdHMgPSB7XG4gICAgcmVhZFVua25vd25GaWVsZHM6IHRydWUsXG4gICAgcmVhZGVyRmFjdG9yeTogKGJ5dGVzKSA9PiBuZXcgQmluYXJ5UmVhZGVyKGJ5dGVzKSxcbn07XG4vLyBEZWZhdWx0IG9wdGlvbnMgZm9yIHNlcmlhbGl6aW5nIGJpbmFyeSBkYXRhLlxuY29uc3Qgd3JpdGVEZWZhdWx0cyA9IHtcbiAgICB3cml0ZVVua25vd25GaWVsZHM6IHRydWUsXG4gICAgd3JpdGVyRmFjdG9yeTogKCkgPT4gbmV3IEJpbmFyeVdyaXRlcigpLFxufTtcbmZ1bmN0aW9uIG1ha2VSZWFkT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMgPyBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHJlYWREZWZhdWx0cyksIG9wdGlvbnMpIDogcmVhZERlZmF1bHRzO1xufVxuZnVuY3Rpb24gbWFrZVdyaXRlT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMgPyBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHdyaXRlRGVmYXVsdHMpLCBvcHRpb25zKSA6IHdyaXRlRGVmYXVsdHM7XG59XG5leHBvcnQgZnVuY3Rpb24gbWFrZUJpbmFyeUZvcm1hdENvbW1vbigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBtYWtlUmVhZE9wdGlvbnMsXG4gICAgICAgIG1ha2VXcml0ZU9wdGlvbnMsXG4gICAgICAgIGxpc3RVbmtub3duRmllbGRzKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIHJldHVybiAoX2EgPSBtZXNzYWdlW3Vua25vd25GaWVsZHNTeW1ib2xdKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBbXTtcbiAgICAgICAgfSxcbiAgICAgICAgZGlzY2FyZFVua25vd25GaWVsZHMobWVzc2FnZSkge1xuICAgICAgICAgICAgZGVsZXRlIG1lc3NhZ2VbdW5rbm93bkZpZWxkc1N5bWJvbF07XG4gICAgICAgIH0sXG4gICAgICAgIHdyaXRlVW5rbm93bkZpZWxkcyhtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IG0gPSBtZXNzYWdlO1xuICAgICAgICAgICAgY29uc3QgYyA9IG1bdW5rbm93bkZpZWxkc1N5bWJvbF07XG4gICAgICAgICAgICBpZiAoYykge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZiBvZiBjKSB7XG4gICAgICAgICAgICAgICAgICAgIHdyaXRlci50YWcoZi5ubywgZi53aXJlVHlwZSkucmF3KGYuZGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBvblVua25vd25GaWVsZChtZXNzYWdlLCBubywgd2lyZVR5cGUsIGRhdGEpIHtcbiAgICAgICAgICAgIGNvbnN0IG0gPSBtZXNzYWdlO1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG1bdW5rbm93bkZpZWxkc1N5bWJvbF0pKSB7XG4gICAgICAgICAgICAgICAgbVt1bmtub3duRmllbGRzU3ltYm9sXSA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbVt1bmtub3duRmllbGRzU3ltYm9sXS5wdXNoKHsgbm8sIHdpcmVUeXBlLCBkYXRhIH0pO1xuICAgICAgICB9LFxuICAgICAgICByZWFkTWVzc2FnZShtZXNzYWdlLCByZWFkZXIsIGxlbmd0aCwgb3B0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgdHlwZSA9IG1lc3NhZ2UuZ2V0VHlwZSgpO1xuICAgICAgICAgICAgY29uc3QgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgW2ZpZWxkTm8sIHdpcmVUeXBlXSA9IHJlYWRlci50YWcoKSwgZmllbGQgPSB0eXBlLmZpZWxkcy5maW5kKGZpZWxkTm8pO1xuICAgICAgICAgICAgICAgIGlmICghZmllbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IHJlYWRlci5za2lwKHdpcmVUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMucmVhZFVua25vd25GaWVsZHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub25Vbmtub3duRmllbGQobWVzc2FnZSwgZmllbGRObywgd2lyZVR5cGUsIGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgdGFyZ2V0ID0gbWVzc2FnZSwgcmVwZWF0ZWQgPSBmaWVsZC5yZXBlYXRlZCwgbG9jYWxOYW1lID0gZmllbGQubG9jYWxOYW1lO1xuICAgICAgICAgICAgICAgIGlmIChmaWVsZC5vbmVvZikge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXQgPSB0YXJnZXRbZmllbGQub25lb2YubG9jYWxOYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRhcmdldC5jYXNlICE9IGxvY2FsTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRhcmdldC52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0YXJnZXQuY2FzZSA9IGxvY2FsTmFtZTtcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxOYW1lID0gXCJ2YWx1ZVwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGZpZWxkLmtpbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInNjYWxhclwiOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZW51bVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2NhbGFyVHlwZSA9IGZpZWxkLmtpbmQgPT0gXCJlbnVtXCIgPyBTY2FsYXJUeXBlLklOVDMyIDogZmllbGQuVDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCByZWFkID0gcmVhZFNjYWxhcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWVudW0tY29tcGFyaXNvbiAtLSBhY2NlcHRhYmxlIHNpbmNlIGl0J3MgY292ZXJlZCBieSB0ZXN0c1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpZWxkLmtpbmQgPT0gXCJzY2FsYXJcIiAmJiBmaWVsZC5MID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYWQgPSByZWFkU2NhbGFyTFRTdHJpbmc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVwZWF0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgYXJyID0gdGFyZ2V0W2xvY2FsTmFtZV07IC8vIHNhZmUgdG8gYXNzdW1lIHByZXNlbmNlIG9mIGFycmF5LCBvbmVvZiBjYW5ub3QgY29udGFpbiByZXBlYXRlZCB2YWx1ZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAod2lyZVR5cGUgPT0gV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjYWxhclR5cGUgIT0gU2NhbGFyVHlwZS5TVFJJTkcgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NhbGFyVHlwZSAhPSBTY2FsYXJUeXBlLkJZVEVTKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBlID0gcmVhZGVyLnVpbnQzMigpICsgcmVhZGVyLnBvcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcnIucHVzaChyZWFkKHJlYWRlciwgc2NhbGFyVHlwZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcnIucHVzaChyZWFkKHJlYWRlciwgc2NhbGFyVHlwZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldFtsb2NhbE5hbWVdID0gcmVhZChyZWFkZXIsIHNjYWxhclR5cGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJtZXNzYWdlXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtZXNzYWdlVHlwZSA9IGZpZWxkLlQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVwZWF0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzYWZlIHRvIGFzc3VtZSBwcmVzZW5jZSBvZiBhcnJheSwgb25lb2YgY2Fubm90IGNvbnRhaW4gcmVwZWF0ZWQgdmFsdWVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W2xvY2FsTmFtZV0ucHVzaChyZWFkTWVzc2FnZUZpZWxkKHJlYWRlciwgbmV3IG1lc3NhZ2VUeXBlKCksIG9wdGlvbnMpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXRbbG9jYWxOYW1lXSBpbnN0YW5jZW9mIE1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhZE1lc3NhZ2VGaWVsZChyZWFkZXIsIHRhcmdldFtsb2NhbE5hbWVdLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldFtsb2NhbE5hbWVdID0gcmVhZE1lc3NhZ2VGaWVsZChyZWFkZXIsIG5ldyBtZXNzYWdlVHlwZSgpLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2VUeXBlLmZpZWxkV3JhcHBlciAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIWZpZWxkLm9uZW9mICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAhZmllbGQucmVwZWF0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldFtsb2NhbE5hbWVdID0gbWVzc2FnZVR5cGUuZmllbGRXcmFwcGVyLnVud3JhcEZpZWxkKHRhcmdldFtsb2NhbE5hbWVdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwibWFwXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgW21hcEtleSwgbWFwVmFsXSA9IHJlYWRNYXBFbnRyeShmaWVsZCwgcmVhZGVyLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNhZmUgdG8gYXNzdW1lIHByZXNlbmNlIG9mIG1hcCBvYmplY3QsIG9uZW9mIGNhbm5vdCBjb250YWluIHJlcGVhdGVkIHZhbHVlc1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W2xvY2FsTmFtZV1bbWFwS2V5XSA9IG1hcFZhbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICB9O1xufVxuLy8gUmVhZCBhIG1lc3NhZ2UsIGF2b2lkaW5nIE1lc3NhZ2VUeXBlLmZyb21CaW5hcnkoKSB0byByZS11c2UgdGhlXG4vLyBCaW5hcnlSZWFkT3B0aW9ucyBhbmQgdGhlIElCaW5hcnlSZWFkZXIuXG5mdW5jdGlvbiByZWFkTWVzc2FnZUZpZWxkKHJlYWRlciwgbWVzc2FnZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IGZvcm1hdCA9IG1lc3NhZ2UuZ2V0VHlwZSgpLnJ1bnRpbWUuYmluO1xuICAgIGZvcm1hdC5yZWFkTWVzc2FnZShtZXNzYWdlLCByZWFkZXIsIHJlYWRlci51aW50MzIoKSwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIG1lc3NhZ2U7XG59XG4vLyBSZWFkIGEgbWFwIGZpZWxkLCBleHBlY3Rpbmcga2V5IGZpZWxkID0gMSwgdmFsdWUgZmllbGQgPSAyXG5mdW5jdGlvbiByZWFkTWFwRW50cnkoZmllbGQsIHJlYWRlciwgb3B0aW9ucykge1xuICAgIGNvbnN0IGxlbmd0aCA9IHJlYWRlci51aW50MzIoKSwgZW5kID0gcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICBsZXQga2V5LCB2YWw7XG4gICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgbGV0IFtmaWVsZE5vXSA9IHJlYWRlci50YWcoKTtcbiAgICAgICAgc3dpdGNoIChmaWVsZE5vKSB7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAga2V5ID0gcmVhZFNjYWxhcihyZWFkZXIsIGZpZWxkLkspO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIHN3aXRjaCAoZmllbGQuVi5raW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJzY2FsYXJcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbCA9IHJlYWRTY2FsYXIocmVhZGVyLCBmaWVsZC5WLlQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJlbnVtXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWwgPSByZWFkZXIuaW50MzIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwibWVzc2FnZVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsID0gcmVhZE1lc3NhZ2VGaWVsZChyZWFkZXIsIG5ldyBmaWVsZC5WLlQoKSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGtleSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCBrZXlSYXcgPSBzY2FsYXJEZWZhdWx0VmFsdWUoZmllbGQuSywgTG9uZ1R5cGUuQklHSU5UKTtcbiAgICAgICAga2V5ID1cbiAgICAgICAgICAgIGZpZWxkLksgPT0gU2NhbGFyVHlwZS5CT09MXG4gICAgICAgICAgICAgICAgPyBrZXlSYXcudG9TdHJpbmcoKVxuICAgICAgICAgICAgICAgIDoga2V5UmF3O1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGtleSAhPSBcInN0cmluZ1wiICYmIHR5cGVvZiBrZXkgIT0gXCJudW1iZXJcIikge1xuICAgICAgICBrZXkgPSBrZXkudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgaWYgKHZhbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHN3aXRjaCAoZmllbGQuVi5raW5kKSB7XG4gICAgICAgICAgICBjYXNlIFwic2NhbGFyXCI6XG4gICAgICAgICAgICAgICAgdmFsID0gc2NhbGFyRGVmYXVsdFZhbHVlKGZpZWxkLlYuVCwgTG9uZ1R5cGUuQklHSU5UKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJlbnVtXCI6XG4gICAgICAgICAgICAgICAgdmFsID0gMDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJtZXNzYWdlXCI6XG4gICAgICAgICAgICAgICAgdmFsID0gbmV3IGZpZWxkLlYuVCgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBba2V5LCB2YWxdO1xufVxuLy8gUmVhZCBhIHNjYWxhciB2YWx1ZSwgYnV0IHJldHVybiA2NCBiaXQgaW50ZWdyYWwgdHlwZXMgKGludDY0LCB1aW50NjQsXG4vLyBzaW50NjQsIGZpeGVkNjQsIHNmaXhlZDY0KSBhcyBzdHJpbmcgaW5zdGVhZCBvZiBiaWdpbnQuXG5leHBvcnQgZnVuY3Rpb24gcmVhZFNjYWxhckxUU3RyaW5nKHJlYWRlciwgdHlwZSkge1xuICAgIGNvbnN0IHYgPSByZWFkU2NhbGFyKHJlYWRlciwgdHlwZSk7XG4gICAgcmV0dXJuIHR5cGVvZiB2ID09IFwiYmlnaW50XCIgPyB2LnRvU3RyaW5nKCkgOiB2O1xufVxuLy8gRG9lcyBub3QgdXNlIHNjYWxhclR5cGVJbmZvKCkgZm9yIGJldHRlciBwZXJmb3JtYW5jZS5cbmZ1bmN0aW9uIHJlYWRTY2FsYXIocmVhZGVyLCB0eXBlKSB7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgU2NhbGFyVHlwZS5TVFJJTkc6XG4gICAgICAgICAgICByZXR1cm4gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICBjYXNlIFNjYWxhclR5cGUuQk9PTDpcbiAgICAgICAgICAgIHJldHVybiByZWFkZXIuYm9vbCgpO1xuICAgICAgICBjYXNlIFNjYWxhclR5cGUuRE9VQkxFOlxuICAgICAgICAgICAgcmV0dXJuIHJlYWRlci5kb3VibGUoKTtcbiAgICAgICAgY2FzZSBTY2FsYXJUeXBlLkZMT0FUOlxuICAgICAgICAgICAgcmV0dXJuIHJlYWRlci5mbG9hdCgpO1xuICAgICAgICBjYXNlIFNjYWxhclR5cGUuSU5UMzI6XG4gICAgICAgICAgICByZXR1cm4gcmVhZGVyLmludDMyKCk7XG4gICAgICAgIGNhc2UgU2NhbGFyVHlwZS5JTlQ2NDpcbiAgICAgICAgICAgIHJldHVybiByZWFkZXIuaW50NjQoKTtcbiAgICAgICAgY2FzZSBTY2FsYXJUeXBlLlVJTlQ2NDpcbiAgICAgICAgICAgIHJldHVybiByZWFkZXIudWludDY0KCk7XG4gICAgICAgIGNhc2UgU2NhbGFyVHlwZS5GSVhFRDY0OlxuICAgICAgICAgICAgcmV0dXJuIHJlYWRlci5maXhlZDY0KCk7XG4gICAgICAgIGNhc2UgU2NhbGFyVHlwZS5CWVRFUzpcbiAgICAgICAgICAgIHJldHVybiByZWFkZXIuYnl0ZXMoKTtcbiAgICAgICAgY2FzZSBTY2FsYXJUeXBlLkZJWEVEMzI6XG4gICAgICAgICAgICByZXR1cm4gcmVhZGVyLmZpeGVkMzIoKTtcbiAgICAgICAgY2FzZSBTY2FsYXJUeXBlLlNGSVhFRDMyOlxuICAgICAgICAgICAgcmV0dXJuIHJlYWRlci5zZml4ZWQzMigpO1xuICAgICAgICBjYXNlIFNjYWxhclR5cGUuU0ZJWEVENjQ6XG4gICAgICAgICAgICByZXR1cm4gcmVhZGVyLnNmaXhlZDY0KCk7XG4gICAgICAgIGNhc2UgU2NhbGFyVHlwZS5TSU5UNjQ6XG4gICAgICAgICAgICByZXR1cm4gcmVhZGVyLnNpbnQ2NCgpO1xuICAgICAgICBjYXNlIFNjYWxhclR5cGUuVUlOVDMyOlxuICAgICAgICAgICAgcmV0dXJuIHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgY2FzZSBTY2FsYXJUeXBlLlNJTlQzMjpcbiAgICAgICAgICAgIHJldHVybiByZWFkZXIuc2ludDMyKCk7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIHdyaXRlTWFwRW50cnkod3JpdGVyLCBvcHRpb25zLCBmaWVsZCwga2V5LCB2YWx1ZSkge1xuICAgIHdyaXRlci50YWcoZmllbGQubm8sIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCk7XG4gICAgd3JpdGVyLmZvcmsoKTtcbiAgICAvLyBqYXZhc2NyaXB0IG9ubHkgYWxsb3dzIG51bWJlciBvciBzdHJpbmcgZm9yIG9iamVjdCBwcm9wZXJ0aWVzXG4gICAgLy8gd2UgY29udmVydCBmcm9tIG91ciByZXByZXNlbnRhdGlvbiB0byB0aGUgcHJvdG9idWYgdHlwZVxuICAgIGxldCBrZXlWYWx1ZSA9IGtleTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3N3aXRjaC1leGhhdXN0aXZlbmVzcy1jaGVjayAtLSB3ZSBkZWxpYmVyYXRlbHkgaGFuZGxlIGp1c3QgdGhlIHNwZWNpYWwgY2FzZXMgZm9yIG1hcCBrZXlzXG4gICAgc3dpdGNoIChmaWVsZC5LKSB7XG4gICAgICAgIGNhc2UgU2NhbGFyVHlwZS5JTlQzMjpcbiAgICAgICAgY2FzZSBTY2FsYXJUeXBlLkZJWEVEMzI6XG4gICAgICAgIGNhc2UgU2NhbGFyVHlwZS5VSU5UMzI6XG4gICAgICAgIGNhc2UgU2NhbGFyVHlwZS5TRklYRUQzMjpcbiAgICAgICAgY2FzZSBTY2FsYXJUeXBlLlNJTlQzMjpcbiAgICAgICAgICAgIGtleVZhbHVlID0gTnVtYmVyLnBhcnNlSW50KGtleSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBTY2FsYXJUeXBlLkJPT0w6XG4gICAgICAgICAgICBhc3NlcnQoa2V5ID09IFwidHJ1ZVwiIHx8IGtleSA9PSBcImZhbHNlXCIpO1xuICAgICAgICAgICAga2V5VmFsdWUgPSBrZXkgPT0gXCJ0cnVlXCI7XG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgLy8gd3JpdGUga2V5LCBleHBlY3Rpbmcga2V5IGZpZWxkIG51bWJlciA9IDFcbiAgICB3cml0ZVNjYWxhcih3cml0ZXIsIGZpZWxkLkssIDEsIGtleVZhbHVlLCB0cnVlKTtcbiAgICAvLyB3cml0ZSB2YWx1ZSwgZXhwZWN0aW5nIHZhbHVlIGZpZWxkIG51bWJlciA9IDJcbiAgICBzd2l0Y2ggKGZpZWxkLlYua2luZCkge1xuICAgICAgICBjYXNlIFwic2NhbGFyXCI6XG4gICAgICAgICAgICB3cml0ZVNjYWxhcih3cml0ZXIsIGZpZWxkLlYuVCwgMiwgdmFsdWUsIHRydWUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJlbnVtXCI6XG4gICAgICAgICAgICB3cml0ZVNjYWxhcih3cml0ZXIsIFNjYWxhclR5cGUuSU5UMzIsIDIsIHZhbHVlLCB0cnVlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwibWVzc2FnZVwiOlxuICAgICAgICAgICAgd3JpdGVNZXNzYWdlRmllbGQod3JpdGVyLCBvcHRpb25zLCBmaWVsZC5WLlQsIDIsIHZhbHVlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICB3cml0ZXIuam9pbigpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHdyaXRlTWVzc2FnZUZpZWxkKHdyaXRlciwgb3B0aW9ucywgdHlwZSwgZmllbGRObywgdmFsdWUpIHtcbiAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gd3JhcEZpZWxkKHR5cGUsIHZhbHVlKTtcbiAgICAgICAgd3JpdGVyXG4gICAgICAgICAgICAudGFnKGZpZWxkTm8sIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZClcbiAgICAgICAgICAgIC5ieXRlcyhtZXNzYWdlLnRvQmluYXJ5KG9wdGlvbnMpKTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gd3JpdGVTY2FsYXIod3JpdGVyLCB0eXBlLCBmaWVsZE5vLCB2YWx1ZSwgZW1pdEludHJpbnNpY0RlZmF1bHQpIHtcbiAgICBsZXQgW3dpcmVUeXBlLCBtZXRob2QsIGlzSW50cmluc2ljRGVmYXVsdF0gPSBzY2FsYXJUeXBlSW5mbyh0eXBlLCB2YWx1ZSk7XG4gICAgaWYgKCFpc0ludHJpbnNpY0RlZmF1bHQgfHwgZW1pdEludHJpbnNpY0RlZmF1bHQpIHtcbiAgICAgICAgd3JpdGVyLnRhZyhmaWVsZE5vLCB3aXJlVHlwZSlbbWV0aG9kXSh2YWx1ZSk7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIHdyaXRlUGFja2VkKHdyaXRlciwgdHlwZSwgZmllbGRObywgdmFsdWUpIHtcbiAgICBpZiAoIXZhbHVlLmxlbmd0aCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHdyaXRlci50YWcoZmllbGRObywgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5mb3JrKCk7XG4gICAgbGV0IFssIG1ldGhvZF0gPSBzY2FsYXJUeXBlSW5mbyh0eXBlKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHdyaXRlclttZXRob2RdKHZhbHVlW2ldKTtcbiAgICB9XG4gICAgd3JpdGVyLmpvaW4oKTtcbn1cbiIsIi8vIENvcHlyaWdodCAyMDIxLTIwMjMgQnVmIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5pbXBvcnQgeyBTY2FsYXJUeXBlIH0gZnJvbSBcIi4uL2ZpZWxkLmpzXCI7XG5pbXBvcnQgeyBtYWtlQmluYXJ5Rm9ybWF0Q29tbW9uLCB3cml0ZU1hcEVudHJ5LCB3cml0ZU1lc3NhZ2VGaWVsZCwgd3JpdGVQYWNrZWQsIHdyaXRlU2NhbGFyLCB9IGZyb20gXCIuL2JpbmFyeS1mb3JtYXQtY29tbW9uLmpzXCI7XG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLW1lbWJlci1hY2Nlc3MsIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXJndW1lbnQsIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXNzaWdubWVudCwgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVubmVjZXNzYXJ5LWNvbmRpdGlvbiwgQHR5cGVzY3JpcHQtZXNsaW50L3N0cmljdC1ib29sZWFuLWV4cHJlc3Npb25zLCBwcmVmZXItY29uc3QsIG5vLWNhc2UtZGVjbGFyYXRpb25zICovXG5leHBvcnQgZnVuY3Rpb24gbWFrZUJpbmFyeUZvcm1hdFByb3RvMygpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBtYWtlQmluYXJ5Rm9ybWF0Q29tbW9uKCkpLCB7IHdyaXRlTWVzc2FnZShtZXNzYWdlLCB3cml0ZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IHR5cGUgPSBtZXNzYWdlLmdldFR5cGUoKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZmllbGQgb2YgdHlwZS5maWVsZHMuYnlOdW1iZXIoKSkge1xuICAgICAgICAgICAgICAgIGxldCB2YWx1ZSwgLy8gdGhpcyB3aWxsIGJlIG91ciBmaWVsZCB2YWx1ZSwgd2hldGhlciBpdCBpcyBtZW1iZXIgb2YgYSBvbmVvZiBvciByZWd1bGFyIGZpZWxkXG4gICAgICAgICAgICAgICAgcmVwZWF0ZWQgPSBmaWVsZC5yZXBlYXRlZCwgbG9jYWxOYW1lID0gZmllbGQubG9jYWxOYW1lO1xuICAgICAgICAgICAgICAgIGlmIChmaWVsZC5vbmVvZikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvbmVvZiA9IG1lc3NhZ2VbZmllbGQub25lb2YubG9jYWxOYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9uZW9mLmNhc2UgIT09IGxvY2FsTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7IC8vIGZpZWxkIGlzIG5vdCBzZWxlY3RlZCwgc2tpcFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gb25lb2YudmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IG1lc3NhZ2VbbG9jYWxOYW1lXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3dpdGNoIChmaWVsZC5raW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJzY2FsYXJcIjpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImVudW1cIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBzY2FsYXJUeXBlID0gZmllbGQua2luZCA9PSBcImVudW1cIiA/IFNjYWxhclR5cGUuSU5UMzIgOiBmaWVsZC5UO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlcGVhdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpZWxkLnBhY2tlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3cml0ZVBhY2tlZCh3cml0ZXIsIHNjYWxhclR5cGUsIGZpZWxkLm5vLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdyaXRlU2NhbGFyKHdyaXRlciwgc2NhbGFyVHlwZSwgZmllbGQubm8sIGl0ZW0sIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd3JpdGVTY2FsYXIod3JpdGVyLCBzY2FsYXJUeXBlLCBmaWVsZC5ubywgdmFsdWUsICEhZmllbGQub25lb2YgfHwgZmllbGQub3B0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm1lc3NhZ2VcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXBlYXRlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3cml0ZU1lc3NhZ2VGaWVsZCh3cml0ZXIsIG9wdGlvbnMsIGZpZWxkLlQsIGZpZWxkLm5vLCBpdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3cml0ZU1lc3NhZ2VGaWVsZCh3cml0ZXIsIG9wdGlvbnMsIGZpZWxkLlQsIGZpZWxkLm5vLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm1hcFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWxdIG9mIE9iamVjdC5lbnRyaWVzKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdyaXRlTWFwRW50cnkod3JpdGVyLCBvcHRpb25zLCBmaWVsZCwga2V5LCB2YWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdGlvbnMud3JpdGVVbmtub3duRmllbGRzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy53cml0ZVVua25vd25GaWVsZHMobWVzc2FnZSwgd3JpdGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgICAgIH0gfSk7XG59XG4iLCIvLyBDb3B5cmlnaHQgMjAyMS0yMDIzIEJ1ZiBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10cy1jb21tZW50LCBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5uZWNlc3NhcnktY29uZGl0aW9uLCBwcmVmZXItY29uc3QgKi9cbi8vIGxvb2t1cCB0YWJsZSBmcm9tIGJhc2U2NCBjaGFyYWN0ZXIgdG8gYnl0ZVxubGV0IGVuY1RhYmxlID0gXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvXCIuc3BsaXQoXCJcIik7XG4vLyBsb29rdXAgdGFibGUgZnJvbSBiYXNlNjQgY2hhcmFjdGVyICpjb2RlKiB0byBieXRlIGJlY2F1c2UgbG9va3VwIGJ5IG51bWJlciBpcyBmYXN0XG5sZXQgZGVjVGFibGUgPSBbXTtcbmZvciAobGV0IGkgPSAwOyBpIDwgZW5jVGFibGUubGVuZ3RoOyBpKyspXG4gICAgZGVjVGFibGVbZW5jVGFibGVbaV0uY2hhckNvZGVBdCgwKV0gPSBpO1xuLy8gc3VwcG9ydCBiYXNlNjR1cmwgdmFyaWFudHNcbmRlY1RhYmxlW1wiLVwiLmNoYXJDb2RlQXQoMCldID0gZW5jVGFibGUuaW5kZXhPZihcIitcIik7XG5kZWNUYWJsZVtcIl9cIi5jaGFyQ29kZUF0KDApXSA9IGVuY1RhYmxlLmluZGV4T2YoXCIvXCIpO1xuZXhwb3J0IGNvbnN0IHByb3RvQmFzZTY0ID0ge1xuICAgIC8qKlxuICAgICAqIERlY29kZXMgYSBiYXNlNjQgc3RyaW5nIHRvIGEgYnl0ZSBhcnJheS5cbiAgICAgKlxuICAgICAqIC0gaWdub3JlcyB3aGl0ZS1zcGFjZSwgaW5jbHVkaW5nIGxpbmUgYnJlYWtzIGFuZCB0YWJzXG4gICAgICogLSBhbGxvd3MgaW5uZXIgcGFkZGluZyAoY2FuIGRlY29kZSBjb25jYXRlbmF0ZWQgYmFzZTY0IHN0cmluZ3MpXG4gICAgICogLSBkb2VzIG5vdCByZXF1aXJlIHBhZGRpbmdcbiAgICAgKiAtIHVuZGVyc3RhbmRzIGJhc2U2NHVybCBlbmNvZGluZzpcbiAgICAgKiAgIFwiLVwiIGluc3RlYWQgb2YgXCIrXCIsXG4gICAgICogICBcIl9cIiBpbnN0ZWFkIG9mIFwiL1wiLFxuICAgICAqICAgbm8gcGFkZGluZ1xuICAgICAqL1xuICAgIGRlYyhiYXNlNjRTdHIpIHtcbiAgICAgICAgLy8gZXN0aW1hdGUgYnl0ZSBzaXplLCBub3QgYWNjb3VudGluZyBmb3IgaW5uZXIgcGFkZGluZyBhbmQgd2hpdGVzcGFjZVxuICAgICAgICBsZXQgZXMgPSAoYmFzZTY0U3RyLmxlbmd0aCAqIDMpIC8gNDtcbiAgICAgICAgaWYgKGJhc2U2NFN0cltiYXNlNjRTdHIubGVuZ3RoIC0gMl0gPT0gXCI9XCIpXG4gICAgICAgICAgICBlcyAtPSAyO1xuICAgICAgICBlbHNlIGlmIChiYXNlNjRTdHJbYmFzZTY0U3RyLmxlbmd0aCAtIDFdID09IFwiPVwiKVxuICAgICAgICAgICAgZXMgLT0gMTtcbiAgICAgICAgbGV0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoZXMpLCBieXRlUG9zID0gMCwgLy8gcG9zaXRpb24gaW4gYnl0ZSBhcnJheVxuICAgICAgICBncm91cFBvcyA9IDAsIC8vIHBvc2l0aW9uIGluIGJhc2U2NCBncm91cFxuICAgICAgICBiLCAvLyBjdXJyZW50IGJ5dGVcbiAgICAgICAgcCA9IDA7IC8vIHByZXZpb3VzIGJ5dGVcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBiYXNlNjRTdHIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGIgPSBkZWNUYWJsZVtiYXNlNjRTdHIuY2hhckNvZGVBdChpKV07XG4gICAgICAgICAgICBpZiAoYiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChiYXNlNjRTdHJbaV0pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZSBUUzcwMjk6IEZhbGx0aHJvdWdoIGNhc2UgaW4gc3dpdGNoXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCI9XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBncm91cFBvcyA9IDA7IC8vIHJlc2V0IHN0YXRlIHdoZW4gcGFkZGluZyBmb3VuZFxuICAgICAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlIFRTNzAyOTogRmFsbHRocm91Z2ggY2FzZSBpbiBzd2l0Y2hcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIlxcblwiOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiXFxyXCI6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJcXHRcIjpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIiBcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlOyAvLyBza2lwIHdoaXRlLXNwYWNlLCBhbmQgcGFkZGluZ1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJpbnZhbGlkIGJhc2U2NCBzdHJpbmcuXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN3aXRjaCAoZ3JvdXBQb3MpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgIHAgPSBiO1xuICAgICAgICAgICAgICAgICAgICBncm91cFBvcyA9IDE7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgYnl0ZXNbYnl0ZVBvcysrXSA9IChwIDw8IDIpIHwgKChiICYgNDgpID4+IDQpO1xuICAgICAgICAgICAgICAgICAgICBwID0gYjtcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXBQb3MgPSAyO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIGJ5dGVzW2J5dGVQb3MrK10gPSAoKHAgJiAxNSkgPDwgNCkgfCAoKGIgJiA2MCkgPj4gMik7XG4gICAgICAgICAgICAgICAgICAgIHAgPSBiO1xuICAgICAgICAgICAgICAgICAgICBncm91cFBvcyA9IDM7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgYnl0ZXNbYnl0ZVBvcysrXSA9ICgocCAmIDMpIDw8IDYpIHwgYjtcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXBQb3MgPSAwO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZ3JvdXBQb3MgPT0gMSlcbiAgICAgICAgICAgIHRocm93IEVycm9yKFwiaW52YWxpZCBiYXNlNjQgc3RyaW5nLlwiKTtcbiAgICAgICAgcmV0dXJuIGJ5dGVzLnN1YmFycmF5KDAsIGJ5dGVQb3MpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogRW5jb2RlIGEgYnl0ZSBhcnJheSB0byBhIGJhc2U2NCBzdHJpbmcuXG4gICAgICovXG4gICAgZW5jKGJ5dGVzKSB7XG4gICAgICAgIGxldCBiYXNlNjQgPSBcIlwiLCBncm91cFBvcyA9IDAsIC8vIHBvc2l0aW9uIGluIGJhc2U2NCBncm91cFxuICAgICAgICBiLCAvLyBjdXJyZW50IGJ5dGVcbiAgICAgICAgcCA9IDA7IC8vIGNhcnJ5IG92ZXIgZnJvbSBwcmV2aW91cyBieXRlXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGIgPSBieXRlc1tpXTtcbiAgICAgICAgICAgIHN3aXRjaCAoZ3JvdXBQb3MpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgIGJhc2U2NCArPSBlbmNUYWJsZVtiID4+IDJdO1xuICAgICAgICAgICAgICAgICAgICBwID0gKGIgJiAzKSA8PCA0O1xuICAgICAgICAgICAgICAgICAgICBncm91cFBvcyA9IDE7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgYmFzZTY0ICs9IGVuY1RhYmxlW3AgfCAoYiA+PiA0KV07XG4gICAgICAgICAgICAgICAgICAgIHAgPSAoYiAmIDE1KSA8PCAyO1xuICAgICAgICAgICAgICAgICAgICBncm91cFBvcyA9IDI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgYmFzZTY0ICs9IGVuY1RhYmxlW3AgfCAoYiA+PiA2KV07XG4gICAgICAgICAgICAgICAgICAgIGJhc2U2NCArPSBlbmNUYWJsZVtiICYgNjNdO1xuICAgICAgICAgICAgICAgICAgICBncm91cFBvcyA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGFkZCBvdXRwdXQgcGFkZGluZ1xuICAgICAgICBpZiAoZ3JvdXBQb3MpIHtcbiAgICAgICAgICAgIGJhc2U2NCArPSBlbmNUYWJsZVtwXTtcbiAgICAgICAgICAgIGJhc2U2NCArPSBcIj1cIjtcbiAgICAgICAgICAgIGlmIChncm91cFBvcyA9PSAxKVxuICAgICAgICAgICAgICAgIGJhc2U2NCArPSBcIj1cIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYmFzZTY0O1xuICAgIH0sXG59O1xuIiwiLy8gQ29weXJpZ2h0IDIwMjEtMjAyMyBCdWYgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbmltcG9ydCB7IE1lc3NhZ2UgfSBmcm9tIFwiLi4vbWVzc2FnZS5qc1wiO1xuaW1wb3J0IHsgTG9uZ1R5cGUsIFNjYWxhclR5cGUgfSBmcm9tIFwiLi4vZmllbGQuanNcIjtcbmltcG9ydCB7IGFzc2VydCwgYXNzZXJ0RmxvYXQzMiwgYXNzZXJ0SW50MzIsIGFzc2VydFVJbnQzMiB9IGZyb20gXCIuL2Fzc2VydC5qc1wiO1xuaW1wb3J0IHsgcHJvdG9JbnQ2NCB9IGZyb20gXCIuLi9wcm90by1pbnQ2NC5qc1wiO1xuaW1wb3J0IHsgcHJvdG9CYXNlNjQgfSBmcm9tIFwiLi4vcHJvdG8tYmFzZTY0LmpzXCI7XG4vKiBlc2xpbnQtZGlzYWJsZSBuby1jYXNlLWRlY2xhcmF0aW9ucywgQHR5cGVzY3JpcHQtZXNsaW50L3Jlc3RyaWN0LXBsdXMtb3BlcmFuZHMsQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSxAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFzc2lnbm1lbnQsQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1jYWxsLEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtbWVtYmVyLWFjY2VzcyxAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFyZ3VtZW50ICovXG4vLyBEZWZhdWx0IG9wdGlvbnMgZm9yIHBhcnNpbmcgSlNPTi5cbmNvbnN0IGpzb25SZWFkRGVmYXVsdHMgPSB7XG4gICAgaWdub3JlVW5rbm93bkZpZWxkczogZmFsc2UsXG59O1xuLy8gRGVmYXVsdCBvcHRpb25zIGZvciBzZXJpYWxpemluZyB0byBKU09OLlxuY29uc3QganNvbldyaXRlRGVmYXVsdHMgPSB7XG4gICAgZW1pdERlZmF1bHRWYWx1ZXM6IGZhbHNlLFxuICAgIGVudW1Bc0ludGVnZXI6IGZhbHNlLFxuICAgIHVzZVByb3RvRmllbGROYW1lOiBmYWxzZSxcbiAgICBwcmV0dHlTcGFjZXM6IDAsXG59O1xuZnVuY3Rpb24gbWFrZVJlYWRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gb3B0aW9ucyA/IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwganNvblJlYWREZWZhdWx0cyksIG9wdGlvbnMpIDoganNvblJlYWREZWZhdWx0cztcbn1cbmZ1bmN0aW9uIG1ha2VXcml0ZU9wdGlvbnMob3B0aW9ucykge1xuICAgIHJldHVybiBvcHRpb25zID8gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBqc29uV3JpdGVEZWZhdWx0cyksIG9wdGlvbnMpIDoganNvbldyaXRlRGVmYXVsdHM7XG59XG5leHBvcnQgZnVuY3Rpb24gbWFrZUpzb25Gb3JtYXRDb21tb24obWFrZVdyaXRlRmllbGQpIHtcbiAgICBjb25zdCB3cml0ZUZpZWxkID0gbWFrZVdyaXRlRmllbGQod3JpdGVFbnVtLCB3cml0ZVNjYWxhcik7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbWFrZVJlYWRPcHRpb25zLFxuICAgICAgICBtYWtlV3JpdGVPcHRpb25zLFxuICAgICAgICByZWFkTWVzc2FnZSh0eXBlLCBqc29uLCBvcHRpb25zLCBtZXNzYWdlKSB7XG4gICAgICAgICAgICBpZiAoanNvbiA9PSBudWxsIHx8IEFycmF5LmlzQXJyYXkoanNvbikgfHwgdHlwZW9mIGpzb24gIT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgY2Fubm90IGRlY29kZSBtZXNzYWdlICR7dHlwZS50eXBlTmFtZX0gZnJvbSBKU09OOiAke3RoaXMuZGVidWcoanNvbil9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtZXNzYWdlID0gbWVzc2FnZSAhPT0gbnVsbCAmJiBtZXNzYWdlICE9PSB2b2lkIDAgPyBtZXNzYWdlIDogbmV3IHR5cGUoKTtcbiAgICAgICAgICAgIGNvbnN0IG9uZW9mU2VlbiA9IHt9O1xuICAgICAgICAgICAgZm9yIChjb25zdCBbanNvbktleSwganNvblZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhqc29uKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpZWxkID0gdHlwZS5maWVsZHMuZmluZEpzb25OYW1lKGpzb25LZXkpO1xuICAgICAgICAgICAgICAgIGlmICghZmllbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFvcHRpb25zLmlnbm9yZVVua25vd25GaWVsZHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgY2Fubm90IGRlY29kZSBtZXNzYWdlICR7dHlwZS50eXBlTmFtZX0gZnJvbSBKU09OOiBrZXkgXCIke2pzb25LZXl9XCIgaXMgdW5rbm93bmApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgbG9jYWxOYW1lID0gZmllbGQubG9jYWxOYW1lO1xuICAgICAgICAgICAgICAgIGxldCB0YXJnZXQgPSBtZXNzYWdlO1xuICAgICAgICAgICAgICAgIGlmIChmaWVsZC5vbmVvZikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoanNvblZhbHVlID09PSBudWxsICYmIGZpZWxkLmtpbmQgPT0gXCJzY2FsYXJcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2VlIGNvbmZvcm1hbmNlIHRlc3QgUmVxdWlyZWQuUHJvdG8zLkpzb25JbnB1dC5PbmVvZkZpZWxkTnVsbHtGaXJzdCxTZWNvbmR9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzZWVuID0gb25lb2ZTZWVuW2ZpZWxkLm9uZW9mLmxvY2FsTmFtZV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWVuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNhbm5vdCBkZWNvZGUgbWVzc2FnZSAke3R5cGUudHlwZU5hbWV9IGZyb20gSlNPTjogbXVsdGlwbGUga2V5cyBmb3Igb25lb2YgXCIke2ZpZWxkLm9uZW9mLm5hbWV9XCIgcHJlc2VudDogXCIke3NlZW59XCIsIFwiJHtqc29uS2V5fVwiYCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgb25lb2ZTZWVuW2ZpZWxkLm9uZW9mLmxvY2FsTmFtZV0gPSBqc29uS2V5O1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXQgPSB0YXJnZXRbZmllbGQub25lb2YubG9jYWxOYW1lXSA9IHsgY2FzZTogbG9jYWxOYW1lIH07XG4gICAgICAgICAgICAgICAgICAgIGxvY2FsTmFtZSA9IFwidmFsdWVcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGZpZWxkLnJlcGVhdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChqc29uVmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShqc29uVmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNhbm5vdCBkZWNvZGUgZmllbGQgJHt0eXBlLnR5cGVOYW1lfS4ke2ZpZWxkLm5hbWV9IGZyb20gSlNPTjogJHt0aGlzLmRlYnVnKGpzb25WYWx1ZSl9YCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGFyZ2V0QXJyYXkgPSB0YXJnZXRbbG9jYWxOYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBqc29uSXRlbSBvZiBqc29uVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChqc29uSXRlbSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgY2Fubm90IGRlY29kZSBmaWVsZCAke3R5cGUudHlwZU5hbWV9LiR7ZmllbGQubmFtZX0gZnJvbSBKU09OOiAke3RoaXMuZGVidWcoanNvbkl0ZW0pfWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHZhbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvc3dpdGNoLWV4aGF1c3RpdmVuZXNzLWNoZWNrIC0tIFwibWFwXCIgaXMgaW52YWxpZCBmb3IgcmVwZWF0ZWQgZmllbGRzXG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGZpZWxkLmtpbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwibWVzc2FnZVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWwgPSBmaWVsZC5ULmZyb21Kc29uKGpzb25JdGVtLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImVudW1cIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsID0gcmVhZEVudW0oZmllbGQuVCwganNvbkl0ZW0sIG9wdGlvbnMuaWdub3JlVW5rbm93bkZpZWxkcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWwgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwic2NhbGFyXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWwgPSByZWFkU2NhbGFyKGZpZWxkLlQsIGpzb25JdGVtLCBmaWVsZC5MKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG0gPSBgY2Fubm90IGRlY29kZSBmaWVsZCAke3R5cGUudHlwZU5hbWV9LiR7ZmllbGQubmFtZX0gZnJvbSBKU09OOiAke3RoaXMuZGVidWcoanNvbkl0ZW0pfWA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIEVycm9yICYmIGUubWVzc2FnZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbSArPSBgOiAke2UubWVzc2FnZX1gO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0QXJyYXkucHVzaCh2YWwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGZpZWxkLmtpbmQgPT0gXCJtYXBcIikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoanNvblZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShqc29uVmFsdWUpIHx8IHR5cGVvZiBqc29uVmFsdWUgIT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjYW5ub3QgZGVjb2RlIGZpZWxkICR7dHlwZS50eXBlTmFtZX0uJHtmaWVsZC5uYW1lfSBmcm9tIEpTT046ICR7dGhpcy5kZWJ1Zyhqc29uVmFsdWUpfWApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRhcmdldE1hcCA9IHRhcmdldFtsb2NhbE5hbWVdO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IFtqc29uTWFwS2V5LCBqc29uTWFwVmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGpzb25WYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChqc29uTWFwVmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNhbm5vdCBkZWNvZGUgZmllbGQgJHt0eXBlLnR5cGVOYW1lfS4ke2ZpZWxkLm5hbWV9IGZyb20gSlNPTjogbWFwIHZhbHVlIG51bGxgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCB2YWw7XG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGZpZWxkLlYua2luZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJtZXNzYWdlXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbCA9IGZpZWxkLlYuVC5mcm9tSnNvbihqc29uTWFwVmFsdWUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZW51bVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWwgPSByZWFkRW51bShmaWVsZC5WLlQsIGpzb25NYXBWYWx1ZSwgb3B0aW9ucy5pZ25vcmVVbmtub3duRmllbGRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJzY2FsYXJcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbCA9IHJlYWRTY2FsYXIoZmllbGQuVi5ULCBqc29uTWFwVmFsdWUsIExvbmdUeXBlLkJJR0lOVCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBtID0gYGNhbm5vdCBkZWNvZGUgbWFwIHZhbHVlIGZvciBmaWVsZCAke3R5cGUudHlwZU5hbWV9LiR7ZmllbGQubmFtZX0gZnJvbSBKU09OOiAke3RoaXMuZGVidWcoanNvblZhbHVlKX1gO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBFcnJvciAmJiBlLm1lc3NhZ2UubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG0gKz0gYDogJHtlLm1lc3NhZ2V9YDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0TWFwW3JlYWRTY2FsYXIoZmllbGQuSywgZmllbGQuSyA9PSBTY2FsYXJUeXBlLkJPT0xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBqc29uTWFwS2V5ID09IFwidHJ1ZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDoganNvbk1hcEtleSA9PSBcImZhbHNlXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBqc29uTWFwS2V5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDoganNvbk1hcEtleSwgTG9uZ1R5cGUuQklHSU5UKS50b1N0cmluZygpXSA9IHZhbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG0gPSBgY2Fubm90IGRlY29kZSBtYXAga2V5IGZvciBmaWVsZCAke3R5cGUudHlwZU5hbWV9LiR7ZmllbGQubmFtZX0gZnJvbSBKU09OOiAke3RoaXMuZGVidWcoanNvblZhbHVlKX1gO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgRXJyb3IgJiYgZS5tZXNzYWdlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbSArPSBgOiAke2UubWVzc2FnZX1gO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoZmllbGQua2luZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm1lc3NhZ2VcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtZXNzYWdlVHlwZSA9IGZpZWxkLlQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGpzb25WYWx1ZSA9PT0gbnVsbCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlVHlwZS50eXBlTmFtZSAhPSBcImdvb2dsZS5wcm90b2J1Zi5WYWx1ZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmaWVsZC5vbmVvZikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjYW5ub3QgZGVjb2RlIGZpZWxkICR7dHlwZS50eXBlTmFtZX0uJHtmaWVsZC5uYW1lfSBmcm9tIEpTT046IG51bGwgaXMgaW52YWxpZCBmb3Igb25lb2YgZmllbGQgXCIke2pzb25LZXl9XCJgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRhcmdldFtsb2NhbE5hbWVdIGluc3RhbmNlb2YgTWVzc2FnZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRbbG9jYWxOYW1lXS5mcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W2xvY2FsTmFtZV0gPSBtZXNzYWdlVHlwZS5mcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWVzc2FnZVR5cGUuZmllbGRXcmFwcGVyICYmICFmaWVsZC5vbmVvZikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W2xvY2FsTmFtZV0gPSBtZXNzYWdlVHlwZS5maWVsZFdyYXBwZXIudW53cmFwRmllbGQodGFyZ2V0W2xvY2FsTmFtZV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImVudW1cIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlbnVtVmFsdWUgPSByZWFkRW51bShmaWVsZC5ULCBqc29uVmFsdWUsIG9wdGlvbnMuaWdub3JlVW5rbm93bkZpZWxkcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVudW1WYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldFtsb2NhbE5hbWVdID0gZW51bVZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJzY2FsYXJcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRbbG9jYWxOYW1lXSA9IHJlYWRTY2FsYXIoZmllbGQuVCwganNvblZhbHVlLCBmaWVsZC5MKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG0gPSBgY2Fubm90IGRlY29kZSBmaWVsZCAke3R5cGUudHlwZU5hbWV9LiR7ZmllbGQubmFtZX0gZnJvbSBKU09OOiAke3RoaXMuZGVidWcoanNvblZhbHVlKX1gO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIEVycm9yICYmIGUubWVzc2FnZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtICs9IGA6ICR7ZS5tZXNzYWdlfWA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICB9LFxuICAgICAgICB3cml0ZU1lc3NhZ2UobWVzc2FnZSwgb3B0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgdHlwZSA9IG1lc3NhZ2UuZ2V0VHlwZSgpO1xuICAgICAgICAgICAgY29uc3QganNvbiA9IHt9O1xuICAgICAgICAgICAgbGV0IGZpZWxkO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IG1lbWJlciBvZiB0eXBlLmZpZWxkcy5ieU1lbWJlcigpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBqc29uVmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtZW1iZXIua2luZCA9PSBcIm9uZW9mXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG9uZW9mID0gbWVzc2FnZVttZW1iZXIubG9jYWxOYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvbmVvZi52YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBmaWVsZCA9IG1lbWJlci5maW5kRmllbGQob25lb2YuY2FzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWZpZWxkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgXCJvbmVvZiBjYXNlIG5vdCBmb3VuZDogXCIgKyBvbmVvZi5jYXNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAganNvblZhbHVlID0gd3JpdGVGaWVsZChmaWVsZCwgb25lb2YudmFsdWUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmllbGQgPSBtZW1iZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICBqc29uVmFsdWUgPSB3cml0ZUZpZWxkKGZpZWxkLCBtZXNzYWdlW2ZpZWxkLmxvY2FsTmFtZV0sIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChqc29uVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAganNvbltvcHRpb25zLnVzZVByb3RvRmllbGROYW1lID8gZmllbGQubmFtZSA6IGZpZWxkLmpzb25OYW1lXSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAganNvblZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtID0gZmllbGRcbiAgICAgICAgICAgICAgICAgICAgPyBgY2Fubm90IGVuY29kZSBmaWVsZCAke3R5cGUudHlwZU5hbWV9LiR7ZmllbGQubmFtZX0gdG8gSlNPTmBcbiAgICAgICAgICAgICAgICAgICAgOiBgY2Fubm90IGVuY29kZSBtZXNzYWdlICR7dHlwZS50eXBlTmFtZX0gdG8gSlNPTmA7XG4gICAgICAgICAgICAgICAgY29uc3QgciA9IGUgaW5zdGFuY2VvZiBFcnJvciA/IGUubWVzc2FnZSA6IFN0cmluZyhlKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobSArIChyLmxlbmd0aCA+IDAgPyBgOiAke3J9YCA6IFwiXCIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBqc29uO1xuICAgICAgICB9LFxuICAgICAgICByZWFkU2NhbGFyLFxuICAgICAgICB3cml0ZVNjYWxhcixcbiAgICAgICAgZGVidWc6IGRlYnVnSnNvblZhbHVlLFxuICAgIH07XG59XG5mdW5jdGlvbiBkZWJ1Z0pzb25WYWx1ZShqc29uKSB7XG4gICAgaWYgKGpzb24gPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIFwibnVsbFwiO1xuICAgIH1cbiAgICBzd2l0Y2ggKHR5cGVvZiBqc29uKSB7XG4gICAgICAgIGNhc2UgXCJvYmplY3RcIjpcbiAgICAgICAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KGpzb24pID8gXCJhcnJheVwiIDogXCJvYmplY3RcIjtcbiAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICAgICAgcmV0dXJuIGpzb24ubGVuZ3RoID4gMTAwID8gXCJzdHJpbmdcIiA6IGBcIiR7anNvbi5zcGxpdCgnXCInKS5qb2luKCdcXFxcXCInKX1cImA7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gU3RyaW5nKGpzb24pO1xuICAgIH1cbn1cbi8vIE1heSB0aHJvdyBhbiBlcnJvci4gSWYgdGhlIGVycm9yIG1lc3NhZ2UgaXMgbm9uLWJsYW5rLCBpdCBzaG91bGQgYmUgc2hvd24uXG4vLyBJdCBpcyB1cCB0byB0aGUgY2FsbGVyIHRvIHByb3ZpZGUgY29udGV4dC5cbmZ1bmN0aW9uIHJlYWRTY2FsYXIodHlwZSwganNvbiwgbG9uZ1R5cGUpIHtcbiAgICAvLyBldmVyeSB2YWxpZCBjYXNlIGluIHRoZSBzd2l0Y2ggYmVsb3cgcmV0dXJucywgYW5kIGV2ZXJ5IGZhbGxcbiAgICAvLyB0aHJvdWdoIGlzIHJlZ2FyZGVkIGFzIGEgZmFpbHVyZS5cbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgLy8gZmxvYXQsIGRvdWJsZTogSlNPTiB2YWx1ZSB3aWxsIGJlIGEgbnVtYmVyIG9yIG9uZSBvZiB0aGUgc3BlY2lhbCBzdHJpbmcgdmFsdWVzIFwiTmFOXCIsIFwiSW5maW5pdHlcIiwgYW5kIFwiLUluZmluaXR5XCIuXG4gICAgICAgIC8vIEVpdGhlciBudW1iZXJzIG9yIHN0cmluZ3MgYXJlIGFjY2VwdGVkLiBFeHBvbmVudCBub3RhdGlvbiBpcyBhbHNvIGFjY2VwdGVkLlxuICAgICAgICBjYXNlIFNjYWxhclR5cGUuRE9VQkxFOlxuICAgICAgICBjYXNlIFNjYWxhclR5cGUuRkxPQVQ6XG4gICAgICAgICAgICBpZiAoanNvbiA9PT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm4gMC4wO1xuICAgICAgICAgICAgaWYgKGpzb24gPT09IFwiTmFOXCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIE51bWJlci5OYU47XG4gICAgICAgICAgICBpZiAoanNvbiA9PT0gXCJJbmZpbml0eVwiKVxuICAgICAgICAgICAgICAgIHJldHVybiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgICAgICAgICBpZiAoanNvbiA9PT0gXCItSW5maW5pdHlcIilcbiAgICAgICAgICAgICAgICByZXR1cm4gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZO1xuICAgICAgICAgICAgaWYgKGpzb24gPT09IFwiXCIpIHtcbiAgICAgICAgICAgICAgICAvLyBlbXB0eSBzdHJpbmcgaXMgbm90IGEgbnVtYmVyXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIGpzb24gPT0gXCJzdHJpbmdcIiAmJiBqc29uLnRyaW0oKS5sZW5ndGggIT09IGpzb24ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgLy8gZXh0cmEgd2hpdGVzcGFjZVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBqc29uICE9IFwic3RyaW5nXCIgJiYgdHlwZW9mIGpzb24gIT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZmxvYXQgPSBOdW1iZXIoanNvbik7XG4gICAgICAgICAgICBpZiAoTnVtYmVyLmlzTmFOKGZsb2F0KSkge1xuICAgICAgICAgICAgICAgIC8vIG5vdCBhIG51bWJlclxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUoZmxvYXQpKSB7XG4gICAgICAgICAgICAgICAgLy8gaW5maW5pdHkgYW5kIC1pbmZpbml0eSBhcmUgaGFuZGxlZCBieSBzdHJpbmcgcmVwcmVzZW50YXRpb24gYWJvdmUsIHNvIHRoaXMgaXMgYW4gZXJyb3JcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlID09IFNjYWxhclR5cGUuRkxPQVQpXG4gICAgICAgICAgICAgICAgYXNzZXJ0RmxvYXQzMihmbG9hdCk7XG4gICAgICAgICAgICByZXR1cm4gZmxvYXQ7XG4gICAgICAgIC8vIGludDMyLCBmaXhlZDMyLCB1aW50MzI6IEpTT04gdmFsdWUgd2lsbCBiZSBhIGRlY2ltYWwgbnVtYmVyLiBFaXRoZXIgbnVtYmVycyBvciBzdHJpbmdzIGFyZSBhY2NlcHRlZC5cbiAgICAgICAgY2FzZSBTY2FsYXJUeXBlLklOVDMyOlxuICAgICAgICBjYXNlIFNjYWxhclR5cGUuRklYRUQzMjpcbiAgICAgICAgY2FzZSBTY2FsYXJUeXBlLlNGSVhFRDMyOlxuICAgICAgICBjYXNlIFNjYWxhclR5cGUuU0lOVDMyOlxuICAgICAgICBjYXNlIFNjYWxhclR5cGUuVUlOVDMyOlxuICAgICAgICAgICAgaWYgKGpzb24gPT09IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICBsZXQgaW50MzI7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGpzb24gPT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgICAgICBpbnQzMiA9IGpzb247XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YganNvbiA9PSBcInN0cmluZ1wiICYmIGpzb24ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGlmIChqc29uLnRyaW0oKS5sZW5ndGggPT09IGpzb24ubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICBpbnQzMiA9IE51bWJlcihqc29uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpbnQzMiA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgaWYgKHR5cGUgPT0gU2NhbGFyVHlwZS5VSU5UMzIpXG4gICAgICAgICAgICAgICAgYXNzZXJ0VUludDMyKGludDMyKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBhc3NlcnRJbnQzMihpbnQzMik7XG4gICAgICAgICAgICByZXR1cm4gaW50MzI7XG4gICAgICAgIC8vIGludDY0LCBmaXhlZDY0LCB1aW50NjQ6IEpTT04gdmFsdWUgd2lsbCBiZSBhIGRlY2ltYWwgc3RyaW5nLiBFaXRoZXIgbnVtYmVycyBvciBzdHJpbmdzIGFyZSBhY2NlcHRlZC5cbiAgICAgICAgY2FzZSBTY2FsYXJUeXBlLklOVDY0OlxuICAgICAgICBjYXNlIFNjYWxhclR5cGUuU0ZJWEVENjQ6XG4gICAgICAgIGNhc2UgU2NhbGFyVHlwZS5TSU5UNjQ6XG4gICAgICAgICAgICBpZiAoanNvbiA9PT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvdG9JbnQ2NC56ZXJvO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBqc29uICE9IFwibnVtYmVyXCIgJiYgdHlwZW9mIGpzb24gIT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNvbnN0IGxvbmcgPSBwcm90b0ludDY0LnBhcnNlKGpzb24pO1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9zdHJpY3QtYm9vbGVhbi1leHByZXNzaW9uc1xuICAgICAgICAgICAgcmV0dXJuIGxvbmdUeXBlID8gbG9uZy50b1N0cmluZygpIDogbG9uZztcbiAgICAgICAgY2FzZSBTY2FsYXJUeXBlLkZJWEVENjQ6XG4gICAgICAgIGNhc2UgU2NhbGFyVHlwZS5VSU5UNjQ6XG4gICAgICAgICAgICBpZiAoanNvbiA9PT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvdG9JbnQ2NC56ZXJvO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBqc29uICE9IFwibnVtYmVyXCIgJiYgdHlwZW9mIGpzb24gIT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNvbnN0IHVMb25nID0gcHJvdG9JbnQ2NC51UGFyc2UoanNvbik7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3N0cmljdC1ib29sZWFuLWV4cHJlc3Npb25zXG4gICAgICAgICAgICByZXR1cm4gbG9uZ1R5cGUgPyB1TG9uZy50b1N0cmluZygpIDogdUxvbmc7XG4gICAgICAgIC8vIGJvb2w6XG4gICAgICAgIGNhc2UgU2NhbGFyVHlwZS5CT09MOlxuICAgICAgICAgICAgaWYgKGpzb24gPT09IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBqc29uICE9PSBcImJvb2xlYW5cIilcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIHJldHVybiBqc29uO1xuICAgICAgICAvLyBzdHJpbmc6XG4gICAgICAgIGNhc2UgU2NhbGFyVHlwZS5TVFJJTkc6XG4gICAgICAgICAgICBpZiAoanNvbiA9PT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgICAgIGlmICh0eXBlb2YganNvbiAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQSBzdHJpbmcgbXVzdCBhbHdheXMgY29udGFpbiBVVEYtOCBlbmNvZGVkIG9yIDctYml0IEFTQ0lJLlxuICAgICAgICAgICAgLy8gV2UgdmFsaWRhdGUgd2l0aCBlbmNvZGVVUklDb21wb25lbnQsIHdoaWNoIGFwcGVhcnMgdG8gYmUgdGhlIGZhc3Rlc3Qgd2lkZWx5IGF2YWlsYWJsZSBvcHRpb24uXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGVuY29kZVVSSUNvbXBvbmVudChqc29uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBVVEY4XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGpzb247XG4gICAgICAgIC8vIGJ5dGVzOiBKU09OIHZhbHVlIHdpbGwgYmUgdGhlIGRhdGEgZW5jb2RlZCBhcyBhIHN0cmluZyB1c2luZyBzdGFuZGFyZCBiYXNlNjQgZW5jb2Rpbmcgd2l0aCBwYWRkaW5ncy5cbiAgICAgICAgLy8gRWl0aGVyIHN0YW5kYXJkIG9yIFVSTC1zYWZlIGJhc2U2NCBlbmNvZGluZyB3aXRoL3dpdGhvdXQgcGFkZGluZ3MgYXJlIGFjY2VwdGVkLlxuICAgICAgICBjYXNlIFNjYWxhclR5cGUuQllURVM6XG4gICAgICAgICAgICBpZiAoanNvbiA9PT0gbnVsbCB8fCBqc29uID09PSBcIlwiKVxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheSgwKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YganNvbiAhPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIHJldHVybiBwcm90b0Jhc2U2NC5kZWMoanNvbik7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcigpO1xufVxuZnVuY3Rpb24gcmVhZEVudW0odHlwZSwganNvbiwgaWdub3JlVW5rbm93bkZpZWxkcykge1xuICAgIGlmIChqc29uID09PSBudWxsKSB7XG4gICAgICAgIC8vIHByb3RvMyByZXF1aXJlcyAwIHRvIGJlIGRlZmF1bHQgdmFsdWUgZm9yIGFsbCBlbnVtc1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9zd2l0Y2gtZXhoYXVzdGl2ZW5lc3MtY2hlY2tcbiAgICBzd2l0Y2ggKHR5cGVvZiBqc29uKSB7XG4gICAgICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgICAgICAgIGlmIChOdW1iZXIuaXNJbnRlZ2VyKGpzb24pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGpzb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB0eXBlLmZpbmROYW1lKGpzb24pO1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9wcmVmZXItbnVsbGlzaC1jb2FsZXNjaW5nXG4gICAgICAgICAgICBpZiAodmFsdWUgfHwgaWdub3JlVW5rbm93bkZpZWxkcykge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogdmFsdWUubm87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBjYW5ub3QgZGVjb2RlIGVudW0gJHt0eXBlLnR5cGVOYW1lfSBmcm9tIEpTT046ICR7ZGVidWdKc29uVmFsdWUoanNvbil9YCk7XG59XG5mdW5jdGlvbiB3cml0ZUVudW0odHlwZSwgdmFsdWUsIGVtaXRJbnRyaW5zaWNEZWZhdWx0LCBlbnVtQXNJbnRlZ2VyKSB7XG4gICAgdmFyIF9hO1xuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgaWYgKHZhbHVlID09PSAwICYmICFlbWl0SW50cmluc2ljRGVmYXVsdCkge1xuICAgICAgICAvLyBwcm90bzMgcmVxdWlyZXMgMCB0byBiZSBkZWZhdWx0IHZhbHVlIGZvciBhbGwgZW51bXNcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaWYgKGVudW1Bc0ludGVnZXIpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBpZiAodHlwZS50eXBlTmFtZSA9PSBcImdvb2dsZS5wcm90b2J1Zi5OdWxsVmFsdWVcIikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgdmFsID0gdHlwZS5maW5kTnVtYmVyKHZhbHVlKTtcbiAgICByZXR1cm4gKF9hID0gdmFsID09PSBudWxsIHx8IHZhbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogdmFsLm5hbWUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHZhbHVlOyAvLyBpZiB3ZSBkb24ndCBrbm93IHRoZSBlbnVtIHZhbHVlLCBqdXN0IHJldHVybiB0aGUgbnVtYmVyXG59XG5mdW5jdGlvbiB3cml0ZVNjYWxhcih0eXBlLCB2YWx1ZSwgZW1pdEludHJpbnNpY0RlZmF1bHQpIHtcbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgLy8gaW50MzIsIGZpeGVkMzIsIHVpbnQzMjogSlNPTiB2YWx1ZSB3aWxsIGJlIGEgZGVjaW1hbCBudW1iZXIuIEVpdGhlciBudW1iZXJzIG9yIHN0cmluZ3MgYXJlIGFjY2VwdGVkLlxuICAgICAgICBjYXNlIFNjYWxhclR5cGUuSU5UMzI6XG4gICAgICAgIGNhc2UgU2NhbGFyVHlwZS5TRklYRUQzMjpcbiAgICAgICAgY2FzZSBTY2FsYXJUeXBlLlNJTlQzMjpcbiAgICAgICAgY2FzZSBTY2FsYXJUeXBlLkZJWEVEMzI6XG4gICAgICAgIGNhc2UgU2NhbGFyVHlwZS5VSU5UMzI6XG4gICAgICAgICAgICBhc3NlcnQodHlwZW9mIHZhbHVlID09IFwibnVtYmVyXCIpO1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlICE9IDAgfHwgZW1pdEludHJpbnNpY0RlZmF1bHQgPyB2YWx1ZSA6IHVuZGVmaW5lZDtcbiAgICAgICAgLy8gZmxvYXQsIGRvdWJsZTogSlNPTiB2YWx1ZSB3aWxsIGJlIGEgbnVtYmVyIG9yIG9uZSBvZiB0aGUgc3BlY2lhbCBzdHJpbmcgdmFsdWVzIFwiTmFOXCIsIFwiSW5maW5pdHlcIiwgYW5kIFwiLUluZmluaXR5XCIuXG4gICAgICAgIC8vIEVpdGhlciBudW1iZXJzIG9yIHN0cmluZ3MgYXJlIGFjY2VwdGVkLiBFeHBvbmVudCBub3RhdGlvbiBpcyBhbHNvIGFjY2VwdGVkLlxuICAgICAgICBjYXNlIFNjYWxhclR5cGUuRkxPQVQ6XG4gICAgICAgIC8vIGFzc2VydEZsb2F0MzIodmFsdWUpO1xuICAgICAgICBjYXNlIFNjYWxhclR5cGUuRE9VQkxFOiAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWZhbGx0aHJvdWdoXG4gICAgICAgICAgICBhc3NlcnQodHlwZW9mIHZhbHVlID09IFwibnVtYmVyXCIpO1xuICAgICAgICAgICAgaWYgKE51bWJlci5pc05hTih2YWx1ZSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiTmFOXCI7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSlcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJJbmZpbml0eVwiO1xuICAgICAgICAgICAgaWYgKHZhbHVlID09PSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiLUluZmluaXR5XCI7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUgIT09IDAgfHwgZW1pdEludHJpbnNpY0RlZmF1bHQgPyB2YWx1ZSA6IHVuZGVmaW5lZDtcbiAgICAgICAgLy8gc3RyaW5nOlxuICAgICAgICBjYXNlIFNjYWxhclR5cGUuU1RSSU5HOlxuICAgICAgICAgICAgYXNzZXJ0KHR5cGVvZiB2YWx1ZSA9PSBcInN0cmluZ1wiKTtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS5sZW5ndGggPiAwIHx8IGVtaXRJbnRyaW5zaWNEZWZhdWx0ID8gdmFsdWUgOiB1bmRlZmluZWQ7XG4gICAgICAgIC8vIGJvb2w6XG4gICAgICAgIGNhc2UgU2NhbGFyVHlwZS5CT09MOlxuICAgICAgICAgICAgYXNzZXJ0KHR5cGVvZiB2YWx1ZSA9PSBcImJvb2xlYW5cIik7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUgfHwgZW1pdEludHJpbnNpY0RlZmF1bHQgPyB2YWx1ZSA6IHVuZGVmaW5lZDtcbiAgICAgICAgLy8gSlNPTiB2YWx1ZSB3aWxsIGJlIGEgZGVjaW1hbCBzdHJpbmcuIEVpdGhlciBudW1iZXJzIG9yIHN0cmluZ3MgYXJlIGFjY2VwdGVkLlxuICAgICAgICBjYXNlIFNjYWxhclR5cGUuVUlOVDY0OlxuICAgICAgICBjYXNlIFNjYWxhclR5cGUuRklYRUQ2NDpcbiAgICAgICAgY2FzZSBTY2FsYXJUeXBlLklOVDY0OlxuICAgICAgICBjYXNlIFNjYWxhclR5cGUuU0ZJWEVENjQ6XG4gICAgICAgIGNhc2UgU2NhbGFyVHlwZS5TSU5UNjQ6XG4gICAgICAgICAgICBhc3NlcnQodHlwZW9mIHZhbHVlID09IFwiYmlnaW50XCIgfHxcbiAgICAgICAgICAgICAgICB0eXBlb2YgdmFsdWUgPT0gXCJzdHJpbmdcIiB8fFxuICAgICAgICAgICAgICAgIHR5cGVvZiB2YWx1ZSA9PSBcIm51bWJlclwiKTtcbiAgICAgICAgICAgIC8vIFdlIHVzZSBpbXBsaWNpdCBjb252ZXJzaW9uIHdpdGggYHZhbHVlICE9IDBgIHRvIGNhdGNoIGJvdGggMG4gYW5kIFwiMFwiXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10cy1jb21tZW50XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICByZXR1cm4gZW1pdEludHJpbnNpY0RlZmF1bHQgfHwgdmFsdWUgIT0gMFxuICAgICAgICAgICAgICAgID8gdmFsdWUudG9TdHJpbmcoMTApXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIC8vIGJ5dGVzOiBKU09OIHZhbHVlIHdpbGwgYmUgdGhlIGRhdGEgZW5jb2RlZCBhcyBhIHN0cmluZyB1c2luZyBzdGFuZGFyZCBiYXNlNjQgZW5jb2Rpbmcgd2l0aCBwYWRkaW5ncy5cbiAgICAgICAgLy8gRWl0aGVyIHN0YW5kYXJkIG9yIFVSTC1zYWZlIGJhc2U2NCBlbmNvZGluZyB3aXRoL3dpdGhvdXQgcGFkZGluZ3MgYXJlIGFjY2VwdGVkLlxuICAgICAgICBjYXNlIFNjYWxhclR5cGUuQllURVM6XG4gICAgICAgICAgICBhc3NlcnQodmFsdWUgaW5zdGFuY2VvZiBVaW50OEFycmF5KTtcbiAgICAgICAgICAgIHJldHVybiBlbWl0SW50cmluc2ljRGVmYXVsdCB8fCB2YWx1ZS5ieXRlTGVuZ3RoID4gMFxuICAgICAgICAgICAgICAgID8gcHJvdG9CYXNlNjQuZW5jKHZhbHVlKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgIH1cbn1cbiIsIi8vIENvcHlyaWdodCAyMDIxLTIwMjMgQnVmIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5pbXBvcnQgeyB3cmFwRmllbGQgfSBmcm9tIFwiLi9maWVsZC13cmFwcGVyLmpzXCI7XG5pbXBvcnQgeyBhc3NlcnQgfSBmcm9tIFwiLi9hc3NlcnQuanNcIjtcbmltcG9ydCB7IG1ha2VKc29uRm9ybWF0Q29tbW9uIH0gZnJvbSBcIi4vanNvbi1mb3JtYXQtY29tbW9uLmpzXCI7XG4vKiBlc2xpbnQtZGlzYWJsZSBuby1jYXNlLWRlY2xhcmF0aW9ucywgQHR5cGVzY3JpcHQtZXNsaW50L3Jlc3RyaWN0LXBsdXMtb3BlcmFuZHMsQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSxAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLXJldHVybixAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFzc2lnbm1lbnQsQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1jYWxsLEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtbWVtYmVyLWFjY2VzcyxAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFyZ3VtZW50ICovXG5leHBvcnQgZnVuY3Rpb24gbWFrZUpzb25Gb3JtYXRQcm90bzMoKSB7XG4gICAgcmV0dXJuIG1ha2VKc29uRm9ybWF0Q29tbW9uKCh3cml0ZUVudW0sIHdyaXRlU2NhbGFyKSA9PiB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiB3cml0ZUZpZWxkKGZpZWxkLCB2YWx1ZSwgb3B0aW9ucykge1xuICAgICAgICAgICAgaWYgKGZpZWxkLmtpbmQgPT0gXCJtYXBcIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGpzb25PYmogPSB7fTtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGZpZWxkLlYua2luZCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwic2NhbGFyXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IFtlbnRyeUtleSwgZW50cnlWYWx1ZV0gb2YgT2JqZWN0LmVudHJpZXModmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsID0gd3JpdGVTY2FsYXIoZmllbGQuVi5ULCBlbnRyeVZhbHVlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQodmFsICE9PSB1bmRlZmluZWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpzb25PYmpbZW50cnlLZXkudG9TdHJpbmcoKV0gPSB2YWw7IC8vIEpTT04gc3RhbmRhcmQgYWxsb3dzIG9ubHkgKGRvdWJsZSBxdW90ZWQpIHN0cmluZyBhcyBwcm9wZXJ0eSBrZXlcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwibWVzc2FnZVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBbZW50cnlLZXksIGVudHJ5VmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEpTT04gc3RhbmRhcmQgYWxsb3dzIG9ubHkgKGRvdWJsZSBxdW90ZWQpIHN0cmluZyBhcyBwcm9wZXJ0eSBrZXlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqc29uT2JqW2VudHJ5S2V5LnRvU3RyaW5nKCldID0gZW50cnlWYWx1ZS50b0pzb24ob3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImVudW1cIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVudW1UeXBlID0gZmllbGQuVi5UO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBbZW50cnlLZXksIGVudHJ5VmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydChlbnRyeVZhbHVlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIGVudHJ5VmFsdWUgPT0gXCJudW1iZXJcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsID0gd3JpdGVFbnVtKGVudW1UeXBlLCBlbnRyeVZhbHVlLCB0cnVlLCBvcHRpb25zLmVudW1Bc0ludGVnZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydCh2YWwgIT09IHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAganNvbk9ialtlbnRyeUtleS50b1N0cmluZygpXSA9IHZhbDsgLy8gSlNPTiBzdGFuZGFyZCBhbGxvd3Mgb25seSAoZG91YmxlIHF1b3RlZCkgc3RyaW5nIGFzIHByb3BlcnR5IGtleVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBvcHRpb25zLmVtaXREZWZhdWx0VmFsdWVzIHx8IE9iamVjdC5rZXlzKGpzb25PYmopLmxlbmd0aCA+IDBcbiAgICAgICAgICAgICAgICAgICAgPyBqc29uT2JqXG4gICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZmllbGQucmVwZWF0ZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBqc29uQXJyID0gW107XG4gICAgICAgICAgICAgICAgc3dpdGNoIChmaWVsZC5raW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJzY2FsYXJcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqc29uQXJyLnB1c2god3JpdGVTY2FsYXIoZmllbGQuVCwgdmFsdWVbaV0sIHRydWUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZW51bVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpzb25BcnIucHVzaCh3cml0ZUVudW0oZmllbGQuVCwgdmFsdWVbaV0sIHRydWUsIG9wdGlvbnMuZW51bUFzSW50ZWdlcikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJtZXNzYWdlXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAganNvbkFyci5wdXNoKHdyYXBGaWVsZChmaWVsZC5ULCB2YWx1ZVtpXSkudG9Kc29uKG9wdGlvbnMpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gb3B0aW9ucy5lbWl0RGVmYXVsdFZhbHVlcyB8fCBqc29uQXJyLmxlbmd0aCA+IDBcbiAgICAgICAgICAgICAgICAgICAgPyBqc29uQXJyXG4gICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChmaWVsZC5raW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJzY2FsYXJcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB3cml0ZVNjYWxhcihmaWVsZC5ULCB2YWx1ZSwgISFmaWVsZC5vbmVvZiB8fCBmaWVsZC5vcHQgfHwgb3B0aW9ucy5lbWl0RGVmYXVsdFZhbHVlcyk7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJlbnVtXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gd3JpdGVFbnVtKGZpZWxkLlQsIHZhbHVlLCAhIWZpZWxkLm9uZW9mIHx8IGZpZWxkLm9wdCB8fCBvcHRpb25zLmVtaXREZWZhdWx0VmFsdWVzLCBvcHRpb25zLmVudW1Bc0ludGVnZXIpO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwibWVzc2FnZVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHdyYXBGaWVsZChmaWVsZC5ULCB2YWx1ZSkudG9Kc29uKG9wdGlvbnMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0pO1xufVxuIiwiLy8gQ29weXJpZ2h0IDIwMjEtMjAyMyBCdWYgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbmltcG9ydCB7IHNldEVudW1UeXBlIH0gZnJvbSBcIi4vZW51bS5qc1wiO1xuaW1wb3J0IHsgTWVzc2FnZSB9IGZyb20gXCIuLi9tZXNzYWdlLmpzXCI7XG5pbXBvcnQgeyBTY2FsYXJUeXBlIH0gZnJvbSBcIi4uL2ZpZWxkLmpzXCI7XG5pbXBvcnQgeyBzY2FsYXJFcXVhbHMgfSBmcm9tIFwiLi9zY2FsYXJzLmpzXCI7XG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55LEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXNzaWdubWVudCxAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLW1lbWJlci1hY2Nlc3MsQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1yZXR1cm4sQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hcmd1bWVudCxuby1jYXNlLWRlY2xhcmF0aW9ucyAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1ha2VVdGlsQ29tbW9uKCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHNldEVudW1UeXBlLFxuICAgICAgICBpbml0UGFydGlhbChzb3VyY2UsIHRhcmdldCkge1xuICAgICAgICAgICAgaWYgKHNvdXJjZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdHlwZSA9IHRhcmdldC5nZXRUeXBlKCk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IG1lbWJlciBvZiB0eXBlLmZpZWxkcy5ieU1lbWJlcigpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbG9jYWxOYW1lID0gbWVtYmVyLmxvY2FsTmFtZSwgdCA9IHRhcmdldCwgcyA9IHNvdXJjZTtcbiAgICAgICAgICAgICAgICBpZiAoc1tsb2NhbE5hbWVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN3aXRjaCAobWVtYmVyLmtpbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm9uZW9mXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzayA9IHNbbG9jYWxOYW1lXS5jYXNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNrID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNvdXJjZUZpZWxkID0gbWVtYmVyLmZpbmRGaWVsZChzayk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgdmFsID0gc1tsb2NhbE5hbWVdLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNvdXJjZUZpZWxkICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlRmllbGQua2luZCA9PSBcIm1lc3NhZ2VcIiAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICEodmFsIGluc3RhbmNlb2Ygc291cmNlRmllbGQuVCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWwgPSBuZXcgc291cmNlRmllbGQuVCh2YWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoc291cmNlRmllbGQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2VGaWVsZC5raW5kID09PSBcInNjYWxhclwiICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlRmllbGQuVCA9PT0gU2NhbGFyVHlwZS5CWVRFUykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbCA9IHRvVThBcnIodmFsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRbbG9jYWxOYW1lXSA9IHsgY2FzZTogc2ssIHZhbHVlOiB2YWwgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwic2NhbGFyXCI6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJlbnVtXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgY29weSA9IHNbbG9jYWxOYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtZW1iZXIuVCA9PT0gU2NhbGFyVHlwZS5CWVRFUykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvcHkgPSBtZW1iZXIucmVwZWF0ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBjb3B5Lm1hcCh0b1U4QXJyKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHRvVThBcnIoY29weSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0W2xvY2FsTmFtZV0gPSBjb3B5O1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJtYXBcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAobWVtYmVyLlYua2luZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJzY2FsYXJcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZW51bVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWVtYmVyLlYuVCA9PT0gU2NhbGFyVHlwZS5CWVRFUykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBbaywgdl0gb2YgT2JqZWN0LmVudHJpZXMoc1tsb2NhbE5hbWVdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRbbG9jYWxOYW1lXVtrXSA9IHRvVThBcnIodik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHRbbG9jYWxOYW1lXSwgc1tsb2NhbE5hbWVdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwibWVzc2FnZVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtZXNzYWdlVHlwZSA9IG1lbWJlci5WLlQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgayBvZiBPYmplY3Qua2V5cyhzW2xvY2FsTmFtZV0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgdmFsID0gc1tsb2NhbE5hbWVdW2tdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFtZXNzYWdlVHlwZS5maWVsZFdyYXBwZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBvbmx5IHRha2UgcGFydGlhbCBpbnB1dCBmb3IgbWVzc2FnZXMgdGhhdCBhcmUgbm90IGEgd3JhcHBlciB0eXBlLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZvciB0aG9zZSBtZXNzYWdlcywgd2UgcmVjdXJzaXZlbHkgbm9ybWFsaXplIHRoZSBwYXJ0aWFsIGlucHV0LlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbCA9IG5ldyBtZXNzYWdlVHlwZSh2YWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdFtsb2NhbE5hbWVdW2tdID0gdmFsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJtZXNzYWdlXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtdCA9IG1lbWJlci5UO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1lbWJlci5yZXBlYXRlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRbbG9jYWxOYW1lXSA9IHNbbG9jYWxOYW1lXS5tYXAoKHZhbCkgPT4gdmFsIGluc3RhbmNlb2YgbXQgPyB2YWwgOiBuZXcgbXQodmFsKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChzW2xvY2FsTmFtZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbCA9IHNbbG9jYWxOYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobXQuZmllbGRXcmFwcGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UgY2FuJ3QgdXNlIEJ5dGVzVmFsdWUudHlwZU5hbWUgYXMgdGhhdCB3aWxsIGNyZWF0ZSBhIGNpcmN1bGFyIGltcG9ydFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtdC50eXBlTmFtZSA9PT0gXCJnb29nbGUucHJvdG9idWYuQnl0ZXNWYWx1ZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0W2xvY2FsTmFtZV0gPSB0b1U4QXJyKHZhbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0W2xvY2FsTmFtZV0gPSB2YWw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRbbG9jYWxOYW1lXSA9IHZhbCBpbnN0YW5jZW9mIG10ID8gdmFsIDogbmV3IG10KHZhbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBlcXVhbHModHlwZSwgYSwgYikge1xuICAgICAgICAgICAgaWYgKGEgPT09IGIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghYSB8fCAhYikge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0eXBlLmZpZWxkcy5ieU1lbWJlcigpLmV2ZXJ5KChtKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmEgPSBhW20ubG9jYWxOYW1lXTtcbiAgICAgICAgICAgICAgICBjb25zdCB2YiA9IGJbbS5sb2NhbE5hbWVdO1xuICAgICAgICAgICAgICAgIGlmIChtLnJlcGVhdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YS5sZW5ndGggIT09IHZiLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvc3dpdGNoLWV4aGF1c3RpdmVuZXNzLWNoZWNrIC0tIHJlcGVhdGVkIGZpZWxkcyBhcmUgbmV2ZXIgXCJtYXBcIlxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKG0ua2luZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm1lc3NhZ2VcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmEuZXZlcnkoKGEsIGkpID0+IG0uVC5lcXVhbHMoYSwgdmJbaV0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJzY2FsYXJcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmEuZXZlcnkoKGEsIGkpID0+IHNjYWxhckVxdWFscyhtLlQsIGEsIHZiW2ldKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZW51bVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YS5ldmVyeSgoYSwgaSkgPT4gc2NhbGFyRXF1YWxzKFNjYWxhclR5cGUuSU5UMzIsIGEsIHZiW2ldKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGByZXBlYXRlZCBjYW5ub3QgY29udGFpbiAke20ua2luZH1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3dpdGNoIChtLmtpbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm1lc3NhZ2VcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtLlQuZXF1YWxzKHZhLCB2Yik7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJlbnVtXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2NhbGFyRXF1YWxzKFNjYWxhclR5cGUuSU5UMzIsIHZhLCB2Yik7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJzY2FsYXJcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzY2FsYXJFcXVhbHMobS5ULCB2YSwgdmIpO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwib25lb2ZcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YS5jYXNlICE9PSB2Yi5jYXNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcyA9IG0uZmluZEZpZWxkKHZhLmNhc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9zd2l0Y2gtZXhoYXVzdGl2ZW5lc3MtY2hlY2sgLS0gb25lb2YgZmllbGRzIGFyZSBuZXZlciBcIm1hcFwiXG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHMua2luZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJtZXNzYWdlXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzLlQuZXF1YWxzKHZhLnZhbHVlLCB2Yi52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImVudW1cIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNjYWxhckVxdWFscyhTY2FsYXJUeXBlLklOVDMyLCB2YS52YWx1ZSwgdmIudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJzY2FsYXJcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNjYWxhckVxdWFscyhzLlQsIHZhLnZhbHVlLCB2Yi52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYG9uZW9mIGNhbm5vdCBjb250YWluICR7cy5raW5kfWApO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwibWFwXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXModmEpLmNvbmNhdChPYmplY3Qua2V5cyh2YikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChtLlYua2luZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJtZXNzYWdlXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2VUeXBlID0gbS5WLlQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBrZXlzLmV2ZXJ5KChrKSA9PiBtZXNzYWdlVHlwZS5lcXVhbHModmFba10sIHZiW2tdKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImVudW1cIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGtleXMuZXZlcnkoKGspID0+IHNjYWxhckVxdWFscyhTY2FsYXJUeXBlLklOVDMyLCB2YVtrXSwgdmJba10pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwic2NhbGFyXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNjYWxhclR5cGUgPSBtLlYuVDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGtleXMuZXZlcnkoKGspID0+IHNjYWxhckVxdWFscyhzY2FsYXJUeXBlLCB2YVtrXSwgdmJba10pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBjbG9uZShtZXNzYWdlKSB7XG4gICAgICAgICAgICBjb25zdCB0eXBlID0gbWVzc2FnZS5nZXRUeXBlKCksIHRhcmdldCA9IG5ldyB0eXBlKCksIGFueSA9IHRhcmdldDtcbiAgICAgICAgICAgIGZvciAoY29uc3QgbWVtYmVyIG9mIHR5cGUuZmllbGRzLmJ5TWVtYmVyKCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzb3VyY2UgPSBtZXNzYWdlW21lbWJlci5sb2NhbE5hbWVdO1xuICAgICAgICAgICAgICAgIGxldCBjb3B5O1xuICAgICAgICAgICAgICAgIGlmIChtZW1iZXIucmVwZWF0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29weSA9IHNvdXJjZS5tYXAoY2xvbmVTaW5ndWxhckZpZWxkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobWVtYmVyLmtpbmQgPT0gXCJtYXBcIikge1xuICAgICAgICAgICAgICAgICAgICBjb3B5ID0gYW55W21lbWJlci5sb2NhbE5hbWVdO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZdIG9mIE9iamVjdC5lbnRyaWVzKHNvdXJjZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvcHlba2V5XSA9IGNsb25lU2luZ3VsYXJGaWVsZCh2KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChtZW1iZXIua2luZCA9PSBcIm9uZW9mXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZiA9IG1lbWJlci5maW5kRmllbGQoc291cmNlLmNhc2UpO1xuICAgICAgICAgICAgICAgICAgICBjb3B5ID0gZlxuICAgICAgICAgICAgICAgICAgICAgICAgPyB7IGNhc2U6IHNvdXJjZS5jYXNlLCB2YWx1ZTogY2xvbmVTaW5ndWxhckZpZWxkKHNvdXJjZS52YWx1ZSkgfVxuICAgICAgICAgICAgICAgICAgICAgICAgOiB7IGNhc2U6IHVuZGVmaW5lZCB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29weSA9IGNsb25lU2luZ3VsYXJGaWVsZChzb3VyY2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhbnlbbWVtYmVyLmxvY2FsTmFtZV0gPSBjb3B5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuLy8gY2xvbmUgYSBzaW5nbGUgZmllbGQgdmFsdWUgLSBpLmUuIHRoZSBlbGVtZW50IHR5cGUgb2YgcmVwZWF0ZWQgZmllbGRzLCB0aGUgdmFsdWUgdHlwZSBvZiBtYXBzXG5mdW5jdGlvbiBjbG9uZVNpbmd1bGFyRmllbGQodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIE1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLmNsb25lKCk7XG4gICAgfVxuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgY29uc3QgYyA9IG5ldyBVaW50OEFycmF5KHZhbHVlLmJ5dGVMZW5ndGgpO1xuICAgICAgICBjLnNldCh2YWx1ZSk7XG4gICAgICAgIHJldHVybiBjO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59XG4vLyBjb252ZXJ0cyBhbnkgQXJyYXlMaWtlPG51bWJlcj4gdG8gVWludDhBcnJheSBpZiBuZWNlc3NhcnkuXG5mdW5jdGlvbiB0b1U4QXJyKGlucHV0KSB7XG4gICAgcmV0dXJuIGlucHV0IGluc3RhbmNlb2YgVWludDhBcnJheSA/IGlucHV0IDogbmV3IFVpbnQ4QXJyYXkoaW5wdXQpO1xufVxuIiwiLy8gQ29weXJpZ2h0IDIwMjEtMjAyMyBCdWYgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbmV4cG9ydCBjbGFzcyBJbnRlcm5hbEZpZWxkTGlzdCB7XG4gICAgY29uc3RydWN0b3IoZmllbGRzLCBub3JtYWxpemVyKSB7XG4gICAgICAgIHRoaXMuX2ZpZWxkcyA9IGZpZWxkcztcbiAgICAgICAgdGhpcy5fbm9ybWFsaXplciA9IG5vcm1hbGl6ZXI7XG4gICAgfVxuICAgIGZpbmRKc29uTmFtZShqc29uTmFtZSkge1xuICAgICAgICBpZiAoIXRoaXMuanNvbk5hbWVzKSB7XG4gICAgICAgICAgICBjb25zdCB0ID0ge307XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGYgb2YgdGhpcy5saXN0KCkpIHtcbiAgICAgICAgICAgICAgICB0W2YuanNvbk5hbWVdID0gdFtmLm5hbWVdID0gZjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuanNvbk5hbWVzID0gdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5qc29uTmFtZXNbanNvbk5hbWVdO1xuICAgIH1cbiAgICBmaW5kKGZpZWxkTm8pIHtcbiAgICAgICAgaWYgKCF0aGlzLm51bWJlcnMpIHtcbiAgICAgICAgICAgIGNvbnN0IHQgPSB7fTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZiBvZiB0aGlzLmxpc3QoKSkge1xuICAgICAgICAgICAgICAgIHRbZi5ub10gPSBmO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5udW1iZXJzID0gdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5udW1iZXJzW2ZpZWxkTm9dO1xuICAgIH1cbiAgICBsaXN0KCkge1xuICAgICAgICBpZiAoIXRoaXMuYWxsKSB7XG4gICAgICAgICAgICB0aGlzLmFsbCA9IHRoaXMuX25vcm1hbGl6ZXIodGhpcy5fZmllbGRzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5hbGw7XG4gICAgfVxuICAgIGJ5TnVtYmVyKCkge1xuICAgICAgICBpZiAoIXRoaXMubnVtYmVyc0FzYykge1xuICAgICAgICAgICAgdGhpcy5udW1iZXJzQXNjID0gdGhpcy5saXN0KClcbiAgICAgICAgICAgICAgICAuY29uY2F0KClcbiAgICAgICAgICAgICAgICAuc29ydCgoYSwgYikgPT4gYS5ubyAtIGIubm8pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLm51bWJlcnNBc2M7XG4gICAgfVxuICAgIGJ5TWVtYmVyKCkge1xuICAgICAgICBpZiAoIXRoaXMubWVtYmVycykge1xuICAgICAgICAgICAgdGhpcy5tZW1iZXJzID0gW107XG4gICAgICAgICAgICBjb25zdCBhID0gdGhpcy5tZW1iZXJzO1xuICAgICAgICAgICAgbGV0IG87XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGYgb2YgdGhpcy5saXN0KCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoZi5vbmVvZikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZi5vbmVvZiAhPT0gbykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbyA9IGYub25lb2Y7XG4gICAgICAgICAgICAgICAgICAgICAgICBhLnB1c2gobyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGEucHVzaChmKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubWVtYmVycztcbiAgICB9XG59XG4iLCIvLyBDb3B5cmlnaHQgMjAyMS0yMDIzIEJ1ZiBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuLyoqXG4gKiBSZXR1cm5zIHRoZSBuYW1lIG9mIGEgcHJvdG9idWYgZWxlbWVudCBpbiBnZW5lcmF0ZWQgY29kZS5cbiAqXG4gKiBGaWVsZCBuYW1lcyAtIGluY2x1ZGluZyBvbmVvZnMgLSBhcmUgY29udmVydGVkIHRvIGxvd2VyQ2FtZWxDYXNlLiBGb3JcbiAqIG1lc3NhZ2VzLCBlbnVtZXJhdGlvbnMgYW5kIHNlcnZpY2VzLCB0aGUgcGFja2FnZSBuYW1lIGlzIHN0cmlwcGVkIGZyb21cbiAqIHRoZSB0eXBlIG5hbWUuIEZvciBuZXN0ZWQgbWVzc2FnZXMgYW5kIGVudW1lcmF0aW9ucywgdGhlIG5hbWVzIGFyZSBqb2luZWRcbiAqIHdpdGggYW4gdW5kZXJzY29yZS4gRm9yIG1ldGhvZHMsIHRoZSBmaXJzdCBjaGFyYWN0ZXIgaXMgbWFkZSBsb3dlcmNhc2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsb2NhbE5hbWUoZGVzYykge1xuICAgIHN3aXRjaCAoZGVzYy5raW5kKSB7XG4gICAgICAgIGNhc2UgXCJmaWVsZFwiOlxuICAgICAgICAgICAgcmV0dXJuIGxvY2FsRmllbGROYW1lKGRlc2MubmFtZSwgZGVzYy5vbmVvZiAhPT0gdW5kZWZpbmVkKTtcbiAgICAgICAgY2FzZSBcIm9uZW9mXCI6XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxPbmVvZk5hbWUoZGVzYy5uYW1lKTtcbiAgICAgICAgY2FzZSBcImVudW1cIjpcbiAgICAgICAgY2FzZSBcIm1lc3NhZ2VcIjpcbiAgICAgICAgY2FzZSBcInNlcnZpY2VcIjoge1xuICAgICAgICAgICAgY29uc3QgcGtnID0gZGVzYy5maWxlLnByb3RvLnBhY2thZ2U7XG4gICAgICAgICAgICBjb25zdCBvZmZzZXQgPSBwa2cgPT09IHVuZGVmaW5lZCA/IDAgOiBwa2cubGVuZ3RoICsgMTtcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBkZXNjLnR5cGVOYW1lLnN1YnN0cmluZyhvZmZzZXQpLnJlcGxhY2UoL1xcLi9nLCBcIl9cIik7XG4gICAgICAgICAgICAvLyBGb3Igc2VydmljZXMsIHdlIG9ubHkgY2FyZSBhYm91dCBzYWZlIGlkZW50aWZpZXJzLCBub3Qgc2FmZSBvYmplY3QgcHJvcGVydGllcyxcbiAgICAgICAgICAgIC8vIGJ1dCB3ZSBoYXZlIHNoaXBwZWQgdjEgd2l0aCBhIGJ1ZyB0aGF0IHJlc3BlY3RlZCBvYmplY3QgcHJvcGVydGllcywgYW5kIHdlXG4gICAgICAgICAgICAvLyBkbyBub3Qgd2FudCB0byBpbnRyb2R1Y2UgYSBicmVha2luZyBjaGFuZ2UsIHNvIHdlIGNvbnRpbnVlIHRvIGVzY2FwZSBmb3JcbiAgICAgICAgICAgIC8vIHNhZmUgb2JqZWN0IHByb3BlcnRpZXMuXG4gICAgICAgICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2J1ZmJ1aWxkL3Byb3RvYnVmLWVzL3B1bGwvMzkxXG4gICAgICAgICAgICByZXR1cm4gc2FmZU9iamVjdFByb3BlcnR5KHNhZmVJZGVudGlmaWVyKG5hbWUpKTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiZW51bV92YWx1ZVwiOiB7XG4gICAgICAgICAgICBjb25zdCBzaGFyZWRQcmVmaXggPSBkZXNjLnBhcmVudC5zaGFyZWRQcmVmaXg7XG4gICAgICAgICAgICBpZiAoc2hhcmVkUHJlZml4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVzYy5uYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbmFtZSA9IGRlc2MubmFtZS5zdWJzdHJpbmcoc2hhcmVkUHJlZml4Lmxlbmd0aCk7XG4gICAgICAgICAgICByZXR1cm4gc2FmZU9iamVjdFByb3BlcnR5KG5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJycGNcIjoge1xuICAgICAgICAgICAgbGV0IG5hbWUgPSBkZXNjLm5hbWU7XG4gICAgICAgICAgICBpZiAobmFtZS5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmFtZSA9IG5hbWVbMF0udG9Mb3dlckNhc2UoKSArIG5hbWUuc3Vic3RyaW5nKDEpO1xuICAgICAgICAgICAgcmV0dXJuIHNhZmVPYmplY3RQcm9wZXJ0eShuYW1lKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogUmV0dXJucyB0aGUgbmFtZSBvZiBhIGZpZWxkIGluIGdlbmVyYXRlZCBjb2RlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbG9jYWxGaWVsZE5hbWUocHJvdG9OYW1lLCBpbk9uZW9mKSB7XG4gICAgY29uc3QgbmFtZSA9IHByb3RvQ2FtZWxDYXNlKHByb3RvTmFtZSk7XG4gICAgaWYgKGluT25lb2YpIHtcbiAgICAgICAgLy8gb25lb2YgbWVtYmVyIG5hbWVzIGFyZSBub3QgcHJvcGVydGllcywgYnV0IHZhbHVlcyBvZiB0aGUgYGNhc2VgIHByb3BlcnR5LlxuICAgICAgICByZXR1cm4gbmFtZTtcbiAgICB9XG4gICAgcmV0dXJuIHNhZmVPYmplY3RQcm9wZXJ0eShzYWZlTWVzc2FnZVByb3BlcnR5KG5hbWUpKTtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgbmFtZSBvZiBhIG9uZW9mIGdyb3VwIGluIGdlbmVyYXRlZCBjb2RlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbG9jYWxPbmVvZk5hbWUocHJvdG9OYW1lKSB7XG4gICAgcmV0dXJuIGxvY2FsRmllbGROYW1lKHByb3RvTmFtZSwgZmFsc2UpO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSBKU09OIG5hbWUgZm9yIGEgcHJvdG9idWYgZmllbGQsIGV4YWN0bHkgbGlrZSBwcm90b2MgZG9lcy5cbiAqL1xuZXhwb3J0IGNvbnN0IGZpZWxkSnNvbk5hbWUgPSBwcm90b0NhbWVsQ2FzZTtcbi8qKlxuICogRmluZHMgYSBwcmVmaXggc2hhcmVkIGJ5IGVudW0gdmFsdWVzLCBmb3IgZXhhbXBsZSBgTVlfRU5VTV9gIGZvclxuICogYGVudW0gTXlFbnVtIHtNWV9FTlVNX0E9MDsgTVlfRU5VTV9CPTE7fWAuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmaW5kRW51bVNoYXJlZFByZWZpeChlbnVtTmFtZSwgdmFsdWVOYW1lcykge1xuICAgIGNvbnN0IHByZWZpeCA9IGNhbWVsVG9TbmFrZUNhc2UoZW51bU5hbWUpICsgXCJfXCI7XG4gICAgZm9yIChjb25zdCBuYW1lIG9mIHZhbHVlTmFtZXMpIHtcbiAgICAgICAgaWYgKCFuYW1lLnRvTG93ZXJDYXNlKCkuc3RhcnRzV2l0aChwcmVmaXgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNob3J0TmFtZSA9IG5hbWUuc3Vic3RyaW5nKHByZWZpeC5sZW5ndGgpO1xuICAgICAgICBpZiAoc2hvcnROYW1lLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmICgvXlxcZC8udGVzdChzaG9ydE5hbWUpKSB7XG4gICAgICAgICAgICAvLyBpZGVudGlmaWVycyBtdXN0IG5vdCBzdGFydCB3aXRoIG51bWJlcnNcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHByZWZpeDtcbn1cbi8qKlxuICogQ29udmVydHMgbG93ZXJDYW1lbENhc2Ugb3IgVXBwZXJDYW1lbENhc2UgaW50byBsb3dlcl9zbmFrZV9jYXNlLlxuICogVGhpcyBpcyB1c2VkIHRvIGZpbmQgc2hhcmVkIHByZWZpeGVzIGluIGFuIGVudW0uXG4gKi9cbmZ1bmN0aW9uIGNhbWVsVG9TbmFrZUNhc2UoY2FtZWwpIHtcbiAgICByZXR1cm4gKGNhbWVsLnN1YnN0cmluZygwLCAxKSArIGNhbWVsLnN1YnN0cmluZygxKS5yZXBsYWNlKC9bQS1aXS9nLCAoYykgPT4gXCJfXCIgKyBjKSkudG9Mb3dlckNhc2UoKTtcbn1cbi8qKlxuICogQ29udmVydHMgc25ha2VfY2FzZSB0byBwcm90b0NhbWVsQ2FzZSBhY2NvcmRpbmcgdG8gdGhlIGNvbnZlbnRpb25cbiAqIHVzZWQgYnkgcHJvdG9jIHRvIGNvbnZlcnQgYSBmaWVsZCBuYW1lIHRvIGEgSlNPTiBuYW1lLlxuICovXG5mdW5jdGlvbiBwcm90b0NhbWVsQ2FzZShzbmFrZUNhc2UpIHtcbiAgICBsZXQgY2FwTmV4dCA9IGZhbHNlO1xuICAgIGNvbnN0IGIgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNuYWtlQ2FzZS5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgYyA9IHNuYWtlQ2FzZS5jaGFyQXQoaSk7XG4gICAgICAgIHN3aXRjaCAoYykge1xuICAgICAgICAgICAgY2FzZSBcIl9cIjpcbiAgICAgICAgICAgICAgICBjYXBOZXh0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCIwXCI6XG4gICAgICAgICAgICBjYXNlIFwiMVwiOlxuICAgICAgICAgICAgY2FzZSBcIjJcIjpcbiAgICAgICAgICAgIGNhc2UgXCIzXCI6XG4gICAgICAgICAgICBjYXNlIFwiNFwiOlxuICAgICAgICAgICAgY2FzZSBcIjVcIjpcbiAgICAgICAgICAgIGNhc2UgXCI2XCI6XG4gICAgICAgICAgICBjYXNlIFwiN1wiOlxuICAgICAgICAgICAgY2FzZSBcIjhcIjpcbiAgICAgICAgICAgIGNhc2UgXCI5XCI6XG4gICAgICAgICAgICAgICAgYi5wdXNoKGMpO1xuICAgICAgICAgICAgICAgIGNhcE5leHQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgaWYgKGNhcE5leHQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FwTmV4dCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBjID0gYy50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBiLnB1c2goYyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGIuam9pbihcIlwiKTtcbn1cbi8qKlxuICogTmFtZXMgdGhhdCBjYW5ub3QgYmUgdXNlZCBmb3IgaWRlbnRpZmllcnMsIHN1Y2ggYXMgY2xhc3MgbmFtZXMsXG4gKiBidXQgX2Nhbl8gYmUgdXNlZCBmb3Igb2JqZWN0IHByb3BlcnRpZXMuXG4gKi9cbmNvbnN0IHJlc2VydmVkSWRlbnRpZmllcnMgPSBuZXcgU2V0KFtcbiAgICAvLyBFQ01BU2NyaXB0IDIwMTUga2V5d29yZHNcbiAgICBcImJyZWFrXCIsXG4gICAgXCJjYXNlXCIsXG4gICAgXCJjYXRjaFwiLFxuICAgIFwiY2xhc3NcIixcbiAgICBcImNvbnN0XCIsXG4gICAgXCJjb250aW51ZVwiLFxuICAgIFwiZGVidWdnZXJcIixcbiAgICBcImRlZmF1bHRcIixcbiAgICBcImRlbGV0ZVwiLFxuICAgIFwiZG9cIixcbiAgICBcImVsc2VcIixcbiAgICBcImV4cG9ydFwiLFxuICAgIFwiZXh0ZW5kc1wiLFxuICAgIFwiZmFsc2VcIixcbiAgICBcImZpbmFsbHlcIixcbiAgICBcImZvclwiLFxuICAgIFwiZnVuY3Rpb25cIixcbiAgICBcImlmXCIsXG4gICAgXCJpbXBvcnRcIixcbiAgICBcImluXCIsXG4gICAgXCJpbnN0YW5jZW9mXCIsXG4gICAgXCJuZXdcIixcbiAgICBcIm51bGxcIixcbiAgICBcInJldHVyblwiLFxuICAgIFwic3VwZXJcIixcbiAgICBcInN3aXRjaFwiLFxuICAgIFwidGhpc1wiLFxuICAgIFwidGhyb3dcIixcbiAgICBcInRydWVcIixcbiAgICBcInRyeVwiLFxuICAgIFwidHlwZW9mXCIsXG4gICAgXCJ2YXJcIixcbiAgICBcInZvaWRcIixcbiAgICBcIndoaWxlXCIsXG4gICAgXCJ3aXRoXCIsXG4gICAgXCJ5aWVsZFwiLFxuICAgIC8vIEVDTUFTY3JpcHQgMjAxNSBmdXR1cmUgcmVzZXJ2ZWQga2V5d29yZHNcbiAgICBcImVudW1cIixcbiAgICBcImltcGxlbWVudHNcIixcbiAgICBcImludGVyZmFjZVwiLFxuICAgIFwibGV0XCIsXG4gICAgXCJwYWNrYWdlXCIsXG4gICAgXCJwcml2YXRlXCIsXG4gICAgXCJwcm90ZWN0ZWRcIixcbiAgICBcInB1YmxpY1wiLFxuICAgIFwic3RhdGljXCIsXG4gICAgLy8gQ2xhc3MgbmFtZSBjYW5ub3QgYmUgJ09iamVjdCcgd2hlbiB0YXJnZXRpbmcgRVM1IHdpdGggbW9kdWxlIENvbW1vbkpTXG4gICAgXCJPYmplY3RcIixcbiAgICAvLyBUeXBlU2NyaXB0IGtleXdvcmRzIHRoYXQgY2Fubm90IGJlIHVzZWQgZm9yIHR5cGVzIChhcyBvcHBvc2VkIHRvIHZhcmlhYmxlcylcbiAgICBcImJpZ2ludFwiLFxuICAgIFwibnVtYmVyXCIsXG4gICAgXCJib29sZWFuXCIsXG4gICAgXCJzdHJpbmdcIixcbiAgICBcIm9iamVjdFwiLFxuICAgIC8vIElkZW50aWZpZXJzIHJlc2VydmVkIGZvciB0aGUgcnVudGltZSwgc28gd2UgY2FuIGdlbmVyYXRlIGxlZ2libGUgY29kZVxuICAgIFwiZ2xvYmFsVGhpc1wiLFxuICAgIFwiVWludDhBcnJheVwiLFxuICAgIFwiUGFydGlhbFwiLFxuXSk7XG4vKipcbiAqIE5hbWVzIHRoYXQgY2Fubm90IGJlIHVzZWQgZm9yIG9iamVjdCBwcm9wZXJ0aWVzIGJlY2F1c2UgdGhleSBhcmUgcmVzZXJ2ZWRcbiAqIGJ5IGJ1aWx0LWluIEphdmFTY3JpcHQgcHJvcGVydGllcy5cbiAqL1xuY29uc3QgcmVzZXJ2ZWRPYmplY3RQcm9wZXJ0aWVzID0gbmV3IFNldChbXG4gICAgLy8gbmFtZXMgcmVzZXJ2ZWQgYnkgSmF2YVNjcmlwdFxuICAgIFwiY29uc3RydWN0b3JcIixcbiAgICBcInRvU3RyaW5nXCIsXG4gICAgXCJ0b0pTT05cIixcbiAgICBcInZhbHVlT2ZcIixcbl0pO1xuLyoqXG4gKiBOYW1lcyB0aGF0IGNhbm5vdCBiZSB1c2VkIGZvciBvYmplY3QgcHJvcGVydGllcyBiZWNhdXNlIHRoZXkgYXJlIHJlc2VydmVkXG4gKiBieSB0aGUgcnVudGltZS5cbiAqL1xuY29uc3QgcmVzZXJ2ZWRNZXNzYWdlUHJvcGVydGllcyA9IG5ldyBTZXQoW1xuICAgIC8vIG5hbWVzIHJlc2VydmVkIGJ5IHRoZSBydW50aW1lXG4gICAgXCJnZXRUeXBlXCIsXG4gICAgXCJjbG9uZVwiLFxuICAgIFwiZXF1YWxzXCIsXG4gICAgXCJmcm9tQmluYXJ5XCIsXG4gICAgXCJmcm9tSnNvblwiLFxuICAgIFwiZnJvbUpzb25TdHJpbmdcIixcbiAgICBcInRvQmluYXJ5XCIsXG4gICAgXCJ0b0pzb25cIixcbiAgICBcInRvSnNvblN0cmluZ1wiLFxuICAgIC8vIG5hbWVzIHJlc2VydmVkIGJ5IHRoZSBydW50aW1lIGZvciB0aGUgZnV0dXJlXG4gICAgXCJ0b09iamVjdFwiLFxuXSk7XG5jb25zdCBmYWxsYmFjayA9IChuYW1lKSA9PiBgJHtuYW1lfSRgO1xuLyoqXG4gKiBXaWxsIHdyYXAgbmFtZXMgdGhhdCBhcmUgT2JqZWN0IHByb3RvdHlwZSBwcm9wZXJ0aWVzIG9yIG5hbWVzIHJlc2VydmVkXG4gKiBmb3IgYE1lc3NhZ2Vgcy5cbiAqL1xuY29uc3Qgc2FmZU1lc3NhZ2VQcm9wZXJ0eSA9IChuYW1lKSA9PiB7XG4gICAgaWYgKHJlc2VydmVkTWVzc2FnZVByb3BlcnRpZXMuaGFzKG5hbWUpKSB7XG4gICAgICAgIHJldHVybiBmYWxsYmFjayhuYW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIG5hbWU7XG59O1xuLyoqXG4gKiBOYW1lcyB0aGF0IGNhbm5vdCBiZSB1c2VkIGZvciBvYmplY3QgcHJvcGVydGllcyBiZWNhdXNlIHRoZXkgYXJlIHJlc2VydmVkXG4gKiBieSBidWlsdC1pbiBKYXZhU2NyaXB0IHByb3BlcnRpZXMuXG4gKi9cbmV4cG9ydCBjb25zdCBzYWZlT2JqZWN0UHJvcGVydHkgPSAobmFtZSkgPT4ge1xuICAgIGlmIChyZXNlcnZlZE9iamVjdFByb3BlcnRpZXMuaGFzKG5hbWUpKSB7XG4gICAgICAgIHJldHVybiBmYWxsYmFjayhuYW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIG5hbWU7XG59O1xuLyoqXG4gKiBOYW1lcyB0aGF0IGNhbiBiZSB1c2VkIGZvciBpZGVudGlmaWVycyBvciBjbGFzcyBwcm9wZXJ0aWVzXG4gKi9cbmV4cG9ydCBjb25zdCBzYWZlSWRlbnRpZmllciA9IChuYW1lKSA9PiB7XG4gICAgaWYgKHJlc2VydmVkSWRlbnRpZmllcnMuaGFzKG5hbWUpKSB7XG4gICAgICAgIHJldHVybiBmYWxsYmFjayhuYW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIG5hbWU7XG59O1xuIiwiLy8gQ29weXJpZ2h0IDIwMjEtMjAyMyBCdWYgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbmltcG9ydCB7IGxvY2FsT25lb2ZOYW1lIH0gZnJvbSBcIi4vbmFtZXMuanNcIjtcbmltcG9ydCB7IGFzc2VydCB9IGZyb20gXCIuL2Fzc2VydC5qc1wiO1xuZXhwb3J0IGNsYXNzIEludGVybmFsT25lb2ZJbmZvIHtcbiAgICBjb25zdHJ1Y3RvcihuYW1lKSB7XG4gICAgICAgIHRoaXMua2luZCA9IFwib25lb2ZcIjtcbiAgICAgICAgdGhpcy5yZXBlYXRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnBhY2tlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLm9wdCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmRlZmF1bHQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuZmllbGRzID0gW107XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMubG9jYWxOYW1lID0gbG9jYWxPbmVvZk5hbWUobmFtZSk7XG4gICAgfVxuICAgIGFkZEZpZWxkKGZpZWxkKSB7XG4gICAgICAgIGFzc2VydChmaWVsZC5vbmVvZiA9PT0gdGhpcywgYGZpZWxkICR7ZmllbGQubmFtZX0gbm90IG9uZSBvZiAke3RoaXMubmFtZX1gKTtcbiAgICAgICAgdGhpcy5maWVsZHMucHVzaChmaWVsZCk7XG4gICAgfVxuICAgIGZpbmRGaWVsZChsb2NhbE5hbWUpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9sb29rdXApIHtcbiAgICAgICAgICAgIHRoaXMuX2xvb2t1cCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZmllbGRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbG9va3VwW3RoaXMuZmllbGRzW2ldLmxvY2FsTmFtZV0gPSB0aGlzLmZpZWxkc1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fbG9va3VwW2xvY2FsTmFtZV07XG4gICAgfVxufVxuIiwiLy8gQ29weXJpZ2h0IDIwMjEtMjAyMyBCdWYgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbmltcG9ydCB7IG1ha2VQcm90b1J1bnRpbWUgfSBmcm9tIFwiLi9wcml2YXRlL3Byb3RvLXJ1bnRpbWUuanNcIjtcbmltcG9ydCB7IG1ha2VCaW5hcnlGb3JtYXRQcm90bzMgfSBmcm9tIFwiLi9wcml2YXRlL2JpbmFyeS1mb3JtYXQtcHJvdG8zLmpzXCI7XG5pbXBvcnQgeyBtYWtlSnNvbkZvcm1hdFByb3RvMyB9IGZyb20gXCIuL3ByaXZhdGUvanNvbi1mb3JtYXQtcHJvdG8zLmpzXCI7XG5pbXBvcnQgeyBtYWtlVXRpbENvbW1vbiB9IGZyb20gXCIuL3ByaXZhdGUvdXRpbC1jb21tb24uanNcIjtcbmltcG9ydCB7IEludGVybmFsRmllbGRMaXN0IH0gZnJvbSBcIi4vcHJpdmF0ZS9maWVsZC1saXN0LmpzXCI7XG5pbXBvcnQgeyBzY2FsYXJEZWZhdWx0VmFsdWUgfSBmcm9tIFwiLi9wcml2YXRlL3NjYWxhcnMuanNcIjtcbmltcG9ydCB7IExvbmdUeXBlLCBTY2FsYXJUeXBlIH0gZnJvbSBcIi4vZmllbGQuanNcIjtcbmltcG9ydCB7IEludGVybmFsT25lb2ZJbmZvIH0gZnJvbSBcIi4vcHJpdmF0ZS9maWVsZC5qc1wiO1xuaW1wb3J0IHsgbG9jYWxGaWVsZE5hbWUsIGZpZWxkSnNvbk5hbWUgfSBmcm9tIFwiLi9wcml2YXRlL25hbWVzLmpzXCI7XG4vKipcbiAqIFByb3ZpZGVzIGZ1bmN0aW9uYWxpdHkgZm9yIG1lc3NhZ2VzIGRlZmluZWQgd2l0aCB0aGUgcHJvdG8zIHN5bnRheC5cbiAqL1xuZXhwb3J0IGNvbnN0IHByb3RvMyA9IG1ha2VQcm90b1J1bnRpbWUoXCJwcm90bzNcIiwgbWFrZUpzb25Gb3JtYXRQcm90bzMoKSwgbWFrZUJpbmFyeUZvcm1hdFByb3RvMygpLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG1ha2VVdGlsQ29tbW9uKCkpLCB7IG5ld0ZpZWxkTGlzdChmaWVsZHMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBJbnRlcm5hbEZpZWxkTGlzdChmaWVsZHMsIG5vcm1hbGl6ZUZpZWxkSW5mb3NQcm90bzMpO1xuICAgIH0sXG4gICAgaW5pdEZpZWxkcyh0YXJnZXQpIHtcbiAgICAgICAgZm9yIChjb25zdCBtZW1iZXIgb2YgdGFyZ2V0LmdldFR5cGUoKS5maWVsZHMuYnlNZW1iZXIoKSkge1xuICAgICAgICAgICAgaWYgKG1lbWJlci5vcHQpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBtZW1iZXIubG9jYWxOYW1lLCB0ID0gdGFyZ2V0O1xuICAgICAgICAgICAgaWYgKG1lbWJlci5yZXBlYXRlZCkge1xuICAgICAgICAgICAgICAgIHRbbmFtZV0gPSBbXTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN3aXRjaCAobWVtYmVyLmtpbmQpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwib25lb2ZcIjpcbiAgICAgICAgICAgICAgICAgICAgdFtuYW1lXSA9IHsgY2FzZTogdW5kZWZpbmVkIH07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJlbnVtXCI6XG4gICAgICAgICAgICAgICAgICAgIHRbbmFtZV0gPSAwO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwibWFwXCI6XG4gICAgICAgICAgICAgICAgICAgIHRbbmFtZV0gPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcInNjYWxhclwiOlxuICAgICAgICAgICAgICAgICAgICB0W25hbWVdID0gc2NhbGFyRGVmYXVsdFZhbHVlKG1lbWJlci5ULCBtZW1iZXIuTCk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hc3NpZ25tZW50XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJtZXNzYWdlXCI6XG4gICAgICAgICAgICAgICAgICAgIC8vIG1lc3NhZ2UgZmllbGRzIGFyZSBhbHdheXMgb3B0aW9uYWwgaW4gcHJvdG8zXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSB9KSk7XG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55LEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXNzaWdubWVudCxAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLW1lbWJlci1hY2Nlc3MsQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hcmd1bWVudCAqL1xuZnVuY3Rpb24gbm9ybWFsaXplRmllbGRJbmZvc1Byb3RvMyhmaWVsZEluZm9zKSB7XG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgIGNvbnN0IHIgPSBbXTtcbiAgICBsZXQgbztcbiAgICBmb3IgKGNvbnN0IGZpZWxkIG9mIHR5cGVvZiBmaWVsZEluZm9zID09IFwiZnVuY3Rpb25cIlxuICAgICAgICA/IGZpZWxkSW5mb3MoKVxuICAgICAgICA6IGZpZWxkSW5mb3MpIHtcbiAgICAgICAgY29uc3QgZiA9IGZpZWxkO1xuICAgICAgICBmLmxvY2FsTmFtZSA9IGxvY2FsRmllbGROYW1lKGZpZWxkLm5hbWUsIGZpZWxkLm9uZW9mICE9PSB1bmRlZmluZWQpO1xuICAgICAgICBmLmpzb25OYW1lID0gKF9hID0gZmllbGQuanNvbk5hbWUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGZpZWxkSnNvbk5hbWUoZmllbGQubmFtZSk7XG4gICAgICAgIGYucmVwZWF0ZWQgPSAoX2IgPSBmaWVsZC5yZXBlYXRlZCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogZmFsc2U7XG4gICAgICAgIGlmIChmaWVsZC5raW5kID09IFwic2NhbGFyXCIpIHtcbiAgICAgICAgICAgIGYuTCA9IChfYyA9IGZpZWxkLkwpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IExvbmdUeXBlLkJJR0lOVDtcbiAgICAgICAgfVxuICAgICAgICAvLyBGcm9tIHRoZSBwcm90bzMgbGFuZ3VhZ2UgZ3VpZGU6XG4gICAgICAgIC8vID4gSW4gcHJvdG8zLCByZXBlYXRlZCBmaWVsZHMgb2Ygc2NhbGFyIG51bWVyaWMgdHlwZXMgYXJlIHBhY2tlZCBieSBkZWZhdWx0LlxuICAgICAgICAvLyBUaGlzIGluZm9ybWF0aW9uIGlzIGluY29tcGxldGUgLSBhY2NvcmRpbmcgdG8gdGhlIGNvbmZvcm1hbmNlIHRlc3RzLCBCT09MXG4gICAgICAgIC8vIGFuZCBFTlVNIGFyZSBwYWNrZWQgYnkgZGVmYXVsdCBhcyB3ZWxsLiBUaGlzIG1lYW5zIG9ubHkgU1RSSU5HIGFuZCBCWVRFU1xuICAgICAgICAvLyBhcmUgbm90IHBhY2tlZCBieSBkZWZhdWx0LCB3aGljaCBtYWtlcyBzZW5zZSBiZWNhdXNlIHRoZXkgYXJlIGxlbmd0aC1kZWxpbWl0ZWQuXG4gICAgICAgIGYucGFja2VkID1cbiAgICAgICAgICAgIChfZCA9IGZpZWxkLnBhY2tlZCkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogKGZpZWxkLmtpbmQgPT0gXCJlbnVtXCIgfHxcbiAgICAgICAgICAgICAgICAoZmllbGQua2luZCA9PSBcInNjYWxhclwiICYmXG4gICAgICAgICAgICAgICAgICAgIGZpZWxkLlQgIT0gU2NhbGFyVHlwZS5CWVRFUyAmJlxuICAgICAgICAgICAgICAgICAgICBmaWVsZC5UICE9IFNjYWxhclR5cGUuU1RSSU5HKSk7XG4gICAgICAgIC8vIFdlIGRvIG5vdCBzdXJmYWNlIG9wdGlvbnMgYXQgdGhpcyB0aW1lXG4gICAgICAgIC8vIGYub3B0aW9ucyA9IGZpZWxkLm9wdGlvbnMgPz8gZW1wdHlSZWFkb25seU9iamVjdDtcbiAgICAgICAgaWYgKGZpZWxkLm9uZW9mICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IG9vbmFtZSA9IHR5cGVvZiBmaWVsZC5vbmVvZiA9PSBcInN0cmluZ1wiID8gZmllbGQub25lb2YgOiBmaWVsZC5vbmVvZi5uYW1lO1xuICAgICAgICAgICAgaWYgKCFvIHx8IG8ubmFtZSAhPSBvb25hbWUpIHtcbiAgICAgICAgICAgICAgICBvID0gbmV3IEludGVybmFsT25lb2ZJbmZvKG9vbmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmLm9uZW9mID0gbztcbiAgICAgICAgICAgIG8uYWRkRmllbGQoZik7XG4gICAgICAgIH1cbiAgICAgICAgci5wdXNoKGYpO1xuICAgIH1cbiAgICByZXR1cm4gcjtcbn1cbiIsIi8vIENvcHlyaWdodCAyMDIxLTIwMjMgQnVmIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5pbXBvcnQgeyBNZXNzYWdlIH0gZnJvbSBcIi4uLy4uL21lc3NhZ2UuanNcIjtcbmltcG9ydCB7IHByb3RvSW50NjQgfSBmcm9tIFwiLi4vLi4vcHJvdG8taW50NjQuanNcIjtcbmltcG9ydCB7IHByb3RvMyB9IGZyb20gXCIuLi8uLi9wcm90bzMuanNcIjtcbi8qKlxuICogQSBUaW1lc3RhbXAgcmVwcmVzZW50cyBhIHBvaW50IGluIHRpbWUgaW5kZXBlbmRlbnQgb2YgYW55IHRpbWUgem9uZSBvciBsb2NhbFxuICogY2FsZW5kYXIsIGVuY29kZWQgYXMgYSBjb3VudCBvZiBzZWNvbmRzIGFuZCBmcmFjdGlvbnMgb2Ygc2Vjb25kcyBhdFxuICogbmFub3NlY29uZCByZXNvbHV0aW9uLiBUaGUgY291bnQgaXMgcmVsYXRpdmUgdG8gYW4gZXBvY2ggYXQgVVRDIG1pZG5pZ2h0IG9uXG4gKiBKYW51YXJ5IDEsIDE5NzAsIGluIHRoZSBwcm9sZXB0aWMgR3JlZ29yaWFuIGNhbGVuZGFyIHdoaWNoIGV4dGVuZHMgdGhlXG4gKiBHcmVnb3JpYW4gY2FsZW5kYXIgYmFja3dhcmRzIHRvIHllYXIgb25lLlxuICpcbiAqIEFsbCBtaW51dGVzIGFyZSA2MCBzZWNvbmRzIGxvbmcuIExlYXAgc2Vjb25kcyBhcmUgXCJzbWVhcmVkXCIgc28gdGhhdCBubyBsZWFwXG4gKiBzZWNvbmQgdGFibGUgaXMgbmVlZGVkIGZvciBpbnRlcnByZXRhdGlvbiwgdXNpbmcgYSBbMjQtaG91ciBsaW5lYXJcbiAqIHNtZWFyXShodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS90aW1lL3NtZWFyKS5cbiAqXG4gKiBUaGUgcmFuZ2UgaXMgZnJvbSAwMDAxLTAxLTAxVDAwOjAwOjAwWiB0byA5OTk5LTEyLTMxVDIzOjU5OjU5Ljk5OTk5OTk5OVouIEJ5XG4gKiByZXN0cmljdGluZyB0byB0aGF0IHJhbmdlLCB3ZSBlbnN1cmUgdGhhdCB3ZSBjYW4gY29udmVydCB0byBhbmQgZnJvbSBbUkZDXG4gKiAzMzM5XShodHRwczovL3d3dy5pZXRmLm9yZy9yZmMvcmZjMzMzOS50eHQpIGRhdGUgc3RyaW5ncy5cbiAqXG4gKiAjIEV4YW1wbGVzXG4gKlxuICogRXhhbXBsZSAxOiBDb21wdXRlIFRpbWVzdGFtcCBmcm9tIFBPU0lYIGB0aW1lKClgLlxuICpcbiAqICAgICBUaW1lc3RhbXAgdGltZXN0YW1wO1xuICogICAgIHRpbWVzdGFtcC5zZXRfc2Vjb25kcyh0aW1lKE5VTEwpKTtcbiAqICAgICB0aW1lc3RhbXAuc2V0X25hbm9zKDApO1xuICpcbiAqIEV4YW1wbGUgMjogQ29tcHV0ZSBUaW1lc3RhbXAgZnJvbSBQT1NJWCBgZ2V0dGltZW9mZGF5KClgLlxuICpcbiAqICAgICBzdHJ1Y3QgdGltZXZhbCB0djtcbiAqICAgICBnZXR0aW1lb2ZkYXkoJnR2LCBOVUxMKTtcbiAqXG4gKiAgICAgVGltZXN0YW1wIHRpbWVzdGFtcDtcbiAqICAgICB0aW1lc3RhbXAuc2V0X3NlY29uZHModHYudHZfc2VjKTtcbiAqICAgICB0aW1lc3RhbXAuc2V0X25hbm9zKHR2LnR2X3VzZWMgKiAxMDAwKTtcbiAqXG4gKiBFeGFtcGxlIDM6IENvbXB1dGUgVGltZXN0YW1wIGZyb20gV2luMzIgYEdldFN5c3RlbVRpbWVBc0ZpbGVUaW1lKClgLlxuICpcbiAqICAgICBGSUxFVElNRSBmdDtcbiAqICAgICBHZXRTeXN0ZW1UaW1lQXNGaWxlVGltZSgmZnQpO1xuICogICAgIFVJTlQ2NCB0aWNrcyA9ICgoKFVJTlQ2NClmdC5kd0hpZ2hEYXRlVGltZSkgPDwgMzIpIHwgZnQuZHdMb3dEYXRlVGltZTtcbiAqXG4gKiAgICAgLy8gQSBXaW5kb3dzIHRpY2sgaXMgMTAwIG5hbm9zZWNvbmRzLiBXaW5kb3dzIGVwb2NoIDE2MDEtMDEtMDFUMDA6MDA6MDBaXG4gKiAgICAgLy8gaXMgMTE2NDQ0NzM2MDAgc2Vjb25kcyBiZWZvcmUgVW5peCBlcG9jaCAxOTcwLTAxLTAxVDAwOjAwOjAwWi5cbiAqICAgICBUaW1lc3RhbXAgdGltZXN0YW1wO1xuICogICAgIHRpbWVzdGFtcC5zZXRfc2Vjb25kcygoSU5UNjQpICgodGlja3MgLyAxMDAwMDAwMCkgLSAxMTY0NDQ3MzYwMExMKSk7XG4gKiAgICAgdGltZXN0YW1wLnNldF9uYW5vcygoSU5UMzIpICgodGlja3MgJSAxMDAwMDAwMCkgKiAxMDApKTtcbiAqXG4gKiBFeGFtcGxlIDQ6IENvbXB1dGUgVGltZXN0YW1wIGZyb20gSmF2YSBgU3lzdGVtLmN1cnJlbnRUaW1lTWlsbGlzKClgLlxuICpcbiAqICAgICBsb25nIG1pbGxpcyA9IFN5c3RlbS5jdXJyZW50VGltZU1pbGxpcygpO1xuICpcbiAqICAgICBUaW1lc3RhbXAgdGltZXN0YW1wID0gVGltZXN0YW1wLm5ld0J1aWxkZXIoKS5zZXRTZWNvbmRzKG1pbGxpcyAvIDEwMDApXG4gKiAgICAgICAgIC5zZXROYW5vcygoaW50KSAoKG1pbGxpcyAlIDEwMDApICogMTAwMDAwMCkpLmJ1aWxkKCk7XG4gKlxuICogRXhhbXBsZSA1OiBDb21wdXRlIFRpbWVzdGFtcCBmcm9tIEphdmEgYEluc3RhbnQubm93KClgLlxuICpcbiAqICAgICBJbnN0YW50IG5vdyA9IEluc3RhbnQubm93KCk7XG4gKlxuICogICAgIFRpbWVzdGFtcCB0aW1lc3RhbXAgPVxuICogICAgICAgICBUaW1lc3RhbXAubmV3QnVpbGRlcigpLnNldFNlY29uZHMobm93LmdldEVwb2NoU2Vjb25kKCkpXG4gKiAgICAgICAgICAgICAuc2V0TmFub3Mobm93LmdldE5hbm8oKSkuYnVpbGQoKTtcbiAqXG4gKiBFeGFtcGxlIDY6IENvbXB1dGUgVGltZXN0YW1wIGZyb20gY3VycmVudCB0aW1lIGluIFB5dGhvbi5cbiAqXG4gKiAgICAgdGltZXN0YW1wID0gVGltZXN0YW1wKClcbiAqICAgICB0aW1lc3RhbXAuR2V0Q3VycmVudFRpbWUoKVxuICpcbiAqICMgSlNPTiBNYXBwaW5nXG4gKlxuICogSW4gSlNPTiBmb3JtYXQsIHRoZSBUaW1lc3RhbXAgdHlwZSBpcyBlbmNvZGVkIGFzIGEgc3RyaW5nIGluIHRoZVxuICogW1JGQyAzMzM5XShodHRwczovL3d3dy5pZXRmLm9yZy9yZmMvcmZjMzMzOS50eHQpIGZvcm1hdC4gVGhhdCBpcywgdGhlXG4gKiBmb3JtYXQgaXMgXCJ7eWVhcn0te21vbnRofS17ZGF5fVR7aG91cn06e21pbn06e3NlY31bLntmcmFjX3NlY31dWlwiXG4gKiB3aGVyZSB7eWVhcn0gaXMgYWx3YXlzIGV4cHJlc3NlZCB1c2luZyBmb3VyIGRpZ2l0cyB3aGlsZSB7bW9udGh9LCB7ZGF5fSxcbiAqIHtob3VyfSwge21pbn0sIGFuZCB7c2VjfSBhcmUgemVyby1wYWRkZWQgdG8gdHdvIGRpZ2l0cyBlYWNoLiBUaGUgZnJhY3Rpb25hbFxuICogc2Vjb25kcywgd2hpY2ggY2FuIGdvIHVwIHRvIDkgZGlnaXRzIChpLmUuIHVwIHRvIDEgbmFub3NlY29uZCByZXNvbHV0aW9uKSxcbiAqIGFyZSBvcHRpb25hbC4gVGhlIFwiWlwiIHN1ZmZpeCBpbmRpY2F0ZXMgdGhlIHRpbWV6b25lIChcIlVUQ1wiKTsgdGhlIHRpbWV6b25lXG4gKiBpcyByZXF1aXJlZC4gQSBwcm90bzMgSlNPTiBzZXJpYWxpemVyIHNob3VsZCBhbHdheXMgdXNlIFVUQyAoYXMgaW5kaWNhdGVkIGJ5XG4gKiBcIlpcIikgd2hlbiBwcmludGluZyB0aGUgVGltZXN0YW1wIHR5cGUgYW5kIGEgcHJvdG8zIEpTT04gcGFyc2VyIHNob3VsZCBiZVxuICogYWJsZSB0byBhY2NlcHQgYm90aCBVVEMgYW5kIG90aGVyIHRpbWV6b25lcyAoYXMgaW5kaWNhdGVkIGJ5IGFuIG9mZnNldCkuXG4gKlxuICogRm9yIGV4YW1wbGUsIFwiMjAxNy0wMS0xNVQwMTozMDoxNS4wMVpcIiBlbmNvZGVzIDE1LjAxIHNlY29uZHMgcGFzdFxuICogMDE6MzAgVVRDIG9uIEphbnVhcnkgMTUsIDIwMTcuXG4gKlxuICogSW4gSmF2YVNjcmlwdCwgb25lIGNhbiBjb252ZXJ0IGEgRGF0ZSBvYmplY3QgdG8gdGhpcyBmb3JtYXQgdXNpbmcgdGhlXG4gKiBzdGFuZGFyZFxuICogW3RvSVNPU3RyaW5nKCldKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0RhdGUvdG9JU09TdHJpbmcpXG4gKiBtZXRob2QuIEluIFB5dGhvbiwgYSBzdGFuZGFyZCBgZGF0ZXRpbWUuZGF0ZXRpbWVgIG9iamVjdCBjYW4gYmUgY29udmVydGVkXG4gKiB0byB0aGlzIGZvcm1hdCB1c2luZ1xuICogW2BzdHJmdGltZWBdKGh0dHBzOi8vZG9jcy5weXRob24ub3JnLzIvbGlicmFyeS90aW1lLmh0bWwjdGltZS5zdHJmdGltZSkgd2l0aFxuICogdGhlIHRpbWUgZm9ybWF0IHNwZWMgJyVZLSVtLSVkVCVIOiVNOiVTLiVmWicuIExpa2V3aXNlLCBpbiBKYXZhLCBvbmUgY2FuIHVzZVxuICogdGhlIEpvZGEgVGltZSdzIFtgSVNPRGF0ZVRpbWVGb3JtYXQuZGF0ZVRpbWUoKWBdKFxuICogaHR0cDovL2pvZGEtdGltZS5zb3VyY2Vmb3JnZS5uZXQvYXBpZG9jcy9vcmcvam9kYS90aW1lL2Zvcm1hdC9JU09EYXRlVGltZUZvcm1hdC5odG1sI2RhdGVUaW1lKClcbiAqICkgdG8gb2J0YWluIGEgZm9ybWF0dGVyIGNhcGFibGUgb2YgZ2VuZXJhdGluZyB0aW1lc3RhbXBzIGluIHRoaXMgZm9ybWF0LlxuICpcbiAqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBnb29nbGUucHJvdG9idWYuVGltZXN0YW1wXG4gKi9cbmV4cG9ydCBjbGFzcyBUaW1lc3RhbXAgZXh0ZW5kcyBNZXNzYWdlIHtcbiAgICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXByZXNlbnRzIHNlY29uZHMgb2YgVVRDIHRpbWUgc2luY2UgVW5peCBlcG9jaFxuICAgICAgICAgKiAxOTcwLTAxLTAxVDAwOjAwOjAwWi4gTXVzdCBiZSBmcm9tIDAwMDEtMDEtMDFUMDA6MDA6MDBaIHRvXG4gICAgICAgICAqIDk5OTktMTItMzFUMjM6NTk6NTlaIGluY2x1c2l2ZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBpbnQ2NCBzZWNvbmRzID0gMTtcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2Vjb25kcyA9IHByb3RvSW50NjQuemVybztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE5vbi1uZWdhdGl2ZSBmcmFjdGlvbnMgb2YgYSBzZWNvbmQgYXQgbmFub3NlY29uZCByZXNvbHV0aW9uLiBOZWdhdGl2ZVxuICAgICAgICAgKiBzZWNvbmQgdmFsdWVzIHdpdGggZnJhY3Rpb25zIG11c3Qgc3RpbGwgaGF2ZSBub24tbmVnYXRpdmUgbmFub3MgdmFsdWVzXG4gICAgICAgICAqIHRoYXQgY291bnQgZm9yd2FyZCBpbiB0aW1lLiBNdXN0IGJlIGZyb20gMCB0byA5OTksOTk5LDk5OVxuICAgICAgICAgKiBpbmNsdXNpdmUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogaW50MzIgbmFub3MgPSAyO1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5uYW5vcyA9IDA7XG4gICAgICAgIHByb3RvMy51dGlsLmluaXRQYXJ0aWFsKGRhdGEsIHRoaXMpO1xuICAgIH1cbiAgICBmcm9tSnNvbihqc29uLCBvcHRpb25zKSB7XG4gICAgICAgIGlmICh0eXBlb2YganNvbiAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjYW5ub3QgZGVjb2RlIGdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXAgZnJvbSBKU09OOiAke3Byb3RvMy5qc29uLmRlYnVnKGpzb24pfWApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1hdGNoZXMgPSBqc29uLm1hdGNoKC9eKFswLTldezR9KS0oWzAtOV17Mn0pLShbMC05XXsyfSlUKFswLTldezJ9KTooWzAtOV17Mn0pOihbMC05XXsyfSkoPzpafFxcLihbMC05XXszLDl9KVp8KFsrLV1bMC05XVswLTldOlswLTldWzAtOV0pKSQvKTtcbiAgICAgICAgaWYgKCFtYXRjaGVzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNhbm5vdCBkZWNvZGUgZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcCBmcm9tIEpTT046IGludmFsaWQgUkZDIDMzMzkgc3RyaW5nYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbXMgPSBEYXRlLnBhcnNlKG1hdGNoZXNbMV0gKyBcIi1cIiArIG1hdGNoZXNbMl0gKyBcIi1cIiArIG1hdGNoZXNbM10gKyBcIlRcIiArIG1hdGNoZXNbNF0gKyBcIjpcIiArIG1hdGNoZXNbNV0gKyBcIjpcIiArIG1hdGNoZXNbNl0gKyAobWF0Y2hlc1s4XSA/IG1hdGNoZXNbOF0gOiBcIlpcIikpO1xuICAgICAgICBpZiAoTnVtYmVyLmlzTmFOKG1zKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjYW5ub3QgZGVjb2RlIGdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXAgZnJvbSBKU09OOiBpbnZhbGlkIFJGQyAzMzM5IHN0cmluZ2ApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtcyA8IERhdGUucGFyc2UoXCIwMDAxLTAxLTAxVDAwOjAwOjAwWlwiKSB8fCBtcyA+IERhdGUucGFyc2UoXCI5OTk5LTEyLTMxVDIzOjU5OjU5WlwiKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjYW5ub3QgZGVjb2RlIG1lc3NhZ2UgZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcCBmcm9tIEpTT046IG11c3QgYmUgZnJvbSAwMDAxLTAxLTAxVDAwOjAwOjAwWiB0byA5OTk5LTEyLTMxVDIzOjU5OjU5WiBpbmNsdXNpdmVgKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNlY29uZHMgPSBwcm90b0ludDY0LnBhcnNlKG1zIC8gMTAwMCk7XG4gICAgICAgIHRoaXMubmFub3MgPSAwO1xuICAgICAgICBpZiAobWF0Y2hlc1s3XSkge1xuICAgICAgICAgICAgdGhpcy5uYW5vcyA9IChwYXJzZUludChcIjFcIiArIG1hdGNoZXNbN10gKyBcIjBcIi5yZXBlYXQoOSAtIG1hdGNoZXNbN10ubGVuZ3RoKSkgLSAxMDAwMDAwMDAwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdG9Kc29uKG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgbXMgPSBOdW1iZXIodGhpcy5zZWNvbmRzKSAqIDEwMDA7XG4gICAgICAgIGlmIChtcyA8IERhdGUucGFyc2UoXCIwMDAxLTAxLTAxVDAwOjAwOjAwWlwiKSB8fCBtcyA+IERhdGUucGFyc2UoXCI5OTk5LTEyLTMxVDIzOjU5OjU5WlwiKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjYW5ub3QgZW5jb2RlIGdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXAgdG8gSlNPTjogbXVzdCBiZSBmcm9tIDAwMDEtMDEtMDFUMDA6MDA6MDBaIHRvIDk5OTktMTItMzFUMjM6NTk6NTlaIGluY2x1c2l2ZWApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm5hbm9zIDwgMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjYW5ub3QgZW5jb2RlIGdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXAgdG8gSlNPTjogbmFub3MgbXVzdCBub3QgYmUgbmVnYXRpdmVgKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgeiA9IFwiWlwiO1xuICAgICAgICBpZiAodGhpcy5uYW5vcyA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IG5hbm9zU3RyID0gKHRoaXMubmFub3MgKyAxMDAwMDAwMDAwKS50b1N0cmluZygpLnN1YnN0cmluZygxKTtcbiAgICAgICAgICAgIGlmIChuYW5vc1N0ci5zdWJzdHJpbmcoMykgPT09IFwiMDAwMDAwXCIpIHtcbiAgICAgICAgICAgICAgICB6ID0gXCIuXCIgKyBuYW5vc1N0ci5zdWJzdHJpbmcoMCwgMykgKyBcIlpcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG5hbm9zU3RyLnN1YnN0cmluZyg2KSA9PT0gXCIwMDBcIikge1xuICAgICAgICAgICAgICAgIHogPSBcIi5cIiArIG5hbm9zU3RyLnN1YnN0cmluZygwLCA2KSArIFwiWlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgeiA9IFwiLlwiICsgbmFub3NTdHIgKyBcIlpcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IERhdGUobXMpLnRvSVNPU3RyaW5nKCkucmVwbGFjZShcIi4wMDBaXCIsIHopO1xuICAgIH1cbiAgICB0b0RhdGUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZShOdW1iZXIodGhpcy5zZWNvbmRzKSAqIDEwMDAgKyBNYXRoLmNlaWwodGhpcy5uYW5vcyAvIDEwMDAwMDApKTtcbiAgICB9XG4gICAgc3RhdGljIG5vdygpIHtcbiAgICAgICAgcmV0dXJuIFRpbWVzdGFtcC5mcm9tRGF0ZShuZXcgRGF0ZSgpKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21EYXRlKGRhdGUpIHtcbiAgICAgICAgY29uc3QgbXMgPSBkYXRlLmdldFRpbWUoKTtcbiAgICAgICAgcmV0dXJuIG5ldyBUaW1lc3RhbXAoe1xuICAgICAgICAgICAgc2Vjb25kczogcHJvdG9JbnQ2NC5wYXJzZShNYXRoLmZsb29yKG1zIC8gMTAwMCkpLFxuICAgICAgICAgICAgbmFub3M6IChtcyAlIDEwMDApICogMTAwMDAwMCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBuZXcgVGltZXN0YW1wKCkuZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucyk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUaW1lc3RhbXAoKS5mcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gbmV3IFRpbWVzdGFtcCgpLmZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBzdGF0aWMgZXF1YWxzKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIHByb3RvMy51dGlsLmVxdWFscyhUaW1lc3RhbXAsIGEsIGIpO1xuICAgIH1cbn1cblRpbWVzdGFtcC5ydW50aW1lID0gcHJvdG8zO1xuVGltZXN0YW1wLnR5cGVOYW1lID0gXCJnb29nbGUucHJvdG9idWYuVGltZXN0YW1wXCI7XG5UaW1lc3RhbXAuZmllbGRzID0gcHJvdG8zLnV0aWwubmV3RmllbGRMaXN0KCgpID0+IFtcbiAgICB7IG5vOiAxLCBuYW1lOiBcInNlY29uZHNcIiwga2luZDogXCJzY2FsYXJcIiwgVDogMyAvKiBTY2FsYXJUeXBlLklOVDY0ICovIH0sXG4gICAgeyBubzogMiwgbmFtZTogXCJuYW5vc1wiLCBraW5kOiBcInNjYWxhclwiLCBUOiA1IC8qIFNjYWxhclR5cGUuSU5UMzIgKi8gfSxcbl0pO1xuIiwiLy8gQ29weXJpZ2h0IDIwMjMgTGl2ZUtpdCwgSW5jLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuLy8gQGdlbmVyYXRlZCBieSBwcm90b2MtZ2VuLWVzIHYxLjQuMiB3aXRoIHBhcmFtZXRlciBcInRhcmdldD10c1wiXG4vLyBAZ2VuZXJhdGVkIGZyb20gZmlsZSBsaXZla2l0X21vZGVscy5wcm90byAocGFja2FnZSBsaXZla2l0LCBzeW50YXggcHJvdG8zKVxuLyogZXNsaW50LWRpc2FibGUgKi9cbi8vIEB0cy1ub2NoZWNrXG5cbmltcG9ydCB0eXBlIHsgQmluYXJ5UmVhZE9wdGlvbnMsIEZpZWxkTGlzdCwgSnNvblJlYWRPcHRpb25zLCBKc29uVmFsdWUsIFBhcnRpYWxNZXNzYWdlLCBQbGFpbk1lc3NhZ2UgfSBmcm9tIFwiQGJ1ZmJ1aWxkL3Byb3RvYnVmXCI7XG5pbXBvcnQgeyBNZXNzYWdlLCBwcm90bzMsIHByb3RvSW50NjQsIFRpbWVzdGFtcCB9IGZyb20gXCJAYnVmYnVpbGQvcHJvdG9idWZcIjtcblxuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gZW51bSBsaXZla2l0LkF1ZGlvQ29kZWNcbiAqL1xuZXhwb3J0IGVudW0gQXVkaW9Db2RlYyB7XG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZW51bSB2YWx1ZTogREVGQVVMVF9BQyA9IDA7XG4gICAqL1xuICBERUZBVUxUX0FDID0gMCxcblxuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGVudW0gdmFsdWU6IE9QVVMgPSAxO1xuICAgKi9cbiAgT1BVUyA9IDEsXG5cbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBBQUMgPSAyO1xuICAgKi9cbiAgQUFDID0gMixcbn1cbi8vIFJldHJpZXZlIGVudW0gbWV0YWRhdGEgd2l0aDogcHJvdG8zLmdldEVudW1UeXBlKEF1ZGlvQ29kZWMpXG5wcm90bzMudXRpbC5zZXRFbnVtVHlwZShBdWRpb0NvZGVjLCBcImxpdmVraXQuQXVkaW9Db2RlY1wiLCBbXG4gIHsgbm86IDAsIG5hbWU6IFwiREVGQVVMVF9BQ1wiIH0sXG4gIHsgbm86IDEsIG5hbWU6IFwiT1BVU1wiIH0sXG4gIHsgbm86IDIsIG5hbWU6IFwiQUFDXCIgfSxcbl0pO1xuXG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIGxpdmVraXQuVmlkZW9Db2RlY1xuICovXG5leHBvcnQgZW51bSBWaWRlb0NvZGVjIHtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBERUZBVUxUX1ZDID0gMDtcbiAgICovXG4gIERFRkFVTFRfVkMgPSAwLFxuXG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZW51bSB2YWx1ZTogSDI2NF9CQVNFTElORSA9IDE7XG4gICAqL1xuICBIMjY0X0JBU0VMSU5FID0gMSxcblxuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGVudW0gdmFsdWU6IEgyNjRfTUFJTiA9IDI7XG4gICAqL1xuICBIMjY0X01BSU4gPSAyLFxuXG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZW51bSB2YWx1ZTogSDI2NF9ISUdIID0gMztcbiAgICovXG4gIEgyNjRfSElHSCA9IDMsXG5cbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBWUDggPSA0O1xuICAgKi9cbiAgVlA4ID0gNCxcbn1cbi8vIFJldHJpZXZlIGVudW0gbWV0YWRhdGEgd2l0aDogcHJvdG8zLmdldEVudW1UeXBlKFZpZGVvQ29kZWMpXG5wcm90bzMudXRpbC5zZXRFbnVtVHlwZShWaWRlb0NvZGVjLCBcImxpdmVraXQuVmlkZW9Db2RlY1wiLCBbXG4gIHsgbm86IDAsIG5hbWU6IFwiREVGQVVMVF9WQ1wiIH0sXG4gIHsgbm86IDEsIG5hbWU6IFwiSDI2NF9CQVNFTElORVwiIH0sXG4gIHsgbm86IDIsIG5hbWU6IFwiSDI2NF9NQUlOXCIgfSxcbiAgeyBubzogMywgbmFtZTogXCJIMjY0X0hJR0hcIiB9LFxuICB7IG5vOiA0LCBuYW1lOiBcIlZQOFwiIH0sXG5dKTtcblxuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gZW51bSBsaXZla2l0LkltYWdlQ29kZWNcbiAqL1xuZXhwb3J0IGVudW0gSW1hZ2VDb2RlYyB7XG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZW51bSB2YWx1ZTogSUNfREVGQVVMVCA9IDA7XG4gICAqL1xuICBJQ19ERUZBVUxUID0gMCxcblxuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGVudW0gdmFsdWU6IElDX0pQRUcgPSAxO1xuICAgKi9cbiAgSUNfSlBFRyA9IDEsXG59XG4vLyBSZXRyaWV2ZSBlbnVtIG1ldGFkYXRhIHdpdGg6IHByb3RvMy5nZXRFbnVtVHlwZShJbWFnZUNvZGVjKVxucHJvdG8zLnV0aWwuc2V0RW51bVR5cGUoSW1hZ2VDb2RlYywgXCJsaXZla2l0LkltYWdlQ29kZWNcIiwgW1xuICB7IG5vOiAwLCBuYW1lOiBcIklDX0RFRkFVTFRcIiB9LFxuICB7IG5vOiAxLCBuYW1lOiBcIklDX0pQRUdcIiB9LFxuXSk7XG5cbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIGVudW0gbGl2ZWtpdC5UcmFja1R5cGVcbiAqL1xuZXhwb3J0IGVudW0gVHJhY2tUeXBlIHtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBBVURJTyA9IDA7XG4gICAqL1xuICBBVURJTyA9IDAsXG5cbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBWSURFTyA9IDE7XG4gICAqL1xuICBWSURFTyA9IDEsXG5cbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBEQVRBID0gMjtcbiAgICovXG4gIERBVEEgPSAyLFxufVxuLy8gUmV0cmlldmUgZW51bSBtZXRhZGF0YSB3aXRoOiBwcm90bzMuZ2V0RW51bVR5cGUoVHJhY2tUeXBlKVxucHJvdG8zLnV0aWwuc2V0RW51bVR5cGUoVHJhY2tUeXBlLCBcImxpdmVraXQuVHJhY2tUeXBlXCIsIFtcbiAgeyBubzogMCwgbmFtZTogXCJBVURJT1wiIH0sXG4gIHsgbm86IDEsIG5hbWU6IFwiVklERU9cIiB9LFxuICB7IG5vOiAyLCBuYW1lOiBcIkRBVEFcIiB9LFxuXSk7XG5cbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIGVudW0gbGl2ZWtpdC5UcmFja1NvdXJjZVxuICovXG5leHBvcnQgZW51bSBUcmFja1NvdXJjZSB7XG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZW51bSB2YWx1ZTogVU5LTk9XTiA9IDA7XG4gICAqL1xuICBVTktOT1dOID0gMCxcblxuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGVudW0gdmFsdWU6IENBTUVSQSA9IDE7XG4gICAqL1xuICBDQU1FUkEgPSAxLFxuXG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZW51bSB2YWx1ZTogTUlDUk9QSE9ORSA9IDI7XG4gICAqL1xuICBNSUNST1BIT05FID0gMixcblxuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGVudW0gdmFsdWU6IFNDUkVFTl9TSEFSRSA9IDM7XG4gICAqL1xuICBTQ1JFRU5fU0hBUkUgPSAzLFxuXG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZW51bSB2YWx1ZTogU0NSRUVOX1NIQVJFX0FVRElPID0gNDtcbiAgICovXG4gIFNDUkVFTl9TSEFSRV9BVURJTyA9IDQsXG59XG4vLyBSZXRyaWV2ZSBlbnVtIG1ldGFkYXRhIHdpdGg6IHByb3RvMy5nZXRFbnVtVHlwZShUcmFja1NvdXJjZSlcbnByb3RvMy51dGlsLnNldEVudW1UeXBlKFRyYWNrU291cmNlLCBcImxpdmVraXQuVHJhY2tTb3VyY2VcIiwgW1xuICB7IG5vOiAwLCBuYW1lOiBcIlVOS05PV05cIiB9LFxuICB7IG5vOiAxLCBuYW1lOiBcIkNBTUVSQVwiIH0sXG4gIHsgbm86IDIsIG5hbWU6IFwiTUlDUk9QSE9ORVwiIH0sXG4gIHsgbm86IDMsIG5hbWU6IFwiU0NSRUVOX1NIQVJFXCIgfSxcbiAgeyBubzogNCwgbmFtZTogXCJTQ1JFRU5fU0hBUkVfQVVESU9cIiB9LFxuXSk7XG5cbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIGVudW0gbGl2ZWtpdC5WaWRlb1F1YWxpdHlcbiAqL1xuZXhwb3J0IGVudW0gVmlkZW9RdWFsaXR5IHtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBMT1cgPSAwO1xuICAgKi9cbiAgTE9XID0gMCxcblxuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGVudW0gdmFsdWU6IE1FRElVTSA9IDE7XG4gICAqL1xuICBNRURJVU0gPSAxLFxuXG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZW51bSB2YWx1ZTogSElHSCA9IDI7XG4gICAqL1xuICBISUdIID0gMixcblxuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGVudW0gdmFsdWU6IE9GRiA9IDM7XG4gICAqL1xuICBPRkYgPSAzLFxufVxuLy8gUmV0cmlldmUgZW51bSBtZXRhZGF0YSB3aXRoOiBwcm90bzMuZ2V0RW51bVR5cGUoVmlkZW9RdWFsaXR5KVxucHJvdG8zLnV0aWwuc2V0RW51bVR5cGUoVmlkZW9RdWFsaXR5LCBcImxpdmVraXQuVmlkZW9RdWFsaXR5XCIsIFtcbiAgeyBubzogMCwgbmFtZTogXCJMT1dcIiB9LFxuICB7IG5vOiAxLCBuYW1lOiBcIk1FRElVTVwiIH0sXG4gIHsgbm86IDIsIG5hbWU6IFwiSElHSFwiIH0sXG4gIHsgbm86IDMsIG5hbWU6IFwiT0ZGXCIgfSxcbl0pO1xuXG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIGxpdmVraXQuQ29ubmVjdGlvblF1YWxpdHlcbiAqL1xuZXhwb3J0IGVudW0gQ29ubmVjdGlvblF1YWxpdHkge1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGVudW0gdmFsdWU6IFBPT1IgPSAwO1xuICAgKi9cbiAgUE9PUiA9IDAsXG5cbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBHT09EID0gMTtcbiAgICovXG4gIEdPT0QgPSAxLFxuXG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZW51bSB2YWx1ZTogRVhDRUxMRU5UID0gMjtcbiAgICovXG4gIEVYQ0VMTEVOVCA9IDIsXG5cbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBMT1NUID0gMztcbiAgICovXG4gIExPU1QgPSAzLFxufVxuLy8gUmV0cmlldmUgZW51bSBtZXRhZGF0YSB3aXRoOiBwcm90bzMuZ2V0RW51bVR5cGUoQ29ubmVjdGlvblF1YWxpdHkpXG5wcm90bzMudXRpbC5zZXRFbnVtVHlwZShDb25uZWN0aW9uUXVhbGl0eSwgXCJsaXZla2l0LkNvbm5lY3Rpb25RdWFsaXR5XCIsIFtcbiAgeyBubzogMCwgbmFtZTogXCJQT09SXCIgfSxcbiAgeyBubzogMSwgbmFtZTogXCJHT09EXCIgfSxcbiAgeyBubzogMiwgbmFtZTogXCJFWENFTExFTlRcIiB9LFxuICB7IG5vOiAzLCBuYW1lOiBcIkxPU1RcIiB9LFxuXSk7XG5cbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIGVudW0gbGl2ZWtpdC5DbGllbnRDb25maWdTZXR0aW5nXG4gKi9cbmV4cG9ydCBlbnVtIENsaWVudENvbmZpZ1NldHRpbmcge1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGVudW0gdmFsdWU6IFVOU0VUID0gMDtcbiAgICovXG4gIFVOU0VUID0gMCxcblxuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGVudW0gdmFsdWU6IERJU0FCTEVEID0gMTtcbiAgICovXG4gIERJU0FCTEVEID0gMSxcblxuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGVudW0gdmFsdWU6IEVOQUJMRUQgPSAyO1xuICAgKi9cbiAgRU5BQkxFRCA9IDIsXG59XG4vLyBSZXRyaWV2ZSBlbnVtIG1ldGFkYXRhIHdpdGg6IHByb3RvMy5nZXRFbnVtVHlwZShDbGllbnRDb25maWdTZXR0aW5nKVxucHJvdG8zLnV0aWwuc2V0RW51bVR5cGUoQ2xpZW50Q29uZmlnU2V0dGluZywgXCJsaXZla2l0LkNsaWVudENvbmZpZ1NldHRpbmdcIiwgW1xuICB7IG5vOiAwLCBuYW1lOiBcIlVOU0VUXCIgfSxcbiAgeyBubzogMSwgbmFtZTogXCJESVNBQkxFRFwiIH0sXG4gIHsgbm86IDIsIG5hbWU6IFwiRU5BQkxFRFwiIH0sXG5dKTtcblxuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gZW51bSBsaXZla2l0LkRpc2Nvbm5lY3RSZWFzb25cbiAqL1xuZXhwb3J0IGVudW0gRGlzY29ubmVjdFJlYXNvbiB7XG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZW51bSB2YWx1ZTogVU5LTk9XTl9SRUFTT04gPSAwO1xuICAgKi9cbiAgVU5LTk9XTl9SRUFTT04gPSAwLFxuXG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZW51bSB2YWx1ZTogQ0xJRU5UX0lOSVRJQVRFRCA9IDE7XG4gICAqL1xuICBDTElFTlRfSU5JVElBVEVEID0gMSxcblxuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGVudW0gdmFsdWU6IERVUExJQ0FURV9JREVOVElUWSA9IDI7XG4gICAqL1xuICBEVVBMSUNBVEVfSURFTlRJVFkgPSAyLFxuXG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZW51bSB2YWx1ZTogU0VSVkVSX1NIVVRET1dOID0gMztcbiAgICovXG4gIFNFUlZFUl9TSFVURE9XTiA9IDMsXG5cbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBQQVJUSUNJUEFOVF9SRU1PVkVEID0gNDtcbiAgICovXG4gIFBBUlRJQ0lQQU5UX1JFTU9WRUQgPSA0LFxuXG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZW51bSB2YWx1ZTogUk9PTV9ERUxFVEVEID0gNTtcbiAgICovXG4gIFJPT01fREVMRVRFRCA9IDUsXG5cbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBTVEFURV9NSVNNQVRDSCA9IDY7XG4gICAqL1xuICBTVEFURV9NSVNNQVRDSCA9IDYsXG5cbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBKT0lOX0ZBSUxVUkUgPSA3O1xuICAgKi9cbiAgSk9JTl9GQUlMVVJFID0gNyxcbn1cbi8vIFJldHJpZXZlIGVudW0gbWV0YWRhdGEgd2l0aDogcHJvdG8zLmdldEVudW1UeXBlKERpc2Nvbm5lY3RSZWFzb24pXG5wcm90bzMudXRpbC5zZXRFbnVtVHlwZShEaXNjb25uZWN0UmVhc29uLCBcImxpdmVraXQuRGlzY29ubmVjdFJlYXNvblwiLCBbXG4gIHsgbm86IDAsIG5hbWU6IFwiVU5LTk9XTl9SRUFTT05cIiB9LFxuICB7IG5vOiAxLCBuYW1lOiBcIkNMSUVOVF9JTklUSUFURURcIiB9LFxuICB7IG5vOiAyLCBuYW1lOiBcIkRVUExJQ0FURV9JREVOVElUWVwiIH0sXG4gIHsgbm86IDMsIG5hbWU6IFwiU0VSVkVSX1NIVVRET1dOXCIgfSxcbiAgeyBubzogNCwgbmFtZTogXCJQQVJUSUNJUEFOVF9SRU1PVkVEXCIgfSxcbiAgeyBubzogNSwgbmFtZTogXCJST09NX0RFTEVURURcIiB9LFxuICB7IG5vOiA2LCBuYW1lOiBcIlNUQVRFX01JU01BVENIXCIgfSxcbiAgeyBubzogNywgbmFtZTogXCJKT0lOX0ZBSUxVUkVcIiB9LFxuXSk7XG5cbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIGVudW0gbGl2ZWtpdC5SZWNvbm5lY3RSZWFzb25cbiAqL1xuZXhwb3J0IGVudW0gUmVjb25uZWN0UmVhc29uIHtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBSUl9VTktOT1dOID0gMDtcbiAgICovXG4gIFJSX1VOS05PV04gPSAwLFxuXG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZW51bSB2YWx1ZTogUlJfU0lHTkFMX0RJU0NPTk5FQ1RFRCA9IDE7XG4gICAqL1xuICBSUl9TSUdOQUxfRElTQ09OTkVDVEVEID0gMSxcblxuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGVudW0gdmFsdWU6IFJSX1BVQkxJU0hFUl9GQUlMRUQgPSAyO1xuICAgKi9cbiAgUlJfUFVCTElTSEVSX0ZBSUxFRCA9IDIsXG5cbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBSUl9TVUJTQ1JJQkVSX0ZBSUxFRCA9IDM7XG4gICAqL1xuICBSUl9TVUJTQ1JJQkVSX0ZBSUxFRCA9IDMsXG5cbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBSUl9TV0lUQ0hfQ0FORElEQVRFID0gNDtcbiAgICovXG4gIFJSX1NXSVRDSF9DQU5ESURBVEUgPSA0LFxufVxuLy8gUmV0cmlldmUgZW51bSBtZXRhZGF0YSB3aXRoOiBwcm90bzMuZ2V0RW51bVR5cGUoUmVjb25uZWN0UmVhc29uKVxucHJvdG8zLnV0aWwuc2V0RW51bVR5cGUoUmVjb25uZWN0UmVhc29uLCBcImxpdmVraXQuUmVjb25uZWN0UmVhc29uXCIsIFtcbiAgeyBubzogMCwgbmFtZTogXCJSUl9VTktOT1dOXCIgfSxcbiAgeyBubzogMSwgbmFtZTogXCJSUl9TSUdOQUxfRElTQ09OTkVDVEVEXCIgfSxcbiAgeyBubzogMiwgbmFtZTogXCJSUl9QVUJMSVNIRVJfRkFJTEVEXCIgfSxcbiAgeyBubzogMywgbmFtZTogXCJSUl9TVUJTQ1JJQkVSX0ZBSUxFRFwiIH0sXG4gIHsgbm86IDQsIG5hbWU6IFwiUlJfU1dJVENIX0NBTkRJREFURVwiIH0sXG5dKTtcblxuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gZW51bSBsaXZla2l0LlN1YnNjcmlwdGlvbkVycm9yXG4gKi9cbmV4cG9ydCBlbnVtIFN1YnNjcmlwdGlvbkVycm9yIHtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBTRV9VTktOT1dOID0gMDtcbiAgICovXG4gIFNFX1VOS05PV04gPSAwLFxuXG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZW51bSB2YWx1ZTogU0VfQ09ERUNfVU5TVVBQT1JURUQgPSAxO1xuICAgKi9cbiAgU0VfQ09ERUNfVU5TVVBQT1JURUQgPSAxLFxuXG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZW51bSB2YWx1ZTogU0VfVFJBQ0tfTk9URk9VTkQgPSAyO1xuICAgKi9cbiAgU0VfVFJBQ0tfTk9URk9VTkQgPSAyLFxufVxuLy8gUmV0cmlldmUgZW51bSBtZXRhZGF0YSB3aXRoOiBwcm90bzMuZ2V0RW51bVR5cGUoU3Vic2NyaXB0aW9uRXJyb3IpXG5wcm90bzMudXRpbC5zZXRFbnVtVHlwZShTdWJzY3JpcHRpb25FcnJvciwgXCJsaXZla2l0LlN1YnNjcmlwdGlvbkVycm9yXCIsIFtcbiAgeyBubzogMCwgbmFtZTogXCJTRV9VTktOT1dOXCIgfSxcbiAgeyBubzogMSwgbmFtZTogXCJTRV9DT0RFQ19VTlNVUFBPUlRFRFwiIH0sXG4gIHsgbm86IDIsIG5hbWU6IFwiU0VfVFJBQ0tfTk9URk9VTkRcIiB9LFxuXSk7XG5cbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgbGl2ZWtpdC5Sb29tXG4gKi9cbmV4cG9ydCBjbGFzcyBSb29tIGV4dGVuZHMgTWVzc2FnZTxSb29tPiB7XG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHN0cmluZyBzaWQgPSAxO1xuICAgKi9cbiAgc2lkID0gXCJcIjtcblxuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBzdHJpbmcgbmFtZSA9IDI7XG4gICAqL1xuICBuYW1lID0gXCJcIjtcblxuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiB1aW50MzIgZW1wdHlfdGltZW91dCA9IDM7XG4gICAqL1xuICBlbXB0eVRpbWVvdXQgPSAwO1xuXG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHVpbnQzMiBtYXhfcGFydGljaXBhbnRzID0gNDtcbiAgICovXG4gIG1heFBhcnRpY2lwYW50cyA9IDA7XG5cbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogaW50NjQgY3JlYXRpb25fdGltZSA9IDU7XG4gICAqL1xuICBjcmVhdGlvblRpbWUgPSBwcm90b0ludDY0Lnplcm87XG5cbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogc3RyaW5nIHR1cm5fcGFzc3dvcmQgPSA2O1xuICAgKi9cbiAgdHVyblBhc3N3b3JkID0gXCJcIjtcblxuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiByZXBlYXRlZCBsaXZla2l0LkNvZGVjIGVuYWJsZWRfY29kZWNzID0gNztcbiAgICovXG4gIGVuYWJsZWRDb2RlY3M6IENvZGVjW10gPSBbXTtcblxuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBzdHJpbmcgbWV0YWRhdGEgPSA4O1xuICAgKi9cbiAgbWV0YWRhdGEgPSBcIlwiO1xuXG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHVpbnQzMiBudW1fcGFydGljaXBhbnRzID0gOTtcbiAgICovXG4gIG51bVBhcnRpY2lwYW50cyA9IDA7XG5cbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogdWludDMyIG51bV9wdWJsaXNoZXJzID0gMTE7XG4gICAqL1xuICBudW1QdWJsaXNoZXJzID0gMDtcblxuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBib29sIGFjdGl2ZV9yZWNvcmRpbmcgPSAxMDtcbiAgICovXG4gIGFjdGl2ZVJlY29yZGluZyA9IGZhbHNlO1xuXG4gIGNvbnN0cnVjdG9yKGRhdGE/OiBQYXJ0aWFsTWVzc2FnZTxSb29tPikge1xuICAgIHN1cGVyKCk7XG4gICAgcHJvdG8zLnV0aWwuaW5pdFBhcnRpYWwoZGF0YSwgdGhpcyk7XG4gIH1cblxuICBzdGF0aWMgcmVhZG9ubHkgcnVudGltZTogdHlwZW9mIHByb3RvMyA9IHByb3RvMztcbiAgc3RhdGljIHJlYWRvbmx5IHR5cGVOYW1lID0gXCJsaXZla2l0LlJvb21cIjtcbiAgc3RhdGljIHJlYWRvbmx5IGZpZWxkczogRmllbGRMaXN0ID0gcHJvdG8zLnV0aWwubmV3RmllbGRMaXN0KCgpID0+IFtcbiAgICB7IG5vOiAxLCBuYW1lOiBcInNpZFwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovIH0sXG4gICAgeyBubzogMiwgbmFtZTogXCJuYW1lXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi8gfSxcbiAgICB7IG5vOiAzLCBuYW1lOiBcImVtcHR5X3RpbWVvdXRcIiwga2luZDogXCJzY2FsYXJcIiwgVDogMTMgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi8gfSxcbiAgICB7IG5vOiA0LCBuYW1lOiBcIm1heF9wYXJ0aWNpcGFudHNcIiwga2luZDogXCJzY2FsYXJcIiwgVDogMTMgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi8gfSxcbiAgICB7IG5vOiA1LCBuYW1lOiBcImNyZWF0aW9uX3RpbWVcIiwga2luZDogXCJzY2FsYXJcIiwgVDogMyAvKiBTY2FsYXJUeXBlLklOVDY0ICovIH0sXG4gICAgeyBubzogNiwgbmFtZTogXCJ0dXJuX3Bhc3N3b3JkXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi8gfSxcbiAgICB7IG5vOiA3LCBuYW1lOiBcImVuYWJsZWRfY29kZWNzXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBDb2RlYywgcmVwZWF0ZWQ6IHRydWUgfSxcbiAgICB7IG5vOiA4LCBuYW1lOiBcIm1ldGFkYXRhXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi8gfSxcbiAgICB7IG5vOiA5LCBuYW1lOiBcIm51bV9wYXJ0aWNpcGFudHNcIiwga2luZDogXCJzY2FsYXJcIiwgVDogMTMgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi8gfSxcbiAgICB7IG5vOiAxMSwgbmFtZTogXCJudW1fcHVibGlzaGVyc1wiLCBraW5kOiBcInNjYWxhclwiLCBUOiAxMyAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqLyB9LFxuICAgIHsgbm86IDEwLCBuYW1lOiBcImFjdGl2ZV9yZWNvcmRpbmdcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOCAvKiBTY2FsYXJUeXBlLkJPT0wgKi8gfSxcbiAgXSk7XG5cbiAgc3RhdGljIGZyb21CaW5hcnkoYnl0ZXM6IFVpbnQ4QXJyYXksIG9wdGlvbnM/OiBQYXJ0aWFsPEJpbmFyeVJlYWRPcHRpb25zPik6IFJvb20ge1xuICAgIHJldHVybiBuZXcgUm9vbSgpLmZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpO1xuICB9XG5cbiAgc3RhdGljIGZyb21Kc29uKGpzb25WYWx1ZTogSnNvblZhbHVlLCBvcHRpb25zPzogUGFydGlhbDxKc29uUmVhZE9wdGlvbnM+KTogUm9vbSB7XG4gICAgcmV0dXJuIG5ldyBSb29tKCkuZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tSnNvblN0cmluZyhqc29uU3RyaW5nOiBzdHJpbmcsIG9wdGlvbnM/OiBQYXJ0aWFsPEpzb25SZWFkT3B0aW9ucz4pOiBSb29tIHtcbiAgICByZXR1cm4gbmV3IFJvb20oKS5mcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKTtcbiAgfVxuXG4gIHN0YXRpYyBlcXVhbHMoYTogUm9vbSB8IFBsYWluTWVzc2FnZTxSb29tPiB8IHVuZGVmaW5lZCwgYjogUm9vbSB8IFBsYWluTWVzc2FnZTxSb29tPiB8IHVuZGVmaW5lZCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBwcm90bzMudXRpbC5lcXVhbHMoUm9vbSwgYSwgYik7XG4gIH1cbn1cblxuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBsaXZla2l0LkNvZGVjXG4gKi9cbmV4cG9ydCBjbGFzcyBDb2RlYyBleHRlbmRzIE1lc3NhZ2U8Q29kZWM+IHtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogc3RyaW5nIG1pbWUgPSAxO1xuICAgKi9cbiAgbWltZSA9IFwiXCI7XG5cbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogc3RyaW5nIGZtdHBfbGluZSA9IDI7XG4gICAqL1xuICBmbXRwTGluZSA9IFwiXCI7XG5cbiAgY29uc3RydWN0b3IoZGF0YT86IFBhcnRpYWxNZXNzYWdlPENvZGVjPikge1xuICAgIHN1cGVyKCk7XG4gICAgcHJvdG8zLnV0aWwuaW5pdFBhcnRpYWwoZGF0YSwgdGhpcyk7XG4gIH1cblxuICBzdGF0aWMgcmVhZG9ubHkgcnVudGltZTogdHlwZW9mIHByb3RvMyA9IHByb3RvMztcbiAgc3RhdGljIHJlYWRvbmx5IHR5cGVOYW1lID0gXCJsaXZla2l0LkNvZGVjXCI7XG4gIHN0YXRpYyByZWFkb25seSBmaWVsZHM6IEZpZWxkTGlzdCA9IHByb3RvMy51dGlsLm5ld0ZpZWxkTGlzdCgoKSA9PiBbXG4gICAgeyBubzogMSwgbmFtZTogXCJtaW1lXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi8gfSxcbiAgICB7IG5vOiAyLCBuYW1lOiBcImZtdHBfbGluZVwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovIH0sXG4gIF0pO1xuXG4gIHN0YXRpYyBmcm9tQmluYXJ5KGJ5dGVzOiBVaW50OEFycmF5LCBvcHRpb25zPzogUGFydGlhbDxCaW5hcnlSZWFkT3B0aW9ucz4pOiBDb2RlYyB7XG4gICAgcmV0dXJuIG5ldyBDb2RlYygpLmZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpO1xuICB9XG5cbiAgc3RhdGljIGZyb21Kc29uKGpzb25WYWx1ZTogSnNvblZhbHVlLCBvcHRpb25zPzogUGFydGlhbDxKc29uUmVhZE9wdGlvbnM+KTogQ29kZWMge1xuICAgIHJldHVybiBuZXcgQ29kZWMoKS5mcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpO1xuICB9XG5cbiAgc3RhdGljIGZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmc6IHN0cmluZywgb3B0aW9ucz86IFBhcnRpYWw8SnNvblJlYWRPcHRpb25zPik6IENvZGVjIHtcbiAgICByZXR1cm4gbmV3IENvZGVjKCkuZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucyk7XG4gIH1cblxuICBzdGF0aWMgZXF1YWxzKGE6IENvZGVjIHwgUGxhaW5NZXNzYWdlPENvZGVjPiB8IHVuZGVmaW5lZCwgYjogQ29kZWMgfCBQbGFpbk1lc3NhZ2U8Q29kZWM+IHwgdW5kZWZpbmVkKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHByb3RvMy51dGlsLmVxdWFscyhDb2RlYywgYSwgYik7XG4gIH1cbn1cblxuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBsaXZla2l0LlBsYXlvdXREZWxheVxuICovXG5leHBvcnQgY2xhc3MgUGxheW91dERlbGF5IGV4dGVuZHMgTWVzc2FnZTxQbGF5b3V0RGVsYXk+IHtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogYm9vbCBlbmFibGVkID0gMTtcbiAgICovXG4gIGVuYWJsZWQgPSBmYWxzZTtcblxuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiB1aW50MzIgbWluID0gMjtcbiAgICovXG4gIG1pbiA9IDA7XG5cbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogdWludDMyIG1heCA9IDM7XG4gICAqL1xuICBtYXggPSAwO1xuXG4gIGNvbnN0cnVjdG9yKGRhdGE/OiBQYXJ0aWFsTWVzc2FnZTxQbGF5b3V0RGVsYXk+KSB7XG4gICAgc3VwZXIoKTtcbiAgICBwcm90bzMudXRpbC5pbml0UGFydGlhbChkYXRhLCB0aGlzKTtcbiAgfVxuXG4gIHN0YXRpYyByZWFkb25seSBydW50aW1lOiB0eXBlb2YgcHJvdG8zID0gcHJvdG8zO1xuICBzdGF0aWMgcmVhZG9ubHkgdHlwZU5hbWUgPSBcImxpdmVraXQuUGxheW91dERlbGF5XCI7XG4gIHN0YXRpYyByZWFkb25seSBmaWVsZHM6IEZpZWxkTGlzdCA9IHByb3RvMy51dGlsLm5ld0ZpZWxkTGlzdCgoKSA9PiBbXG4gICAgeyBubzogMSwgbmFtZTogXCJlbmFibGVkXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDggLyogU2NhbGFyVHlwZS5CT09MICovIH0sXG4gICAgeyBubzogMiwgbmFtZTogXCJtaW5cIiwga2luZDogXCJzY2FsYXJcIiwgVDogMTMgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi8gfSxcbiAgICB7IG5vOiAzLCBuYW1lOiBcIm1heFwiLCBraW5kOiBcInNjYWxhclwiLCBUOiAxMyAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqLyB9LFxuICBdKTtcblxuICBzdGF0aWMgZnJvbUJpbmFyeShieXRlczogVWludDhBcnJheSwgb3B0aW9ucz86IFBhcnRpYWw8QmluYXJ5UmVhZE9wdGlvbnM+KTogUGxheW91dERlbGF5IHtcbiAgICByZXR1cm4gbmV3IFBsYXlvdXREZWxheSgpLmZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpO1xuICB9XG5cbiAgc3RhdGljIGZyb21Kc29uKGpzb25WYWx1ZTogSnNvblZhbHVlLCBvcHRpb25zPzogUGFydGlhbDxKc29uUmVhZE9wdGlvbnM+KTogUGxheW91dERlbGF5IHtcbiAgICByZXR1cm4gbmV3IFBsYXlvdXREZWxheSgpLmZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucyk7XG4gIH1cblxuICBzdGF0aWMgZnJvbUpzb25TdHJpbmcoanNvblN0cmluZzogc3RyaW5nLCBvcHRpb25zPzogUGFydGlhbDxKc29uUmVhZE9wdGlvbnM+KTogUGxheW91dERlbGF5IHtcbiAgICByZXR1cm4gbmV3IFBsYXlvdXREZWxheSgpLmZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpO1xuICB9XG5cbiAgc3RhdGljIGVxdWFscyhhOiBQbGF5b3V0RGVsYXkgfCBQbGFpbk1lc3NhZ2U8UGxheW91dERlbGF5PiB8IHVuZGVmaW5lZCwgYjogUGxheW91dERlbGF5IHwgUGxhaW5NZXNzYWdlPFBsYXlvdXREZWxheT4gfCB1bmRlZmluZWQpOiBib29sZWFuIHtcbiAgICByZXR1cm4gcHJvdG8zLnV0aWwuZXF1YWxzKFBsYXlvdXREZWxheSwgYSwgYik7XG4gIH1cbn1cblxuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBsaXZla2l0LlBhcnRpY2lwYW50UGVybWlzc2lvblxuICovXG5leHBvcnQgY2xhc3MgUGFydGljaXBhbnRQZXJtaXNzaW9uIGV4dGVuZHMgTWVzc2FnZTxQYXJ0aWNpcGFudFBlcm1pc3Npb24+IHtcbiAgLyoqXG4gICAqIGFsbG93IHBhcnRpY2lwYW50IHRvIHN1YnNjcmliZSB0byBvdGhlciB0cmFja3MgaW4gdGhlIHJvb21cbiAgICpcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBib29sIGNhbl9zdWJzY3JpYmUgPSAxO1xuICAgKi9cbiAgY2FuU3Vic2NyaWJlID0gZmFsc2U7XG5cbiAgLyoqXG4gICAqIGFsbG93IHBhcnRpY2lwYW50IHRvIHB1Ymxpc2ggbmV3IHRyYWNrcyB0byByb29tXG4gICAqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogYm9vbCBjYW5fcHVibGlzaCA9IDI7XG4gICAqL1xuICBjYW5QdWJsaXNoID0gZmFsc2U7XG5cbiAgLyoqXG4gICAqIGFsbG93IHBhcnRpY2lwYW50IHRvIHB1Ymxpc2ggZGF0YVxuICAgKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGJvb2wgY2FuX3B1Ymxpc2hfZGF0YSA9IDM7XG4gICAqL1xuICBjYW5QdWJsaXNoRGF0YSA9IGZhbHNlO1xuXG4gIC8qKlxuICAgKiBzb3VyY2VzIHRoYXQgYXJlIGFsbG93ZWQgdG8gYmUgcHVibGlzaGVkXG4gICAqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogcmVwZWF0ZWQgbGl2ZWtpdC5UcmFja1NvdXJjZSBjYW5fcHVibGlzaF9zb3VyY2VzID0gOTtcbiAgICovXG4gIGNhblB1Ymxpc2hTb3VyY2VzOiBUcmFja1NvdXJjZVtdID0gW107XG5cbiAgLyoqXG4gICAqIGluZGljYXRlcyB0aGF0IGl0J3MgaGlkZGVuIHRvIG90aGVyc1xuICAgKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGJvb2wgaGlkZGVuID0gNztcbiAgICovXG4gIGhpZGRlbiA9IGZhbHNlO1xuXG4gIC8qKlxuICAgKiBpbmRpY2F0ZXMgaXQncyBhIHJlY29yZGVyIGluc3RhbmNlXG4gICAqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogYm9vbCByZWNvcmRlciA9IDg7XG4gICAqL1xuICByZWNvcmRlciA9IGZhbHNlO1xuXG4gIC8qKlxuICAgKiBpbmRpY2F0ZXMgdGhhdCBwYXJ0aWNpcGFudCBjYW4gdXBkYXRlIG93biBtZXRhZGF0YVxuICAgKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGJvb2wgY2FuX3VwZGF0ZV9tZXRhZGF0YSA9IDEwO1xuICAgKi9cbiAgY2FuVXBkYXRlTWV0YWRhdGEgPSBmYWxzZTtcblxuICAvKipcbiAgICogaW5kaWNhdGVzIHRoYXQgcGFydGljaXBhbnQgaXMgYW4gYWdlbnRcbiAgICpcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBib29sIGFnZW50ID0gMTE7XG4gICAqL1xuICBhZ2VudCA9IGZhbHNlO1xuXG4gIGNvbnN0cnVjdG9yKGRhdGE/OiBQYXJ0aWFsTWVzc2FnZTxQYXJ0aWNpcGFudFBlcm1pc3Npb24+KSB7XG4gICAgc3VwZXIoKTtcbiAgICBwcm90bzMudXRpbC5pbml0UGFydGlhbChkYXRhLCB0aGlzKTtcbiAgfVxuXG4gIHN0YXRpYyByZWFkb25seSBydW50aW1lOiB0eXBlb2YgcHJvdG8zID0gcHJvdG8zO1xuICBzdGF0aWMgcmVhZG9ubHkgdHlwZU5hbWUgPSBcImxpdmVraXQuUGFydGljaXBhbnRQZXJtaXNzaW9uXCI7XG4gIHN0YXRpYyByZWFkb25seSBmaWVsZHM6IEZpZWxkTGlzdCA9IHByb3RvMy51dGlsLm5ld0ZpZWxkTGlzdCgoKSA9PiBbXG4gICAgeyBubzogMSwgbmFtZTogXCJjYW5fc3Vic2NyaWJlXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDggLyogU2NhbGFyVHlwZS5CT09MICovIH0sXG4gICAgeyBubzogMiwgbmFtZTogXCJjYW5fcHVibGlzaFwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA4IC8qIFNjYWxhclR5cGUuQk9PTCAqLyB9LFxuICAgIHsgbm86IDMsIG5hbWU6IFwiY2FuX3B1Ymxpc2hfZGF0YVwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA4IC8qIFNjYWxhclR5cGUuQk9PTCAqLyB9LFxuICAgIHsgbm86IDksIG5hbWU6IFwiY2FuX3B1Ymxpc2hfc291cmNlc1wiLCBraW5kOiBcImVudW1cIiwgVDogcHJvdG8zLmdldEVudW1UeXBlKFRyYWNrU291cmNlKSwgcmVwZWF0ZWQ6IHRydWUgfSxcbiAgICB7IG5vOiA3LCBuYW1lOiBcImhpZGRlblwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA4IC8qIFNjYWxhclR5cGUuQk9PTCAqLyB9LFxuICAgIHsgbm86IDgsIG5hbWU6IFwicmVjb3JkZXJcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOCAvKiBTY2FsYXJUeXBlLkJPT0wgKi8gfSxcbiAgICB7IG5vOiAxMCwgbmFtZTogXCJjYW5fdXBkYXRlX21ldGFkYXRhXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDggLyogU2NhbGFyVHlwZS5CT09MICovIH0sXG4gICAgeyBubzogMTEsIG5hbWU6IFwiYWdlbnRcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOCAvKiBTY2FsYXJUeXBlLkJPT0wgKi8gfSxcbiAgXSk7XG5cbiAgc3RhdGljIGZyb21CaW5hcnkoYnl0ZXM6IFVpbnQ4QXJyYXksIG9wdGlvbnM/OiBQYXJ0aWFsPEJpbmFyeVJlYWRPcHRpb25zPik6IFBhcnRpY2lwYW50UGVybWlzc2lvbiB7XG4gICAgcmV0dXJuIG5ldyBQYXJ0aWNpcGFudFBlcm1pc3Npb24oKS5mcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tSnNvbihqc29uVmFsdWU6IEpzb25WYWx1ZSwgb3B0aW9ucz86IFBhcnRpYWw8SnNvblJlYWRPcHRpb25zPik6IFBhcnRpY2lwYW50UGVybWlzc2lvbiB7XG4gICAgcmV0dXJuIG5ldyBQYXJ0aWNpcGFudFBlcm1pc3Npb24oKS5mcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpO1xuICB9XG5cbiAgc3RhdGljIGZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmc6IHN0cmluZywgb3B0aW9ucz86IFBhcnRpYWw8SnNvblJlYWRPcHRpb25zPik6IFBhcnRpY2lwYW50UGVybWlzc2lvbiB7XG4gICAgcmV0dXJuIG5ldyBQYXJ0aWNpcGFudFBlcm1pc3Npb24oKS5mcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKTtcbiAgfVxuXG4gIHN0YXRpYyBlcXVhbHMoYTogUGFydGljaXBhbnRQZXJtaXNzaW9uIHwgUGxhaW5NZXNzYWdlPFBhcnRpY2lwYW50UGVybWlzc2lvbj4gfCB1bmRlZmluZWQsIGI6IFBhcnRpY2lwYW50UGVybWlzc2lvbiB8IFBsYWluTWVzc2FnZTxQYXJ0aWNpcGFudFBlcm1pc3Npb24+IHwgdW5kZWZpbmVkKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHByb3RvMy51dGlsLmVxdWFscyhQYXJ0aWNpcGFudFBlcm1pc3Npb24sIGEsIGIpO1xuICB9XG59XG5cbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgbGl2ZWtpdC5QYXJ0aWNpcGFudEluZm9cbiAqL1xuZXhwb3J0IGNsYXNzIFBhcnRpY2lwYW50SW5mbyBleHRlbmRzIE1lc3NhZ2U8UGFydGljaXBhbnRJbmZvPiB7XG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHN0cmluZyBzaWQgPSAxO1xuICAgKi9cbiAgc2lkID0gXCJcIjtcblxuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBzdHJpbmcgaWRlbnRpdHkgPSAyO1xuICAgKi9cbiAgaWRlbnRpdHkgPSBcIlwiO1xuXG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGxpdmVraXQuUGFydGljaXBhbnRJbmZvLlN0YXRlIHN0YXRlID0gMztcbiAgICovXG4gIHN0YXRlID0gUGFydGljaXBhbnRJbmZvX1N0YXRlLkpPSU5JTkc7XG5cbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogcmVwZWF0ZWQgbGl2ZWtpdC5UcmFja0luZm8gdHJhY2tzID0gNDtcbiAgICovXG4gIHRyYWNrczogVHJhY2tJbmZvW10gPSBbXTtcblxuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBzdHJpbmcgbWV0YWRhdGEgPSA1O1xuICAgKi9cbiAgbWV0YWRhdGEgPSBcIlwiO1xuXG4gIC8qKlxuICAgKiB0aW1lc3RhbXAgd2hlbiBwYXJ0aWNpcGFudCBqb2luZWQgcm9vbSwgaW4gc2Vjb25kc1xuICAgKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGludDY0IGpvaW5lZF9hdCA9IDY7XG4gICAqL1xuICBqb2luZWRBdCA9IHByb3RvSW50NjQuemVybztcblxuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBzdHJpbmcgbmFtZSA9IDk7XG4gICAqL1xuICBuYW1lID0gXCJcIjtcblxuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiB1aW50MzIgdmVyc2lvbiA9IDEwO1xuICAgKi9cbiAgdmVyc2lvbiA9IDA7XG5cbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogbGl2ZWtpdC5QYXJ0aWNpcGFudFBlcm1pc3Npb24gcGVybWlzc2lvbiA9IDExO1xuICAgKi9cbiAgcGVybWlzc2lvbj86IFBhcnRpY2lwYW50UGVybWlzc2lvbjtcblxuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBzdHJpbmcgcmVnaW9uID0gMTI7XG4gICAqL1xuICByZWdpb24gPSBcIlwiO1xuXG4gIC8qKlxuICAgKiBpbmRpY2F0ZXMgdGhlIHBhcnRpY2lwYW50IGhhcyBhbiBhY3RpdmUgcHVibGlzaGVyIGNvbm5lY3Rpb25cbiAgICogYW5kIGNhbiBwdWJsaXNoIHRvIHRoZSBzZXJ2ZXJcbiAgICpcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBib29sIGlzX3B1Ymxpc2hlciA9IDEzO1xuICAgKi9cbiAgaXNQdWJsaXNoZXIgPSBmYWxzZTtcblxuICBjb25zdHJ1Y3RvcihkYXRhPzogUGFydGlhbE1lc3NhZ2U8UGFydGljaXBhbnRJbmZvPikge1xuICAgIHN1cGVyKCk7XG4gICAgcHJvdG8zLnV0aWwuaW5pdFBhcnRpYWwoZGF0YSwgdGhpcyk7XG4gIH1cblxuICBzdGF0aWMgcmVhZG9ubHkgcnVudGltZTogdHlwZW9mIHByb3RvMyA9IHByb3RvMztcbiAgc3RhdGljIHJlYWRvbmx5IHR5cGVOYW1lID0gXCJsaXZla2l0LlBhcnRpY2lwYW50SW5mb1wiO1xuICBzdGF0aWMgcmVhZG9ubHkgZmllbGRzOiBGaWVsZExpc3QgPSBwcm90bzMudXRpbC5uZXdGaWVsZExpc3QoKCkgPT4gW1xuICAgIHsgbm86IDEsIG5hbWU6IFwic2lkXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi8gfSxcbiAgICB7IG5vOiAyLCBuYW1lOiBcImlkZW50aXR5XCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi8gfSxcbiAgICB7IG5vOiAzLCBuYW1lOiBcInN0YXRlXCIsIGtpbmQ6IFwiZW51bVwiLCBUOiBwcm90bzMuZ2V0RW51bVR5cGUoUGFydGljaXBhbnRJbmZvX1N0YXRlKSB9LFxuICAgIHsgbm86IDQsIG5hbWU6IFwidHJhY2tzXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBUcmFja0luZm8sIHJlcGVhdGVkOiB0cnVlIH0sXG4gICAgeyBubzogNSwgbmFtZTogXCJtZXRhZGF0YVwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovIH0sXG4gICAgeyBubzogNiwgbmFtZTogXCJqb2luZWRfYXRcIiwga2luZDogXCJzY2FsYXJcIiwgVDogMyAvKiBTY2FsYXJUeXBlLklOVDY0ICovIH0sXG4gICAgeyBubzogOSwgbmFtZTogXCJuYW1lXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi8gfSxcbiAgICB7IG5vOiAxMCwgbmFtZTogXCJ2ZXJzaW9uXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDEzIC8qIFNjYWxhclR5cGUuVUlOVDMyICovIH0sXG4gICAgeyBubzogMTEsIG5hbWU6IFwicGVybWlzc2lvblwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogUGFydGljaXBhbnRQZXJtaXNzaW9uIH0sXG4gICAgeyBubzogMTIsIG5hbWU6IFwicmVnaW9uXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi8gfSxcbiAgICB7IG5vOiAxMywgbmFtZTogXCJpc19wdWJsaXNoZXJcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOCAvKiBTY2FsYXJUeXBlLkJPT0wgKi8gfSxcbiAgXSk7XG5cbiAgc3RhdGljIGZyb21CaW5hcnkoYnl0ZXM6IFVpbnQ4QXJyYXksIG9wdGlvbnM/OiBQYXJ0aWFsPEJpbmFyeVJlYWRPcHRpb25zPik6IFBhcnRpY2lwYW50SW5mbyB7XG4gICAgcmV0dXJuIG5ldyBQYXJ0aWNpcGFudEluZm8oKS5mcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tSnNvbihqc29uVmFsdWU6IEpzb25WYWx1ZSwgb3B0aW9ucz86IFBhcnRpYWw8SnNvblJlYWRPcHRpb25zPik6IFBhcnRpY2lwYW50SW5mbyB7XG4gICAgcmV0dXJuIG5ldyBQYXJ0aWNpcGFudEluZm8oKS5mcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpO1xuICB9XG5cbiAgc3RhdGljIGZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmc6IHN0cmluZywgb3B0aW9ucz86IFBhcnRpYWw8SnNvblJlYWRPcHRpb25zPik6IFBhcnRpY2lwYW50SW5mbyB7XG4gICAgcmV0dXJuIG5ldyBQYXJ0aWNpcGFudEluZm8oKS5mcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKTtcbiAgfVxuXG4gIHN0YXRpYyBlcXVhbHMoYTogUGFydGljaXBhbnRJbmZvIHwgUGxhaW5NZXNzYWdlPFBhcnRpY2lwYW50SW5mbz4gfCB1bmRlZmluZWQsIGI6IFBhcnRpY2lwYW50SW5mbyB8IFBsYWluTWVzc2FnZTxQYXJ0aWNpcGFudEluZm8+IHwgdW5kZWZpbmVkKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHByb3RvMy51dGlsLmVxdWFscyhQYXJ0aWNpcGFudEluZm8sIGEsIGIpO1xuICB9XG59XG5cbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIGVudW0gbGl2ZWtpdC5QYXJ0aWNpcGFudEluZm8uU3RhdGVcbiAqL1xuZXhwb3J0IGVudW0gUGFydGljaXBhbnRJbmZvX1N0YXRlIHtcbiAgLyoqXG4gICAqIHdlYnNvY2tldCcgY29ubmVjdGVkLCBidXQgbm90IG9mZmVyZWQgeWV0XG4gICAqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBKT0lOSU5HID0gMDtcbiAgICovXG4gIEpPSU5JTkcgPSAwLFxuXG4gIC8qKlxuICAgKiBzZXJ2ZXIgcmVjZWl2ZWQgY2xpZW50IG9mZmVyXG4gICAqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBKT0lORUQgPSAxO1xuICAgKi9cbiAgSk9JTkVEID0gMSxcblxuICAvKipcbiAgICogSUNFIGNvbm5lY3Rpdml0eSBlc3RhYmxpc2hlZFxuICAgKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZW51bSB2YWx1ZTogQUNUSVZFID0gMjtcbiAgICovXG4gIEFDVElWRSA9IDIsXG5cbiAgLyoqXG4gICAqIFdTIGRpc2Nvbm5lY3RlZFxuICAgKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZW51bSB2YWx1ZTogRElTQ09OTkVDVEVEID0gMztcbiAgICovXG4gIERJU0NPTk5FQ1RFRCA9IDMsXG59XG4vLyBSZXRyaWV2ZSBlbnVtIG1ldGFkYXRhIHdpdGg6IHByb3RvMy5nZXRFbnVtVHlwZShQYXJ0aWNpcGFudEluZm9fU3RhdGUpXG5wcm90bzMudXRpbC5zZXRFbnVtVHlwZShQYXJ0aWNpcGFudEluZm9fU3RhdGUsIFwibGl2ZWtpdC5QYXJ0aWNpcGFudEluZm8uU3RhdGVcIiwgW1xuICB7IG5vOiAwLCBuYW1lOiBcIkpPSU5JTkdcIiB9LFxuICB7IG5vOiAxLCBuYW1lOiBcIkpPSU5FRFwiIH0sXG4gIHsgbm86IDIsIG5hbWU6IFwiQUNUSVZFXCIgfSxcbiAgeyBubzogMywgbmFtZTogXCJESVNDT05ORUNURURcIiB9LFxuXSk7XG5cbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgbGl2ZWtpdC5FbmNyeXB0aW9uXG4gKi9cbmV4cG9ydCBjbGFzcyBFbmNyeXB0aW9uIGV4dGVuZHMgTWVzc2FnZTxFbmNyeXB0aW9uPiB7XG4gIGNvbnN0cnVjdG9yKGRhdGE/OiBQYXJ0aWFsTWVzc2FnZTxFbmNyeXB0aW9uPikge1xuICAgIHN1cGVyKCk7XG4gICAgcHJvdG8zLnV0aWwuaW5pdFBhcnRpYWwoZGF0YSwgdGhpcyk7XG4gIH1cblxuICBzdGF0aWMgcmVhZG9ubHkgcnVudGltZTogdHlwZW9mIHByb3RvMyA9IHByb3RvMztcbiAgc3RhdGljIHJlYWRvbmx5IHR5cGVOYW1lID0gXCJsaXZla2l0LkVuY3J5cHRpb25cIjtcbiAgc3RhdGljIHJlYWRvbmx5IGZpZWxkczogRmllbGRMaXN0ID0gcHJvdG8zLnV0aWwubmV3RmllbGRMaXN0KCgpID0+IFtcbiAgXSk7XG5cbiAgc3RhdGljIGZyb21CaW5hcnkoYnl0ZXM6IFVpbnQ4QXJyYXksIG9wdGlvbnM/OiBQYXJ0aWFsPEJpbmFyeVJlYWRPcHRpb25zPik6IEVuY3J5cHRpb24ge1xuICAgIHJldHVybiBuZXcgRW5jcnlwdGlvbigpLmZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpO1xuICB9XG5cbiAgc3RhdGljIGZyb21Kc29uKGpzb25WYWx1ZTogSnNvblZhbHVlLCBvcHRpb25zPzogUGFydGlhbDxKc29uUmVhZE9wdGlvbnM+KTogRW5jcnlwdGlvbiB7XG4gICAgcmV0dXJuIG5ldyBFbmNyeXB0aW9uKCkuZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tSnNvblN0cmluZyhqc29uU3RyaW5nOiBzdHJpbmcsIG9wdGlvbnM/OiBQYXJ0aWFsPEpzb25SZWFkT3B0aW9ucz4pOiBFbmNyeXB0aW9uIHtcbiAgICByZXR1cm4gbmV3IEVuY3J5cHRpb24oKS5mcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKTtcbiAgfVxuXG4gIHN0YXRpYyBlcXVhbHMoYTogRW5jcnlwdGlvbiB8IFBsYWluTWVzc2FnZTxFbmNyeXB0aW9uPiB8IHVuZGVmaW5lZCwgYjogRW5jcnlwdGlvbiB8IFBsYWluTWVzc2FnZTxFbmNyeXB0aW9uPiB8IHVuZGVmaW5lZCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBwcm90bzMudXRpbC5lcXVhbHMoRW5jcnlwdGlvbiwgYSwgYik7XG4gIH1cbn1cblxuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gZW51bSBsaXZla2l0LkVuY3J5cHRpb24uVHlwZVxuICovXG5leHBvcnQgZW51bSBFbmNyeXB0aW9uX1R5cGUge1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGVudW0gdmFsdWU6IE5PTkUgPSAwO1xuICAgKi9cbiAgTk9ORSA9IDAsXG5cbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBHQ00gPSAxO1xuICAgKi9cbiAgR0NNID0gMSxcblxuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGVudW0gdmFsdWU6IENVU1RPTSA9IDI7XG4gICAqL1xuICBDVVNUT00gPSAyLFxufVxuLy8gUmV0cmlldmUgZW51bSBtZXRhZGF0YSB3aXRoOiBwcm90bzMuZ2V0RW51bVR5cGUoRW5jcnlwdGlvbl9UeXBlKVxucHJvdG8zLnV0aWwuc2V0RW51bVR5cGUoRW5jcnlwdGlvbl9UeXBlLCBcImxpdmVraXQuRW5jcnlwdGlvbi5UeXBlXCIsIFtcbiAgeyBubzogMCwgbmFtZTogXCJOT05FXCIgfSxcbiAgeyBubzogMSwgbmFtZTogXCJHQ01cIiB9LFxuICB7IG5vOiAyLCBuYW1lOiBcIkNVU1RPTVwiIH0sXG5dKTtcblxuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBsaXZla2l0LlNpbXVsY2FzdENvZGVjSW5mb1xuICovXG5leHBvcnQgY2xhc3MgU2ltdWxjYXN0Q29kZWNJbmZvIGV4dGVuZHMgTWVzc2FnZTxTaW11bGNhc3RDb2RlY0luZm8+IHtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogc3RyaW5nIG1pbWVfdHlwZSA9IDE7XG4gICAqL1xuICBtaW1lVHlwZSA9IFwiXCI7XG5cbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogc3RyaW5nIG1pZCA9IDI7XG4gICAqL1xuICBtaWQgPSBcIlwiO1xuXG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHN0cmluZyBjaWQgPSAzO1xuICAgKi9cbiAgY2lkID0gXCJcIjtcblxuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiByZXBlYXRlZCBsaXZla2l0LlZpZGVvTGF5ZXIgbGF5ZXJzID0gNDtcbiAgICovXG4gIGxheWVyczogVmlkZW9MYXllcltdID0gW107XG5cbiAgY29uc3RydWN0b3IoZGF0YT86IFBhcnRpYWxNZXNzYWdlPFNpbXVsY2FzdENvZGVjSW5mbz4pIHtcbiAgICBzdXBlcigpO1xuICAgIHByb3RvMy51dGlsLmluaXRQYXJ0aWFsKGRhdGEsIHRoaXMpO1xuICB9XG5cbiAgc3RhdGljIHJlYWRvbmx5IHJ1bnRpbWU6IHR5cGVvZiBwcm90bzMgPSBwcm90bzM7XG4gIHN0YXRpYyByZWFkb25seSB0eXBlTmFtZSA9IFwibGl2ZWtpdC5TaW11bGNhc3RDb2RlY0luZm9cIjtcbiAgc3RhdGljIHJlYWRvbmx5IGZpZWxkczogRmllbGRMaXN0ID0gcHJvdG8zLnV0aWwubmV3RmllbGRMaXN0KCgpID0+IFtcbiAgICB7IG5vOiAxLCBuYW1lOiBcIm1pbWVfdHlwZVwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovIH0sXG4gICAgeyBubzogMiwgbmFtZTogXCJtaWRcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqLyB9LFxuICAgIHsgbm86IDMsIG5hbWU6IFwiY2lkXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi8gfSxcbiAgICB7IG5vOiA0LCBuYW1lOiBcImxheWVyc1wiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogVmlkZW9MYXllciwgcmVwZWF0ZWQ6IHRydWUgfSxcbiAgXSk7XG5cbiAgc3RhdGljIGZyb21CaW5hcnkoYnl0ZXM6IFVpbnQ4QXJyYXksIG9wdGlvbnM/OiBQYXJ0aWFsPEJpbmFyeVJlYWRPcHRpb25zPik6IFNpbXVsY2FzdENvZGVjSW5mbyB7XG4gICAgcmV0dXJuIG5ldyBTaW11bGNhc3RDb2RlY0luZm8oKS5mcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tSnNvbihqc29uVmFsdWU6IEpzb25WYWx1ZSwgb3B0aW9ucz86IFBhcnRpYWw8SnNvblJlYWRPcHRpb25zPik6IFNpbXVsY2FzdENvZGVjSW5mbyB7XG4gICAgcmV0dXJuIG5ldyBTaW11bGNhc3RDb2RlY0luZm8oKS5mcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpO1xuICB9XG5cbiAgc3RhdGljIGZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmc6IHN0cmluZywgb3B0aW9ucz86IFBhcnRpYWw8SnNvblJlYWRPcHRpb25zPik6IFNpbXVsY2FzdENvZGVjSW5mbyB7XG4gICAgcmV0dXJuIG5ldyBTaW11bGNhc3RDb2RlY0luZm8oKS5mcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKTtcbiAgfVxuXG4gIHN0YXRpYyBlcXVhbHMoYTogU2ltdWxjYXN0Q29kZWNJbmZvIHwgUGxhaW5NZXNzYWdlPFNpbXVsY2FzdENvZGVjSW5mbz4gfCB1bmRlZmluZWQsIGI6IFNpbXVsY2FzdENvZGVjSW5mbyB8IFBsYWluTWVzc2FnZTxTaW11bGNhc3RDb2RlY0luZm8+IHwgdW5kZWZpbmVkKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHByb3RvMy51dGlsLmVxdWFscyhTaW11bGNhc3RDb2RlY0luZm8sIGEsIGIpO1xuICB9XG59XG5cbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgbGl2ZWtpdC5UcmFja0luZm9cbiAqL1xuZXhwb3J0IGNsYXNzIFRyYWNrSW5mbyBleHRlbmRzIE1lc3NhZ2U8VHJhY2tJbmZvPiB7XG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHN0cmluZyBzaWQgPSAxO1xuICAgKi9cbiAgc2lkID0gXCJcIjtcblxuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBsaXZla2l0LlRyYWNrVHlwZSB0eXBlID0gMjtcbiAgICovXG4gIHR5cGUgPSBUcmFja1R5cGUuQVVESU87XG5cbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogc3RyaW5nIG5hbWUgPSAzO1xuICAgKi9cbiAgbmFtZSA9IFwiXCI7XG5cbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogYm9vbCBtdXRlZCA9IDQ7XG4gICAqL1xuICBtdXRlZCA9IGZhbHNlO1xuXG4gIC8qKlxuICAgKiBvcmlnaW5hbCB3aWR0aCBvZiB2aWRlbyAodW5zZXQgZm9yIGF1ZGlvKVxuICAgKiBjbGllbnRzIG1heSByZWNlaXZlIGEgbG93ZXIgcmVzb2x1dGlvbiB2ZXJzaW9uIHdpdGggc2ltdWxjYXN0XG4gICAqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogdWludDMyIHdpZHRoID0gNTtcbiAgICovXG4gIHdpZHRoID0gMDtcblxuICAvKipcbiAgICogb3JpZ2luYWwgaGVpZ2h0IG9mIHZpZGVvICh1bnNldCBmb3IgYXVkaW8pXG4gICAqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogdWludDMyIGhlaWdodCA9IDY7XG4gICAqL1xuICBoZWlnaHQgPSAwO1xuXG4gIC8qKlxuICAgKiB0cnVlIGlmIHRyYWNrIGlzIHNpbXVsY2FzdGVkXG4gICAqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogYm9vbCBzaW11bGNhc3QgPSA3O1xuICAgKi9cbiAgc2ltdWxjYXN0ID0gZmFsc2U7XG5cbiAgLyoqXG4gICAqIHRydWUgaWYgRFRYIChEaXNjb250aW51b3VzIFRyYW5zbWlzc2lvbikgaXMgZGlzYWJsZWQgZm9yIGF1ZGlvXG4gICAqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogYm9vbCBkaXNhYmxlX2R0eCA9IDg7XG4gICAqL1xuICBkaXNhYmxlRHR4ID0gZmFsc2U7XG5cbiAgLyoqXG4gICAqIHNvdXJjZSBvZiBtZWRpYVxuICAgKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGxpdmVraXQuVHJhY2tTb3VyY2Ugc291cmNlID0gOTtcbiAgICovXG4gIHNvdXJjZSA9IFRyYWNrU291cmNlLlVOS05PV047XG5cbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogcmVwZWF0ZWQgbGl2ZWtpdC5WaWRlb0xheWVyIGxheWVycyA9IDEwO1xuICAgKi9cbiAgbGF5ZXJzOiBWaWRlb0xheWVyW10gPSBbXTtcblxuICAvKipcbiAgICogbWltZSB0eXBlIG9mIGNvZGVjXG4gICAqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogc3RyaW5nIG1pbWVfdHlwZSA9IDExO1xuICAgKi9cbiAgbWltZVR5cGUgPSBcIlwiO1xuXG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHN0cmluZyBtaWQgPSAxMjtcbiAgICovXG4gIG1pZCA9IFwiXCI7XG5cbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogcmVwZWF0ZWQgbGl2ZWtpdC5TaW11bGNhc3RDb2RlY0luZm8gY29kZWNzID0gMTM7XG4gICAqL1xuICBjb2RlY3M6IFNpbXVsY2FzdENvZGVjSW5mb1tdID0gW107XG5cbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogYm9vbCBzdGVyZW8gPSAxNDtcbiAgICovXG4gIHN0ZXJlbyA9IGZhbHNlO1xuXG4gIC8qKlxuICAgKiB0cnVlIGlmIFJFRCAoUmVkdW5kYW50IEVuY29kaW5nKSBpcyBkaXNhYmxlZCBmb3IgYXVkaW9cbiAgICpcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBib29sIGRpc2FibGVfcmVkID0gMTU7XG4gICAqL1xuICBkaXNhYmxlUmVkID0gZmFsc2U7XG5cbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogbGl2ZWtpdC5FbmNyeXB0aW9uLlR5cGUgZW5jcnlwdGlvbiA9IDE2O1xuICAgKi9cbiAgZW5jcnlwdGlvbiA9IEVuY3J5cHRpb25fVHlwZS5OT05FO1xuXG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHN0cmluZyBzdHJlYW0gPSAxNztcbiAgICovXG4gIHN0cmVhbSA9IFwiXCI7XG5cbiAgY29uc3RydWN0b3IoZGF0YT86IFBhcnRpYWxNZXNzYWdlPFRyYWNrSW5mbz4pIHtcbiAgICBzdXBlcigpO1xuICAgIHByb3RvMy51dGlsLmluaXRQYXJ0aWFsKGRhdGEsIHRoaXMpO1xuICB9XG5cbiAgc3RhdGljIHJlYWRvbmx5IHJ1bnRpbWU6IHR5cGVvZiBwcm90bzMgPSBwcm90bzM7XG4gIHN0YXRpYyByZWFkb25seSB0eXBlTmFtZSA9IFwibGl2ZWtpdC5UcmFja0luZm9cIjtcbiAgc3RhdGljIHJlYWRvbmx5IGZpZWxkczogRmllbGRMaXN0ID0gcHJvdG8zLnV0aWwubmV3RmllbGRMaXN0KCgpID0+IFtcbiAgICB7IG5vOiAxLCBuYW1lOiBcInNpZFwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovIH0sXG4gICAgeyBubzogMiwgbmFtZTogXCJ0eXBlXCIsIGtpbmQ6IFwiZW51bVwiLCBUOiBwcm90bzMuZ2V0RW51bVR5cGUoVHJhY2tUeXBlKSB9LFxuICAgIHsgbm86IDMsIG5hbWU6IFwibmFtZVwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovIH0sXG4gICAgeyBubzogNCwgbmFtZTogXCJtdXRlZFwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA4IC8qIFNjYWxhclR5cGUuQk9PTCAqLyB9LFxuICAgIHsgbm86IDUsIG5hbWU6IFwid2lkdGhcIiwga2luZDogXCJzY2FsYXJcIiwgVDogMTMgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi8gfSxcbiAgICB7IG5vOiA2LCBuYW1lOiBcImhlaWdodFwiLCBraW5kOiBcInNjYWxhclwiLCBUOiAxMyAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqLyB9LFxuICAgIHsgbm86IDcsIG5hbWU6IFwic2ltdWxjYXN0XCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDggLyogU2NhbGFyVHlwZS5CT09MICovIH0sXG4gICAgeyBubzogOCwgbmFtZTogXCJkaXNhYmxlX2R0eFwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA4IC8qIFNjYWxhclR5cGUuQk9PTCAqLyB9LFxuICAgIHsgbm86IDksIG5hbWU6IFwic291cmNlXCIsIGtpbmQ6IFwiZW51bVwiLCBUOiBwcm90bzMuZ2V0RW51bVR5cGUoVHJhY2tTb3VyY2UpIH0sXG4gICAgeyBubzogMTAsIG5hbWU6IFwibGF5ZXJzXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBWaWRlb0xheWVyLCByZXBlYXRlZDogdHJ1ZSB9LFxuICAgIHsgbm86IDExLCBuYW1lOiBcIm1pbWVfdHlwZVwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovIH0sXG4gICAgeyBubzogMTIsIG5hbWU6IFwibWlkXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi8gfSxcbiAgICB7IG5vOiAxMywgbmFtZTogXCJjb2RlY3NcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFNpbXVsY2FzdENvZGVjSW5mbywgcmVwZWF0ZWQ6IHRydWUgfSxcbiAgICB7IG5vOiAxNCwgbmFtZTogXCJzdGVyZW9cIiwga2luZDogXCJzY2FsYXJcIiwgVDogOCAvKiBTY2FsYXJUeXBlLkJPT0wgKi8gfSxcbiAgICB7IG5vOiAxNSwgbmFtZTogXCJkaXNhYmxlX3JlZFwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA4IC8qIFNjYWxhclR5cGUuQk9PTCAqLyB9LFxuICAgIHsgbm86IDE2LCBuYW1lOiBcImVuY3J5cHRpb25cIiwga2luZDogXCJlbnVtXCIsIFQ6IHByb3RvMy5nZXRFbnVtVHlwZShFbmNyeXB0aW9uX1R5cGUpIH0sXG4gICAgeyBubzogMTcsIG5hbWU6IFwic3RyZWFtXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi8gfSxcbiAgXSk7XG5cbiAgc3RhdGljIGZyb21CaW5hcnkoYnl0ZXM6IFVpbnQ4QXJyYXksIG9wdGlvbnM/OiBQYXJ0aWFsPEJpbmFyeVJlYWRPcHRpb25zPik6IFRyYWNrSW5mbyB7XG4gICAgcmV0dXJuIG5ldyBUcmFja0luZm8oKS5mcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tSnNvbihqc29uVmFsdWU6IEpzb25WYWx1ZSwgb3B0aW9ucz86IFBhcnRpYWw8SnNvblJlYWRPcHRpb25zPik6IFRyYWNrSW5mbyB7XG4gICAgcmV0dXJuIG5ldyBUcmFja0luZm8oKS5mcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpO1xuICB9XG5cbiAgc3RhdGljIGZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmc6IHN0cmluZywgb3B0aW9ucz86IFBhcnRpYWw8SnNvblJlYWRPcHRpb25zPik6IFRyYWNrSW5mbyB7XG4gICAgcmV0dXJuIG5ldyBUcmFja0luZm8oKS5mcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKTtcbiAgfVxuXG4gIHN0YXRpYyBlcXVhbHMoYTogVHJhY2tJbmZvIHwgUGxhaW5NZXNzYWdlPFRyYWNrSW5mbz4gfCB1bmRlZmluZWQsIGI6IFRyYWNrSW5mbyB8IFBsYWluTWVzc2FnZTxUcmFja0luZm8+IHwgdW5kZWZpbmVkKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHByb3RvMy51dGlsLmVxdWFscyhUcmFja0luZm8sIGEsIGIpO1xuICB9XG59XG5cbi8qKlxuICogcHJvdmlkZSBpbmZvcm1hdGlvbiBhYm91dCBhdmFpbGFibGUgc3BhdGlhbCBsYXllcnNcbiAqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBsaXZla2l0LlZpZGVvTGF5ZXJcbiAqL1xuZXhwb3J0IGNsYXNzIFZpZGVvTGF5ZXIgZXh0ZW5kcyBNZXNzYWdlPFZpZGVvTGF5ZXI+IHtcbiAgLyoqXG4gICAqIGZvciB0cmFja3Mgd2l0aCBhIHNpbmdsZSBsYXllciwgdGhpcyBzaG91bGQgYmUgSElHSFxuICAgKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGxpdmVraXQuVmlkZW9RdWFsaXR5IHF1YWxpdHkgPSAxO1xuICAgKi9cbiAgcXVhbGl0eSA9IFZpZGVvUXVhbGl0eS5MT1c7XG5cbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogdWludDMyIHdpZHRoID0gMjtcbiAgICovXG4gIHdpZHRoID0gMDtcblxuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiB1aW50MzIgaGVpZ2h0ID0gMztcbiAgICovXG4gIGhlaWdodCA9IDA7XG5cbiAgLyoqXG4gICAqIHRhcmdldCBiaXRyYXRlIGluIGJpdCBwZXIgc2Vjb25kIChicHMpLCBzZXJ2ZXIgd2lsbCBtZWFzdXJlIGFjdHVhbFxuICAgKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHVpbnQzMiBiaXRyYXRlID0gNDtcbiAgICovXG4gIGJpdHJhdGUgPSAwO1xuXG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHVpbnQzMiBzc3JjID0gNTtcbiAgICovXG4gIHNzcmMgPSAwO1xuXG4gIGNvbnN0cnVjdG9yKGRhdGE/OiBQYXJ0aWFsTWVzc2FnZTxWaWRlb0xheWVyPikge1xuICAgIHN1cGVyKCk7XG4gICAgcHJvdG8zLnV0aWwuaW5pdFBhcnRpYWwoZGF0YSwgdGhpcyk7XG4gIH1cblxuICBzdGF0aWMgcmVhZG9ubHkgcnVudGltZTogdHlwZW9mIHByb3RvMyA9IHByb3RvMztcbiAgc3RhdGljIHJlYWRvbmx5IHR5cGVOYW1lID0gXCJsaXZla2l0LlZpZGVvTGF5ZXJcIjtcbiAgc3RhdGljIHJlYWRvbmx5IGZpZWxkczogRmllbGRMaXN0ID0gcHJvdG8zLnV0aWwubmV3RmllbGRMaXN0KCgpID0+IFtcbiAgICB7IG5vOiAxLCBuYW1lOiBcInF1YWxpdHlcIiwga2luZDogXCJlbnVtXCIsIFQ6IHByb3RvMy5nZXRFbnVtVHlwZShWaWRlb1F1YWxpdHkpIH0sXG4gICAgeyBubzogMiwgbmFtZTogXCJ3aWR0aFwiLCBraW5kOiBcInNjYWxhclwiLCBUOiAxMyAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqLyB9LFxuICAgIHsgbm86IDMsIG5hbWU6IFwiaGVpZ2h0XCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDEzIC8qIFNjYWxhclR5cGUuVUlOVDMyICovIH0sXG4gICAgeyBubzogNCwgbmFtZTogXCJiaXRyYXRlXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDEzIC8qIFNjYWxhclR5cGUuVUlOVDMyICovIH0sXG4gICAgeyBubzogNSwgbmFtZTogXCJzc3JjXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDEzIC8qIFNjYWxhclR5cGUuVUlOVDMyICovIH0sXG4gIF0pO1xuXG4gIHN0YXRpYyBmcm9tQmluYXJ5KGJ5dGVzOiBVaW50OEFycmF5LCBvcHRpb25zPzogUGFydGlhbDxCaW5hcnlSZWFkT3B0aW9ucz4pOiBWaWRlb0xheWVyIHtcbiAgICByZXR1cm4gbmV3IFZpZGVvTGF5ZXIoKS5mcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tSnNvbihqc29uVmFsdWU6IEpzb25WYWx1ZSwgb3B0aW9ucz86IFBhcnRpYWw8SnNvblJlYWRPcHRpb25zPik6IFZpZGVvTGF5ZXIge1xuICAgIHJldHVybiBuZXcgVmlkZW9MYXllcigpLmZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucyk7XG4gIH1cblxuICBzdGF0aWMgZnJvbUpzb25TdHJpbmcoanNvblN0cmluZzogc3RyaW5nLCBvcHRpb25zPzogUGFydGlhbDxKc29uUmVhZE9wdGlvbnM+KTogVmlkZW9MYXllciB7XG4gICAgcmV0dXJuIG5ldyBWaWRlb0xheWVyKCkuZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucyk7XG4gIH1cblxuICBzdGF0aWMgZXF1YWxzKGE6IFZpZGVvTGF5ZXIgfCBQbGFpbk1lc3NhZ2U8VmlkZW9MYXllcj4gfCB1bmRlZmluZWQsIGI6IFZpZGVvTGF5ZXIgfCBQbGFpbk1lc3NhZ2U8VmlkZW9MYXllcj4gfCB1bmRlZmluZWQpOiBib29sZWFuIHtcbiAgICByZXR1cm4gcHJvdG8zLnV0aWwuZXF1YWxzKFZpZGVvTGF5ZXIsIGEsIGIpO1xuICB9XG59XG5cbi8qKlxuICogbmV3IERhdGFQYWNrZXQgQVBJXG4gKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgbGl2ZWtpdC5EYXRhUGFja2V0XG4gKi9cbmV4cG9ydCBjbGFzcyBEYXRhUGFja2V0IGV4dGVuZHMgTWVzc2FnZTxEYXRhUGFja2V0PiB7XG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGxpdmVraXQuRGF0YVBhY2tldC5LaW5kIGtpbmQgPSAxO1xuICAgKi9cbiAga2luZCA9IERhdGFQYWNrZXRfS2luZC5SRUxJQUJMRTtcblxuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIG9uZW9mIGxpdmVraXQuRGF0YVBhY2tldC52YWx1ZVxuICAgKi9cbiAgdmFsdWU6IHtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGxpdmVraXQuVXNlclBhY2tldCB1c2VyID0gMjtcbiAgICAgKi9cbiAgICB2YWx1ZTogVXNlclBhY2tldDtcbiAgICBjYXNlOiBcInVzZXJcIjtcbiAgfSB8IHtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGxpdmVraXQuQWN0aXZlU3BlYWtlclVwZGF0ZSBzcGVha2VyID0gMztcbiAgICAgKi9cbiAgICB2YWx1ZTogQWN0aXZlU3BlYWtlclVwZGF0ZTtcbiAgICBjYXNlOiBcInNwZWFrZXJcIjtcbiAgfSB8IHsgY2FzZTogdW5kZWZpbmVkOyB2YWx1ZT86IHVuZGVmaW5lZCB9ID0geyBjYXNlOiB1bmRlZmluZWQgfTtcblxuICBjb25zdHJ1Y3RvcihkYXRhPzogUGFydGlhbE1lc3NhZ2U8RGF0YVBhY2tldD4pIHtcbiAgICBzdXBlcigpO1xuICAgIHByb3RvMy51dGlsLmluaXRQYXJ0aWFsKGRhdGEsIHRoaXMpO1xuICB9XG5cbiAgc3RhdGljIHJlYWRvbmx5IHJ1bnRpbWU6IHR5cGVvZiBwcm90bzMgPSBwcm90bzM7XG4gIHN0YXRpYyByZWFkb25seSB0eXBlTmFtZSA9IFwibGl2ZWtpdC5EYXRhUGFja2V0XCI7XG4gIHN0YXRpYyByZWFkb25seSBmaWVsZHM6IEZpZWxkTGlzdCA9IHByb3RvMy51dGlsLm5ld0ZpZWxkTGlzdCgoKSA9PiBbXG4gICAgeyBubzogMSwgbmFtZTogXCJraW5kXCIsIGtpbmQ6IFwiZW51bVwiLCBUOiBwcm90bzMuZ2V0RW51bVR5cGUoRGF0YVBhY2tldF9LaW5kKSB9LFxuICAgIHsgbm86IDIsIG5hbWU6IFwidXNlclwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogVXNlclBhY2tldCwgb25lb2Y6IFwidmFsdWVcIiB9LFxuICAgIHsgbm86IDMsIG5hbWU6IFwic3BlYWtlclwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogQWN0aXZlU3BlYWtlclVwZGF0ZSwgb25lb2Y6IFwidmFsdWVcIiB9LFxuICBdKTtcblxuICBzdGF0aWMgZnJvbUJpbmFyeShieXRlczogVWludDhBcnJheSwgb3B0aW9ucz86IFBhcnRpYWw8QmluYXJ5UmVhZE9wdGlvbnM+KTogRGF0YVBhY2tldCB7XG4gICAgcmV0dXJuIG5ldyBEYXRhUGFja2V0KCkuZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucyk7XG4gIH1cblxuICBzdGF0aWMgZnJvbUpzb24oanNvblZhbHVlOiBKc29uVmFsdWUsIG9wdGlvbnM/OiBQYXJ0aWFsPEpzb25SZWFkT3B0aW9ucz4pOiBEYXRhUGFja2V0IHtcbiAgICByZXR1cm4gbmV3IERhdGFQYWNrZXQoKS5mcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpO1xuICB9XG5cbiAgc3RhdGljIGZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmc6IHN0cmluZywgb3B0aW9ucz86IFBhcnRpYWw8SnNvblJlYWRPcHRpb25zPik6IERhdGFQYWNrZXQge1xuICAgIHJldHVybiBuZXcgRGF0YVBhY2tldCgpLmZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpO1xuICB9XG5cbiAgc3RhdGljIGVxdWFscyhhOiBEYXRhUGFja2V0IHwgUGxhaW5NZXNzYWdlPERhdGFQYWNrZXQ+IHwgdW5kZWZpbmVkLCBiOiBEYXRhUGFja2V0IHwgUGxhaW5NZXNzYWdlPERhdGFQYWNrZXQ+IHwgdW5kZWZpbmVkKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHByb3RvMy51dGlsLmVxdWFscyhEYXRhUGFja2V0LCBhLCBiKTtcbiAgfVxufVxuXG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIGxpdmVraXQuRGF0YVBhY2tldC5LaW5kXG4gKi9cbmV4cG9ydCBlbnVtIERhdGFQYWNrZXRfS2luZCB7XG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZW51bSB2YWx1ZTogUkVMSUFCTEUgPSAwO1xuICAgKi9cbiAgUkVMSUFCTEUgPSAwLFxuXG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZW51bSB2YWx1ZTogTE9TU1kgPSAxO1xuICAgKi9cbiAgTE9TU1kgPSAxLFxufVxuLy8gUmV0cmlldmUgZW51bSBtZXRhZGF0YSB3aXRoOiBwcm90bzMuZ2V0RW51bVR5cGUoRGF0YVBhY2tldF9LaW5kKVxucHJvdG8zLnV0aWwuc2V0RW51bVR5cGUoRGF0YVBhY2tldF9LaW5kLCBcImxpdmVraXQuRGF0YVBhY2tldC5LaW5kXCIsIFtcbiAgeyBubzogMCwgbmFtZTogXCJSRUxJQUJMRVwiIH0sXG4gIHsgbm86IDEsIG5hbWU6IFwiTE9TU1lcIiB9LFxuXSk7XG5cbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgbGl2ZWtpdC5BY3RpdmVTcGVha2VyVXBkYXRlXG4gKi9cbmV4cG9ydCBjbGFzcyBBY3RpdmVTcGVha2VyVXBkYXRlIGV4dGVuZHMgTWVzc2FnZTxBY3RpdmVTcGVha2VyVXBkYXRlPiB7XG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHJlcGVhdGVkIGxpdmVraXQuU3BlYWtlckluZm8gc3BlYWtlcnMgPSAxO1xuICAgKi9cbiAgc3BlYWtlcnM6IFNwZWFrZXJJbmZvW10gPSBbXTtcblxuICBjb25zdHJ1Y3RvcihkYXRhPzogUGFydGlhbE1lc3NhZ2U8QWN0aXZlU3BlYWtlclVwZGF0ZT4pIHtcbiAgICBzdXBlcigpO1xuICAgIHByb3RvMy51dGlsLmluaXRQYXJ0aWFsKGRhdGEsIHRoaXMpO1xuICB9XG5cbiAgc3RhdGljIHJlYWRvbmx5IHJ1bnRpbWU6IHR5cGVvZiBwcm90bzMgPSBwcm90bzM7XG4gIHN0YXRpYyByZWFkb25seSB0eXBlTmFtZSA9IFwibGl2ZWtpdC5BY3RpdmVTcGVha2VyVXBkYXRlXCI7XG4gIHN0YXRpYyByZWFkb25seSBmaWVsZHM6IEZpZWxkTGlzdCA9IHByb3RvMy51dGlsLm5ld0ZpZWxkTGlzdCgoKSA9PiBbXG4gICAgeyBubzogMSwgbmFtZTogXCJzcGVha2Vyc1wiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogU3BlYWtlckluZm8sIHJlcGVhdGVkOiB0cnVlIH0sXG4gIF0pO1xuXG4gIHN0YXRpYyBmcm9tQmluYXJ5KGJ5dGVzOiBVaW50OEFycmF5LCBvcHRpb25zPzogUGFydGlhbDxCaW5hcnlSZWFkT3B0aW9ucz4pOiBBY3RpdmVTcGVha2VyVXBkYXRlIHtcbiAgICByZXR1cm4gbmV3IEFjdGl2ZVNwZWFrZXJVcGRhdGUoKS5mcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tSnNvbihqc29uVmFsdWU6IEpzb25WYWx1ZSwgb3B0aW9ucz86IFBhcnRpYWw8SnNvblJlYWRPcHRpb25zPik6IEFjdGl2ZVNwZWFrZXJVcGRhdGUge1xuICAgIHJldHVybiBuZXcgQWN0aXZlU3BlYWtlclVwZGF0ZSgpLmZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucyk7XG4gIH1cblxuICBzdGF0aWMgZnJvbUpzb25TdHJpbmcoanNvblN0cmluZzogc3RyaW5nLCBvcHRpb25zPzogUGFydGlhbDxKc29uUmVhZE9wdGlvbnM+KTogQWN0aXZlU3BlYWtlclVwZGF0ZSB7XG4gICAgcmV0dXJuIG5ldyBBY3RpdmVTcGVha2VyVXBkYXRlKCkuZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucyk7XG4gIH1cblxuICBzdGF0aWMgZXF1YWxzKGE6IEFjdGl2ZVNwZWFrZXJVcGRhdGUgfCBQbGFpbk1lc3NhZ2U8QWN0aXZlU3BlYWtlclVwZGF0ZT4gfCB1bmRlZmluZWQsIGI6IEFjdGl2ZVNwZWFrZXJVcGRhdGUgfCBQbGFpbk1lc3NhZ2U8QWN0aXZlU3BlYWtlclVwZGF0ZT4gfCB1bmRlZmluZWQpOiBib29sZWFuIHtcbiAgICByZXR1cm4gcHJvdG8zLnV0aWwuZXF1YWxzKEFjdGl2ZVNwZWFrZXJVcGRhdGUsIGEsIGIpO1xuICB9XG59XG5cbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgbGl2ZWtpdC5TcGVha2VySW5mb1xuICovXG5leHBvcnQgY2xhc3MgU3BlYWtlckluZm8gZXh0ZW5kcyBNZXNzYWdlPFNwZWFrZXJJbmZvPiB7XG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHN0cmluZyBzaWQgPSAxO1xuICAgKi9cbiAgc2lkID0gXCJcIjtcblxuICAvKipcbiAgICogYXVkaW8gbGV2ZWwsIDAtMS4wLCAxIGlzIGxvdWRlc3RcbiAgICpcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBmbG9hdCBsZXZlbCA9IDI7XG4gICAqL1xuICBsZXZlbCA9IDA7XG5cbiAgLyoqXG4gICAqIHRydWUgaWYgc3BlYWtlciBpcyBjdXJyZW50bHkgYWN0aXZlXG4gICAqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogYm9vbCBhY3RpdmUgPSAzO1xuICAgKi9cbiAgYWN0aXZlID0gZmFsc2U7XG5cbiAgY29uc3RydWN0b3IoZGF0YT86IFBhcnRpYWxNZXNzYWdlPFNwZWFrZXJJbmZvPikge1xuICAgIHN1cGVyKCk7XG4gICAgcHJvdG8zLnV0aWwuaW5pdFBhcnRpYWwoZGF0YSwgdGhpcyk7XG4gIH1cblxuICBzdGF0aWMgcmVhZG9ubHkgcnVudGltZTogdHlwZW9mIHByb3RvMyA9IHByb3RvMztcbiAgc3RhdGljIHJlYWRvbmx5IHR5cGVOYW1lID0gXCJsaXZla2l0LlNwZWFrZXJJbmZvXCI7XG4gIHN0YXRpYyByZWFkb25seSBmaWVsZHM6IEZpZWxkTGlzdCA9IHByb3RvMy51dGlsLm5ld0ZpZWxkTGlzdCgoKSA9PiBbXG4gICAgeyBubzogMSwgbmFtZTogXCJzaWRcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqLyB9LFxuICAgIHsgbm86IDIsIG5hbWU6IFwibGV2ZWxcIiwga2luZDogXCJzY2FsYXJcIiwgVDogMiAvKiBTY2FsYXJUeXBlLkZMT0FUICovIH0sXG4gICAgeyBubzogMywgbmFtZTogXCJhY3RpdmVcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOCAvKiBTY2FsYXJUeXBlLkJPT0wgKi8gfSxcbiAgXSk7XG5cbiAgc3RhdGljIGZyb21CaW5hcnkoYnl0ZXM6IFVpbnQ4QXJyYXksIG9wdGlvbnM/OiBQYXJ0aWFsPEJpbmFyeVJlYWRPcHRpb25zPik6IFNwZWFrZXJJbmZvIHtcbiAgICByZXR1cm4gbmV3IFNwZWFrZXJJbmZvKCkuZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucyk7XG4gIH1cblxuICBzdGF0aWMgZnJvbUpzb24oanNvblZhbHVlOiBKc29uVmFsdWUsIG9wdGlvbnM/OiBQYXJ0aWFsPEpzb25SZWFkT3B0aW9ucz4pOiBTcGVha2VySW5mbyB7XG4gICAgcmV0dXJuIG5ldyBTcGVha2VySW5mbygpLmZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucyk7XG4gIH1cblxuICBzdGF0aWMgZnJvbUpzb25TdHJpbmcoanNvblN0cmluZzogc3RyaW5nLCBvcHRpb25zPzogUGFydGlhbDxKc29uUmVhZE9wdGlvbnM+KTogU3BlYWtlckluZm8ge1xuICAgIHJldHVybiBuZXcgU3BlYWtlckluZm8oKS5mcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKTtcbiAgfVxuXG4gIHN0YXRpYyBlcXVhbHMoYTogU3BlYWtlckluZm8gfCBQbGFpbk1lc3NhZ2U8U3BlYWtlckluZm8+IHwgdW5kZWZpbmVkLCBiOiBTcGVha2VySW5mbyB8IFBsYWluTWVzc2FnZTxTcGVha2VySW5mbz4gfCB1bmRlZmluZWQpOiBib29sZWFuIHtcbiAgICByZXR1cm4gcHJvdG8zLnV0aWwuZXF1YWxzKFNwZWFrZXJJbmZvLCBhLCBiKTtcbiAgfVxufVxuXG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBtZXNzYWdlIGxpdmVraXQuVXNlclBhY2tldFxuICovXG5leHBvcnQgY2xhc3MgVXNlclBhY2tldCBleHRlbmRzIE1lc3NhZ2U8VXNlclBhY2tldD4ge1xuICAvKipcbiAgICogcGFydGljaXBhbnQgSUQgb2YgdXNlciB0aGF0IHNlbnQgdGhlIG1lc3NhZ2VcbiAgICpcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBzdHJpbmcgcGFydGljaXBhbnRfc2lkID0gMTtcbiAgICovXG4gIHBhcnRpY2lwYW50U2lkID0gXCJcIjtcblxuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBzdHJpbmcgcGFydGljaXBhbnRfaWRlbnRpdHkgPSA1O1xuICAgKi9cbiAgcGFydGljaXBhbnRJZGVudGl0eSA9IFwiXCI7XG5cbiAgLyoqXG4gICAqIHVzZXIgZGVmaW5lZCBwYXlsb2FkXG4gICAqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogYnl0ZXMgcGF5bG9hZCA9IDI7XG4gICAqL1xuICBwYXlsb2FkID0gbmV3IFVpbnQ4QXJyYXkoMCk7XG5cbiAgLyoqXG4gICAqIHRoZSBJRCBvZiB0aGUgcGFydGljaXBhbnRzIHdobyB3aWxsIHJlY2VpdmUgdGhlIG1lc3NhZ2UgKHNlbnQgdG8gYWxsIGJ5IGRlZmF1bHQpXG4gICAqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogcmVwZWF0ZWQgc3RyaW5nIGRlc3RpbmF0aW9uX3NpZHMgPSAzO1xuICAgKi9cbiAgZGVzdGluYXRpb25TaWRzOiBzdHJpbmdbXSA9IFtdO1xuXG4gIC8qKlxuICAgKiBpZGVudGl0aWVzIG9mIHBhcnRpY2lwYW50cyB3aG8gd2lsbCByZWNlaXZlIHRoZSBtZXNzYWdlIChzZW50IHRvIGFsbCBieSBkZWZhdWx0KVxuICAgKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHJlcGVhdGVkIHN0cmluZyBkZXN0aW5hdGlvbl9pZGVudGl0aWVzID0gNjtcbiAgICovXG4gIGRlc3RpbmF0aW9uSWRlbnRpdGllczogc3RyaW5nW10gPSBbXTtcblxuICAvKipcbiAgICogdG9waWMgdW5kZXIgd2hpY2ggdGhlIG1lc3NhZ2Ugd2FzIHB1Ymxpc2hlZFxuICAgKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IG9wdGlvbmFsIHN0cmluZyB0b3BpYyA9IDQ7XG4gICAqL1xuICB0b3BpYz86IHN0cmluZztcblxuICBjb25zdHJ1Y3RvcihkYXRhPzogUGFydGlhbE1lc3NhZ2U8VXNlclBhY2tldD4pIHtcbiAgICBzdXBlcigpO1xuICAgIHByb3RvMy51dGlsLmluaXRQYXJ0aWFsKGRhdGEsIHRoaXMpO1xuICB9XG5cbiAgc3RhdGljIHJlYWRvbmx5IHJ1bnRpbWU6IHR5cGVvZiBwcm90bzMgPSBwcm90bzM7XG4gIHN0YXRpYyByZWFkb25seSB0eXBlTmFtZSA9IFwibGl2ZWtpdC5Vc2VyUGFja2V0XCI7XG4gIHN0YXRpYyByZWFkb25seSBmaWVsZHM6IEZpZWxkTGlzdCA9IHByb3RvMy51dGlsLm5ld0ZpZWxkTGlzdCgoKSA9PiBbXG4gICAgeyBubzogMSwgbmFtZTogXCJwYXJ0aWNpcGFudF9zaWRcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqLyB9LFxuICAgIHsgbm86IDUsIG5hbWU6IFwicGFydGljaXBhbnRfaWRlbnRpdHlcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqLyB9LFxuICAgIHsgbm86IDIsIG5hbWU6IFwicGF5bG9hZFwiLCBraW5kOiBcInNjYWxhclwiLCBUOiAxMiAvKiBTY2FsYXJUeXBlLkJZVEVTICovIH0sXG4gICAgeyBubzogMywgbmFtZTogXCJkZXN0aW5hdGlvbl9zaWRzXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi8sIHJlcGVhdGVkOiB0cnVlIH0sXG4gICAgeyBubzogNiwgbmFtZTogXCJkZXN0aW5hdGlvbl9pZGVudGl0aWVzXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi8sIHJlcGVhdGVkOiB0cnVlIH0sXG4gICAgeyBubzogNCwgbmFtZTogXCJ0b3BpY1wiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovLCBvcHQ6IHRydWUgfSxcbiAgXSk7XG5cbiAgc3RhdGljIGZyb21CaW5hcnkoYnl0ZXM6IFVpbnQ4QXJyYXksIG9wdGlvbnM/OiBQYXJ0aWFsPEJpbmFyeVJlYWRPcHRpb25zPik6IFVzZXJQYWNrZXQge1xuICAgIHJldHVybiBuZXcgVXNlclBhY2tldCgpLmZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpO1xuICB9XG5cbiAgc3RhdGljIGZyb21Kc29uKGpzb25WYWx1ZTogSnNvblZhbHVlLCBvcHRpb25zPzogUGFydGlhbDxKc29uUmVhZE9wdGlvbnM+KTogVXNlclBhY2tldCB7XG4gICAgcmV0dXJuIG5ldyBVc2VyUGFja2V0KCkuZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tSnNvblN0cmluZyhqc29uU3RyaW5nOiBzdHJpbmcsIG9wdGlvbnM/OiBQYXJ0aWFsPEpzb25SZWFkT3B0aW9ucz4pOiBVc2VyUGFja2V0IHtcbiAgICByZXR1cm4gbmV3IFVzZXJQYWNrZXQoKS5mcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKTtcbiAgfVxuXG4gIHN0YXRpYyBlcXVhbHMoYTogVXNlclBhY2tldCB8IFBsYWluTWVzc2FnZTxVc2VyUGFja2V0PiB8IHVuZGVmaW5lZCwgYjogVXNlclBhY2tldCB8IFBsYWluTWVzc2FnZTxVc2VyUGFja2V0PiB8IHVuZGVmaW5lZCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBwcm90bzMudXRpbC5lcXVhbHMoVXNlclBhY2tldCwgYSwgYik7XG4gIH1cbn1cblxuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBsaXZla2l0LlBhcnRpY2lwYW50VHJhY2tzXG4gKi9cbmV4cG9ydCBjbGFzcyBQYXJ0aWNpcGFudFRyYWNrcyBleHRlbmRzIE1lc3NhZ2U8UGFydGljaXBhbnRUcmFja3M+IHtcbiAgLyoqXG4gICAqIHBhcnRpY2lwYW50IElEIG9mIHBhcnRpY2lwYW50IHRvIHdob20gdGhlIHRyYWNrcyBiZWxvbmdcbiAgICpcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBzdHJpbmcgcGFydGljaXBhbnRfc2lkID0gMTtcbiAgICovXG4gIHBhcnRpY2lwYW50U2lkID0gXCJcIjtcblxuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiByZXBlYXRlZCBzdHJpbmcgdHJhY2tfc2lkcyA9IDI7XG4gICAqL1xuICB0cmFja1NpZHM6IHN0cmluZ1tdID0gW107XG5cbiAgY29uc3RydWN0b3IoZGF0YT86IFBhcnRpYWxNZXNzYWdlPFBhcnRpY2lwYW50VHJhY2tzPikge1xuICAgIHN1cGVyKCk7XG4gICAgcHJvdG8zLnV0aWwuaW5pdFBhcnRpYWwoZGF0YSwgdGhpcyk7XG4gIH1cblxuICBzdGF0aWMgcmVhZG9ubHkgcnVudGltZTogdHlwZW9mIHByb3RvMyA9IHByb3RvMztcbiAgc3RhdGljIHJlYWRvbmx5IHR5cGVOYW1lID0gXCJsaXZla2l0LlBhcnRpY2lwYW50VHJhY2tzXCI7XG4gIHN0YXRpYyByZWFkb25seSBmaWVsZHM6IEZpZWxkTGlzdCA9IHByb3RvMy51dGlsLm5ld0ZpZWxkTGlzdCgoKSA9PiBbXG4gICAgeyBubzogMSwgbmFtZTogXCJwYXJ0aWNpcGFudF9zaWRcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqLyB9LFxuICAgIHsgbm86IDIsIG5hbWU6IFwidHJhY2tfc2lkc1wiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovLCByZXBlYXRlZDogdHJ1ZSB9LFxuICBdKTtcblxuICBzdGF0aWMgZnJvbUJpbmFyeShieXRlczogVWludDhBcnJheSwgb3B0aW9ucz86IFBhcnRpYWw8QmluYXJ5UmVhZE9wdGlvbnM+KTogUGFydGljaXBhbnRUcmFja3Mge1xuICAgIHJldHVybiBuZXcgUGFydGljaXBhbnRUcmFja3MoKS5mcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tSnNvbihqc29uVmFsdWU6IEpzb25WYWx1ZSwgb3B0aW9ucz86IFBhcnRpYWw8SnNvblJlYWRPcHRpb25zPik6IFBhcnRpY2lwYW50VHJhY2tzIHtcbiAgICByZXR1cm4gbmV3IFBhcnRpY2lwYW50VHJhY2tzKCkuZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tSnNvblN0cmluZyhqc29uU3RyaW5nOiBzdHJpbmcsIG9wdGlvbnM/OiBQYXJ0aWFsPEpzb25SZWFkT3B0aW9ucz4pOiBQYXJ0aWNpcGFudFRyYWNrcyB7XG4gICAgcmV0dXJuIG5ldyBQYXJ0aWNpcGFudFRyYWNrcygpLmZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpO1xuICB9XG5cbiAgc3RhdGljIGVxdWFscyhhOiBQYXJ0aWNpcGFudFRyYWNrcyB8IFBsYWluTWVzc2FnZTxQYXJ0aWNpcGFudFRyYWNrcz4gfCB1bmRlZmluZWQsIGI6IFBhcnRpY2lwYW50VHJhY2tzIHwgUGxhaW5NZXNzYWdlPFBhcnRpY2lwYW50VHJhY2tzPiB8IHVuZGVmaW5lZCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBwcm90bzMudXRpbC5lcXVhbHMoUGFydGljaXBhbnRUcmFja3MsIGEsIGIpO1xuICB9XG59XG5cbi8qKlxuICogZGV0YWlscyBhYm91dCB0aGUgc2VydmVyXG4gKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgbGl2ZWtpdC5TZXJ2ZXJJbmZvXG4gKi9cbmV4cG9ydCBjbGFzcyBTZXJ2ZXJJbmZvIGV4dGVuZHMgTWVzc2FnZTxTZXJ2ZXJJbmZvPiB7XG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGxpdmVraXQuU2VydmVySW5mby5FZGl0aW9uIGVkaXRpb24gPSAxO1xuICAgKi9cbiAgZWRpdGlvbiA9IFNlcnZlckluZm9fRWRpdGlvbi5TdGFuZGFyZDtcblxuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBzdHJpbmcgdmVyc2lvbiA9IDI7XG4gICAqL1xuICB2ZXJzaW9uID0gXCJcIjtcblxuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBpbnQzMiBwcm90b2NvbCA9IDM7XG4gICAqL1xuICBwcm90b2NvbCA9IDA7XG5cbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogc3RyaW5nIHJlZ2lvbiA9IDQ7XG4gICAqL1xuICByZWdpb24gPSBcIlwiO1xuXG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHN0cmluZyBub2RlX2lkID0gNTtcbiAgICovXG4gIG5vZGVJZCA9IFwiXCI7XG5cbiAgLyoqXG4gICAqIGFkZGl0aW9uYWwgZGVidWdnaW5nIGluZm9ybWF0aW9uLiBzZW50IG9ubHkgaWYgc2VydmVyIGlzIGluIGRldmVsb3BtZW50IG1vZGVcbiAgICpcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBzdHJpbmcgZGVidWdfaW5mbyA9IDY7XG4gICAqL1xuICBkZWJ1Z0luZm8gPSBcIlwiO1xuXG4gIGNvbnN0cnVjdG9yKGRhdGE/OiBQYXJ0aWFsTWVzc2FnZTxTZXJ2ZXJJbmZvPikge1xuICAgIHN1cGVyKCk7XG4gICAgcHJvdG8zLnV0aWwuaW5pdFBhcnRpYWwoZGF0YSwgdGhpcyk7XG4gIH1cblxuICBzdGF0aWMgcmVhZG9ubHkgcnVudGltZTogdHlwZW9mIHByb3RvMyA9IHByb3RvMztcbiAgc3RhdGljIHJlYWRvbmx5IHR5cGVOYW1lID0gXCJsaXZla2l0LlNlcnZlckluZm9cIjtcbiAgc3RhdGljIHJlYWRvbmx5IGZpZWxkczogRmllbGRMaXN0ID0gcHJvdG8zLnV0aWwubmV3RmllbGRMaXN0KCgpID0+IFtcbiAgICB7IG5vOiAxLCBuYW1lOiBcImVkaXRpb25cIiwga2luZDogXCJlbnVtXCIsIFQ6IHByb3RvMy5nZXRFbnVtVHlwZShTZXJ2ZXJJbmZvX0VkaXRpb24pIH0sXG4gICAgeyBubzogMiwgbmFtZTogXCJ2ZXJzaW9uXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi8gfSxcbiAgICB7IG5vOiAzLCBuYW1lOiBcInByb3RvY29sXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDUgLyogU2NhbGFyVHlwZS5JTlQzMiAqLyB9LFxuICAgIHsgbm86IDQsIG5hbWU6IFwicmVnaW9uXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi8gfSxcbiAgICB7IG5vOiA1LCBuYW1lOiBcIm5vZGVfaWRcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqLyB9LFxuICAgIHsgbm86IDYsIG5hbWU6IFwiZGVidWdfaW5mb1wiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovIH0sXG4gIF0pO1xuXG4gIHN0YXRpYyBmcm9tQmluYXJ5KGJ5dGVzOiBVaW50OEFycmF5LCBvcHRpb25zPzogUGFydGlhbDxCaW5hcnlSZWFkT3B0aW9ucz4pOiBTZXJ2ZXJJbmZvIHtcbiAgICByZXR1cm4gbmV3IFNlcnZlckluZm8oKS5mcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tSnNvbihqc29uVmFsdWU6IEpzb25WYWx1ZSwgb3B0aW9ucz86IFBhcnRpYWw8SnNvblJlYWRPcHRpb25zPik6IFNlcnZlckluZm8ge1xuICAgIHJldHVybiBuZXcgU2VydmVySW5mbygpLmZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucyk7XG4gIH1cblxuICBzdGF0aWMgZnJvbUpzb25TdHJpbmcoanNvblN0cmluZzogc3RyaW5nLCBvcHRpb25zPzogUGFydGlhbDxKc29uUmVhZE9wdGlvbnM+KTogU2VydmVySW5mbyB7XG4gICAgcmV0dXJuIG5ldyBTZXJ2ZXJJbmZvKCkuZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucyk7XG4gIH1cblxuICBzdGF0aWMgZXF1YWxzKGE6IFNlcnZlckluZm8gfCBQbGFpbk1lc3NhZ2U8U2VydmVySW5mbz4gfCB1bmRlZmluZWQsIGI6IFNlcnZlckluZm8gfCBQbGFpbk1lc3NhZ2U8U2VydmVySW5mbz4gfCB1bmRlZmluZWQpOiBib29sZWFuIHtcbiAgICByZXR1cm4gcHJvdG8zLnV0aWwuZXF1YWxzKFNlcnZlckluZm8sIGEsIGIpO1xuICB9XG59XG5cbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIGVudW0gbGl2ZWtpdC5TZXJ2ZXJJbmZvLkVkaXRpb25cbiAqL1xuZXhwb3J0IGVudW0gU2VydmVySW5mb19FZGl0aW9uIHtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBTdGFuZGFyZCA9IDA7XG4gICAqL1xuICBTdGFuZGFyZCA9IDAsXG5cbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBDbG91ZCA9IDE7XG4gICAqL1xuICBDbG91ZCA9IDEsXG59XG4vLyBSZXRyaWV2ZSBlbnVtIG1ldGFkYXRhIHdpdGg6IHByb3RvMy5nZXRFbnVtVHlwZShTZXJ2ZXJJbmZvX0VkaXRpb24pXG5wcm90bzMudXRpbC5zZXRFbnVtVHlwZShTZXJ2ZXJJbmZvX0VkaXRpb24sIFwibGl2ZWtpdC5TZXJ2ZXJJbmZvLkVkaXRpb25cIiwgW1xuICB7IG5vOiAwLCBuYW1lOiBcIlN0YW5kYXJkXCIgfSxcbiAgeyBubzogMSwgbmFtZTogXCJDbG91ZFwiIH0sXG5dKTtcblxuLyoqXG4gKiBkZXRhaWxzIGFib3V0IHRoZSBjbGllbnRcbiAqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBsaXZla2l0LkNsaWVudEluZm9cbiAqL1xuZXhwb3J0IGNsYXNzIENsaWVudEluZm8gZXh0ZW5kcyBNZXNzYWdlPENsaWVudEluZm8+IHtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogbGl2ZWtpdC5DbGllbnRJbmZvLlNESyBzZGsgPSAxO1xuICAgKi9cbiAgc2RrID0gQ2xpZW50SW5mb19TREsuVU5LTk9XTjtcblxuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBzdHJpbmcgdmVyc2lvbiA9IDI7XG4gICAqL1xuICB2ZXJzaW9uID0gXCJcIjtcblxuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBpbnQzMiBwcm90b2NvbCA9IDM7XG4gICAqL1xuICBwcm90b2NvbCA9IDA7XG5cbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogc3RyaW5nIG9zID0gNDtcbiAgICovXG4gIG9zID0gXCJcIjtcblxuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBzdHJpbmcgb3NfdmVyc2lvbiA9IDU7XG4gICAqL1xuICBvc1ZlcnNpb24gPSBcIlwiO1xuXG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHN0cmluZyBkZXZpY2VfbW9kZWwgPSA2O1xuICAgKi9cbiAgZGV2aWNlTW9kZWwgPSBcIlwiO1xuXG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHN0cmluZyBicm93c2VyID0gNztcbiAgICovXG4gIGJyb3dzZXIgPSBcIlwiO1xuXG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHN0cmluZyBicm93c2VyX3ZlcnNpb24gPSA4O1xuICAgKi9cbiAgYnJvd3NlclZlcnNpb24gPSBcIlwiO1xuXG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHN0cmluZyBhZGRyZXNzID0gOTtcbiAgICovXG4gIGFkZHJlc3MgPSBcIlwiO1xuXG4gIC8qKlxuICAgKiB3aWZpLCB3aXJlZCwgY2VsbHVsYXIsIHZwbiwgZW1wdHkgaWYgbm90IGtub3duXG4gICAqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogc3RyaW5nIG5ldHdvcmsgPSAxMDtcbiAgICovXG4gIG5ldHdvcmsgPSBcIlwiO1xuXG4gIGNvbnN0cnVjdG9yKGRhdGE/OiBQYXJ0aWFsTWVzc2FnZTxDbGllbnRJbmZvPikge1xuICAgIHN1cGVyKCk7XG4gICAgcHJvdG8zLnV0aWwuaW5pdFBhcnRpYWwoZGF0YSwgdGhpcyk7XG4gIH1cblxuICBzdGF0aWMgcmVhZG9ubHkgcnVudGltZTogdHlwZW9mIHByb3RvMyA9IHByb3RvMztcbiAgc3RhdGljIHJlYWRvbmx5IHR5cGVOYW1lID0gXCJsaXZla2l0LkNsaWVudEluZm9cIjtcbiAgc3RhdGljIHJlYWRvbmx5IGZpZWxkczogRmllbGRMaXN0ID0gcHJvdG8zLnV0aWwubmV3RmllbGRMaXN0KCgpID0+IFtcbiAgICB7IG5vOiAxLCBuYW1lOiBcInNka1wiLCBraW5kOiBcImVudW1cIiwgVDogcHJvdG8zLmdldEVudW1UeXBlKENsaWVudEluZm9fU0RLKSB9LFxuICAgIHsgbm86IDIsIG5hbWU6IFwidmVyc2lvblwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovIH0sXG4gICAgeyBubzogMywgbmFtZTogXCJwcm90b2NvbFwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA1IC8qIFNjYWxhclR5cGUuSU5UMzIgKi8gfSxcbiAgICB7IG5vOiA0LCBuYW1lOiBcIm9zXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi8gfSxcbiAgICB7IG5vOiA1LCBuYW1lOiBcIm9zX3ZlcnNpb25cIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqLyB9LFxuICAgIHsgbm86IDYsIG5hbWU6IFwiZGV2aWNlX21vZGVsXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi8gfSxcbiAgICB7IG5vOiA3LCBuYW1lOiBcImJyb3dzZXJcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqLyB9LFxuICAgIHsgbm86IDgsIG5hbWU6IFwiYnJvd3Nlcl92ZXJzaW9uXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi8gfSxcbiAgICB7IG5vOiA5LCBuYW1lOiBcImFkZHJlc3NcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqLyB9LFxuICAgIHsgbm86IDEwLCBuYW1lOiBcIm5ldHdvcmtcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqLyB9LFxuICBdKTtcblxuICBzdGF0aWMgZnJvbUJpbmFyeShieXRlczogVWludDhBcnJheSwgb3B0aW9ucz86IFBhcnRpYWw8QmluYXJ5UmVhZE9wdGlvbnM+KTogQ2xpZW50SW5mbyB7XG4gICAgcmV0dXJuIG5ldyBDbGllbnRJbmZvKCkuZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucyk7XG4gIH1cblxuICBzdGF0aWMgZnJvbUpzb24oanNvblZhbHVlOiBKc29uVmFsdWUsIG9wdGlvbnM/OiBQYXJ0aWFsPEpzb25SZWFkT3B0aW9ucz4pOiBDbGllbnRJbmZvIHtcbiAgICByZXR1cm4gbmV3IENsaWVudEluZm8oKS5mcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpO1xuICB9XG5cbiAgc3RhdGljIGZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmc6IHN0cmluZywgb3B0aW9ucz86IFBhcnRpYWw8SnNvblJlYWRPcHRpb25zPik6IENsaWVudEluZm8ge1xuICAgIHJldHVybiBuZXcgQ2xpZW50SW5mbygpLmZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpO1xuICB9XG5cbiAgc3RhdGljIGVxdWFscyhhOiBDbGllbnRJbmZvIHwgUGxhaW5NZXNzYWdlPENsaWVudEluZm8+IHwgdW5kZWZpbmVkLCBiOiBDbGllbnRJbmZvIHwgUGxhaW5NZXNzYWdlPENsaWVudEluZm8+IHwgdW5kZWZpbmVkKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHByb3RvMy51dGlsLmVxdWFscyhDbGllbnRJbmZvLCBhLCBiKTtcbiAgfVxufVxuXG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIGxpdmVraXQuQ2xpZW50SW5mby5TREtcbiAqL1xuZXhwb3J0IGVudW0gQ2xpZW50SW5mb19TREsge1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGVudW0gdmFsdWU6IFVOS05PV04gPSAwO1xuICAgKi9cbiAgVU5LTk9XTiA9IDAsXG5cbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBKUyA9IDE7XG4gICAqL1xuICBKUyA9IDEsXG5cbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBTV0lGVCA9IDI7XG4gICAqL1xuICBTV0lGVCA9IDIsXG5cbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBBTkRST0lEID0gMztcbiAgICovXG4gIEFORFJPSUQgPSAzLFxuXG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZW51bSB2YWx1ZTogRkxVVFRFUiA9IDQ7XG4gICAqL1xuICBGTFVUVEVSID0gNCxcblxuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGVudW0gdmFsdWU6IEdPID0gNTtcbiAgICovXG4gIEdPID0gNSxcblxuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGVudW0gdmFsdWU6IFVOSVRZID0gNjtcbiAgICovXG4gIFVOSVRZID0gNixcblxuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGVudW0gdmFsdWU6IFJFQUNUX05BVElWRSA9IDc7XG4gICAqL1xuICBSRUFDVF9OQVRJVkUgPSA3LFxuXG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZW51bSB2YWx1ZTogUlVTVCA9IDg7XG4gICAqL1xuICBSVVNUID0gOCxcblxuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGVudW0gdmFsdWU6IFBZVEhPTiA9IDk7XG4gICAqL1xuICBQWVRIT04gPSA5LFxuXG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZW51bSB2YWx1ZTogQ1BQID0gMTA7XG4gICAqL1xuICBDUFAgPSAxMCxcbn1cbi8vIFJldHJpZXZlIGVudW0gbWV0YWRhdGEgd2l0aDogcHJvdG8zLmdldEVudW1UeXBlKENsaWVudEluZm9fU0RLKVxucHJvdG8zLnV0aWwuc2V0RW51bVR5cGUoQ2xpZW50SW5mb19TREssIFwibGl2ZWtpdC5DbGllbnRJbmZvLlNES1wiLCBbXG4gIHsgbm86IDAsIG5hbWU6IFwiVU5LTk9XTlwiIH0sXG4gIHsgbm86IDEsIG5hbWU6IFwiSlNcIiB9LFxuICB7IG5vOiAyLCBuYW1lOiBcIlNXSUZUXCIgfSxcbiAgeyBubzogMywgbmFtZTogXCJBTkRST0lEXCIgfSxcbiAgeyBubzogNCwgbmFtZTogXCJGTFVUVEVSXCIgfSxcbiAgeyBubzogNSwgbmFtZTogXCJHT1wiIH0sXG4gIHsgbm86IDYsIG5hbWU6IFwiVU5JVFlcIiB9LFxuICB7IG5vOiA3LCBuYW1lOiBcIlJFQUNUX05BVElWRVwiIH0sXG4gIHsgbm86IDgsIG5hbWU6IFwiUlVTVFwiIH0sXG4gIHsgbm86IDksIG5hbWU6IFwiUFlUSE9OXCIgfSxcbiAgeyBubzogMTAsIG5hbWU6IFwiQ1BQXCIgfSxcbl0pO1xuXG4vKipcbiAqIHNlcnZlciBwcm92aWRlZCBjbGllbnQgY29uZmlndXJhdGlvblxuICpcbiAqIEBnZW5lcmF0ZWQgZnJvbSBtZXNzYWdlIGxpdmVraXQuQ2xpZW50Q29uZmlndXJhdGlvblxuICovXG5leHBvcnQgY2xhc3MgQ2xpZW50Q29uZmlndXJhdGlvbiBleHRlbmRzIE1lc3NhZ2U8Q2xpZW50Q29uZmlndXJhdGlvbj4ge1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBsaXZla2l0LlZpZGVvQ29uZmlndXJhdGlvbiB2aWRlbyA9IDE7XG4gICAqL1xuICB2aWRlbz86IFZpZGVvQ29uZmlndXJhdGlvbjtcblxuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBsaXZla2l0LlZpZGVvQ29uZmlndXJhdGlvbiBzY3JlZW4gPSAyO1xuICAgKi9cbiAgc2NyZWVuPzogVmlkZW9Db25maWd1cmF0aW9uO1xuXG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGxpdmVraXQuQ2xpZW50Q29uZmlnU2V0dGluZyByZXN1bWVfY29ubmVjdGlvbiA9IDM7XG4gICAqL1xuICByZXN1bWVDb25uZWN0aW9uID0gQ2xpZW50Q29uZmlnU2V0dGluZy5VTlNFVDtcblxuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBsaXZla2l0LkRpc2FibGVkQ29kZWNzIGRpc2FibGVkX2NvZGVjcyA9IDQ7XG4gICAqL1xuICBkaXNhYmxlZENvZGVjcz86IERpc2FibGVkQ29kZWNzO1xuXG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGxpdmVraXQuQ2xpZW50Q29uZmlnU2V0dGluZyBmb3JjZV9yZWxheSA9IDU7XG4gICAqL1xuICBmb3JjZVJlbGF5ID0gQ2xpZW50Q29uZmlnU2V0dGluZy5VTlNFVDtcblxuICBjb25zdHJ1Y3RvcihkYXRhPzogUGFydGlhbE1lc3NhZ2U8Q2xpZW50Q29uZmlndXJhdGlvbj4pIHtcbiAgICBzdXBlcigpO1xuICAgIHByb3RvMy51dGlsLmluaXRQYXJ0aWFsKGRhdGEsIHRoaXMpO1xuICB9XG5cbiAgc3RhdGljIHJlYWRvbmx5IHJ1bnRpbWU6IHR5cGVvZiBwcm90bzMgPSBwcm90bzM7XG4gIHN0YXRpYyByZWFkb25seSB0eXBlTmFtZSA9IFwibGl2ZWtpdC5DbGllbnRDb25maWd1cmF0aW9uXCI7XG4gIHN0YXRpYyByZWFkb25seSBmaWVsZHM6IEZpZWxkTGlzdCA9IHByb3RvMy51dGlsLm5ld0ZpZWxkTGlzdCgoKSA9PiBbXG4gICAgeyBubzogMSwgbmFtZTogXCJ2aWRlb1wiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogVmlkZW9Db25maWd1cmF0aW9uIH0sXG4gICAgeyBubzogMiwgbmFtZTogXCJzY3JlZW5cIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFZpZGVvQ29uZmlndXJhdGlvbiB9LFxuICAgIHsgbm86IDMsIG5hbWU6IFwicmVzdW1lX2Nvbm5lY3Rpb25cIiwga2luZDogXCJlbnVtXCIsIFQ6IHByb3RvMy5nZXRFbnVtVHlwZShDbGllbnRDb25maWdTZXR0aW5nKSB9LFxuICAgIHsgbm86IDQsIG5hbWU6IFwiZGlzYWJsZWRfY29kZWNzXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBEaXNhYmxlZENvZGVjcyB9LFxuICAgIHsgbm86IDUsIG5hbWU6IFwiZm9yY2VfcmVsYXlcIiwga2luZDogXCJlbnVtXCIsIFQ6IHByb3RvMy5nZXRFbnVtVHlwZShDbGllbnRDb25maWdTZXR0aW5nKSB9LFxuICBdKTtcblxuICBzdGF0aWMgZnJvbUJpbmFyeShieXRlczogVWludDhBcnJheSwgb3B0aW9ucz86IFBhcnRpYWw8QmluYXJ5UmVhZE9wdGlvbnM+KTogQ2xpZW50Q29uZmlndXJhdGlvbiB7XG4gICAgcmV0dXJuIG5ldyBDbGllbnRDb25maWd1cmF0aW9uKCkuZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucyk7XG4gIH1cblxuICBzdGF0aWMgZnJvbUpzb24oanNvblZhbHVlOiBKc29uVmFsdWUsIG9wdGlvbnM/OiBQYXJ0aWFsPEpzb25SZWFkT3B0aW9ucz4pOiBDbGllbnRDb25maWd1cmF0aW9uIHtcbiAgICByZXR1cm4gbmV3IENsaWVudENvbmZpZ3VyYXRpb24oKS5mcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpO1xuICB9XG5cbiAgc3RhdGljIGZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmc6IHN0cmluZywgb3B0aW9ucz86IFBhcnRpYWw8SnNvblJlYWRPcHRpb25zPik6IENsaWVudENvbmZpZ3VyYXRpb24ge1xuICAgIHJldHVybiBuZXcgQ2xpZW50Q29uZmlndXJhdGlvbigpLmZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpO1xuICB9XG5cbiAgc3RhdGljIGVxdWFscyhhOiBDbGllbnRDb25maWd1cmF0aW9uIHwgUGxhaW5NZXNzYWdlPENsaWVudENvbmZpZ3VyYXRpb24+IHwgdW5kZWZpbmVkLCBiOiBDbGllbnRDb25maWd1cmF0aW9uIHwgUGxhaW5NZXNzYWdlPENsaWVudENvbmZpZ3VyYXRpb24+IHwgdW5kZWZpbmVkKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHByb3RvMy51dGlsLmVxdWFscyhDbGllbnRDb25maWd1cmF0aW9uLCBhLCBiKTtcbiAgfVxufVxuXG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBtZXNzYWdlIGxpdmVraXQuVmlkZW9Db25maWd1cmF0aW9uXG4gKi9cbmV4cG9ydCBjbGFzcyBWaWRlb0NvbmZpZ3VyYXRpb24gZXh0ZW5kcyBNZXNzYWdlPFZpZGVvQ29uZmlndXJhdGlvbj4ge1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBsaXZla2l0LkNsaWVudENvbmZpZ1NldHRpbmcgaGFyZHdhcmVfZW5jb2RlciA9IDE7XG4gICAqL1xuICBoYXJkd2FyZUVuY29kZXIgPSBDbGllbnRDb25maWdTZXR0aW5nLlVOU0VUO1xuXG4gIGNvbnN0cnVjdG9yKGRhdGE/OiBQYXJ0aWFsTWVzc2FnZTxWaWRlb0NvbmZpZ3VyYXRpb24+KSB7XG4gICAgc3VwZXIoKTtcbiAgICBwcm90bzMudXRpbC5pbml0UGFydGlhbChkYXRhLCB0aGlzKTtcbiAgfVxuXG4gIHN0YXRpYyByZWFkb25seSBydW50aW1lOiB0eXBlb2YgcHJvdG8zID0gcHJvdG8zO1xuICBzdGF0aWMgcmVhZG9ubHkgdHlwZU5hbWUgPSBcImxpdmVraXQuVmlkZW9Db25maWd1cmF0aW9uXCI7XG4gIHN0YXRpYyByZWFkb25seSBmaWVsZHM6IEZpZWxkTGlzdCA9IHByb3RvMy51dGlsLm5ld0ZpZWxkTGlzdCgoKSA9PiBbXG4gICAgeyBubzogMSwgbmFtZTogXCJoYXJkd2FyZV9lbmNvZGVyXCIsIGtpbmQ6IFwiZW51bVwiLCBUOiBwcm90bzMuZ2V0RW51bVR5cGUoQ2xpZW50Q29uZmlnU2V0dGluZykgfSxcbiAgXSk7XG5cbiAgc3RhdGljIGZyb21CaW5hcnkoYnl0ZXM6IFVpbnQ4QXJyYXksIG9wdGlvbnM/OiBQYXJ0aWFsPEJpbmFyeVJlYWRPcHRpb25zPik6IFZpZGVvQ29uZmlndXJhdGlvbiB7XG4gICAgcmV0dXJuIG5ldyBWaWRlb0NvbmZpZ3VyYXRpb24oKS5mcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tSnNvbihqc29uVmFsdWU6IEpzb25WYWx1ZSwgb3B0aW9ucz86IFBhcnRpYWw8SnNvblJlYWRPcHRpb25zPik6IFZpZGVvQ29uZmlndXJhdGlvbiB7XG4gICAgcmV0dXJuIG5ldyBWaWRlb0NvbmZpZ3VyYXRpb24oKS5mcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpO1xuICB9XG5cbiAgc3RhdGljIGZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmc6IHN0cmluZywgb3B0aW9ucz86IFBhcnRpYWw8SnNvblJlYWRPcHRpb25zPik6IFZpZGVvQ29uZmlndXJhdGlvbiB7XG4gICAgcmV0dXJuIG5ldyBWaWRlb0NvbmZpZ3VyYXRpb24oKS5mcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKTtcbiAgfVxuXG4gIHN0YXRpYyBlcXVhbHMoYTogVmlkZW9Db25maWd1cmF0aW9uIHwgUGxhaW5NZXNzYWdlPFZpZGVvQ29uZmlndXJhdGlvbj4gfCB1bmRlZmluZWQsIGI6IFZpZGVvQ29uZmlndXJhdGlvbiB8IFBsYWluTWVzc2FnZTxWaWRlb0NvbmZpZ3VyYXRpb24+IHwgdW5kZWZpbmVkKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHByb3RvMy51dGlsLmVxdWFscyhWaWRlb0NvbmZpZ3VyYXRpb24sIGEsIGIpO1xuICB9XG59XG5cbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgbGl2ZWtpdC5EaXNhYmxlZENvZGVjc1xuICovXG5leHBvcnQgY2xhc3MgRGlzYWJsZWRDb2RlY3MgZXh0ZW5kcyBNZXNzYWdlPERpc2FibGVkQ29kZWNzPiB7XG4gIC8qKlxuICAgKiBkaXNhYmxlZCBmb3IgYm90aCBwdWJsaXNoIGFuZCBzdWJzY3JpYmVcbiAgICpcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiByZXBlYXRlZCBsaXZla2l0LkNvZGVjIGNvZGVjcyA9IDE7XG4gICAqL1xuICBjb2RlY3M6IENvZGVjW10gPSBbXTtcblxuICAvKipcbiAgICogb25seSBkaXNhYmxlIGZvciBwdWJsaXNoXG4gICAqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogcmVwZWF0ZWQgbGl2ZWtpdC5Db2RlYyBwdWJsaXNoID0gMjtcbiAgICovXG4gIHB1Ymxpc2g6IENvZGVjW10gPSBbXTtcblxuICBjb25zdHJ1Y3RvcihkYXRhPzogUGFydGlhbE1lc3NhZ2U8RGlzYWJsZWRDb2RlY3M+KSB7XG4gICAgc3VwZXIoKTtcbiAgICBwcm90bzMudXRpbC5pbml0UGFydGlhbChkYXRhLCB0aGlzKTtcbiAgfVxuXG4gIHN0YXRpYyByZWFkb25seSBydW50aW1lOiB0eXBlb2YgcHJvdG8zID0gcHJvdG8zO1xuICBzdGF0aWMgcmVhZG9ubHkgdHlwZU5hbWUgPSBcImxpdmVraXQuRGlzYWJsZWRDb2RlY3NcIjtcbiAgc3RhdGljIHJlYWRvbmx5IGZpZWxkczogRmllbGRMaXN0ID0gcHJvdG8zLnV0aWwubmV3RmllbGRMaXN0KCgpID0+IFtcbiAgICB7IG5vOiAxLCBuYW1lOiBcImNvZGVjc1wiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogQ29kZWMsIHJlcGVhdGVkOiB0cnVlIH0sXG4gICAgeyBubzogMiwgbmFtZTogXCJwdWJsaXNoXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBDb2RlYywgcmVwZWF0ZWQ6IHRydWUgfSxcbiAgXSk7XG5cbiAgc3RhdGljIGZyb21CaW5hcnkoYnl0ZXM6IFVpbnQ4QXJyYXksIG9wdGlvbnM/OiBQYXJ0aWFsPEJpbmFyeVJlYWRPcHRpb25zPik6IERpc2FibGVkQ29kZWNzIHtcbiAgICByZXR1cm4gbmV3IERpc2FibGVkQ29kZWNzKCkuZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucyk7XG4gIH1cblxuICBzdGF0aWMgZnJvbUpzb24oanNvblZhbHVlOiBKc29uVmFsdWUsIG9wdGlvbnM/OiBQYXJ0aWFsPEpzb25SZWFkT3B0aW9ucz4pOiBEaXNhYmxlZENvZGVjcyB7XG4gICAgcmV0dXJuIG5ldyBEaXNhYmxlZENvZGVjcygpLmZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucyk7XG4gIH1cblxuICBzdGF0aWMgZnJvbUpzb25TdHJpbmcoanNvblN0cmluZzogc3RyaW5nLCBvcHRpb25zPzogUGFydGlhbDxKc29uUmVhZE9wdGlvbnM+KTogRGlzYWJsZWRDb2RlY3Mge1xuICAgIHJldHVybiBuZXcgRGlzYWJsZWRDb2RlY3MoKS5mcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKTtcbiAgfVxuXG4gIHN0YXRpYyBlcXVhbHMoYTogRGlzYWJsZWRDb2RlY3MgfCBQbGFpbk1lc3NhZ2U8RGlzYWJsZWRDb2RlY3M+IHwgdW5kZWZpbmVkLCBiOiBEaXNhYmxlZENvZGVjcyB8IFBsYWluTWVzc2FnZTxEaXNhYmxlZENvZGVjcz4gfCB1bmRlZmluZWQpOiBib29sZWFuIHtcbiAgICByZXR1cm4gcHJvdG8zLnV0aWwuZXF1YWxzKERpc2FibGVkQ29kZWNzLCBhLCBiKTtcbiAgfVxufVxuXG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBtZXNzYWdlIGxpdmVraXQuUlRQRHJpZnRcbiAqL1xuZXhwb3J0IGNsYXNzIFJUUERyaWZ0IGV4dGVuZHMgTWVzc2FnZTxSVFBEcmlmdD4ge1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBnb29nbGUucHJvdG9idWYuVGltZXN0YW1wIHN0YXJ0X3RpbWUgPSAxO1xuICAgKi9cbiAgc3RhcnRUaW1lPzogVGltZXN0YW1wO1xuXG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXAgZW5kX3RpbWUgPSAyO1xuICAgKi9cbiAgZW5kVGltZT86IFRpbWVzdGFtcDtcblxuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBkb3VibGUgZHVyYXRpb24gPSAzO1xuICAgKi9cbiAgZHVyYXRpb24gPSAwO1xuXG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHVpbnQ2NCBzdGFydF90aW1lc3RhbXAgPSA0O1xuICAgKi9cbiAgc3RhcnRUaW1lc3RhbXAgPSBwcm90b0ludDY0Lnplcm87XG5cbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogdWludDY0IGVuZF90aW1lc3RhbXAgPSA1O1xuICAgKi9cbiAgZW5kVGltZXN0YW1wID0gcHJvdG9JbnQ2NC56ZXJvO1xuXG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHVpbnQ2NCBydHBfY2xvY2tfdGlja3MgPSA2O1xuICAgKi9cbiAgcnRwQ2xvY2tUaWNrcyA9IHByb3RvSW50NjQuemVybztcblxuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBpbnQ2NCBkcmlmdF9zYW1wbGVzID0gNztcbiAgICovXG4gIGRyaWZ0U2FtcGxlcyA9IHByb3RvSW50NjQuemVybztcblxuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBkb3VibGUgZHJpZnRfbXMgPSA4O1xuICAgKi9cbiAgZHJpZnRNcyA9IDA7XG5cbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogZG91YmxlIGNsb2NrX3JhdGUgPSA5O1xuICAgKi9cbiAgY2xvY2tSYXRlID0gMDtcblxuICBjb25zdHJ1Y3RvcihkYXRhPzogUGFydGlhbE1lc3NhZ2U8UlRQRHJpZnQ+KSB7XG4gICAgc3VwZXIoKTtcbiAgICBwcm90bzMudXRpbC5pbml0UGFydGlhbChkYXRhLCB0aGlzKTtcbiAgfVxuXG4gIHN0YXRpYyByZWFkb25seSBydW50aW1lOiB0eXBlb2YgcHJvdG8zID0gcHJvdG8zO1xuICBzdGF0aWMgcmVhZG9ubHkgdHlwZU5hbWUgPSBcImxpdmVraXQuUlRQRHJpZnRcIjtcbiAgc3RhdGljIHJlYWRvbmx5IGZpZWxkczogRmllbGRMaXN0ID0gcHJvdG8zLnV0aWwubmV3RmllbGRMaXN0KCgpID0+IFtcbiAgICB7IG5vOiAxLCBuYW1lOiBcInN0YXJ0X3RpbWVcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFRpbWVzdGFtcCB9LFxuICAgIHsgbm86IDIsIG5hbWU6IFwiZW5kX3RpbWVcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFRpbWVzdGFtcCB9LFxuICAgIHsgbm86IDMsIG5hbWU6IFwiZHVyYXRpb25cIiwga2luZDogXCJzY2FsYXJcIiwgVDogMSAvKiBTY2FsYXJUeXBlLkRPVUJMRSAqLyB9LFxuICAgIHsgbm86IDQsIG5hbWU6IFwic3RhcnRfdGltZXN0YW1wXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDQgLyogU2NhbGFyVHlwZS5VSU5UNjQgKi8gfSxcbiAgICB7IG5vOiA1LCBuYW1lOiBcImVuZF90aW1lc3RhbXBcIiwga2luZDogXCJzY2FsYXJcIiwgVDogNCAvKiBTY2FsYXJUeXBlLlVJTlQ2NCAqLyB9LFxuICAgIHsgbm86IDYsIG5hbWU6IFwicnRwX2Nsb2NrX3RpY2tzXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDQgLyogU2NhbGFyVHlwZS5VSU5UNjQgKi8gfSxcbiAgICB7IG5vOiA3LCBuYW1lOiBcImRyaWZ0X3NhbXBsZXNcIiwga2luZDogXCJzY2FsYXJcIiwgVDogMyAvKiBTY2FsYXJUeXBlLklOVDY0ICovIH0sXG4gICAgeyBubzogOCwgbmFtZTogXCJkcmlmdF9tc1wiLCBraW5kOiBcInNjYWxhclwiLCBUOiAxIC8qIFNjYWxhclR5cGUuRE9VQkxFICovIH0sXG4gICAgeyBubzogOSwgbmFtZTogXCJjbG9ja19yYXRlXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDEgLyogU2NhbGFyVHlwZS5ET1VCTEUgKi8gfSxcbiAgXSk7XG5cbiAgc3RhdGljIGZyb21CaW5hcnkoYnl0ZXM6IFVpbnQ4QXJyYXksIG9wdGlvbnM/OiBQYXJ0aWFsPEJpbmFyeVJlYWRPcHRpb25zPik6IFJUUERyaWZ0IHtcbiAgICByZXR1cm4gbmV3IFJUUERyaWZ0KCkuZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucyk7XG4gIH1cblxuICBzdGF0aWMgZnJvbUpzb24oanNvblZhbHVlOiBKc29uVmFsdWUsIG9wdGlvbnM/OiBQYXJ0aWFsPEpzb25SZWFkT3B0aW9ucz4pOiBSVFBEcmlmdCB7XG4gICAgcmV0dXJuIG5ldyBSVFBEcmlmdCgpLmZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucyk7XG4gIH1cblxuICBzdGF0aWMgZnJvbUpzb25TdHJpbmcoanNvblN0cmluZzogc3RyaW5nLCBvcHRpb25zPzogUGFydGlhbDxKc29uUmVhZE9wdGlvbnM+KTogUlRQRHJpZnQge1xuICAgIHJldHVybiBuZXcgUlRQRHJpZnQoKS5mcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKTtcbiAgfVxuXG4gIHN0YXRpYyBlcXVhbHMoYTogUlRQRHJpZnQgfCBQbGFpbk1lc3NhZ2U8UlRQRHJpZnQ+IHwgdW5kZWZpbmVkLCBiOiBSVFBEcmlmdCB8IFBsYWluTWVzc2FnZTxSVFBEcmlmdD4gfCB1bmRlZmluZWQpOiBib29sZWFuIHtcbiAgICByZXR1cm4gcHJvdG8zLnV0aWwuZXF1YWxzKFJUUERyaWZ0LCBhLCBiKTtcbiAgfVxufVxuXG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBtZXNzYWdlIGxpdmVraXQuUlRQU3RhdHNcbiAqL1xuZXhwb3J0IGNsYXNzIFJUUFN0YXRzIGV4dGVuZHMgTWVzc2FnZTxSVFBTdGF0cz4ge1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBnb29nbGUucHJvdG9idWYuVGltZXN0YW1wIHN0YXJ0X3RpbWUgPSAxO1xuICAgKi9cbiAgc3RhcnRUaW1lPzogVGltZXN0YW1wO1xuXG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXAgZW5kX3RpbWUgPSAyO1xuICAgKi9cbiAgZW5kVGltZT86IFRpbWVzdGFtcDtcblxuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBkb3VibGUgZHVyYXRpb24gPSAzO1xuICAgKi9cbiAgZHVyYXRpb24gPSAwO1xuXG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHVpbnQzMiBwYWNrZXRzID0gNDtcbiAgICovXG4gIHBhY2tldHMgPSAwO1xuXG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGRvdWJsZSBwYWNrZXRfcmF0ZSA9IDU7XG4gICAqL1xuICBwYWNrZXRSYXRlID0gMDtcblxuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiB1aW50NjQgYnl0ZXMgPSA2O1xuICAgKi9cbiAgYnl0ZXMgPSBwcm90b0ludDY0Lnplcm87XG5cbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogdWludDY0IGhlYWRlcl9ieXRlcyA9IDM5O1xuICAgKi9cbiAgaGVhZGVyQnl0ZXMgPSBwcm90b0ludDY0Lnplcm87XG5cbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogZG91YmxlIGJpdHJhdGUgPSA3O1xuICAgKi9cbiAgYml0cmF0ZSA9IDA7XG5cbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogdWludDMyIHBhY2tldHNfbG9zdCA9IDg7XG4gICAqL1xuICBwYWNrZXRzTG9zdCA9IDA7XG5cbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogZG91YmxlIHBhY2tldF9sb3NzX3JhdGUgPSA5O1xuICAgKi9cbiAgcGFja2V0TG9zc1JhdGUgPSAwO1xuXG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGZsb2F0IHBhY2tldF9sb3NzX3BlcmNlbnRhZ2UgPSAxMDtcbiAgICovXG4gIHBhY2tldExvc3NQZXJjZW50YWdlID0gMDtcblxuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiB1aW50MzIgcGFja2V0c19kdXBsaWNhdGUgPSAxMTtcbiAgICovXG4gIHBhY2tldHNEdXBsaWNhdGUgPSAwO1xuXG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGRvdWJsZSBwYWNrZXRfZHVwbGljYXRlX3JhdGUgPSAxMjtcbiAgICovXG4gIHBhY2tldER1cGxpY2F0ZVJhdGUgPSAwO1xuXG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHVpbnQ2NCBieXRlc19kdXBsaWNhdGUgPSAxMztcbiAgICovXG4gIGJ5dGVzRHVwbGljYXRlID0gcHJvdG9JbnQ2NC56ZXJvO1xuXG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHVpbnQ2NCBoZWFkZXJfYnl0ZXNfZHVwbGljYXRlID0gNDA7XG4gICAqL1xuICBoZWFkZXJCeXRlc0R1cGxpY2F0ZSA9IHByb3RvSW50NjQuemVybztcblxuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBkb3VibGUgYml0cmF0ZV9kdXBsaWNhdGUgPSAxNDtcbiAgICovXG4gIGJpdHJhdGVEdXBsaWNhdGUgPSAwO1xuXG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHVpbnQzMiBwYWNrZXRzX3BhZGRpbmcgPSAxNTtcbiAgICovXG4gIHBhY2tldHNQYWRkaW5nID0gMDtcblxuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBkb3VibGUgcGFja2V0X3BhZGRpbmdfcmF0ZSA9IDE2O1xuICAgKi9cbiAgcGFja2V0UGFkZGluZ1JhdGUgPSAwO1xuXG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHVpbnQ2NCBieXRlc19wYWRkaW5nID0gMTc7XG4gICAqL1xuICBieXRlc1BhZGRpbmcgPSBwcm90b0ludDY0Lnplcm87XG5cbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogdWludDY0IGhlYWRlcl9ieXRlc19wYWRkaW5nID0gNDE7XG4gICAqL1xuICBoZWFkZXJCeXRlc1BhZGRpbmcgPSBwcm90b0ludDY0Lnplcm87XG5cbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogZG91YmxlIGJpdHJhdGVfcGFkZGluZyA9IDE4O1xuICAgKi9cbiAgYml0cmF0ZVBhZGRpbmcgPSAwO1xuXG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHVpbnQzMiBwYWNrZXRzX291dF9vZl9vcmRlciA9IDE5O1xuICAgKi9cbiAgcGFja2V0c091dE9mT3JkZXIgPSAwO1xuXG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHVpbnQzMiBmcmFtZXMgPSAyMDtcbiAgICovXG4gIGZyYW1lcyA9IDA7XG5cbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogZG91YmxlIGZyYW1lX3JhdGUgPSAyMTtcbiAgICovXG4gIGZyYW1lUmF0ZSA9IDA7XG5cbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogZG91YmxlIGppdHRlcl9jdXJyZW50ID0gMjI7XG4gICAqL1xuICBqaXR0ZXJDdXJyZW50ID0gMDtcblxuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBkb3VibGUgaml0dGVyX21heCA9IDIzO1xuICAgKi9cbiAgaml0dGVyTWF4ID0gMDtcblxuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBtYXA8aW50MzIsIHVpbnQzMj4gZ2FwX2hpc3RvZ3JhbSA9IDI0O1xuICAgKi9cbiAgZ2FwSGlzdG9ncmFtOiB7IFtrZXk6IG51bWJlcl06IG51bWJlciB9ID0ge307XG5cbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogdWludDMyIG5hY2tzID0gMjU7XG4gICAqL1xuICBuYWNrcyA9IDA7XG5cbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogdWludDMyIG5hY2tfYWNrcyA9IDM3O1xuICAgKi9cbiAgbmFja0Fja3MgPSAwO1xuXG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHVpbnQzMiBuYWNrX21pc3NlcyA9IDI2O1xuICAgKi9cbiAgbmFja01pc3NlcyA9IDA7XG5cbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogdWludDMyIG5hY2tfcmVwZWF0ZWQgPSAzODtcbiAgICovXG4gIG5hY2tSZXBlYXRlZCA9IDA7XG5cbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogdWludDMyIHBsaXMgPSAyNztcbiAgICovXG4gIHBsaXMgPSAwO1xuXG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXAgbGFzdF9wbGkgPSAyODtcbiAgICovXG4gIGxhc3RQbGk/OiBUaW1lc3RhbXA7XG5cbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogdWludDMyIGZpcnMgPSAyOTtcbiAgICovXG4gIGZpcnMgPSAwO1xuXG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXAgbGFzdF9maXIgPSAzMDtcbiAgICovXG4gIGxhc3RGaXI/OiBUaW1lc3RhbXA7XG5cbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogdWludDMyIHJ0dF9jdXJyZW50ID0gMzE7XG4gICAqL1xuICBydHRDdXJyZW50ID0gMDtcblxuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiB1aW50MzIgcnR0X21heCA9IDMyO1xuICAgKi9cbiAgcnR0TWF4ID0gMDtcblxuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiB1aW50MzIga2V5X2ZyYW1lcyA9IDMzO1xuICAgKi9cbiAga2V5RnJhbWVzID0gMDtcblxuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBnb29nbGUucHJvdG9idWYuVGltZXN0YW1wIGxhc3Rfa2V5X2ZyYW1lID0gMzQ7XG4gICAqL1xuICBsYXN0S2V5RnJhbWU/OiBUaW1lc3RhbXA7XG5cbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogdWludDMyIGxheWVyX2xvY2tfcGxpcyA9IDM1O1xuICAgKi9cbiAgbGF5ZXJMb2NrUGxpcyA9IDA7XG5cbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcCBsYXN0X2xheWVyX2xvY2tfcGxpID0gMzY7XG4gICAqL1xuICBsYXN0TGF5ZXJMb2NrUGxpPzogVGltZXN0YW1wO1xuXG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGxpdmVraXQuUlRQRHJpZnQgcGFja2V0X2RyaWZ0ID0gNDQ7XG4gICAqL1xuICBwYWNrZXREcmlmdD86IFJUUERyaWZ0O1xuXG4gIC8qKlxuICAgKiBORVhUX0lEOiA0NlxuICAgKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGxpdmVraXQuUlRQRHJpZnQgcmVwb3J0X2RyaWZ0ID0gNDU7XG4gICAqL1xuICByZXBvcnREcmlmdD86IFJUUERyaWZ0O1xuXG4gIGNvbnN0cnVjdG9yKGRhdGE/OiBQYXJ0aWFsTWVzc2FnZTxSVFBTdGF0cz4pIHtcbiAgICBzdXBlcigpO1xuICAgIHByb3RvMy51dGlsLmluaXRQYXJ0aWFsKGRhdGEsIHRoaXMpO1xuICB9XG5cbiAgc3RhdGljIHJlYWRvbmx5IHJ1bnRpbWU6IHR5cGVvZiBwcm90bzMgPSBwcm90bzM7XG4gIHN0YXRpYyByZWFkb25seSB0eXBlTmFtZSA9IFwibGl2ZWtpdC5SVFBTdGF0c1wiO1xuICBzdGF0aWMgcmVhZG9ubHkgZmllbGRzOiBGaWVsZExpc3QgPSBwcm90bzMudXRpbC5uZXdGaWVsZExpc3QoKCkgPT4gW1xuICAgIHsgbm86IDEsIG5hbWU6IFwic3RhcnRfdGltZVwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogVGltZXN0YW1wIH0sXG4gICAgeyBubzogMiwgbmFtZTogXCJlbmRfdGltZVwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogVGltZXN0YW1wIH0sXG4gICAgeyBubzogMywgbmFtZTogXCJkdXJhdGlvblwiLCBraW5kOiBcInNjYWxhclwiLCBUOiAxIC8qIFNjYWxhclR5cGUuRE9VQkxFICovIH0sXG4gICAgeyBubzogNCwgbmFtZTogXCJwYWNrZXRzXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDEzIC8qIFNjYWxhclR5cGUuVUlOVDMyICovIH0sXG4gICAgeyBubzogNSwgbmFtZTogXCJwYWNrZXRfcmF0ZVwiLCBraW5kOiBcInNjYWxhclwiLCBUOiAxIC8qIFNjYWxhclR5cGUuRE9VQkxFICovIH0sXG4gICAgeyBubzogNiwgbmFtZTogXCJieXRlc1wiLCBraW5kOiBcInNjYWxhclwiLCBUOiA0IC8qIFNjYWxhclR5cGUuVUlOVDY0ICovIH0sXG4gICAgeyBubzogMzksIG5hbWU6IFwiaGVhZGVyX2J5dGVzXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDQgLyogU2NhbGFyVHlwZS5VSU5UNjQgKi8gfSxcbiAgICB7IG5vOiA3LCBuYW1lOiBcImJpdHJhdGVcIiwga2luZDogXCJzY2FsYXJcIiwgVDogMSAvKiBTY2FsYXJUeXBlLkRPVUJMRSAqLyB9LFxuICAgIHsgbm86IDgsIG5hbWU6IFwicGFja2V0c19sb3N0XCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDEzIC8qIFNjYWxhclR5cGUuVUlOVDMyICovIH0sXG4gICAgeyBubzogOSwgbmFtZTogXCJwYWNrZXRfbG9zc19yYXRlXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDEgLyogU2NhbGFyVHlwZS5ET1VCTEUgKi8gfSxcbiAgICB7IG5vOiAxMCwgbmFtZTogXCJwYWNrZXRfbG9zc19wZXJjZW50YWdlXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDIgLyogU2NhbGFyVHlwZS5GTE9BVCAqLyB9LFxuICAgIHsgbm86IDExLCBuYW1lOiBcInBhY2tldHNfZHVwbGljYXRlXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDEzIC8qIFNjYWxhclR5cGUuVUlOVDMyICovIH0sXG4gICAgeyBubzogMTIsIG5hbWU6IFwicGFja2V0X2R1cGxpY2F0ZV9yYXRlXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDEgLyogU2NhbGFyVHlwZS5ET1VCTEUgKi8gfSxcbiAgICB7IG5vOiAxMywgbmFtZTogXCJieXRlc19kdXBsaWNhdGVcIiwga2luZDogXCJzY2FsYXJcIiwgVDogNCAvKiBTY2FsYXJUeXBlLlVJTlQ2NCAqLyB9LFxuICAgIHsgbm86IDQwLCBuYW1lOiBcImhlYWRlcl9ieXRlc19kdXBsaWNhdGVcIiwga2luZDogXCJzY2FsYXJcIiwgVDogNCAvKiBTY2FsYXJUeXBlLlVJTlQ2NCAqLyB9LFxuICAgIHsgbm86IDE0LCBuYW1lOiBcImJpdHJhdGVfZHVwbGljYXRlXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDEgLyogU2NhbGFyVHlwZS5ET1VCTEUgKi8gfSxcbiAgICB7IG5vOiAxNSwgbmFtZTogXCJwYWNrZXRzX3BhZGRpbmdcIiwga2luZDogXCJzY2FsYXJcIiwgVDogMTMgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi8gfSxcbiAgICB7IG5vOiAxNiwgbmFtZTogXCJwYWNrZXRfcGFkZGluZ19yYXRlXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDEgLyogU2NhbGFyVHlwZS5ET1VCTEUgKi8gfSxcbiAgICB7IG5vOiAxNywgbmFtZTogXCJieXRlc19wYWRkaW5nXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDQgLyogU2NhbGFyVHlwZS5VSU5UNjQgKi8gfSxcbiAgICB7IG5vOiA0MSwgbmFtZTogXCJoZWFkZXJfYnl0ZXNfcGFkZGluZ1wiLCBraW5kOiBcInNjYWxhclwiLCBUOiA0IC8qIFNjYWxhclR5cGUuVUlOVDY0ICovIH0sXG4gICAgeyBubzogMTgsIG5hbWU6IFwiYml0cmF0ZV9wYWRkaW5nXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDEgLyogU2NhbGFyVHlwZS5ET1VCTEUgKi8gfSxcbiAgICB7IG5vOiAxOSwgbmFtZTogXCJwYWNrZXRzX291dF9vZl9vcmRlclwiLCBraW5kOiBcInNjYWxhclwiLCBUOiAxMyAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqLyB9LFxuICAgIHsgbm86IDIwLCBuYW1lOiBcImZyYW1lc1wiLCBraW5kOiBcInNjYWxhclwiLCBUOiAxMyAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqLyB9LFxuICAgIHsgbm86IDIxLCBuYW1lOiBcImZyYW1lX3JhdGVcIiwga2luZDogXCJzY2FsYXJcIiwgVDogMSAvKiBTY2FsYXJUeXBlLkRPVUJMRSAqLyB9LFxuICAgIHsgbm86IDIyLCBuYW1lOiBcImppdHRlcl9jdXJyZW50XCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDEgLyogU2NhbGFyVHlwZS5ET1VCTEUgKi8gfSxcbiAgICB7IG5vOiAyMywgbmFtZTogXCJqaXR0ZXJfbWF4XCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDEgLyogU2NhbGFyVHlwZS5ET1VCTEUgKi8gfSxcbiAgICB7IG5vOiAyNCwgbmFtZTogXCJnYXBfaGlzdG9ncmFtXCIsIGtpbmQ6IFwibWFwXCIsIEs6IDUgLyogU2NhbGFyVHlwZS5JTlQzMiAqLywgVjoge2tpbmQ6IFwic2NhbGFyXCIsIFQ6IDEzIC8qIFNjYWxhclR5cGUuVUlOVDMyICovfSB9LFxuICAgIHsgbm86IDI1LCBuYW1lOiBcIm5hY2tzXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDEzIC8qIFNjYWxhclR5cGUuVUlOVDMyICovIH0sXG4gICAgeyBubzogMzcsIG5hbWU6IFwibmFja19hY2tzXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDEzIC8qIFNjYWxhclR5cGUuVUlOVDMyICovIH0sXG4gICAgeyBubzogMjYsIG5hbWU6IFwibmFja19taXNzZXNcIiwga2luZDogXCJzY2FsYXJcIiwgVDogMTMgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi8gfSxcbiAgICB7IG5vOiAzOCwgbmFtZTogXCJuYWNrX3JlcGVhdGVkXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDEzIC8qIFNjYWxhclR5cGUuVUlOVDMyICovIH0sXG4gICAgeyBubzogMjcsIG5hbWU6IFwicGxpc1wiLCBraW5kOiBcInNjYWxhclwiLCBUOiAxMyAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqLyB9LFxuICAgIHsgbm86IDI4LCBuYW1lOiBcImxhc3RfcGxpXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBUaW1lc3RhbXAgfSxcbiAgICB7IG5vOiAyOSwgbmFtZTogXCJmaXJzXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDEzIC8qIFNjYWxhclR5cGUuVUlOVDMyICovIH0sXG4gICAgeyBubzogMzAsIG5hbWU6IFwibGFzdF9maXJcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFRpbWVzdGFtcCB9LFxuICAgIHsgbm86IDMxLCBuYW1lOiBcInJ0dF9jdXJyZW50XCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDEzIC8qIFNjYWxhclR5cGUuVUlOVDMyICovIH0sXG4gICAgeyBubzogMzIsIG5hbWU6IFwicnR0X21heFwiLCBraW5kOiBcInNjYWxhclwiLCBUOiAxMyAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqLyB9LFxuICAgIHsgbm86IDMzLCBuYW1lOiBcImtleV9mcmFtZXNcIiwga2luZDogXCJzY2FsYXJcIiwgVDogMTMgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi8gfSxcbiAgICB7IG5vOiAzNCwgbmFtZTogXCJsYXN0X2tleV9mcmFtZVwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogVGltZXN0YW1wIH0sXG4gICAgeyBubzogMzUsIG5hbWU6IFwibGF5ZXJfbG9ja19wbGlzXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDEzIC8qIFNjYWxhclR5cGUuVUlOVDMyICovIH0sXG4gICAgeyBubzogMzYsIG5hbWU6IFwibGFzdF9sYXllcl9sb2NrX3BsaVwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogVGltZXN0YW1wIH0sXG4gICAgeyBubzogNDQsIG5hbWU6IFwicGFja2V0X2RyaWZ0XCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBSVFBEcmlmdCB9LFxuICAgIHsgbm86IDQ1LCBuYW1lOiBcInJlcG9ydF9kcmlmdFwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogUlRQRHJpZnQgfSxcbiAgXSk7XG5cbiAgc3RhdGljIGZyb21CaW5hcnkoYnl0ZXM6IFVpbnQ4QXJyYXksIG9wdGlvbnM/OiBQYXJ0aWFsPEJpbmFyeVJlYWRPcHRpb25zPik6IFJUUFN0YXRzIHtcbiAgICByZXR1cm4gbmV3IFJUUFN0YXRzKCkuZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucyk7XG4gIH1cblxuICBzdGF0aWMgZnJvbUpzb24oanNvblZhbHVlOiBKc29uVmFsdWUsIG9wdGlvbnM/OiBQYXJ0aWFsPEpzb25SZWFkT3B0aW9ucz4pOiBSVFBTdGF0cyB7XG4gICAgcmV0dXJuIG5ldyBSVFBTdGF0cygpLmZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucyk7XG4gIH1cblxuICBzdGF0aWMgZnJvbUpzb25TdHJpbmcoanNvblN0cmluZzogc3RyaW5nLCBvcHRpb25zPzogUGFydGlhbDxKc29uUmVhZE9wdGlvbnM+KTogUlRQU3RhdHMge1xuICAgIHJldHVybiBuZXcgUlRQU3RhdHMoKS5mcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKTtcbiAgfVxuXG4gIHN0YXRpYyBlcXVhbHMoYTogUlRQU3RhdHMgfCBQbGFpbk1lc3NhZ2U8UlRQU3RhdHM+IHwgdW5kZWZpbmVkLCBiOiBSVFBTdGF0cyB8IFBsYWluTWVzc2FnZTxSVFBTdGF0cz4gfCB1bmRlZmluZWQpOiBib29sZWFuIHtcbiAgICByZXR1cm4gcHJvdG8zLnV0aWwuZXF1YWxzKFJUUFN0YXRzLCBhLCBiKTtcbiAgfVxufVxuXG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBtZXNzYWdlIGxpdmVraXQuVGltZWRWZXJzaW9uXG4gKi9cbmV4cG9ydCBjbGFzcyBUaW1lZFZlcnNpb24gZXh0ZW5kcyBNZXNzYWdlPFRpbWVkVmVyc2lvbj4ge1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBpbnQ2NCB1bml4X21pY3JvID0gMTtcbiAgICovXG4gIHVuaXhNaWNybyA9IHByb3RvSW50NjQuemVybztcblxuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBpbnQzMiB0aWNrcyA9IDI7XG4gICAqL1xuICB0aWNrcyA9IDA7XG5cbiAgY29uc3RydWN0b3IoZGF0YT86IFBhcnRpYWxNZXNzYWdlPFRpbWVkVmVyc2lvbj4pIHtcbiAgICBzdXBlcigpO1xuICAgIHByb3RvMy51dGlsLmluaXRQYXJ0aWFsKGRhdGEsIHRoaXMpO1xuICB9XG5cbiAgc3RhdGljIHJlYWRvbmx5IHJ1bnRpbWU6IHR5cGVvZiBwcm90bzMgPSBwcm90bzM7XG4gIHN0YXRpYyByZWFkb25seSB0eXBlTmFtZSA9IFwibGl2ZWtpdC5UaW1lZFZlcnNpb25cIjtcbiAgc3RhdGljIHJlYWRvbmx5IGZpZWxkczogRmllbGRMaXN0ID0gcHJvdG8zLnV0aWwubmV3RmllbGRMaXN0KCgpID0+IFtcbiAgICB7IG5vOiAxLCBuYW1lOiBcInVuaXhfbWljcm9cIiwga2luZDogXCJzY2FsYXJcIiwgVDogMyAvKiBTY2FsYXJUeXBlLklOVDY0ICovIH0sXG4gICAgeyBubzogMiwgbmFtZTogXCJ0aWNrc1wiLCBraW5kOiBcInNjYWxhclwiLCBUOiA1IC8qIFNjYWxhclR5cGUuSU5UMzIgKi8gfSxcbiAgXSk7XG5cbiAgc3RhdGljIGZyb21CaW5hcnkoYnl0ZXM6IFVpbnQ4QXJyYXksIG9wdGlvbnM/OiBQYXJ0aWFsPEJpbmFyeVJlYWRPcHRpb25zPik6IFRpbWVkVmVyc2lvbiB7XG4gICAgcmV0dXJuIG5ldyBUaW1lZFZlcnNpb24oKS5mcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tSnNvbihqc29uVmFsdWU6IEpzb25WYWx1ZSwgb3B0aW9ucz86IFBhcnRpYWw8SnNvblJlYWRPcHRpb25zPik6IFRpbWVkVmVyc2lvbiB7XG4gICAgcmV0dXJuIG5ldyBUaW1lZFZlcnNpb24oKS5mcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpO1xuICB9XG5cbiAgc3RhdGljIGZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmc6IHN0cmluZywgb3B0aW9ucz86IFBhcnRpYWw8SnNvblJlYWRPcHRpb25zPik6IFRpbWVkVmVyc2lvbiB7XG4gICAgcmV0dXJuIG5ldyBUaW1lZFZlcnNpb24oKS5mcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKTtcbiAgfVxuXG4gIHN0YXRpYyBlcXVhbHMoYTogVGltZWRWZXJzaW9uIHwgUGxhaW5NZXNzYWdlPFRpbWVkVmVyc2lvbj4gfCB1bmRlZmluZWQsIGI6IFRpbWVkVmVyc2lvbiB8IFBsYWluTWVzc2FnZTxUaW1lZFZlcnNpb24+IHwgdW5kZWZpbmVkKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHByb3RvMy51dGlsLmVxdWFscyhUaW1lZFZlcnNpb24sIGEsIGIpO1xuICB9XG59XG5cbiIsImltcG9ydCB0eXBlIHsgUmVjb25uZWN0Q29udGV4dCwgUmVjb25uZWN0UG9saWN5IH0gZnJvbSAnLi9SZWNvbm5lY3RQb2xpY3knO1xuXG5jb25zdCBtYXhSZXRyeURlbGF5ID0gNzAwMDtcblxuY29uc3QgREVGQVVMVF9SRVRSWV9ERUxBWVNfSU5fTVMgPSBbXG4gIDAsXG4gIDMwMCxcbiAgMiAqIDIgKiAzMDAsXG4gIDMgKiAzICogMzAwLFxuICA0ICogNCAqIDMwMCxcbiAgbWF4UmV0cnlEZWxheSxcbiAgbWF4UmV0cnlEZWxheSxcbiAgbWF4UmV0cnlEZWxheSxcbiAgbWF4UmV0cnlEZWxheSxcbiAgbWF4UmV0cnlEZWxheSxcbl07XG5cbmNsYXNzIERlZmF1bHRSZWNvbm5lY3RQb2xpY3kgaW1wbGVtZW50cyBSZWNvbm5lY3RQb2xpY3kge1xuICBwcml2YXRlIHJlYWRvbmx5IF9yZXRyeURlbGF5czogbnVtYmVyW107XG5cbiAgY29uc3RydWN0b3IocmV0cnlEZWxheXM/OiBudW1iZXJbXSkge1xuICAgIHRoaXMuX3JldHJ5RGVsYXlzID0gcmV0cnlEZWxheXMgIT09IHVuZGVmaW5lZCA/IFsuLi5yZXRyeURlbGF5c10gOiBERUZBVUxUX1JFVFJZX0RFTEFZU19JTl9NUztcbiAgfVxuXG4gIHB1YmxpYyBuZXh0UmV0cnlEZWxheUluTXMoY29udGV4dDogUmVjb25uZWN0Q29udGV4dCk6IG51bWJlciB8IG51bGwge1xuICAgIGlmIChjb250ZXh0LnJldHJ5Q291bnQgPj0gdGhpcy5fcmV0cnlEZWxheXMubGVuZ3RoKSByZXR1cm4gbnVsbDtcblxuICAgIGNvbnN0IHJldHJ5RGVsYXkgPSB0aGlzLl9yZXRyeURlbGF5c1tjb250ZXh0LnJldHJ5Q291bnRdO1xuICAgIGlmIChjb250ZXh0LnJldHJ5Q291bnQgPD0gMSkgcmV0dXJuIHJldHJ5RGVsYXk7XG5cbiAgICByZXR1cm4gcmV0cnlEZWxheSArIE1hdGgucmFuZG9tKCkgKiAxXzAwMDtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBEZWZhdWx0UmVjb25uZWN0UG9saWN5O1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFIgPSB0eXBlb2YgUmVmbGVjdCA9PT0gJ29iamVjdCcgPyBSZWZsZWN0IDogbnVsbFxudmFyIFJlZmxlY3RBcHBseSA9IFIgJiYgdHlwZW9mIFIuYXBwbHkgPT09ICdmdW5jdGlvbidcbiAgPyBSLmFwcGx5XG4gIDogZnVuY3Rpb24gUmVmbGVjdEFwcGx5KHRhcmdldCwgcmVjZWl2ZXIsIGFyZ3MpIHtcbiAgICByZXR1cm4gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwodGFyZ2V0LCByZWNlaXZlciwgYXJncyk7XG4gIH1cblxudmFyIFJlZmxlY3RPd25LZXlzXG5pZiAoUiAmJiB0eXBlb2YgUi5vd25LZXlzID09PSAnZnVuY3Rpb24nKSB7XG4gIFJlZmxlY3RPd25LZXlzID0gUi5vd25LZXlzXG59IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgUmVmbGVjdE93bktleXMgPSBmdW5jdGlvbiBSZWZsZWN0T3duS2V5cyh0YXJnZXQpIHtcbiAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGFyZ2V0KVxuICAgICAgLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHRhcmdldCkpO1xuICB9O1xufSBlbHNlIHtcbiAgUmVmbGVjdE93bktleXMgPSBmdW5jdGlvbiBSZWZsZWN0T3duS2V5cyh0YXJnZXQpIHtcbiAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGFyZ2V0KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gUHJvY2Vzc0VtaXRXYXJuaW5nKHdhcm5pbmcpIHtcbiAgaWYgKGNvbnNvbGUgJiYgY29uc29sZS53YXJuKSBjb25zb2xlLndhcm4od2FybmluZyk7XG59XG5cbnZhciBOdW1iZXJJc05hTiA9IE51bWJlci5pc05hTiB8fCBmdW5jdGlvbiBOdW1iZXJJc05hTih2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT09IHZhbHVlO1xufVxuXG5mdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG4gIEV2ZW50RW1pdHRlci5pbml0LmNhbGwodGhpcyk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50RW1pdHRlcjtcbm1vZHVsZS5leHBvcnRzLm9uY2UgPSBvbmNlO1xuXG4vLyBCYWNrd2FyZHMtY29tcGF0IHdpdGggbm9kZSAwLjEwLnhcbkV2ZW50RW1pdHRlci5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50cyA9IHVuZGVmaW5lZDtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50c0NvdW50ID0gMDtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX21heExpc3RlbmVycyA9IHVuZGVmaW5lZDtcblxuLy8gQnkgZGVmYXVsdCBFdmVudEVtaXR0ZXJzIHdpbGwgcHJpbnQgYSB3YXJuaW5nIGlmIG1vcmUgdGhhbiAxMCBsaXN0ZW5lcnMgYXJlXG4vLyBhZGRlZCB0byBpdC4gVGhpcyBpcyBhIHVzZWZ1bCBkZWZhdWx0IHdoaWNoIGhlbHBzIGZpbmRpbmcgbWVtb3J5IGxlYWtzLlxudmFyIGRlZmF1bHRNYXhMaXN0ZW5lcnMgPSAxMDtcblxuZnVuY3Rpb24gY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcikge1xuICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwibGlzdGVuZXJcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb24uIFJlY2VpdmVkIHR5cGUgJyArIHR5cGVvZiBsaXN0ZW5lcik7XG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50RW1pdHRlciwgJ2RlZmF1bHRNYXhMaXN0ZW5lcnMnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24oYXJnKSB7XG4gICAgaWYgKHR5cGVvZiBhcmcgIT09ICdudW1iZXInIHx8IGFyZyA8IDAgfHwgTnVtYmVySXNOYU4oYXJnKSkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBvZiBcImRlZmF1bHRNYXhMaXN0ZW5lcnNcIiBpcyBvdXQgb2YgcmFuZ2UuIEl0IG11c3QgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyLiBSZWNlaXZlZCAnICsgYXJnICsgJy4nKTtcbiAgICB9XG4gICAgZGVmYXVsdE1heExpc3RlbmVycyA9IGFyZztcbiAgfVxufSk7XG5cbkV2ZW50RW1pdHRlci5pbml0ID0gZnVuY3Rpb24oKSB7XG5cbiAgaWYgKHRoaXMuX2V2ZW50cyA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICB0aGlzLl9ldmVudHMgPT09IE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKS5fZXZlbnRzKSB7XG4gICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gIH1cblxuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSB0aGlzLl9tYXhMaXN0ZW5lcnMgfHwgdW5kZWZpbmVkO1xufTtcblxuLy8gT2J2aW91c2x5IG5vdCBhbGwgRW1pdHRlcnMgc2hvdWxkIGJlIGxpbWl0ZWQgdG8gMTAuIFRoaXMgZnVuY3Rpb24gYWxsb3dzXG4vLyB0aGF0IHRvIGJlIGluY3JlYXNlZC4gU2V0IHRvIHplcm8gZm9yIHVubGltaXRlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuc2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24gc2V0TWF4TGlzdGVuZXJzKG4pIHtcbiAgaWYgKHR5cGVvZiBuICE9PSAnbnVtYmVyJyB8fCBuIDwgMCB8fCBOdW1iZXJJc05hTihuKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgb2YgXCJuXCIgaXMgb3V0IG9mIHJhbmdlLiBJdCBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlci4gUmVjZWl2ZWQgJyArIG4gKyAnLicpO1xuICB9XG4gIHRoaXMuX21heExpc3RlbmVycyA9IG47XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gX2dldE1heExpc3RlbmVycyh0aGF0KSB7XG4gIGlmICh0aGF0Ll9tYXhMaXN0ZW5lcnMgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gIHJldHVybiB0aGF0Ll9tYXhMaXN0ZW5lcnM7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZ2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24gZ2V0TWF4TGlzdGVuZXJzKCkge1xuICByZXR1cm4gX2dldE1heExpc3RlbmVycyh0aGlzKTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uIGVtaXQodHlwZSkge1xuICB2YXIgYXJncyA9IFtdO1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgYXJncy5wdXNoKGFyZ3VtZW50c1tpXSk7XG4gIHZhciBkb0Vycm9yID0gKHR5cGUgPT09ICdlcnJvcicpO1xuXG4gIHZhciBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gIGlmIChldmVudHMgIT09IHVuZGVmaW5lZClcbiAgICBkb0Vycm9yID0gKGRvRXJyb3IgJiYgZXZlbnRzLmVycm9yID09PSB1bmRlZmluZWQpO1xuICBlbHNlIGlmICghZG9FcnJvcilcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgLy8gSWYgdGhlcmUgaXMgbm8gJ2Vycm9yJyBldmVudCBsaXN0ZW5lciB0aGVuIHRocm93LlxuICBpZiAoZG9FcnJvcikge1xuICAgIHZhciBlcjtcbiAgICBpZiAoYXJncy5sZW5ndGggPiAwKVxuICAgICAgZXIgPSBhcmdzWzBdO1xuICAgIGlmIChlciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAvLyBOb3RlOiBUaGUgY29tbWVudHMgb24gdGhlIGB0aHJvd2AgbGluZXMgYXJlIGludGVudGlvbmFsLCB0aGV5IHNob3dcbiAgICAgIC8vIHVwIGluIE5vZGUncyBvdXRwdXQgaWYgdGhpcyByZXN1bHRzIGluIGFuIHVuaGFuZGxlZCBleGNlcHRpb24uXG4gICAgICB0aHJvdyBlcjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgICB9XG4gICAgLy8gQXQgbGVhc3QgZ2l2ZSBzb21lIGtpbmQgb2YgY29udGV4dCB0byB0aGUgdXNlclxuICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ1VuaGFuZGxlZCBlcnJvci4nICsgKGVyID8gJyAoJyArIGVyLm1lc3NhZ2UgKyAnKScgOiAnJykpO1xuICAgIGVyci5jb250ZXh0ID0gZXI7XG4gICAgdGhyb3cgZXJyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICB9XG5cbiAgdmFyIGhhbmRsZXIgPSBldmVudHNbdHlwZV07XG5cbiAgaWYgKGhhbmRsZXIgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKHR5cGVvZiBoYW5kbGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgUmVmbGVjdEFwcGx5KGhhbmRsZXIsIHRoaXMsIGFyZ3MpO1xuICB9IGVsc2Uge1xuICAgIHZhciBsZW4gPSBoYW5kbGVyLmxlbmd0aDtcbiAgICB2YXIgbGlzdGVuZXJzID0gYXJyYXlDbG9uZShoYW5kbGVyLCBsZW4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpXG4gICAgICBSZWZsZWN0QXBwbHkobGlzdGVuZXJzW2ldLCB0aGlzLCBhcmdzKTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuZnVuY3Rpb24gX2FkZExpc3RlbmVyKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIsIHByZXBlbmQpIHtcbiAgdmFyIG07XG4gIHZhciBldmVudHM7XG4gIHZhciBleGlzdGluZztcblxuICBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKTtcblxuICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcbiAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRhcmdldC5fZXZlbnRzQ291bnQgPSAwO1xuICB9IGVsc2Uge1xuICAgIC8vIFRvIGF2b2lkIHJlY3Vyc2lvbiBpbiB0aGUgY2FzZSB0aGF0IHR5cGUgPT09IFwibmV3TGlzdGVuZXJcIiEgQmVmb3JlXG4gICAgLy8gYWRkaW5nIGl0IHRvIHRoZSBsaXN0ZW5lcnMsIGZpcnN0IGVtaXQgXCJuZXdMaXN0ZW5lclwiLlxuICAgIGlmIChldmVudHMubmV3TGlzdGVuZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGFyZ2V0LmVtaXQoJ25ld0xpc3RlbmVyJywgdHlwZSxcbiAgICAgICAgICAgICAgICAgIGxpc3RlbmVyLmxpc3RlbmVyID8gbGlzdGVuZXIubGlzdGVuZXIgOiBsaXN0ZW5lcik7XG5cbiAgICAgIC8vIFJlLWFzc2lnbiBgZXZlbnRzYCBiZWNhdXNlIGEgbmV3TGlzdGVuZXIgaGFuZGxlciBjb3VsZCBoYXZlIGNhdXNlZCB0aGVcbiAgICAgIC8vIHRoaXMuX2V2ZW50cyB0byBiZSBhc3NpZ25lZCB0byBhIG5ldyBvYmplY3RcbiAgICAgIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuICAgIH1cbiAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXTtcbiAgfVxuXG4gIGlmIChleGlzdGluZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gT3B0aW1pemUgdGhlIGNhc2Ugb2Ygb25lIGxpc3RlbmVyLiBEb24ndCBuZWVkIHRoZSBleHRyYSBhcnJheSBvYmplY3QuXG4gICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV0gPSBsaXN0ZW5lcjtcbiAgICArK3RhcmdldC5fZXZlbnRzQ291bnQ7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHR5cGVvZiBleGlzdGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gQWRkaW5nIHRoZSBzZWNvbmQgZWxlbWVudCwgbmVlZCB0byBjaGFuZ2UgdG8gYXJyYXkuXG4gICAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXSA9XG4gICAgICAgIHByZXBlbmQgPyBbbGlzdGVuZXIsIGV4aXN0aW5nXSA6IFtleGlzdGluZywgbGlzdGVuZXJdO1xuICAgICAgLy8gSWYgd2UndmUgYWxyZWFkeSBnb3QgYW4gYXJyYXksIGp1c3QgYXBwZW5kLlxuICAgIH0gZWxzZSBpZiAocHJlcGVuZCkge1xuICAgICAgZXhpc3RpbmcudW5zaGlmdChsaXN0ZW5lcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4aXN0aW5nLnB1c2gobGlzdGVuZXIpO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGZvciBsaXN0ZW5lciBsZWFrXG4gICAgbSA9IF9nZXRNYXhMaXN0ZW5lcnModGFyZ2V0KTtcbiAgICBpZiAobSA+IDAgJiYgZXhpc3RpbmcubGVuZ3RoID4gbSAmJiAhZXhpc3Rpbmcud2FybmVkKSB7XG4gICAgICBleGlzdGluZy53YXJuZWQgPSB0cnVlO1xuICAgICAgLy8gTm8gZXJyb3IgY29kZSBmb3IgdGhpcyBzaW5jZSBpdCBpcyBhIFdhcm5pbmdcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheFxuICAgICAgdmFyIHcgPSBuZXcgRXJyb3IoJ1Bvc3NpYmxlIEV2ZW50RW1pdHRlciBtZW1vcnkgbGVhayBkZXRlY3RlZC4gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nLmxlbmd0aCArICcgJyArIFN0cmluZyh0eXBlKSArICcgbGlzdGVuZXJzICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAnYWRkZWQuIFVzZSBlbWl0dGVyLnNldE1heExpc3RlbmVycygpIHRvICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAnaW5jcmVhc2UgbGltaXQnKTtcbiAgICAgIHcubmFtZSA9ICdNYXhMaXN0ZW5lcnNFeGNlZWRlZFdhcm5pbmcnO1xuICAgICAgdy5lbWl0dGVyID0gdGFyZ2V0O1xuICAgICAgdy50eXBlID0gdHlwZTtcbiAgICAgIHcuY291bnQgPSBleGlzdGluZy5sZW5ndGg7XG4gICAgICBQcm9jZXNzRW1pdFdhcm5pbmcodyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uIGFkZExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHJldHVybiBfYWRkTGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIsIGZhbHNlKTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnByZXBlbmRMaXN0ZW5lciA9XG4gICAgZnVuY3Rpb24gcHJlcGVuZExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICByZXR1cm4gX2FkZExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyLCB0cnVlKTtcbiAgICB9O1xuXG5mdW5jdGlvbiBvbmNlV3JhcHBlcigpIHtcbiAgaWYgKCF0aGlzLmZpcmVkKSB7XG4gICAgdGhpcy50YXJnZXQucmVtb3ZlTGlzdGVuZXIodGhpcy50eXBlLCB0aGlzLndyYXBGbik7XG4gICAgdGhpcy5maXJlZCA9IHRydWU7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApXG4gICAgICByZXR1cm4gdGhpcy5saXN0ZW5lci5jYWxsKHRoaXMudGFyZ2V0KTtcbiAgICByZXR1cm4gdGhpcy5saXN0ZW5lci5hcHBseSh0aGlzLnRhcmdldCwgYXJndW1lbnRzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfb25jZVdyYXAodGFyZ2V0LCB0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgc3RhdGUgPSB7IGZpcmVkOiBmYWxzZSwgd3JhcEZuOiB1bmRlZmluZWQsIHRhcmdldDogdGFyZ2V0LCB0eXBlOiB0eXBlLCBsaXN0ZW5lcjogbGlzdGVuZXIgfTtcbiAgdmFyIHdyYXBwZWQgPSBvbmNlV3JhcHBlci5iaW5kKHN0YXRlKTtcbiAgd3JhcHBlZC5saXN0ZW5lciA9IGxpc3RlbmVyO1xuICBzdGF0ZS53cmFwRm4gPSB3cmFwcGVkO1xuICByZXR1cm4gd3JhcHBlZDtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24gb25jZSh0eXBlLCBsaXN0ZW5lcikge1xuICBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKTtcbiAgdGhpcy5vbih0eXBlLCBfb25jZVdyYXAodGhpcywgdHlwZSwgbGlzdGVuZXIpKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnByZXBlbmRPbmNlTGlzdGVuZXIgPVxuICAgIGZ1bmN0aW9uIHByZXBlbmRPbmNlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpO1xuICAgICAgdGhpcy5wcmVwZW5kTGlzdGVuZXIodHlwZSwgX29uY2VXcmFwKHRoaXMsIHR5cGUsIGxpc3RlbmVyKSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4vLyBFbWl0cyBhICdyZW1vdmVMaXN0ZW5lcicgZXZlbnQgaWYgYW5kIG9ubHkgaWYgdGhlIGxpc3RlbmVyIHdhcyByZW1vdmVkLlxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9XG4gICAgZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIHZhciBsaXN0LCBldmVudHMsIHBvc2l0aW9uLCBpLCBvcmlnaW5hbExpc3RlbmVyO1xuXG4gICAgICBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKTtcblxuICAgICAgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICAgICAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgbGlzdCA9IGV2ZW50c1t0eXBlXTtcbiAgICAgIGlmIChsaXN0ID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICBpZiAobGlzdCA9PT0gbGlzdGVuZXIgfHwgbGlzdC5saXN0ZW5lciA9PT0gbGlzdGVuZXIpIHtcbiAgICAgICAgaWYgKC0tdGhpcy5fZXZlbnRzQ291bnQgPT09IDApXG4gICAgICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgZGVsZXRlIGV2ZW50c1t0eXBlXTtcbiAgICAgICAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3QubGlzdGVuZXIgfHwgbGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBsaXN0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHBvc2l0aW9uID0gLTE7XG5cbiAgICAgICAgZm9yIChpID0gbGlzdC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIGlmIChsaXN0W2ldID09PSBsaXN0ZW5lciB8fCBsaXN0W2ldLmxpc3RlbmVyID09PSBsaXN0ZW5lcikge1xuICAgICAgICAgICAgb3JpZ2luYWxMaXN0ZW5lciA9IGxpc3RbaV0ubGlzdGVuZXI7XG4gICAgICAgICAgICBwb3NpdGlvbiA9IGk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocG9zaXRpb24gPCAwKVxuICAgICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAgIGlmIChwb3NpdGlvbiA9PT0gMClcbiAgICAgICAgICBsaXN0LnNoaWZ0KCk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHNwbGljZU9uZShsaXN0LCBwb3NpdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobGlzdC5sZW5ndGggPT09IDEpXG4gICAgICAgICAgZXZlbnRzW3R5cGVdID0gbGlzdFswXTtcblxuICAgICAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIG9yaWdpbmFsTGlzdGVuZXIgfHwgbGlzdGVuZXIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9mZiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID1cbiAgICBmdW5jdGlvbiByZW1vdmVBbGxMaXN0ZW5lcnModHlwZSkge1xuICAgICAgdmFyIGxpc3RlbmVycywgZXZlbnRzLCBpO1xuXG4gICAgICBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gICAgICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAvLyBub3QgbGlzdGVuaW5nIGZvciByZW1vdmVMaXN0ZW5lciwgbm8gbmVlZCB0byBlbWl0XG4gICAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgICAgICAgfSBlbHNlIGlmIChldmVudHNbdHlwZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmICgtLXRoaXMuX2V2ZW50c0NvdW50ID09PSAwKVxuICAgICAgICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBkZWxldGUgZXZlbnRzW3R5cGVdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICAvLyBlbWl0IHJlbW92ZUxpc3RlbmVyIGZvciBhbGwgbGlzdGVuZXJzIG9uIGFsbCBldmVudHNcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZXZlbnRzKTtcbiAgICAgICAgdmFyIGtleTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgIGlmIChrZXkgPT09ICdyZW1vdmVMaXN0ZW5lcicpIGNvbnRpbnVlO1xuICAgICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ3JlbW92ZUxpc3RlbmVyJyk7XG4gICAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIGxpc3RlbmVycyA9IGV2ZW50c1t0eXBlXTtcblxuICAgICAgaWYgKHR5cGVvZiBsaXN0ZW5lcnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnMpO1xuICAgICAgfSBlbHNlIGlmIChsaXN0ZW5lcnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBMSUZPIG9yZGVyXG4gICAgICAgIGZvciAoaSA9IGxpc3RlbmVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG5mdW5jdGlvbiBfbGlzdGVuZXJzKHRhcmdldCwgdHlwZSwgdW53cmFwKSB7XG4gIHZhciBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcblxuICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIFtdO1xuXG4gIHZhciBldmxpc3RlbmVyID0gZXZlbnRzW3R5cGVdO1xuICBpZiAoZXZsaXN0ZW5lciA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBbXTtcblxuICBpZiAodHlwZW9mIGV2bGlzdGVuZXIgPT09ICdmdW5jdGlvbicpXG4gICAgcmV0dXJuIHVud3JhcCA/IFtldmxpc3RlbmVyLmxpc3RlbmVyIHx8IGV2bGlzdGVuZXJdIDogW2V2bGlzdGVuZXJdO1xuXG4gIHJldHVybiB1bndyYXAgP1xuICAgIHVud3JhcExpc3RlbmVycyhldmxpc3RlbmVyKSA6IGFycmF5Q2xvbmUoZXZsaXN0ZW5lciwgZXZsaXN0ZW5lci5sZW5ndGgpO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uIGxpc3RlbmVycyh0eXBlKSB7XG4gIHJldHVybiBfbGlzdGVuZXJzKHRoaXMsIHR5cGUsIHRydWUpO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yYXdMaXN0ZW5lcnMgPSBmdW5jdGlvbiByYXdMaXN0ZW5lcnModHlwZSkge1xuICByZXR1cm4gX2xpc3RlbmVycyh0aGlzLCB0eXBlLCBmYWxzZSk7XG59O1xuXG5FdmVudEVtaXR0ZXIubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKGVtaXR0ZXIsIHR5cGUpIHtcbiAgaWYgKHR5cGVvZiBlbWl0dGVyLmxpc3RlbmVyQ291bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZW1pdHRlci5saXN0ZW5lckNvdW50KHR5cGUpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBsaXN0ZW5lckNvdW50LmNhbGwoZW1pdHRlciwgdHlwZSk7XG4gIH1cbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJDb3VudCA9IGxpc3RlbmVyQ291bnQ7XG5mdW5jdGlvbiBsaXN0ZW5lckNvdW50KHR5cGUpIHtcbiAgdmFyIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcblxuICBpZiAoZXZlbnRzICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgZXZsaXN0ZW5lciA9IGV2ZW50c1t0eXBlXTtcblxuICAgIGlmICh0eXBlb2YgZXZsaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfSBlbHNlIGlmIChldmxpc3RlbmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBldmxpc3RlbmVyLmxlbmd0aDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gMDtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5ldmVudE5hbWVzID0gZnVuY3Rpb24gZXZlbnROYW1lcygpIHtcbiAgcmV0dXJuIHRoaXMuX2V2ZW50c0NvdW50ID4gMCA/IFJlZmxlY3RPd25LZXlzKHRoaXMuX2V2ZW50cykgOiBbXTtcbn07XG5cbmZ1bmN0aW9uIGFycmF5Q2xvbmUoYXJyLCBuKSB7XG4gIHZhciBjb3B5ID0gbmV3IEFycmF5KG4pO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG47ICsraSlcbiAgICBjb3B5W2ldID0gYXJyW2ldO1xuICByZXR1cm4gY29weTtcbn1cblxuZnVuY3Rpb24gc3BsaWNlT25lKGxpc3QsIGluZGV4KSB7XG4gIGZvciAoOyBpbmRleCArIDEgPCBsaXN0Lmxlbmd0aDsgaW5kZXgrKylcbiAgICBsaXN0W2luZGV4XSA9IGxpc3RbaW5kZXggKyAxXTtcbiAgbGlzdC5wb3AoKTtcbn1cblxuZnVuY3Rpb24gdW53cmFwTGlzdGVuZXJzKGFycikge1xuICB2YXIgcmV0ID0gbmV3IEFycmF5KGFyci5sZW5ndGgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHJldC5sZW5ndGg7ICsraSkge1xuICAgIHJldFtpXSA9IGFycltpXS5saXN0ZW5lciB8fCBhcnJbaV07XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gb25jZShlbWl0dGVyLCBuYW1lKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgZnVuY3Rpb24gZXJyb3JMaXN0ZW5lcihlcnIpIHtcbiAgICAgIGVtaXR0ZXIucmVtb3ZlTGlzdGVuZXIobmFtZSwgcmVzb2x2ZXIpO1xuICAgICAgcmVqZWN0KGVycik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVzb2x2ZXIoKSB7XG4gICAgICBpZiAodHlwZW9mIGVtaXR0ZXIucmVtb3ZlTGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZW1pdHRlci5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBlcnJvckxpc3RlbmVyKTtcbiAgICAgIH1cbiAgICAgIHJlc29sdmUoW10uc2xpY2UuY2FsbChhcmd1bWVudHMpKTtcbiAgICB9O1xuXG4gICAgZXZlbnRUYXJnZXRBZ25vc3RpY0FkZExpc3RlbmVyKGVtaXR0ZXIsIG5hbWUsIHJlc29sdmVyLCB7IG9uY2U6IHRydWUgfSk7XG4gICAgaWYgKG5hbWUgIT09ICdlcnJvcicpIHtcbiAgICAgIGFkZEVycm9ySGFuZGxlcklmRXZlbnRFbWl0dGVyKGVtaXR0ZXIsIGVycm9yTGlzdGVuZXIsIHsgb25jZTogdHJ1ZSB9KTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBhZGRFcnJvckhhbmRsZXJJZkV2ZW50RW1pdHRlcihlbWl0dGVyLCBoYW5kbGVyLCBmbGFncykge1xuICBpZiAodHlwZW9mIGVtaXR0ZXIub24gPT09ICdmdW5jdGlvbicpIHtcbiAgICBldmVudFRhcmdldEFnbm9zdGljQWRkTGlzdGVuZXIoZW1pdHRlciwgJ2Vycm9yJywgaGFuZGxlciwgZmxhZ3MpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGV2ZW50VGFyZ2V0QWdub3N0aWNBZGRMaXN0ZW5lcihlbWl0dGVyLCBuYW1lLCBsaXN0ZW5lciwgZmxhZ3MpIHtcbiAgaWYgKHR5cGVvZiBlbWl0dGVyLm9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaWYgKGZsYWdzLm9uY2UpIHtcbiAgICAgIGVtaXR0ZXIub25jZShuYW1lLCBsaXN0ZW5lcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVtaXR0ZXIub24obmFtZSwgbGlzdGVuZXIpO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgZW1pdHRlci5hZGRFdmVudExpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gRXZlbnRUYXJnZXQgZG9lcyBub3QgaGF2ZSBgZXJyb3JgIGV2ZW50IHNlbWFudGljcyBsaWtlIE5vZGVcbiAgICAvLyBFdmVudEVtaXR0ZXJzLCB3ZSBkbyBub3QgbGlzdGVuIGZvciBgZXJyb3JgIGV2ZW50cyBoZXJlLlxuICAgIGVtaXR0ZXIuYWRkRXZlbnRMaXN0ZW5lcihuYW1lLCBmdW5jdGlvbiB3cmFwTGlzdGVuZXIoYXJnKSB7XG4gICAgICAvLyBJRSBkb2VzIG5vdCBoYXZlIGJ1aWx0aW4gYHsgb25jZTogdHJ1ZSB9YCBzdXBwb3J0IHNvIHdlXG4gICAgICAvLyBoYXZlIHRvIGRvIGl0IG1hbnVhbGx5LlxuICAgICAgaWYgKGZsYWdzLm9uY2UpIHtcbiAgICAgICAgZW1pdHRlci5yZW1vdmVFdmVudExpc3RlbmVyKG5hbWUsIHdyYXBMaXN0ZW5lcik7XG4gICAgICB9XG4gICAgICBsaXN0ZW5lcihhcmcpO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcImVtaXR0ZXJcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRXZlbnRFbWl0dGVyLiBSZWNlaXZlZCB0eXBlICcgKyB0eXBlb2YgZW1pdHRlcik7XG4gIH1cbn1cbiIsIi8qXG4gKiAgQ29weXJpZ2h0IChjKSAyMDE2IFRoZSBXZWJSVEMgcHJvamVjdCBhdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqICBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhIEJTRC1zdHlsZSBsaWNlbnNlXG4gKiAgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBvZiB0aGUgc291cmNlXG4gKiAgdHJlZS5cbiAqL1xuLyogZXNsaW50LWVudiBub2RlICovXG4ndXNlIHN0cmljdCc7XG5cbmxldCBsb2dEaXNhYmxlZF8gPSB0cnVlO1xubGV0IGRlcHJlY2F0aW9uV2FybmluZ3NfID0gdHJ1ZTtcblxuLyoqXG4gKiBFeHRyYWN0IGJyb3dzZXIgdmVyc2lvbiBvdXQgb2YgdGhlIHByb3ZpZGVkIHVzZXIgYWdlbnQgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7IXN0cmluZ30gdWFzdHJpbmcgdXNlckFnZW50IHN0cmluZy5cbiAqIEBwYXJhbSB7IXN0cmluZ30gZXhwciBSZWd1bGFyIGV4cHJlc3Npb24gdXNlZCBhcyBtYXRjaCBjcml0ZXJpYS5cbiAqIEBwYXJhbSB7IW51bWJlcn0gcG9zIHBvc2l0aW9uIGluIHRoZSB2ZXJzaW9uIHN0cmluZyB0byBiZSByZXR1cm5lZC5cbiAqIEByZXR1cm4geyFudW1iZXJ9IGJyb3dzZXIgdmVyc2lvbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGV4dHJhY3RWZXJzaW9uKHVhc3RyaW5nLCBleHByLCBwb3MpIHtcbiAgY29uc3QgbWF0Y2ggPSB1YXN0cmluZy5tYXRjaChleHByKTtcbiAgcmV0dXJuIG1hdGNoICYmIG1hdGNoLmxlbmd0aCA+PSBwb3MgJiYgcGFyc2VJbnQobWF0Y2hbcG9zXSwgMTApO1xufVxuXG4vLyBXcmFwcyB0aGUgcGVlcmNvbm5lY3Rpb24gZXZlbnQgZXZlbnROYW1lVG9XcmFwIGluIGEgZnVuY3Rpb25cbi8vIHdoaWNoIHJldHVybnMgdGhlIG1vZGlmaWVkIGV2ZW50IG9iamVjdCAob3IgZmFsc2UgdG8gcHJldmVudFxuLy8gdGhlIGV2ZW50KS5cbmV4cG9ydCBmdW5jdGlvbiB3cmFwUGVlckNvbm5lY3Rpb25FdmVudCh3aW5kb3csIGV2ZW50TmFtZVRvV3JhcCwgd3JhcHBlcikge1xuICBpZiAoIXdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbikge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBwcm90byA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGU7XG4gIGNvbnN0IG5hdGl2ZUFkZEV2ZW50TGlzdGVuZXIgPSBwcm90by5hZGRFdmVudExpc3RlbmVyO1xuICBwcm90by5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24obmF0aXZlRXZlbnROYW1lLCBjYikge1xuICAgIGlmIChuYXRpdmVFdmVudE5hbWUgIT09IGV2ZW50TmFtZVRvV3JhcCkge1xuICAgICAgcmV0dXJuIG5hdGl2ZUFkZEV2ZW50TGlzdGVuZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgY29uc3Qgd3JhcHBlZENhbGxiYWNrID0gKGUpID0+IHtcbiAgICAgIGNvbnN0IG1vZGlmaWVkRXZlbnQgPSB3cmFwcGVyKGUpO1xuICAgICAgaWYgKG1vZGlmaWVkRXZlbnQpIHtcbiAgICAgICAgaWYgKGNiLmhhbmRsZUV2ZW50KSB7XG4gICAgICAgICAgY2IuaGFuZGxlRXZlbnQobW9kaWZpZWRFdmVudCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2IobW9kaWZpZWRFdmVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuX2V2ZW50TWFwID0gdGhpcy5fZXZlbnRNYXAgfHwge307XG4gICAgaWYgKCF0aGlzLl9ldmVudE1hcFtldmVudE5hbWVUb1dyYXBdKSB7XG4gICAgICB0aGlzLl9ldmVudE1hcFtldmVudE5hbWVUb1dyYXBdID0gbmV3IE1hcCgpO1xuICAgIH1cbiAgICB0aGlzLl9ldmVudE1hcFtldmVudE5hbWVUb1dyYXBdLnNldChjYiwgd3JhcHBlZENhbGxiYWNrKTtcbiAgICByZXR1cm4gbmF0aXZlQWRkRXZlbnRMaXN0ZW5lci5hcHBseSh0aGlzLCBbbmF0aXZlRXZlbnROYW1lLFxuICAgICAgd3JhcHBlZENhbGxiYWNrXSk7XG4gIH07XG5cbiAgY29uc3QgbmF0aXZlUmVtb3ZlRXZlbnRMaXN0ZW5lciA9IHByb3RvLnJlbW92ZUV2ZW50TGlzdGVuZXI7XG4gIHByb3RvLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbihuYXRpdmVFdmVudE5hbWUsIGNiKSB7XG4gICAgaWYgKG5hdGl2ZUV2ZW50TmFtZSAhPT0gZXZlbnROYW1lVG9XcmFwIHx8ICF0aGlzLl9ldmVudE1hcFxuICAgICAgICB8fCAhdGhpcy5fZXZlbnRNYXBbZXZlbnROYW1lVG9XcmFwXSkge1xuICAgICAgcmV0dXJuIG5hdGl2ZVJlbW92ZUV2ZW50TGlzdGVuZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLl9ldmVudE1hcFtldmVudE5hbWVUb1dyYXBdLmhhcyhjYikpIHtcbiAgICAgIHJldHVybiBuYXRpdmVSZW1vdmVFdmVudExpc3RlbmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIGNvbnN0IHVud3JhcHBlZENiID0gdGhpcy5fZXZlbnRNYXBbZXZlbnROYW1lVG9XcmFwXS5nZXQoY2IpO1xuICAgIHRoaXMuX2V2ZW50TWFwW2V2ZW50TmFtZVRvV3JhcF0uZGVsZXRlKGNiKTtcbiAgICBpZiAodGhpcy5fZXZlbnRNYXBbZXZlbnROYW1lVG9XcmFwXS5zaXplID09PSAwKSB7XG4gICAgICBkZWxldGUgdGhpcy5fZXZlbnRNYXBbZXZlbnROYW1lVG9XcmFwXTtcbiAgICB9XG4gICAgaWYgKE9iamVjdC5rZXlzKHRoaXMuX2V2ZW50TWFwKS5sZW5ndGggPT09IDApIHtcbiAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudE1hcDtcbiAgICB9XG4gICAgcmV0dXJuIG5hdGl2ZVJlbW92ZUV2ZW50TGlzdGVuZXIuYXBwbHkodGhpcywgW25hdGl2ZUV2ZW50TmFtZSxcbiAgICAgIHVud3JhcHBlZENiXSk7XG4gIH07XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3RvLCAnb24nICsgZXZlbnROYW1lVG9XcmFwLCB7XG4gICAgZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXNbJ19vbicgKyBldmVudE5hbWVUb1dyYXBdO1xuICAgIH0sXG4gICAgc2V0KGNiKSB7XG4gICAgICBpZiAodGhpc1snX29uJyArIGV2ZW50TmFtZVRvV3JhcF0pIHtcbiAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50TmFtZVRvV3JhcCxcbiAgICAgICAgICB0aGlzWydfb24nICsgZXZlbnROYW1lVG9XcmFwXSk7XG4gICAgICAgIGRlbGV0ZSB0aGlzWydfb24nICsgZXZlbnROYW1lVG9XcmFwXTtcbiAgICAgIH1cbiAgICAgIGlmIChjYikge1xuICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lVG9XcmFwLFxuICAgICAgICAgIHRoaXNbJ19vbicgKyBldmVudE5hbWVUb1dyYXBdID0gY2IpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkaXNhYmxlTG9nKGJvb2wpIHtcbiAgaWYgKHR5cGVvZiBib29sICE9PSAnYm9vbGVhbicpIHtcbiAgICByZXR1cm4gbmV3IEVycm9yKCdBcmd1bWVudCB0eXBlOiAnICsgdHlwZW9mIGJvb2wgK1xuICAgICAgICAnLiBQbGVhc2UgdXNlIGEgYm9vbGVhbi4nKTtcbiAgfVxuICBsb2dEaXNhYmxlZF8gPSBib29sO1xuICByZXR1cm4gKGJvb2wpID8gJ2FkYXB0ZXIuanMgbG9nZ2luZyBkaXNhYmxlZCcgOlxuICAgICdhZGFwdGVyLmpzIGxvZ2dpbmcgZW5hYmxlZCc7XG59XG5cbi8qKlxuICogRGlzYWJsZSBvciBlbmFibGUgZGVwcmVjYXRpb24gd2FybmluZ3NcbiAqIEBwYXJhbSB7IWJvb2xlYW59IGJvb2wgc2V0IHRvIHRydWUgdG8gZGlzYWJsZSB3YXJuaW5ncy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRpc2FibGVXYXJuaW5ncyhib29sKSB7XG4gIGlmICh0eXBlb2YgYm9vbCAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgcmV0dXJuIG5ldyBFcnJvcignQXJndW1lbnQgdHlwZTogJyArIHR5cGVvZiBib29sICtcbiAgICAgICAgJy4gUGxlYXNlIHVzZSBhIGJvb2xlYW4uJyk7XG4gIH1cbiAgZGVwcmVjYXRpb25XYXJuaW5nc18gPSAhYm9vbDtcbiAgcmV0dXJuICdhZGFwdGVyLmpzIGRlcHJlY2F0aW9uIHdhcm5pbmdzICcgKyAoYm9vbCA/ICdkaXNhYmxlZCcgOiAnZW5hYmxlZCcpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbG9nKCkge1xuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcpIHtcbiAgICBpZiAobG9nRGlzYWJsZWRfKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGNvbnNvbGUubG9nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjb25zb2xlLmxvZy5hcHBseShjb25zb2xlLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFNob3dzIGEgZGVwcmVjYXRpb24gd2FybmluZyBzdWdnZXN0aW5nIHRoZSBtb2Rlcm4gYW5kIHNwZWMtY29tcGF0aWJsZSBBUEkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZXByZWNhdGVkKG9sZE1ldGhvZCwgbmV3TWV0aG9kKSB7XG4gIGlmICghZGVwcmVjYXRpb25XYXJuaW5nc18pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc29sZS53YXJuKG9sZE1ldGhvZCArICcgaXMgZGVwcmVjYXRlZCwgcGxlYXNlIHVzZSAnICsgbmV3TWV0aG9kICtcbiAgICAgICcgaW5zdGVhZC4nKTtcbn1cblxuLyoqXG4gKiBCcm93c2VyIGRldGVjdG9yLlxuICpcbiAqIEByZXR1cm4ge29iamVjdH0gcmVzdWx0IGNvbnRhaW5pbmcgYnJvd3NlciBhbmQgdmVyc2lvblxuICogICAgIHByb3BlcnRpZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZXRlY3RCcm93c2VyKHdpbmRvdykge1xuICAvLyBSZXR1cm5lZCByZXN1bHQgb2JqZWN0LlxuICBjb25zdCByZXN1bHQgPSB7YnJvd3NlcjogbnVsbCwgdmVyc2lvbjogbnVsbH07XG5cbiAgLy8gRmFpbCBlYXJseSBpZiBpdCdzIG5vdCBhIGJyb3dzZXJcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnIHx8ICF3aW5kb3cubmF2aWdhdG9yIHx8XG4gICAgICAhd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQpIHtcbiAgICByZXN1bHQuYnJvd3NlciA9ICdOb3QgYSBicm93c2VyLic7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGNvbnN0IHtuYXZpZ2F0b3J9ID0gd2luZG93O1xuXG4gIGlmIChuYXZpZ2F0b3IubW96R2V0VXNlck1lZGlhKSB7IC8vIEZpcmVmb3guXG4gICAgcmVzdWx0LmJyb3dzZXIgPSAnZmlyZWZveCc7XG4gICAgcmVzdWx0LnZlcnNpb24gPSBleHRyYWN0VmVyc2lvbihuYXZpZ2F0b3IudXNlckFnZW50LFxuICAgICAgL0ZpcmVmb3hcXC8oXFxkKylcXC4vLCAxKTtcbiAgfSBlbHNlIGlmIChuYXZpZ2F0b3Iud2Via2l0R2V0VXNlck1lZGlhIHx8XG4gICAgICAod2luZG93LmlzU2VjdXJlQ29udGV4dCA9PT0gZmFsc2UgJiYgd2luZG93LndlYmtpdFJUQ1BlZXJDb25uZWN0aW9uKSkge1xuICAgIC8vIENocm9tZSwgQ2hyb21pdW0sIFdlYnZpZXcsIE9wZXJhLlxuICAgIC8vIFZlcnNpb24gbWF0Y2hlcyBDaHJvbWUvV2ViUlRDIHZlcnNpb24uXG4gICAgLy8gQ2hyb21lIDc0IHJlbW92ZWQgd2Via2l0R2V0VXNlck1lZGlhIG9uIGh0dHAgYXMgd2VsbCBzbyB3ZSBuZWVkIHRoZVxuICAgIC8vIG1vcmUgY29tcGxpY2F0ZWQgZmFsbGJhY2sgdG8gd2Via2l0UlRDUGVlckNvbm5lY3Rpb24uXG4gICAgcmVzdWx0LmJyb3dzZXIgPSAnY2hyb21lJztcbiAgICByZXN1bHQudmVyc2lvbiA9IGV4dHJhY3RWZXJzaW9uKG5hdmlnYXRvci51c2VyQWdlbnQsXG4gICAgICAvQ2hyb20oZXxpdW0pXFwvKFxcZCspXFwuLywgMik7XG4gIH0gZWxzZSBpZiAod2luZG93LlJUQ1BlZXJDb25uZWN0aW9uICYmXG4gICAgICBuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9BcHBsZVdlYktpdFxcLyhcXGQrKVxcLi8pKSB7IC8vIFNhZmFyaS5cbiAgICByZXN1bHQuYnJvd3NlciA9ICdzYWZhcmknO1xuICAgIHJlc3VsdC52ZXJzaW9uID0gZXh0cmFjdFZlcnNpb24obmF2aWdhdG9yLnVzZXJBZ2VudCxcbiAgICAgIC9BcHBsZVdlYktpdFxcLyhcXGQrKVxcLi8sIDEpO1xuICAgIHJlc3VsdC5zdXBwb3J0c1VuaWZpZWRQbGFuID0gd2luZG93LlJUQ1J0cFRyYW5zY2VpdmVyICYmXG4gICAgICAgICdjdXJyZW50RGlyZWN0aW9uJyBpbiB3aW5kb3cuUlRDUnRwVHJhbnNjZWl2ZXIucHJvdG90eXBlO1xuICB9IGVsc2UgeyAvLyBEZWZhdWx0IGZhbGx0aHJvdWdoOiBub3Qgc3VwcG9ydGVkLlxuICAgIHJlc3VsdC5icm93c2VyID0gJ05vdCBhIHN1cHBvcnRlZCBicm93c2VyLic7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIHNvbWV0aGluZyBpcyBhbiBvYmplY3QuXG4gKlxuICogQHBhcmFtIHsqfSB2YWwgVGhlIHNvbWV0aGluZyB5b3Ugd2FudCB0byBjaGVjay5cbiAqIEByZXR1cm4gdHJ1ZSBpZiB2YWwgaXMgYW4gb2JqZWN0LCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IE9iamVjdF0nO1xufVxuXG4vKipcbiAqIFJlbW92ZSBhbGwgZW1wdHkgb2JqZWN0cyBhbmQgdW5kZWZpbmVkIHZhbHVlc1xuICogZnJvbSBhIG5lc3RlZCBvYmplY3QgLS0gYW4gZW5oYW5jZWQgYW5kIHZhbmlsbGEgdmVyc2lvblxuICogb2YgTG9kYXNoJ3MgYGNvbXBhY3RgLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY29tcGFjdE9iamVjdChkYXRhKSB7XG4gIGlmICghaXNPYmplY3QoZGF0YSkpIHtcbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuXG4gIHJldHVybiBPYmplY3Qua2V5cyhkYXRhKS5yZWR1Y2UoZnVuY3Rpb24oYWNjdW11bGF0b3IsIGtleSkge1xuICAgIGNvbnN0IGlzT2JqID0gaXNPYmplY3QoZGF0YVtrZXldKTtcbiAgICBjb25zdCB2YWx1ZSA9IGlzT2JqID8gY29tcGFjdE9iamVjdChkYXRhW2tleV0pIDogZGF0YVtrZXldO1xuICAgIGNvbnN0IGlzRW1wdHlPYmplY3QgPSBpc09iaiAmJiAhT2JqZWN0LmtleXModmFsdWUpLmxlbmd0aDtcbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCB8fCBpc0VtcHR5T2JqZWN0KSB7XG4gICAgICByZXR1cm4gYWNjdW11bGF0b3I7XG4gICAgfVxuICAgIHJldHVybiBPYmplY3QuYXNzaWduKGFjY3VtdWxhdG9yLCB7W2tleV06IHZhbHVlfSk7XG4gIH0sIHt9KTtcbn1cblxuLyogaXRlcmF0ZXMgdGhlIHN0YXRzIGdyYXBoIHJlY3Vyc2l2ZWx5LiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHdhbGtTdGF0cyhzdGF0cywgYmFzZSwgcmVzdWx0U2V0KSB7XG4gIGlmICghYmFzZSB8fCByZXN1bHRTZXQuaGFzKGJhc2UuaWQpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHJlc3VsdFNldC5zZXQoYmFzZS5pZCwgYmFzZSk7XG4gIE9iamVjdC5rZXlzKGJhc2UpLmZvckVhY2gobmFtZSA9PiB7XG4gICAgaWYgKG5hbWUuZW5kc1dpdGgoJ0lkJykpIHtcbiAgICAgIHdhbGtTdGF0cyhzdGF0cywgc3RhdHMuZ2V0KGJhc2VbbmFtZV0pLCByZXN1bHRTZXQpO1xuICAgIH0gZWxzZSBpZiAobmFtZS5lbmRzV2l0aCgnSWRzJykpIHtcbiAgICAgIGJhc2VbbmFtZV0uZm9yRWFjaChpZCA9PiB7XG4gICAgICAgIHdhbGtTdGF0cyhzdGF0cywgc3RhdHMuZ2V0KGlkKSwgcmVzdWx0U2V0KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG59XG5cbi8qIGZpbHRlciBnZXRTdGF0cyBmb3IgYSBzZW5kZXIvcmVjZWl2ZXIgdHJhY2suICovXG5leHBvcnQgZnVuY3Rpb24gZmlsdGVyU3RhdHMocmVzdWx0LCB0cmFjaywgb3V0Ym91bmQpIHtcbiAgY29uc3Qgc3RyZWFtU3RhdHNUeXBlID0gb3V0Ym91bmQgPyAnb3V0Ym91bmQtcnRwJyA6ICdpbmJvdW5kLXJ0cCc7XG4gIGNvbnN0IGZpbHRlcmVkUmVzdWx0ID0gbmV3IE1hcCgpO1xuICBpZiAodHJhY2sgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmlsdGVyZWRSZXN1bHQ7XG4gIH1cbiAgY29uc3QgdHJhY2tTdGF0cyA9IFtdO1xuICByZXN1bHQuZm9yRWFjaCh2YWx1ZSA9PiB7XG4gICAgaWYgKHZhbHVlLnR5cGUgPT09ICd0cmFjaycgJiZcbiAgICAgICAgdmFsdWUudHJhY2tJZGVudGlmaWVyID09PSB0cmFjay5pZCkge1xuICAgICAgdHJhY2tTdGF0cy5wdXNoKHZhbHVlKTtcbiAgICB9XG4gIH0pO1xuICB0cmFja1N0YXRzLmZvckVhY2godHJhY2tTdGF0ID0+IHtcbiAgICByZXN1bHQuZm9yRWFjaChzdGF0cyA9PiB7XG4gICAgICBpZiAoc3RhdHMudHlwZSA9PT0gc3RyZWFtU3RhdHNUeXBlICYmIHN0YXRzLnRyYWNrSWQgPT09IHRyYWNrU3RhdC5pZCkge1xuICAgICAgICB3YWxrU3RhdHMocmVzdWx0LCBzdGF0cywgZmlsdGVyZWRSZXN1bHQpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbiAgcmV0dXJuIGZpbHRlcmVkUmVzdWx0O1xufVxuXG4iLCIvKlxuICogIENvcHlyaWdodCAoYykgMjAxNiBUaGUgV2ViUlRDIHByb2plY3QgYXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiAgVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYSBCU0Qtc3R5bGUgbGljZW5zZVxuICogIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3Qgb2YgdGhlIHNvdXJjZVxuICogIHRyZWUuXG4gKi9cbi8qIGVzbGludC1lbnYgbm9kZSAqL1xuJ3VzZSBzdHJpY3QnO1xuaW1wb3J0ICogYXMgdXRpbHMgZnJvbSAnLi4vdXRpbHMuanMnO1xuY29uc3QgbG9nZ2luZyA9IHV0aWxzLmxvZztcblxuZXhwb3J0IGZ1bmN0aW9uIHNoaW1HZXRVc2VyTWVkaWEod2luZG93LCBicm93c2VyRGV0YWlscykge1xuICBjb25zdCBuYXZpZ2F0b3IgPSB3aW5kb3cgJiYgd2luZG93Lm5hdmlnYXRvcjtcblxuICBpZiAoIW5hdmlnYXRvci5tZWRpYURldmljZXMpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBjb25zdHJhaW50c1RvQ2hyb21lXyA9IGZ1bmN0aW9uKGMpIHtcbiAgICBpZiAodHlwZW9mIGMgIT09ICdvYmplY3QnIHx8IGMubWFuZGF0b3J5IHx8IGMub3B0aW9uYWwpIHtcbiAgICAgIHJldHVybiBjO1xuICAgIH1cbiAgICBjb25zdCBjYyA9IHt9O1xuICAgIE9iamVjdC5rZXlzKGMpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgIGlmIChrZXkgPT09ICdyZXF1aXJlJyB8fCBrZXkgPT09ICdhZHZhbmNlZCcgfHwga2V5ID09PSAnbWVkaWFTb3VyY2UnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHIgPSAodHlwZW9mIGNba2V5XSA9PT0gJ29iamVjdCcpID8gY1trZXldIDoge2lkZWFsOiBjW2tleV19O1xuICAgICAgaWYgKHIuZXhhY3QgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygci5leGFjdCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgci5taW4gPSByLm1heCA9IHIuZXhhY3Q7XG4gICAgICB9XG4gICAgICBjb25zdCBvbGRuYW1lXyA9IGZ1bmN0aW9uKHByZWZpeCwgbmFtZSkge1xuICAgICAgICBpZiAocHJlZml4KSB7XG4gICAgICAgICAgcmV0dXJuIHByZWZpeCArIG5hbWUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBuYW1lLnNsaWNlKDEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAobmFtZSA9PT0gJ2RldmljZUlkJykgPyAnc291cmNlSWQnIDogbmFtZTtcbiAgICAgIH07XG4gICAgICBpZiAoci5pZGVhbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNjLm9wdGlvbmFsID0gY2Mub3B0aW9uYWwgfHwgW107XG4gICAgICAgIGxldCBvYyA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHIuaWRlYWwgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgb2Nbb2xkbmFtZV8oJ21pbicsIGtleSldID0gci5pZGVhbDtcbiAgICAgICAgICBjYy5vcHRpb25hbC5wdXNoKG9jKTtcbiAgICAgICAgICBvYyA9IHt9O1xuICAgICAgICAgIG9jW29sZG5hbWVfKCdtYXgnLCBrZXkpXSA9IHIuaWRlYWw7XG4gICAgICAgICAgY2Mub3B0aW9uYWwucHVzaChvYyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb2Nbb2xkbmFtZV8oJycsIGtleSldID0gci5pZGVhbDtcbiAgICAgICAgICBjYy5vcHRpb25hbC5wdXNoKG9jKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHIuZXhhY3QgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygci5leGFjdCAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgY2MubWFuZGF0b3J5ID0gY2MubWFuZGF0b3J5IHx8IHt9O1xuICAgICAgICBjYy5tYW5kYXRvcnlbb2xkbmFtZV8oJycsIGtleSldID0gci5leGFjdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIFsnbWluJywgJ21heCddLmZvckVhY2gobWl4ID0+IHtcbiAgICAgICAgICBpZiAoclttaXhdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNjLm1hbmRhdG9yeSA9IGNjLm1hbmRhdG9yeSB8fCB7fTtcbiAgICAgICAgICAgIGNjLm1hbmRhdG9yeVtvbGRuYW1lXyhtaXgsIGtleSldID0gclttaXhdO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKGMuYWR2YW5jZWQpIHtcbiAgICAgIGNjLm9wdGlvbmFsID0gKGNjLm9wdGlvbmFsIHx8IFtdKS5jb25jYXQoYy5hZHZhbmNlZCk7XG4gICAgfVxuICAgIHJldHVybiBjYztcbiAgfTtcblxuICBjb25zdCBzaGltQ29uc3RyYWludHNfID0gZnVuY3Rpb24oY29uc3RyYWludHMsIGZ1bmMpIHtcbiAgICBpZiAoYnJvd3NlckRldGFpbHMudmVyc2lvbiA+PSA2MSkge1xuICAgICAgcmV0dXJuIGZ1bmMoY29uc3RyYWludHMpO1xuICAgIH1cbiAgICBjb25zdHJhaW50cyA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoY29uc3RyYWludHMpKTtcbiAgICBpZiAoY29uc3RyYWludHMgJiYgdHlwZW9mIGNvbnN0cmFpbnRzLmF1ZGlvID09PSAnb2JqZWN0Jykge1xuICAgICAgY29uc3QgcmVtYXAgPSBmdW5jdGlvbihvYmosIGEsIGIpIHtcbiAgICAgICAgaWYgKGEgaW4gb2JqICYmICEoYiBpbiBvYmopKSB7XG4gICAgICAgICAgb2JqW2JdID0gb2JqW2FdO1xuICAgICAgICAgIGRlbGV0ZSBvYmpbYV07XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBjb25zdHJhaW50cyA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoY29uc3RyYWludHMpKTtcbiAgICAgIHJlbWFwKGNvbnN0cmFpbnRzLmF1ZGlvLCAnYXV0b0dhaW5Db250cm9sJywgJ2dvb2dBdXRvR2FpbkNvbnRyb2wnKTtcbiAgICAgIHJlbWFwKGNvbnN0cmFpbnRzLmF1ZGlvLCAnbm9pc2VTdXBwcmVzc2lvbicsICdnb29nTm9pc2VTdXBwcmVzc2lvbicpO1xuICAgICAgY29uc3RyYWludHMuYXVkaW8gPSBjb25zdHJhaW50c1RvQ2hyb21lXyhjb25zdHJhaW50cy5hdWRpbyk7XG4gICAgfVxuICAgIGlmIChjb25zdHJhaW50cyAmJiB0eXBlb2YgY29uc3RyYWludHMudmlkZW8gPT09ICdvYmplY3QnKSB7XG4gICAgICAvLyBTaGltIGZhY2luZ01vZGUgZm9yIG1vYmlsZSAmIHN1cmZhY2UgcHJvLlxuICAgICAgbGV0IGZhY2UgPSBjb25zdHJhaW50cy52aWRlby5mYWNpbmdNb2RlO1xuICAgICAgZmFjZSA9IGZhY2UgJiYgKCh0eXBlb2YgZmFjZSA9PT0gJ29iamVjdCcpID8gZmFjZSA6IHtpZGVhbDogZmFjZX0pO1xuICAgICAgY29uc3QgZ2V0U3VwcG9ydGVkRmFjaW5nTW9kZUxpZXMgPSBicm93c2VyRGV0YWlscy52ZXJzaW9uIDwgNjY7XG5cbiAgICAgIGlmICgoZmFjZSAmJiAoZmFjZS5leGFjdCA9PT0gJ3VzZXInIHx8IGZhY2UuZXhhY3QgPT09ICdlbnZpcm9ubWVudCcgfHxcbiAgICAgICAgICAgICAgICAgICAgZmFjZS5pZGVhbCA9PT0gJ3VzZXInIHx8IGZhY2UuaWRlYWwgPT09ICdlbnZpcm9ubWVudCcpKSAmJlxuICAgICAgICAgICEobmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRTdXBwb3J0ZWRDb25zdHJhaW50cyAmJlxuICAgICAgICAgICAgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRTdXBwb3J0ZWRDb25zdHJhaW50cygpLmZhY2luZ01vZGUgJiZcbiAgICAgICAgICAgICFnZXRTdXBwb3J0ZWRGYWNpbmdNb2RlTGllcykpIHtcbiAgICAgICAgZGVsZXRlIGNvbnN0cmFpbnRzLnZpZGVvLmZhY2luZ01vZGU7XG4gICAgICAgIGxldCBtYXRjaGVzO1xuICAgICAgICBpZiAoZmFjZS5leGFjdCA9PT0gJ2Vudmlyb25tZW50JyB8fCBmYWNlLmlkZWFsID09PSAnZW52aXJvbm1lbnQnKSB7XG4gICAgICAgICAgbWF0Y2hlcyA9IFsnYmFjaycsICdyZWFyJ107XG4gICAgICAgIH0gZWxzZSBpZiAoZmFjZS5leGFjdCA9PT0gJ3VzZXInIHx8IGZhY2UuaWRlYWwgPT09ICd1c2VyJykge1xuICAgICAgICAgIG1hdGNoZXMgPSBbJ2Zyb250J107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1hdGNoZXMpIHtcbiAgICAgICAgICAvLyBMb29rIGZvciBtYXRjaGVzIGluIGxhYmVsLCBvciB1c2UgbGFzdCBjYW0gZm9yIGJhY2sgKHR5cGljYWwpLlxuICAgICAgICAgIHJldHVybiBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmVudW1lcmF0ZURldmljZXMoKVxuICAgICAgICAgICAgLnRoZW4oZGV2aWNlcyA9PiB7XG4gICAgICAgICAgICAgIGRldmljZXMgPSBkZXZpY2VzLmZpbHRlcihkID0+IGQua2luZCA9PT0gJ3ZpZGVvaW5wdXQnKTtcbiAgICAgICAgICAgICAgbGV0IGRldiA9IGRldmljZXMuZmluZChkID0+IG1hdGNoZXMuc29tZShtYXRjaCA9PlxuICAgICAgICAgICAgICAgIGQubGFiZWwudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhtYXRjaCkpKTtcbiAgICAgICAgICAgICAgaWYgKCFkZXYgJiYgZGV2aWNlcy5sZW5ndGggJiYgbWF0Y2hlcy5pbmNsdWRlcygnYmFjaycpKSB7XG4gICAgICAgICAgICAgICAgZGV2ID0gZGV2aWNlc1tkZXZpY2VzLmxlbmd0aCAtIDFdOyAvLyBtb3JlIGxpa2VseSB0aGUgYmFjayBjYW1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoZGV2KSB7XG4gICAgICAgICAgICAgICAgY29uc3RyYWludHMudmlkZW8uZGV2aWNlSWQgPSBmYWNlLmV4YWN0XG4gICAgICAgICAgICAgICAgICA/IHtleGFjdDogZGV2LmRldmljZUlkfVxuICAgICAgICAgICAgICAgICAgOiB7aWRlYWw6IGRldi5kZXZpY2VJZH07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29uc3RyYWludHMudmlkZW8gPSBjb25zdHJhaW50c1RvQ2hyb21lXyhjb25zdHJhaW50cy52aWRlbyk7XG4gICAgICAgICAgICAgIGxvZ2dpbmcoJ2Nocm9tZTogJyArIEpTT04uc3RyaW5naWZ5KGNvbnN0cmFpbnRzKSk7XG4gICAgICAgICAgICAgIHJldHVybiBmdW5jKGNvbnN0cmFpbnRzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdHJhaW50cy52aWRlbyA9IGNvbnN0cmFpbnRzVG9DaHJvbWVfKGNvbnN0cmFpbnRzLnZpZGVvKTtcbiAgICB9XG4gICAgbG9nZ2luZygnY2hyb21lOiAnICsgSlNPTi5zdHJpbmdpZnkoY29uc3RyYWludHMpKTtcbiAgICByZXR1cm4gZnVuYyhjb25zdHJhaW50cyk7XG4gIH07XG5cbiAgY29uc3Qgc2hpbUVycm9yXyA9IGZ1bmN0aW9uKGUpIHtcbiAgICBpZiAoYnJvd3NlckRldGFpbHMudmVyc2lvbiA+PSA2NCkge1xuICAgICAgcmV0dXJuIGU7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiB7XG4gICAgICAgIFBlcm1pc3Npb25EZW5pZWRFcnJvcjogJ05vdEFsbG93ZWRFcnJvcicsXG4gICAgICAgIFBlcm1pc3Npb25EaXNtaXNzZWRFcnJvcjogJ05vdEFsbG93ZWRFcnJvcicsXG4gICAgICAgIEludmFsaWRTdGF0ZUVycm9yOiAnTm90QWxsb3dlZEVycm9yJyxcbiAgICAgICAgRGV2aWNlc05vdEZvdW5kRXJyb3I6ICdOb3RGb3VuZEVycm9yJyxcbiAgICAgICAgQ29uc3RyYWludE5vdFNhdGlzZmllZEVycm9yOiAnT3ZlcmNvbnN0cmFpbmVkRXJyb3InLFxuICAgICAgICBUcmFja1N0YXJ0RXJyb3I6ICdOb3RSZWFkYWJsZUVycm9yJyxcbiAgICAgICAgTWVkaWFEZXZpY2VGYWlsZWREdWVUb1NodXRkb3duOiAnTm90QWxsb3dlZEVycm9yJyxcbiAgICAgICAgTWVkaWFEZXZpY2VLaWxsU3dpdGNoT246ICdOb3RBbGxvd2VkRXJyb3InLFxuICAgICAgICBUYWJDYXB0dXJlRXJyb3I6ICdBYm9ydEVycm9yJyxcbiAgICAgICAgU2NyZWVuQ2FwdHVyZUVycm9yOiAnQWJvcnRFcnJvcicsXG4gICAgICAgIERldmljZUNhcHR1cmVFcnJvcjogJ0Fib3J0RXJyb3InXG4gICAgICB9W2UubmFtZV0gfHwgZS5uYW1lLFxuICAgICAgbWVzc2FnZTogZS5tZXNzYWdlLFxuICAgICAgY29uc3RyYWludDogZS5jb25zdHJhaW50IHx8IGUuY29uc3RyYWludE5hbWUsXG4gICAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmFtZSArICh0aGlzLm1lc3NhZ2UgJiYgJzogJykgKyB0aGlzLm1lc3NhZ2U7XG4gICAgICB9XG4gICAgfTtcbiAgfTtcblxuICBjb25zdCBnZXRVc2VyTWVkaWFfID0gZnVuY3Rpb24oY29uc3RyYWludHMsIG9uU3VjY2Vzcywgb25FcnJvcikge1xuICAgIHNoaW1Db25zdHJhaW50c18oY29uc3RyYWludHMsIGMgPT4ge1xuICAgICAgbmF2aWdhdG9yLndlYmtpdEdldFVzZXJNZWRpYShjLCBvblN1Y2Nlc3MsIGUgPT4ge1xuICAgICAgICBpZiAob25FcnJvcikge1xuICAgICAgICAgIG9uRXJyb3Ioc2hpbUVycm9yXyhlKSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuICBuYXZpZ2F0b3IuZ2V0VXNlck1lZGlhID0gZ2V0VXNlck1lZGlhXy5iaW5kKG5hdmlnYXRvcik7XG5cbiAgLy8gRXZlbiB0aG91Z2ggQ2hyb21lIDQ1IGhhcyBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzIGFuZCBhIGdldFVzZXJNZWRpYVxuICAvLyBmdW5jdGlvbiB3aGljaCByZXR1cm5zIGEgUHJvbWlzZSwgaXQgZG9lcyBub3QgYWNjZXB0IHNwZWMtc3R5bGVcbiAgLy8gY29uc3RyYWludHMuXG4gIGlmIChuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYSkge1xuICAgIGNvbnN0IG9yaWdHZXRVc2VyTWVkaWEgPSBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYS5cbiAgICAgIGJpbmQobmF2aWdhdG9yLm1lZGlhRGV2aWNlcyk7XG4gICAgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEgPSBmdW5jdGlvbihjcykge1xuICAgICAgcmV0dXJuIHNoaW1Db25zdHJhaW50c18oY3MsIGMgPT4gb3JpZ0dldFVzZXJNZWRpYShjKS50aGVuKHN0cmVhbSA9PiB7XG4gICAgICAgIGlmIChjLmF1ZGlvICYmICFzdHJlYW0uZ2V0QXVkaW9UcmFja3MoKS5sZW5ndGggfHxcbiAgICAgICAgICAgIGMudmlkZW8gJiYgIXN0cmVhbS5nZXRWaWRlb1RyYWNrcygpLmxlbmd0aCkge1xuICAgICAgICAgIHN0cmVhbS5nZXRUcmFja3MoKS5mb3JFYWNoKHRyYWNrID0+IHtcbiAgICAgICAgICAgIHRyYWNrLnN0b3AoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKCcnLCAnTm90Rm91bmRFcnJvcicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHJlYW07XG4gICAgICB9LCBlID0+IFByb21pc2UucmVqZWN0KHNoaW1FcnJvcl8oZSkpKSk7XG4gICAgfTtcbiAgfVxufVxuIiwiLypcbiAqICBDb3B5cmlnaHQgKGMpIDIwMTggVGhlIGFkYXB0ZXIuanMgcHJvamVjdCBhdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqICBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhIEJTRC1zdHlsZSBsaWNlbnNlXG4gKiAgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBvZiB0aGUgc291cmNlXG4gKiAgdHJlZS5cbiAqL1xuLyogZXNsaW50LWVudiBub2RlICovXG4ndXNlIHN0cmljdCc7XG5leHBvcnQgZnVuY3Rpb24gc2hpbUdldERpc3BsYXlNZWRpYSh3aW5kb3csIGdldFNvdXJjZUlkKSB7XG4gIGlmICh3aW5kb3cubmF2aWdhdG9yLm1lZGlhRGV2aWNlcyAmJlxuICAgICdnZXREaXNwbGF5TWVkaWEnIGluIHdpbmRvdy5uYXZpZ2F0b3IubWVkaWFEZXZpY2VzKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICghKHdpbmRvdy5uYXZpZ2F0b3IubWVkaWFEZXZpY2VzKSkge1xuICAgIHJldHVybjtcbiAgfVxuICAvLyBnZXRTb3VyY2VJZCBpcyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIHByb21pc2UgcmVzb2x2aW5nIHdpdGhcbiAgLy8gdGhlIHNvdXJjZUlkIG9mIHRoZSBzY3JlZW4vd2luZG93L3RhYiB0byBiZSBzaGFyZWQuXG4gIGlmICh0eXBlb2YgZ2V0U291cmNlSWQgIT09ICdmdW5jdGlvbicpIHtcbiAgICBjb25zb2xlLmVycm9yKCdzaGltR2V0RGlzcGxheU1lZGlhOiBnZXRTb3VyY2VJZCBhcmd1bWVudCBpcyBub3QgJyArXG4gICAgICAgICdhIGZ1bmN0aW9uJyk7XG4gICAgcmV0dXJuO1xuICB9XG4gIHdpbmRvdy5uYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldERpc3BsYXlNZWRpYSA9XG4gICAgZnVuY3Rpb24gZ2V0RGlzcGxheU1lZGlhKGNvbnN0cmFpbnRzKSB7XG4gICAgICByZXR1cm4gZ2V0U291cmNlSWQoY29uc3RyYWludHMpXG4gICAgICAgIC50aGVuKHNvdXJjZUlkID0+IHtcbiAgICAgICAgICBjb25zdCB3aWR0aFNwZWNpZmllZCA9IGNvbnN0cmFpbnRzLnZpZGVvICYmIGNvbnN0cmFpbnRzLnZpZGVvLndpZHRoO1xuICAgICAgICAgIGNvbnN0IGhlaWdodFNwZWNpZmllZCA9IGNvbnN0cmFpbnRzLnZpZGVvICYmXG4gICAgICAgICAgICBjb25zdHJhaW50cy52aWRlby5oZWlnaHQ7XG4gICAgICAgICAgY29uc3QgZnJhbWVSYXRlU3BlY2lmaWVkID0gY29uc3RyYWludHMudmlkZW8gJiZcbiAgICAgICAgICAgIGNvbnN0cmFpbnRzLnZpZGVvLmZyYW1lUmF0ZTtcbiAgICAgICAgICBjb25zdHJhaW50cy52aWRlbyA9IHtcbiAgICAgICAgICAgIG1hbmRhdG9yeToge1xuICAgICAgICAgICAgICBjaHJvbWVNZWRpYVNvdXJjZTogJ2Rlc2t0b3AnLFxuICAgICAgICAgICAgICBjaHJvbWVNZWRpYVNvdXJjZUlkOiBzb3VyY2VJZCxcbiAgICAgICAgICAgICAgbWF4RnJhbWVSYXRlOiBmcmFtZVJhdGVTcGVjaWZpZWQgfHwgM1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgICAgaWYgKHdpZHRoU3BlY2lmaWVkKSB7XG4gICAgICAgICAgICBjb25zdHJhaW50cy52aWRlby5tYW5kYXRvcnkubWF4V2lkdGggPSB3aWR0aFNwZWNpZmllZDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGhlaWdodFNwZWNpZmllZCkge1xuICAgICAgICAgICAgY29uc3RyYWludHMudmlkZW8ubWFuZGF0b3J5Lm1heEhlaWdodCA9IGhlaWdodFNwZWNpZmllZDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHdpbmRvdy5uYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYShjb25zdHJhaW50cyk7XG4gICAgICAgIH0pO1xuICAgIH07XG59XG4iLCIvKlxuICogIENvcHlyaWdodCAoYykgMjAxNiBUaGUgV2ViUlRDIHByb2plY3QgYXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiAgVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYSBCU0Qtc3R5bGUgbGljZW5zZVxuICogIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3Qgb2YgdGhlIHNvdXJjZVxuICogIHRyZWUuXG4gKi9cbi8qIGVzbGludC1lbnYgbm9kZSAqL1xuJ3VzZSBzdHJpY3QnO1xuaW1wb3J0ICogYXMgdXRpbHMgZnJvbSAnLi4vdXRpbHMuanMnO1xuXG5leHBvcnQge3NoaW1HZXRVc2VyTWVkaWF9IGZyb20gJy4vZ2V0dXNlcm1lZGlhJztcbmV4cG9ydCB7c2hpbUdldERpc3BsYXlNZWRpYX0gZnJvbSAnLi9nZXRkaXNwbGF5bWVkaWEnO1xuXG5leHBvcnQgZnVuY3Rpb24gc2hpbU1lZGlhU3RyZWFtKHdpbmRvdykge1xuICB3aW5kb3cuTWVkaWFTdHJlYW0gPSB3aW5kb3cuTWVkaWFTdHJlYW0gfHwgd2luZG93LndlYmtpdE1lZGlhU3RyZWFtO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2hpbU9uVHJhY2sod2luZG93KSB7XG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0JyAmJiB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24gJiYgISgnb250cmFjaycgaW5cbiAgICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUpKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUsICdvbnRyYWNrJywge1xuICAgICAgZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fb250cmFjaztcbiAgICAgIH0sXG4gICAgICBzZXQoZikge1xuICAgICAgICBpZiAodGhpcy5fb250cmFjaykge1xuICAgICAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcigndHJhY2snLCB0aGlzLl9vbnRyYWNrKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ3RyYWNrJywgdGhpcy5fb250cmFjayA9IGYpO1xuICAgICAgfSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBjb25zdCBvcmlnU2V0UmVtb3RlRGVzY3JpcHRpb24gPVxuICAgICAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLnNldFJlbW90ZURlc2NyaXB0aW9uO1xuICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuc2V0UmVtb3RlRGVzY3JpcHRpb24gPVxuICAgICAgZnVuY3Rpb24gc2V0UmVtb3RlRGVzY3JpcHRpb24oKSB7XG4gICAgICAgIGlmICghdGhpcy5fb250cmFja3BvbHkpIHtcbiAgICAgICAgICB0aGlzLl9vbnRyYWNrcG9seSA9IChlKSA9PiB7XG4gICAgICAgICAgICAvLyBvbmFkZHN0cmVhbSBkb2VzIG5vdCBmaXJlIHdoZW4gYSB0cmFjayBpcyBhZGRlZCB0byBhbiBleGlzdGluZ1xuICAgICAgICAgICAgLy8gc3RyZWFtLiBCdXQgc3RyZWFtLm9uYWRkdHJhY2sgaXMgaW1wbGVtZW50ZWQgc28gd2UgdXNlIHRoYXQuXG4gICAgICAgICAgICBlLnN0cmVhbS5hZGRFdmVudExpc3RlbmVyKCdhZGR0cmFjaycsIHRlID0+IHtcbiAgICAgICAgICAgICAgbGV0IHJlY2VpdmVyO1xuICAgICAgICAgICAgICBpZiAod2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5nZXRSZWNlaXZlcnMpIHtcbiAgICAgICAgICAgICAgICByZWNlaXZlciA9IHRoaXMuZ2V0UmVjZWl2ZXJzKClcbiAgICAgICAgICAgICAgICAgIC5maW5kKHIgPT4gci50cmFjayAmJiByLnRyYWNrLmlkID09PSB0ZS50cmFjay5pZCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVjZWl2ZXIgPSB7dHJhY2s6IHRlLnRyYWNrfTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGNvbnN0IGV2ZW50ID0gbmV3IEV2ZW50KCd0cmFjaycpO1xuICAgICAgICAgICAgICBldmVudC50cmFjayA9IHRlLnRyYWNrO1xuICAgICAgICAgICAgICBldmVudC5yZWNlaXZlciA9IHJlY2VpdmVyO1xuICAgICAgICAgICAgICBldmVudC50cmFuc2NlaXZlciA9IHtyZWNlaXZlcn07XG4gICAgICAgICAgICAgIGV2ZW50LnN0cmVhbXMgPSBbZS5zdHJlYW1dO1xuICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBlLnN0cmVhbS5nZXRUcmFja3MoKS5mb3JFYWNoKHRyYWNrID0+IHtcbiAgICAgICAgICAgICAgbGV0IHJlY2VpdmVyO1xuICAgICAgICAgICAgICBpZiAod2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5nZXRSZWNlaXZlcnMpIHtcbiAgICAgICAgICAgICAgICByZWNlaXZlciA9IHRoaXMuZ2V0UmVjZWl2ZXJzKClcbiAgICAgICAgICAgICAgICAgIC5maW5kKHIgPT4gci50cmFjayAmJiByLnRyYWNrLmlkID09PSB0cmFjay5pZCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVjZWl2ZXIgPSB7dHJhY2t9O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbnN0IGV2ZW50ID0gbmV3IEV2ZW50KCd0cmFjaycpO1xuICAgICAgICAgICAgICBldmVudC50cmFjayA9IHRyYWNrO1xuICAgICAgICAgICAgICBldmVudC5yZWNlaXZlciA9IHJlY2VpdmVyO1xuICAgICAgICAgICAgICBldmVudC50cmFuc2NlaXZlciA9IHtyZWNlaXZlcn07XG4gICAgICAgICAgICAgIGV2ZW50LnN0cmVhbXMgPSBbZS5zdHJlYW1dO1xuICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2FkZHN0cmVhbScsIHRoaXMuX29udHJhY2twb2x5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3JpZ1NldFJlbW90ZURlc2NyaXB0aW9uLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuICB9IGVsc2Uge1xuICAgIC8vIGV2ZW4gaWYgUlRDUnRwVHJhbnNjZWl2ZXIgaXMgaW4gd2luZG93LCBpdCBpcyBvbmx5IHVzZWQgYW5kXG4gICAgLy8gZW1pdHRlZCBpbiB1bmlmaWVkLXBsYW4uIFVuZm9ydHVuYXRlbHkgdGhpcyBtZWFucyB3ZSBuZWVkXG4gICAgLy8gdG8gdW5jb25kaXRpb25hbGx5IHdyYXAgdGhlIGV2ZW50LlxuICAgIHV0aWxzLndyYXBQZWVyQ29ubmVjdGlvbkV2ZW50KHdpbmRvdywgJ3RyYWNrJywgZSA9PiB7XG4gICAgICBpZiAoIWUudHJhbnNjZWl2ZXIpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsICd0cmFuc2NlaXZlcicsXG4gICAgICAgICAge3ZhbHVlOiB7cmVjZWl2ZXI6IGUucmVjZWl2ZXJ9fSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZTtcbiAgICB9KTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gc2hpbUdldFNlbmRlcnNXaXRoRHRtZih3aW5kb3cpIHtcbiAgLy8gT3ZlcnJpZGVzIGFkZFRyYWNrL3JlbW92ZVRyYWNrLCBkZXBlbmRzIG9uIHNoaW1BZGRUcmFja1JlbW92ZVRyYWNrLlxuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcgJiYgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uICYmXG4gICAgICAhKCdnZXRTZW5kZXJzJyBpbiB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlKSAmJlxuICAgICAgJ2NyZWF0ZURUTUZTZW5kZXInIGluIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUpIHtcbiAgICBjb25zdCBzaGltU2VuZGVyV2l0aER0bWYgPSBmdW5jdGlvbihwYywgdHJhY2spIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRyYWNrLFxuICAgICAgICBnZXQgZHRtZigpIHtcbiAgICAgICAgICBpZiAodGhpcy5fZHRtZiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAodHJhY2sua2luZCA9PT0gJ2F1ZGlvJykge1xuICAgICAgICAgICAgICB0aGlzLl9kdG1mID0gcGMuY3JlYXRlRFRNRlNlbmRlcih0cmFjayk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLl9kdG1mID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2R0bWY7XG4gICAgICAgIH0sXG4gICAgICAgIF9wYzogcGNcbiAgICAgIH07XG4gICAgfTtcblxuICAgIC8vIGF1Z21lbnQgYWRkVHJhY2sgd2hlbiBnZXRTZW5kZXJzIGlzIG5vdCBhdmFpbGFibGUuXG4gICAgaWYgKCF3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmdldFNlbmRlcnMpIHtcbiAgICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuZ2V0U2VuZGVycyA9IGZ1bmN0aW9uIGdldFNlbmRlcnMoKSB7XG4gICAgICAgIHRoaXMuX3NlbmRlcnMgPSB0aGlzLl9zZW5kZXJzIHx8IFtdO1xuICAgICAgICByZXR1cm4gdGhpcy5fc2VuZGVycy5zbGljZSgpOyAvLyByZXR1cm4gYSBjb3B5IG9mIHRoZSBpbnRlcm5hbCBzdGF0ZS5cbiAgICAgIH07XG4gICAgICBjb25zdCBvcmlnQWRkVHJhY2sgPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmFkZFRyYWNrO1xuICAgICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5hZGRUcmFjayA9XG4gICAgICAgIGZ1bmN0aW9uIGFkZFRyYWNrKHRyYWNrLCBzdHJlYW0pIHtcbiAgICAgICAgICBsZXQgc2VuZGVyID0gb3JpZ0FkZFRyYWNrLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgaWYgKCFzZW5kZXIpIHtcbiAgICAgICAgICAgIHNlbmRlciA9IHNoaW1TZW5kZXJXaXRoRHRtZih0aGlzLCB0cmFjayk7XG4gICAgICAgICAgICB0aGlzLl9zZW5kZXJzLnB1c2goc2VuZGVyKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHNlbmRlcjtcbiAgICAgICAgfTtcblxuICAgICAgY29uc3Qgb3JpZ1JlbW92ZVRyYWNrID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5yZW1vdmVUcmFjaztcbiAgICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUucmVtb3ZlVHJhY2sgPVxuICAgICAgICBmdW5jdGlvbiByZW1vdmVUcmFjayhzZW5kZXIpIHtcbiAgICAgICAgICBvcmlnUmVtb3ZlVHJhY2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICBjb25zdCBpZHggPSB0aGlzLl9zZW5kZXJzLmluZGV4T2Yoc2VuZGVyKTtcbiAgICAgICAgICBpZiAoaWR4ICE9PSAtMSkge1xuICAgICAgICAgICAgdGhpcy5fc2VuZGVycy5zcGxpY2UoaWR4LCAxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IG9yaWdBZGRTdHJlYW0gPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmFkZFN0cmVhbTtcbiAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmFkZFN0cmVhbSA9IGZ1bmN0aW9uIGFkZFN0cmVhbShzdHJlYW0pIHtcbiAgICAgIHRoaXMuX3NlbmRlcnMgPSB0aGlzLl9zZW5kZXJzIHx8IFtdO1xuICAgICAgb3JpZ0FkZFN0cmVhbS5hcHBseSh0aGlzLCBbc3RyZWFtXSk7XG4gICAgICBzdHJlYW0uZ2V0VHJhY2tzKCkuZm9yRWFjaCh0cmFjayA9PiB7XG4gICAgICAgIHRoaXMuX3NlbmRlcnMucHVzaChzaGltU2VuZGVyV2l0aER0bWYodGhpcywgdHJhY2spKTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBjb25zdCBvcmlnUmVtb3ZlU3RyZWFtID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5yZW1vdmVTdHJlYW07XG4gICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5yZW1vdmVTdHJlYW0gPVxuICAgICAgZnVuY3Rpb24gcmVtb3ZlU3RyZWFtKHN0cmVhbSkge1xuICAgICAgICB0aGlzLl9zZW5kZXJzID0gdGhpcy5fc2VuZGVycyB8fCBbXTtcbiAgICAgICAgb3JpZ1JlbW92ZVN0cmVhbS5hcHBseSh0aGlzLCBbc3RyZWFtXSk7XG5cbiAgICAgICAgc3RyZWFtLmdldFRyYWNrcygpLmZvckVhY2godHJhY2sgPT4ge1xuICAgICAgICAgIGNvbnN0IHNlbmRlciA9IHRoaXMuX3NlbmRlcnMuZmluZChzID0+IHMudHJhY2sgPT09IHRyYWNrKTtcbiAgICAgICAgICBpZiAoc2VuZGVyKSB7IC8vIHJlbW92ZSBzZW5kZXJcbiAgICAgICAgICAgIHRoaXMuX3NlbmRlcnMuc3BsaWNlKHRoaXMuX3NlbmRlcnMuaW5kZXhPZihzZW5kZXIpLCAxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgfSBlbHNlIGlmICh0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0JyAmJiB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24gJiZcbiAgICAgICAgICAgICAnZ2V0U2VuZGVycycgaW4gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZSAmJlxuICAgICAgICAgICAgICdjcmVhdGVEVE1GU2VuZGVyJyBpbiB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlICYmXG4gICAgICAgICAgICAgd2luZG93LlJUQ1J0cFNlbmRlciAmJlxuICAgICAgICAgICAgICEoJ2R0bWYnIGluIHdpbmRvdy5SVENSdHBTZW5kZXIucHJvdG90eXBlKSkge1xuICAgIGNvbnN0IG9yaWdHZXRTZW5kZXJzID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5nZXRTZW5kZXJzO1xuICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuZ2V0U2VuZGVycyA9IGZ1bmN0aW9uIGdldFNlbmRlcnMoKSB7XG4gICAgICBjb25zdCBzZW5kZXJzID0gb3JpZ0dldFNlbmRlcnMuYXBwbHkodGhpcywgW10pO1xuICAgICAgc2VuZGVycy5mb3JFYWNoKHNlbmRlciA9PiBzZW5kZXIuX3BjID0gdGhpcyk7XG4gICAgICByZXR1cm4gc2VuZGVycztcbiAgICB9O1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHdpbmRvdy5SVENSdHBTZW5kZXIucHJvdG90eXBlLCAnZHRtZicsIHtcbiAgICAgIGdldCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2R0bWYgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmICh0aGlzLnRyYWNrLmtpbmQgPT09ICdhdWRpbycpIHtcbiAgICAgICAgICAgIHRoaXMuX2R0bWYgPSB0aGlzLl9wYy5jcmVhdGVEVE1GU2VuZGVyKHRoaXMudHJhY2spO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9kdG1mID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2R0bWY7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNoaW1HZXRTdGF0cyh3aW5kb3cpIHtcbiAgaWYgKCF3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24pIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBvcmlnR2V0U3RhdHMgPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmdldFN0YXRzO1xuICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmdldFN0YXRzID0gZnVuY3Rpb24gZ2V0U3RhdHMoKSB7XG4gICAgY29uc3QgW3NlbGVjdG9yLCBvblN1Y2MsIG9uRXJyXSA9IGFyZ3VtZW50cztcblxuICAgIC8vIElmIHNlbGVjdG9yIGlzIGEgZnVuY3Rpb24gdGhlbiB3ZSBhcmUgaW4gdGhlIG9sZCBzdHlsZSBzdGF0cyBzbyBqdXN0XG4gICAgLy8gcGFzcyBiYWNrIHRoZSBvcmlnaW5hbCBnZXRTdGF0cyBmb3JtYXQgdG8gYXZvaWQgYnJlYWtpbmcgb2xkIHVzZXJzLlxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCAmJiB0eXBlb2Ygc2VsZWN0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBvcmlnR2V0U3RhdHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICAvLyBXaGVuIHNwZWMtc3R5bGUgZ2V0U3RhdHMgaXMgc3VwcG9ydGVkLCByZXR1cm4gdGhvc2Ugd2hlbiBjYWxsZWQgd2l0aFxuICAgIC8vIGVpdGhlciBubyBhcmd1bWVudHMgb3IgdGhlIHNlbGVjdG9yIGFyZ3VtZW50IGlzIG51bGwuXG4gICAgaWYgKG9yaWdHZXRTdGF0cy5sZW5ndGggPT09IDAgJiYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDAgfHxcbiAgICAgICAgdHlwZW9mIHNlbGVjdG9yICE9PSAnZnVuY3Rpb24nKSkge1xuICAgICAgcmV0dXJuIG9yaWdHZXRTdGF0cy5hcHBseSh0aGlzLCBbXSk7XG4gICAgfVxuXG4gICAgY29uc3QgZml4Q2hyb21lU3RhdHNfID0gZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgIGNvbnN0IHN0YW5kYXJkUmVwb3J0ID0ge307XG4gICAgICBjb25zdCByZXBvcnRzID0gcmVzcG9uc2UucmVzdWx0KCk7XG4gICAgICByZXBvcnRzLmZvckVhY2gocmVwb3J0ID0+IHtcbiAgICAgICAgY29uc3Qgc3RhbmRhcmRTdGF0cyA9IHtcbiAgICAgICAgICBpZDogcmVwb3J0LmlkLFxuICAgICAgICAgIHRpbWVzdGFtcDogcmVwb3J0LnRpbWVzdGFtcCxcbiAgICAgICAgICB0eXBlOiB7XG4gICAgICAgICAgICBsb2NhbGNhbmRpZGF0ZTogJ2xvY2FsLWNhbmRpZGF0ZScsXG4gICAgICAgICAgICByZW1vdGVjYW5kaWRhdGU6ICdyZW1vdGUtY2FuZGlkYXRlJ1xuICAgICAgICAgIH1bcmVwb3J0LnR5cGVdIHx8IHJlcG9ydC50eXBlXG4gICAgICAgIH07XG4gICAgICAgIHJlcG9ydC5uYW1lcygpLmZvckVhY2gobmFtZSA9PiB7XG4gICAgICAgICAgc3RhbmRhcmRTdGF0c1tuYW1lXSA9IHJlcG9ydC5zdGF0KG5hbWUpO1xuICAgICAgICB9KTtcbiAgICAgICAgc3RhbmRhcmRSZXBvcnRbc3RhbmRhcmRTdGF0cy5pZF0gPSBzdGFuZGFyZFN0YXRzO1xuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBzdGFuZGFyZFJlcG9ydDtcbiAgICB9O1xuXG4gICAgLy8gc2hpbSBnZXRTdGF0cyB3aXRoIG1hcGxpa2Ugc3VwcG9ydFxuICAgIGNvbnN0IG1ha2VNYXBTdGF0cyA9IGZ1bmN0aW9uKHN0YXRzKSB7XG4gICAgICByZXR1cm4gbmV3IE1hcChPYmplY3Qua2V5cyhzdGF0cykubWFwKGtleSA9PiBba2V5LCBzdGF0c1trZXldXSkpO1xuICAgIH07XG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSAyKSB7XG4gICAgICBjb25zdCBzdWNjZXNzQ2FsbGJhY2tXcmFwcGVyXyA9IGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICAgIG9uU3VjYyhtYWtlTWFwU3RhdHMoZml4Q2hyb21lU3RhdHNfKHJlc3BvbnNlKSkpO1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIG9yaWdHZXRTdGF0cy5hcHBseSh0aGlzLCBbc3VjY2Vzc0NhbGxiYWNrV3JhcHBlcl8sXG4gICAgICAgIHNlbGVjdG9yXSk7XG4gICAgfVxuXG4gICAgLy8gcHJvbWlzZS1zdXBwb3J0XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIG9yaWdHZXRTdGF0cy5hcHBseSh0aGlzLCBbXG4gICAgICAgIGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICAgICAgcmVzb2x2ZShtYWtlTWFwU3RhdHMoZml4Q2hyb21lU3RhdHNfKHJlc3BvbnNlKSkpO1xuICAgICAgICB9LCByZWplY3RdKTtcbiAgICB9KS50aGVuKG9uU3VjYywgb25FcnIpO1xuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2hpbVNlbmRlclJlY2VpdmVyR2V0U3RhdHMod2luZG93KSB7XG4gIGlmICghKHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnICYmIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbiAmJlxuICAgICAgd2luZG93LlJUQ1J0cFNlbmRlciAmJiB3aW5kb3cuUlRDUnRwUmVjZWl2ZXIpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gc2hpbSBzZW5kZXIgc3RhdHMuXG4gIGlmICghKCdnZXRTdGF0cycgaW4gd2luZG93LlJUQ1J0cFNlbmRlci5wcm90b3R5cGUpKSB7XG4gICAgY29uc3Qgb3JpZ0dldFNlbmRlcnMgPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmdldFNlbmRlcnM7XG4gICAgaWYgKG9yaWdHZXRTZW5kZXJzKSB7XG4gICAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmdldFNlbmRlcnMgPSBmdW5jdGlvbiBnZXRTZW5kZXJzKCkge1xuICAgICAgICBjb25zdCBzZW5kZXJzID0gb3JpZ0dldFNlbmRlcnMuYXBwbHkodGhpcywgW10pO1xuICAgICAgICBzZW5kZXJzLmZvckVhY2goc2VuZGVyID0+IHNlbmRlci5fcGMgPSB0aGlzKTtcbiAgICAgICAgcmV0dXJuIHNlbmRlcnM7XG4gICAgICB9O1xuICAgIH1cblxuICAgIGNvbnN0IG9yaWdBZGRUcmFjayA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuYWRkVHJhY2s7XG4gICAgaWYgKG9yaWdBZGRUcmFjaykge1xuICAgICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5hZGRUcmFjayA9IGZ1bmN0aW9uIGFkZFRyYWNrKCkge1xuICAgICAgICBjb25zdCBzZW5kZXIgPSBvcmlnQWRkVHJhY2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgc2VuZGVyLl9wYyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBzZW5kZXI7XG4gICAgICB9O1xuICAgIH1cbiAgICB3aW5kb3cuUlRDUnRwU2VuZGVyLnByb3RvdHlwZS5nZXRTdGF0cyA9IGZ1bmN0aW9uIGdldFN0YXRzKCkge1xuICAgICAgY29uc3Qgc2VuZGVyID0gdGhpcztcbiAgICAgIHJldHVybiB0aGlzLl9wYy5nZXRTdGF0cygpLnRoZW4ocmVzdWx0ID0+XG4gICAgICAgIC8qIE5vdGU6IHRoaXMgd2lsbCBpbmNsdWRlIHN0YXRzIG9mIGFsbCBzZW5kZXJzIHRoYXRcbiAgICAgICAgICogICBzZW5kIGEgdHJhY2sgd2l0aCB0aGUgc2FtZSBpZCBhcyBzZW5kZXIudHJhY2sgYXNcbiAgICAgICAgICogICBpdCBpcyBub3QgcG9zc2libGUgdG8gaWRlbnRpZnkgdGhlIFJUQ1J0cFNlbmRlci5cbiAgICAgICAgICovXG4gICAgICAgIHV0aWxzLmZpbHRlclN0YXRzKHJlc3VsdCwgc2VuZGVyLnRyYWNrLCB0cnVlKSk7XG4gICAgfTtcbiAgfVxuXG4gIC8vIHNoaW0gcmVjZWl2ZXIgc3RhdHMuXG4gIGlmICghKCdnZXRTdGF0cycgaW4gd2luZG93LlJUQ1J0cFJlY2VpdmVyLnByb3RvdHlwZSkpIHtcbiAgICBjb25zdCBvcmlnR2V0UmVjZWl2ZXJzID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5nZXRSZWNlaXZlcnM7XG4gICAgaWYgKG9yaWdHZXRSZWNlaXZlcnMpIHtcbiAgICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuZ2V0UmVjZWl2ZXJzID1cbiAgICAgICAgZnVuY3Rpb24gZ2V0UmVjZWl2ZXJzKCkge1xuICAgICAgICAgIGNvbnN0IHJlY2VpdmVycyA9IG9yaWdHZXRSZWNlaXZlcnMuYXBwbHkodGhpcywgW10pO1xuICAgICAgICAgIHJlY2VpdmVycy5mb3JFYWNoKHJlY2VpdmVyID0+IHJlY2VpdmVyLl9wYyA9IHRoaXMpO1xuICAgICAgICAgIHJldHVybiByZWNlaXZlcnM7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHV0aWxzLndyYXBQZWVyQ29ubmVjdGlvbkV2ZW50KHdpbmRvdywgJ3RyYWNrJywgZSA9PiB7XG4gICAgICBlLnJlY2VpdmVyLl9wYyA9IGUuc3JjRWxlbWVudDtcbiAgICAgIHJldHVybiBlO1xuICAgIH0pO1xuICAgIHdpbmRvdy5SVENSdHBSZWNlaXZlci5wcm90b3R5cGUuZ2V0U3RhdHMgPSBmdW5jdGlvbiBnZXRTdGF0cygpIHtcbiAgICAgIGNvbnN0IHJlY2VpdmVyID0gdGhpcztcbiAgICAgIHJldHVybiB0aGlzLl9wYy5nZXRTdGF0cygpLnRoZW4ocmVzdWx0ID0+XG4gICAgICAgIHV0aWxzLmZpbHRlclN0YXRzKHJlc3VsdCwgcmVjZWl2ZXIudHJhY2ssIGZhbHNlKSk7XG4gICAgfTtcbiAgfVxuXG4gIGlmICghKCdnZXRTdGF0cycgaW4gd2luZG93LlJUQ1J0cFNlbmRlci5wcm90b3R5cGUgJiZcbiAgICAgICdnZXRTdGF0cycgaW4gd2luZG93LlJUQ1J0cFJlY2VpdmVyLnByb3RvdHlwZSkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBzaGltIFJUQ1BlZXJDb25uZWN0aW9uLmdldFN0YXRzKHRyYWNrKS5cbiAgY29uc3Qgb3JpZ0dldFN0YXRzID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5nZXRTdGF0cztcbiAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5nZXRTdGF0cyA9IGZ1bmN0aW9uIGdldFN0YXRzKCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCAmJlxuICAgICAgICBhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiB3aW5kb3cuTWVkaWFTdHJlYW1UcmFjaykge1xuICAgICAgY29uc3QgdHJhY2sgPSBhcmd1bWVudHNbMF07XG4gICAgICBsZXQgc2VuZGVyO1xuICAgICAgbGV0IHJlY2VpdmVyO1xuICAgICAgbGV0IGVycjtcbiAgICAgIHRoaXMuZ2V0U2VuZGVycygpLmZvckVhY2gocyA9PiB7XG4gICAgICAgIGlmIChzLnRyYWNrID09PSB0cmFjaykge1xuICAgICAgICAgIGlmIChzZW5kZXIpIHtcbiAgICAgICAgICAgIGVyciA9IHRydWU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNlbmRlciA9IHM7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHRoaXMuZ2V0UmVjZWl2ZXJzKCkuZm9yRWFjaChyID0+IHtcbiAgICAgICAgaWYgKHIudHJhY2sgPT09IHRyYWNrKSB7XG4gICAgICAgICAgaWYgKHJlY2VpdmVyKSB7XG4gICAgICAgICAgICBlcnIgPSB0cnVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZWNlaXZlciA9IHI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByLnRyYWNrID09PSB0cmFjaztcbiAgICAgIH0pO1xuICAgICAgaWYgKGVyciB8fCAoc2VuZGVyICYmIHJlY2VpdmVyKSkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IERPTUV4Y2VwdGlvbihcbiAgICAgICAgICAnVGhlcmUgYXJlIG1vcmUgdGhhbiBvbmUgc2VuZGVyIG9yIHJlY2VpdmVyIGZvciB0aGUgdHJhY2suJyxcbiAgICAgICAgICAnSW52YWxpZEFjY2Vzc0Vycm9yJykpO1xuICAgICAgfSBlbHNlIGlmIChzZW5kZXIpIHtcbiAgICAgICAgcmV0dXJuIHNlbmRlci5nZXRTdGF0cygpO1xuICAgICAgfSBlbHNlIGlmIChyZWNlaXZlcikge1xuICAgICAgICByZXR1cm4gcmVjZWl2ZXIuZ2V0U3RhdHMoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRE9NRXhjZXB0aW9uKFxuICAgICAgICAnVGhlcmUgaXMgbm8gc2VuZGVyIG9yIHJlY2VpdmVyIGZvciB0aGUgdHJhY2suJyxcbiAgICAgICAgJ0ludmFsaWRBY2Nlc3NFcnJvcicpKTtcbiAgICB9XG4gICAgcmV0dXJuIG9yaWdHZXRTdGF0cy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2hpbUFkZFRyYWNrUmVtb3ZlVHJhY2tXaXRoTmF0aXZlKHdpbmRvdykge1xuICAvLyBzaGltIGFkZFRyYWNrL3JlbW92ZVRyYWNrIHdpdGggbmF0aXZlIHZhcmlhbnRzIGluIG9yZGVyIHRvIG1ha2VcbiAgLy8gdGhlIGludGVyYWN0aW9ucyB3aXRoIGxlZ2FjeSBnZXRMb2NhbFN0cmVhbXMgYmVoYXZlIGFzIGluIG90aGVyIGJyb3dzZXJzLlxuICAvLyBLZWVwcyBhIG1hcHBpbmcgc3RyZWFtLmlkID0+IFtzdHJlYW0sIHJ0cHNlbmRlcnMuLi5dXG4gIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuZ2V0TG9jYWxTdHJlYW1zID1cbiAgICBmdW5jdGlvbiBnZXRMb2NhbFN0cmVhbXMoKSB7XG4gICAgICB0aGlzLl9zaGltbWVkTG9jYWxTdHJlYW1zID0gdGhpcy5fc2hpbW1lZExvY2FsU3RyZWFtcyB8fCB7fTtcbiAgICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLl9zaGltbWVkTG9jYWxTdHJlYW1zKVxuICAgICAgICAubWFwKHN0cmVhbUlkID0+IHRoaXMuX3NoaW1tZWRMb2NhbFN0cmVhbXNbc3RyZWFtSWRdWzBdKTtcbiAgICB9O1xuXG4gIGNvbnN0IG9yaWdBZGRUcmFjayA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuYWRkVHJhY2s7XG4gIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuYWRkVHJhY2sgPVxuICAgIGZ1bmN0aW9uIGFkZFRyYWNrKHRyYWNrLCBzdHJlYW0pIHtcbiAgICAgIGlmICghc3RyZWFtKSB7XG4gICAgICAgIHJldHVybiBvcmlnQWRkVHJhY2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3NoaW1tZWRMb2NhbFN0cmVhbXMgPSB0aGlzLl9zaGltbWVkTG9jYWxTdHJlYW1zIHx8IHt9O1xuXG4gICAgICBjb25zdCBzZW5kZXIgPSBvcmlnQWRkVHJhY2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIGlmICghdGhpcy5fc2hpbW1lZExvY2FsU3RyZWFtc1tzdHJlYW0uaWRdKSB7XG4gICAgICAgIHRoaXMuX3NoaW1tZWRMb2NhbFN0cmVhbXNbc3RyZWFtLmlkXSA9IFtzdHJlYW0sIHNlbmRlcl07XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX3NoaW1tZWRMb2NhbFN0cmVhbXNbc3RyZWFtLmlkXS5pbmRleE9mKHNlbmRlcikgPT09IC0xKSB7XG4gICAgICAgIHRoaXMuX3NoaW1tZWRMb2NhbFN0cmVhbXNbc3RyZWFtLmlkXS5wdXNoKHNlbmRlcik7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2VuZGVyO1xuICAgIH07XG5cbiAgY29uc3Qgb3JpZ0FkZFN0cmVhbSA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuYWRkU3RyZWFtO1xuICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmFkZFN0cmVhbSA9IGZ1bmN0aW9uIGFkZFN0cmVhbShzdHJlYW0pIHtcbiAgICB0aGlzLl9zaGltbWVkTG9jYWxTdHJlYW1zID0gdGhpcy5fc2hpbW1lZExvY2FsU3RyZWFtcyB8fCB7fTtcblxuICAgIHN0cmVhbS5nZXRUcmFja3MoKS5mb3JFYWNoKHRyYWNrID0+IHtcbiAgICAgIGNvbnN0IGFscmVhZHlFeGlzdHMgPSB0aGlzLmdldFNlbmRlcnMoKS5maW5kKHMgPT4gcy50cmFjayA9PT0gdHJhY2spO1xuICAgICAgaWYgKGFscmVhZHlFeGlzdHMpIHtcbiAgICAgICAgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbignVHJhY2sgYWxyZWFkeSBleGlzdHMuJyxcbiAgICAgICAgICAnSW52YWxpZEFjY2Vzc0Vycm9yJyk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgY29uc3QgZXhpc3RpbmdTZW5kZXJzID0gdGhpcy5nZXRTZW5kZXJzKCk7XG4gICAgb3JpZ0FkZFN0cmVhbS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIGNvbnN0IG5ld1NlbmRlcnMgPSB0aGlzLmdldFNlbmRlcnMoKVxuICAgICAgLmZpbHRlcihuZXdTZW5kZXIgPT4gZXhpc3RpbmdTZW5kZXJzLmluZGV4T2YobmV3U2VuZGVyKSA9PT0gLTEpO1xuICAgIHRoaXMuX3NoaW1tZWRMb2NhbFN0cmVhbXNbc3RyZWFtLmlkXSA9IFtzdHJlYW1dLmNvbmNhdChuZXdTZW5kZXJzKTtcbiAgfTtcblxuICBjb25zdCBvcmlnUmVtb3ZlU3RyZWFtID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5yZW1vdmVTdHJlYW07XG4gIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUucmVtb3ZlU3RyZWFtID1cbiAgICBmdW5jdGlvbiByZW1vdmVTdHJlYW0oc3RyZWFtKSB7XG4gICAgICB0aGlzLl9zaGltbWVkTG9jYWxTdHJlYW1zID0gdGhpcy5fc2hpbW1lZExvY2FsU3RyZWFtcyB8fCB7fTtcbiAgICAgIGRlbGV0ZSB0aGlzLl9zaGltbWVkTG9jYWxTdHJlYW1zW3N0cmVhbS5pZF07XG4gICAgICByZXR1cm4gb3JpZ1JlbW92ZVN0cmVhbS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG5cbiAgY29uc3Qgb3JpZ1JlbW92ZVRyYWNrID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5yZW1vdmVUcmFjaztcbiAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5yZW1vdmVUcmFjayA9XG4gICAgZnVuY3Rpb24gcmVtb3ZlVHJhY2soc2VuZGVyKSB7XG4gICAgICB0aGlzLl9zaGltbWVkTG9jYWxTdHJlYW1zID0gdGhpcy5fc2hpbW1lZExvY2FsU3RyZWFtcyB8fCB7fTtcbiAgICAgIGlmIChzZW5kZXIpIHtcbiAgICAgICAgT2JqZWN0LmtleXModGhpcy5fc2hpbW1lZExvY2FsU3RyZWFtcykuZm9yRWFjaChzdHJlYW1JZCA9PiB7XG4gICAgICAgICAgY29uc3QgaWR4ID0gdGhpcy5fc2hpbW1lZExvY2FsU3RyZWFtc1tzdHJlYW1JZF0uaW5kZXhPZihzZW5kZXIpO1xuICAgICAgICAgIGlmIChpZHggIT09IC0xKSB7XG4gICAgICAgICAgICB0aGlzLl9zaGltbWVkTG9jYWxTdHJlYW1zW3N0cmVhbUlkXS5zcGxpY2UoaWR4LCAxKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRoaXMuX3NoaW1tZWRMb2NhbFN0cmVhbXNbc3RyZWFtSWRdLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX3NoaW1tZWRMb2NhbFN0cmVhbXNbc3RyZWFtSWRdO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gb3JpZ1JlbW92ZVRyYWNrLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNoaW1BZGRUcmFja1JlbW92ZVRyYWNrKHdpbmRvdywgYnJvd3NlckRldGFpbHMpIHtcbiAgaWYgKCF3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgLy8gc2hpbSBhZGRUcmFjayBhbmQgcmVtb3ZlVHJhY2suXG4gIGlmICh3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmFkZFRyYWNrICYmXG4gICAgICBicm93c2VyRGV0YWlscy52ZXJzaW9uID49IDY1KSB7XG4gICAgcmV0dXJuIHNoaW1BZGRUcmFja1JlbW92ZVRyYWNrV2l0aE5hdGl2ZSh3aW5kb3cpO1xuICB9XG5cbiAgLy8gYWxzbyBzaGltIHBjLmdldExvY2FsU3RyZWFtcyB3aGVuIGFkZFRyYWNrIGlzIHNoaW1tZWRcbiAgLy8gdG8gcmV0dXJuIHRoZSBvcmlnaW5hbCBzdHJlYW1zLlxuICBjb25zdCBvcmlnR2V0TG9jYWxTdHJlYW1zID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZVxuICAgIC5nZXRMb2NhbFN0cmVhbXM7XG4gIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuZ2V0TG9jYWxTdHJlYW1zID1cbiAgICBmdW5jdGlvbiBnZXRMb2NhbFN0cmVhbXMoKSB7XG4gICAgICBjb25zdCBuYXRpdmVTdHJlYW1zID0gb3JpZ0dldExvY2FsU3RyZWFtcy5hcHBseSh0aGlzKTtcbiAgICAgIHRoaXMuX3JldmVyc2VTdHJlYW1zID0gdGhpcy5fcmV2ZXJzZVN0cmVhbXMgfHwge307XG4gICAgICByZXR1cm4gbmF0aXZlU3RyZWFtcy5tYXAoc3RyZWFtID0+IHRoaXMuX3JldmVyc2VTdHJlYW1zW3N0cmVhbS5pZF0pO1xuICAgIH07XG5cbiAgY29uc3Qgb3JpZ0FkZFN0cmVhbSA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuYWRkU3RyZWFtO1xuICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmFkZFN0cmVhbSA9IGZ1bmN0aW9uIGFkZFN0cmVhbShzdHJlYW0pIHtcbiAgICB0aGlzLl9zdHJlYW1zID0gdGhpcy5fc3RyZWFtcyB8fCB7fTtcbiAgICB0aGlzLl9yZXZlcnNlU3RyZWFtcyA9IHRoaXMuX3JldmVyc2VTdHJlYW1zIHx8IHt9O1xuXG4gICAgc3RyZWFtLmdldFRyYWNrcygpLmZvckVhY2godHJhY2sgPT4ge1xuICAgICAgY29uc3QgYWxyZWFkeUV4aXN0cyA9IHRoaXMuZ2V0U2VuZGVycygpLmZpbmQocyA9PiBzLnRyYWNrID09PSB0cmFjayk7XG4gICAgICBpZiAoYWxyZWFkeUV4aXN0cykge1xuICAgICAgICB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKCdUcmFjayBhbHJlYWR5IGV4aXN0cy4nLFxuICAgICAgICAgICdJbnZhbGlkQWNjZXNzRXJyb3InKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICAvLyBBZGQgaWRlbnRpdHkgbWFwcGluZyBmb3IgY29uc2lzdGVuY3kgd2l0aCBhZGRUcmFjay5cbiAgICAvLyBVbmxlc3MgdGhpcyBpcyBiZWluZyB1c2VkIHdpdGggYSBzdHJlYW0gZnJvbSBhZGRUcmFjay5cbiAgICBpZiAoIXRoaXMuX3JldmVyc2VTdHJlYW1zW3N0cmVhbS5pZF0pIHtcbiAgICAgIGNvbnN0IG5ld1N0cmVhbSA9IG5ldyB3aW5kb3cuTWVkaWFTdHJlYW0oc3RyZWFtLmdldFRyYWNrcygpKTtcbiAgICAgIHRoaXMuX3N0cmVhbXNbc3RyZWFtLmlkXSA9IG5ld1N0cmVhbTtcbiAgICAgIHRoaXMuX3JldmVyc2VTdHJlYW1zW25ld1N0cmVhbS5pZF0gPSBzdHJlYW07XG4gICAgICBzdHJlYW0gPSBuZXdTdHJlYW07XG4gICAgfVxuICAgIG9yaWdBZGRTdHJlYW0uYXBwbHkodGhpcywgW3N0cmVhbV0pO1xuICB9O1xuXG4gIGNvbnN0IG9yaWdSZW1vdmVTdHJlYW0gPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLnJlbW92ZVN0cmVhbTtcbiAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5yZW1vdmVTdHJlYW0gPVxuICAgIGZ1bmN0aW9uIHJlbW92ZVN0cmVhbShzdHJlYW0pIHtcbiAgICAgIHRoaXMuX3N0cmVhbXMgPSB0aGlzLl9zdHJlYW1zIHx8IHt9O1xuICAgICAgdGhpcy5fcmV2ZXJzZVN0cmVhbXMgPSB0aGlzLl9yZXZlcnNlU3RyZWFtcyB8fCB7fTtcblxuICAgICAgb3JpZ1JlbW92ZVN0cmVhbS5hcHBseSh0aGlzLCBbKHRoaXMuX3N0cmVhbXNbc3RyZWFtLmlkXSB8fCBzdHJlYW0pXSk7XG4gICAgICBkZWxldGUgdGhpcy5fcmV2ZXJzZVN0cmVhbXNbKHRoaXMuX3N0cmVhbXNbc3RyZWFtLmlkXSA/XG4gICAgICAgIHRoaXMuX3N0cmVhbXNbc3RyZWFtLmlkXS5pZCA6IHN0cmVhbS5pZCldO1xuICAgICAgZGVsZXRlIHRoaXMuX3N0cmVhbXNbc3RyZWFtLmlkXTtcbiAgICB9O1xuXG4gIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuYWRkVHJhY2sgPVxuICAgIGZ1bmN0aW9uIGFkZFRyYWNrKHRyYWNrLCBzdHJlYW0pIHtcbiAgICAgIGlmICh0aGlzLnNpZ25hbGluZ1N0YXRlID09PSAnY2xvc2VkJykge1xuICAgICAgICB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKFxuICAgICAgICAgICdUaGUgUlRDUGVlckNvbm5lY3Rpb25cXCdzIHNpZ25hbGluZ1N0YXRlIGlzIFxcJ2Nsb3NlZFxcJy4nLFxuICAgICAgICAgICdJbnZhbGlkU3RhdGVFcnJvcicpO1xuICAgICAgfVxuICAgICAgY29uc3Qgc3RyZWFtcyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgIGlmIChzdHJlYW1zLmxlbmd0aCAhPT0gMSB8fFxuICAgICAgICAgICFzdHJlYW1zWzBdLmdldFRyYWNrcygpLmZpbmQodCA9PiB0ID09PSB0cmFjaykpIHtcbiAgICAgICAgLy8gdGhpcyBpcyBub3QgZnVsbHkgY29ycmVjdCBidXQgYWxsIHdlIGNhbiBtYW5hZ2Ugd2l0aG91dFxuICAgICAgICAvLyBbW2Fzc29jaWF0ZWQgTWVkaWFTdHJlYW1zXV0gaW50ZXJuYWwgc2xvdC5cbiAgICAgICAgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbihcbiAgICAgICAgICAnVGhlIGFkYXB0ZXIuanMgYWRkVHJhY2sgcG9seWZpbGwgb25seSBzdXBwb3J0cyBhIHNpbmdsZSAnICtcbiAgICAgICAgICAnIHN0cmVhbSB3aGljaCBpcyBhc3NvY2lhdGVkIHdpdGggdGhlIHNwZWNpZmllZCB0cmFjay4nLFxuICAgICAgICAgICdOb3RTdXBwb3J0ZWRFcnJvcicpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBhbHJlYWR5RXhpc3RzID0gdGhpcy5nZXRTZW5kZXJzKCkuZmluZChzID0+IHMudHJhY2sgPT09IHRyYWNrKTtcbiAgICAgIGlmIChhbHJlYWR5RXhpc3RzKSB7XG4gICAgICAgIHRocm93IG5ldyBET01FeGNlcHRpb24oJ1RyYWNrIGFscmVhZHkgZXhpc3RzLicsXG4gICAgICAgICAgJ0ludmFsaWRBY2Nlc3NFcnJvcicpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9zdHJlYW1zID0gdGhpcy5fc3RyZWFtcyB8fCB7fTtcbiAgICAgIHRoaXMuX3JldmVyc2VTdHJlYW1zID0gdGhpcy5fcmV2ZXJzZVN0cmVhbXMgfHwge307XG4gICAgICBjb25zdCBvbGRTdHJlYW0gPSB0aGlzLl9zdHJlYW1zW3N0cmVhbS5pZF07XG4gICAgICBpZiAob2xkU3RyZWFtKSB7XG4gICAgICAgIC8vIHRoaXMgaXMgdXNpbmcgb2RkIENocm9tZSBiZWhhdmlvdXIsIHVzZSB3aXRoIGNhdXRpb246XG4gICAgICAgIC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC93ZWJydGMvaXNzdWVzL2RldGFpbD9pZD03ODE1XG4gICAgICAgIC8vIE5vdGU6IHdlIHJlbHkgb24gdGhlIGhpZ2gtbGV2ZWwgYWRkVHJhY2svZHRtZiBzaGltIHRvXG4gICAgICAgIC8vIGNyZWF0ZSB0aGUgc2VuZGVyIHdpdGggYSBkdG1mIHNlbmRlci5cbiAgICAgICAgb2xkU3RyZWFtLmFkZFRyYWNrKHRyYWNrKTtcblxuICAgICAgICAvLyBUcmlnZ2VyIE9OTiBhc3luYy5cbiAgICAgICAgUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgnbmVnb3RpYXRpb25uZWVkZWQnKSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgbmV3U3RyZWFtID0gbmV3IHdpbmRvdy5NZWRpYVN0cmVhbShbdHJhY2tdKTtcbiAgICAgICAgdGhpcy5fc3RyZWFtc1tzdHJlYW0uaWRdID0gbmV3U3RyZWFtO1xuICAgICAgICB0aGlzLl9yZXZlcnNlU3RyZWFtc1tuZXdTdHJlYW0uaWRdID0gc3RyZWFtO1xuICAgICAgICB0aGlzLmFkZFN0cmVhbShuZXdTdHJlYW0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuZ2V0U2VuZGVycygpLmZpbmQocyA9PiBzLnRyYWNrID09PSB0cmFjayk7XG4gICAgfTtcblxuICAvLyByZXBsYWNlIHRoZSBpbnRlcm5hbCBzdHJlYW0gaWQgd2l0aCB0aGUgZXh0ZXJuYWwgb25lIGFuZFxuICAvLyB2aWNlIHZlcnNhLlxuICBmdW5jdGlvbiByZXBsYWNlSW50ZXJuYWxTdHJlYW1JZChwYywgZGVzY3JpcHRpb24pIHtcbiAgICBsZXQgc2RwID0gZGVzY3JpcHRpb24uc2RwO1xuICAgIE9iamVjdC5rZXlzKHBjLl9yZXZlcnNlU3RyZWFtcyB8fCBbXSkuZm9yRWFjaChpbnRlcm5hbElkID0+IHtcbiAgICAgIGNvbnN0IGV4dGVybmFsU3RyZWFtID0gcGMuX3JldmVyc2VTdHJlYW1zW2ludGVybmFsSWRdO1xuICAgICAgY29uc3QgaW50ZXJuYWxTdHJlYW0gPSBwYy5fc3RyZWFtc1tleHRlcm5hbFN0cmVhbS5pZF07XG4gICAgICBzZHAgPSBzZHAucmVwbGFjZShuZXcgUmVnRXhwKGludGVybmFsU3RyZWFtLmlkLCAnZycpLFxuICAgICAgICBleHRlcm5hbFN0cmVhbS5pZCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIG5ldyBSVENTZXNzaW9uRGVzY3JpcHRpb24oe1xuICAgICAgdHlwZTogZGVzY3JpcHRpb24udHlwZSxcbiAgICAgIHNkcFxuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIHJlcGxhY2VFeHRlcm5hbFN0cmVhbUlkKHBjLCBkZXNjcmlwdGlvbikge1xuICAgIGxldCBzZHAgPSBkZXNjcmlwdGlvbi5zZHA7XG4gICAgT2JqZWN0LmtleXMocGMuX3JldmVyc2VTdHJlYW1zIHx8IFtdKS5mb3JFYWNoKGludGVybmFsSWQgPT4ge1xuICAgICAgY29uc3QgZXh0ZXJuYWxTdHJlYW0gPSBwYy5fcmV2ZXJzZVN0cmVhbXNbaW50ZXJuYWxJZF07XG4gICAgICBjb25zdCBpbnRlcm5hbFN0cmVhbSA9IHBjLl9zdHJlYW1zW2V4dGVybmFsU3RyZWFtLmlkXTtcbiAgICAgIHNkcCA9IHNkcC5yZXBsYWNlKG5ldyBSZWdFeHAoZXh0ZXJuYWxTdHJlYW0uaWQsICdnJyksXG4gICAgICAgIGludGVybmFsU3RyZWFtLmlkKTtcbiAgICB9KTtcbiAgICByZXR1cm4gbmV3IFJUQ1Nlc3Npb25EZXNjcmlwdGlvbih7XG4gICAgICB0eXBlOiBkZXNjcmlwdGlvbi50eXBlLFxuICAgICAgc2RwXG4gICAgfSk7XG4gIH1cbiAgWydjcmVhdGVPZmZlcicsICdjcmVhdGVBbnN3ZXInXS5mb3JFYWNoKGZ1bmN0aW9uKG1ldGhvZCkge1xuICAgIGNvbnN0IG5hdGl2ZU1ldGhvZCA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGVbbWV0aG9kXTtcbiAgICBjb25zdCBtZXRob2RPYmogPSB7W21ldGhvZF0oKSB7XG4gICAgICBjb25zdCBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgY29uc3QgaXNMZWdhY3lDYWxsID0gYXJndW1lbnRzLmxlbmd0aCAmJlxuICAgICAgICAgIHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdmdW5jdGlvbic7XG4gICAgICBpZiAoaXNMZWdhY3lDYWxsKSB7XG4gICAgICAgIHJldHVybiBuYXRpdmVNZXRob2QuYXBwbHkodGhpcywgW1xuICAgICAgICAgIChkZXNjcmlwdGlvbikgPT4ge1xuICAgICAgICAgICAgY29uc3QgZGVzYyA9IHJlcGxhY2VJbnRlcm5hbFN0cmVhbUlkKHRoaXMsIGRlc2NyaXB0aW9uKTtcbiAgICAgICAgICAgIGFyZ3NbMF0uYXBwbHkobnVsbCwgW2Rlc2NdKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIChlcnIpID0+IHtcbiAgICAgICAgICAgIGlmIChhcmdzWzFdKSB7XG4gICAgICAgICAgICAgIGFyZ3NbMV0uYXBwbHkobnVsbCwgZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCBhcmd1bWVudHNbMl1cbiAgICAgICAgXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmF0aXZlTWV0aG9kLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgICAgICAgLnRoZW4oZGVzY3JpcHRpb24gPT4gcmVwbGFjZUludGVybmFsU3RyZWFtSWQodGhpcywgZGVzY3JpcHRpb24pKTtcbiAgICB9fTtcbiAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlW21ldGhvZF0gPSBtZXRob2RPYmpbbWV0aG9kXTtcbiAgfSk7XG5cbiAgY29uc3Qgb3JpZ1NldExvY2FsRGVzY3JpcHRpb24gPVxuICAgICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5zZXRMb2NhbERlc2NyaXB0aW9uO1xuICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLnNldExvY2FsRGVzY3JpcHRpb24gPVxuICAgIGZ1bmN0aW9uIHNldExvY2FsRGVzY3JpcHRpb24oKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGggfHwgIWFyZ3VtZW50c1swXS50eXBlKSB7XG4gICAgICAgIHJldHVybiBvcmlnU2V0TG9jYWxEZXNjcmlwdGlvbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgICAgYXJndW1lbnRzWzBdID0gcmVwbGFjZUV4dGVybmFsU3RyZWFtSWQodGhpcywgYXJndW1lbnRzWzBdKTtcbiAgICAgIHJldHVybiBvcmlnU2V0TG9jYWxEZXNjcmlwdGlvbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG5cbiAgLy8gVE9ETzogbWFuZ2xlIGdldFN0YXRzOiBodHRwczovL3czYy5naXRodWIuaW8vd2VicnRjLXN0YXRzLyNkb20tcnRjbWVkaWFzdHJlYW1zdGF0cy1zdHJlYW1pZGVudGlmaWVyXG5cbiAgY29uc3Qgb3JpZ0xvY2FsRGVzY3JpcHRpb24gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKFxuICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUsICdsb2NhbERlc2NyaXB0aW9uJyk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLFxuICAgICdsb2NhbERlc2NyaXB0aW9uJywge1xuICAgICAgZ2V0KCkge1xuICAgICAgICBjb25zdCBkZXNjcmlwdGlvbiA9IG9yaWdMb2NhbERlc2NyaXB0aW9uLmdldC5hcHBseSh0aGlzKTtcbiAgICAgICAgaWYgKGRlc2NyaXB0aW9uLnR5cGUgPT09ICcnKSB7XG4gICAgICAgICAgcmV0dXJuIGRlc2NyaXB0aW9uO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXBsYWNlSW50ZXJuYWxTdHJlYW1JZCh0aGlzLCBkZXNjcmlwdGlvbik7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5yZW1vdmVUcmFjayA9XG4gICAgZnVuY3Rpb24gcmVtb3ZlVHJhY2soc2VuZGVyKSB7XG4gICAgICBpZiAodGhpcy5zaWduYWxpbmdTdGF0ZSA9PT0gJ2Nsb3NlZCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbihcbiAgICAgICAgICAnVGhlIFJUQ1BlZXJDb25uZWN0aW9uXFwncyBzaWduYWxpbmdTdGF0ZSBpcyBcXCdjbG9zZWRcXCcuJyxcbiAgICAgICAgICAnSW52YWxpZFN0YXRlRXJyb3InKTtcbiAgICAgIH1cbiAgICAgIC8vIFdlIGNhbiBub3QgeWV0IGNoZWNrIGZvciBzZW5kZXIgaW5zdGFuY2VvZiBSVENSdHBTZW5kZXJcbiAgICAgIC8vIHNpbmNlIHdlIHNoaW0gUlRQU2VuZGVyLiBTbyB3ZSBjaGVjayBpZiBzZW5kZXIuX3BjIGlzIHNldC5cbiAgICAgIGlmICghc2VuZGVyLl9wYykge1xuICAgICAgICB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKCdBcmd1bWVudCAxIG9mIFJUQ1BlZXJDb25uZWN0aW9uLnJlbW92ZVRyYWNrICcgK1xuICAgICAgICAgICAgJ2RvZXMgbm90IGltcGxlbWVudCBpbnRlcmZhY2UgUlRDUnRwU2VuZGVyLicsICdUeXBlRXJyb3InKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGlzTG9jYWwgPSBzZW5kZXIuX3BjID09PSB0aGlzO1xuICAgICAgaWYgKCFpc0xvY2FsKSB7XG4gICAgICAgIHRocm93IG5ldyBET01FeGNlcHRpb24oJ1NlbmRlciB3YXMgbm90IGNyZWF0ZWQgYnkgdGhpcyBjb25uZWN0aW9uLicsXG4gICAgICAgICAgJ0ludmFsaWRBY2Nlc3NFcnJvcicpO1xuICAgICAgfVxuXG4gICAgICAvLyBTZWFyY2ggZm9yIHRoZSBuYXRpdmUgc3RyZWFtIHRoZSBzZW5kZXJzIHRyYWNrIGJlbG9uZ3MgdG8uXG4gICAgICB0aGlzLl9zdHJlYW1zID0gdGhpcy5fc3RyZWFtcyB8fCB7fTtcbiAgICAgIGxldCBzdHJlYW07XG4gICAgICBPYmplY3Qua2V5cyh0aGlzLl9zdHJlYW1zKS5mb3JFYWNoKHN0cmVhbWlkID0+IHtcbiAgICAgICAgY29uc3QgaGFzVHJhY2sgPSB0aGlzLl9zdHJlYW1zW3N0cmVhbWlkXS5nZXRUcmFja3MoKVxuICAgICAgICAgIC5maW5kKHRyYWNrID0+IHNlbmRlci50cmFjayA9PT0gdHJhY2spO1xuICAgICAgICBpZiAoaGFzVHJhY2spIHtcbiAgICAgICAgICBzdHJlYW0gPSB0aGlzLl9zdHJlYW1zW3N0cmVhbWlkXTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGlmIChzdHJlYW0pIHtcbiAgICAgICAgaWYgKHN0cmVhbS5nZXRUcmFja3MoKS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAvLyBpZiB0aGlzIGlzIHRoZSBsYXN0IHRyYWNrIG9mIHRoZSBzdHJlYW0sIHJlbW92ZSB0aGUgc3RyZWFtLiBUaGlzXG4gICAgICAgICAgLy8gdGFrZXMgY2FyZSBvZiBhbnkgc2hpbW1lZCBfc2VuZGVycy5cbiAgICAgICAgICB0aGlzLnJlbW92ZVN0cmVhbSh0aGlzLl9yZXZlcnNlU3RyZWFtc1tzdHJlYW0uaWRdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyByZWx5aW5nIG9uIHRoZSBzYW1lIG9kZCBjaHJvbWUgYmVoYXZpb3VyIGFzIGFib3ZlLlxuICAgICAgICAgIHN0cmVhbS5yZW1vdmVUcmFjayhzZW5kZXIudHJhY2spO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoJ25lZ290aWF0aW9ubmVlZGVkJykpO1xuICAgICAgfVxuICAgIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzaGltUGVlckNvbm5lY3Rpb24od2luZG93LCBicm93c2VyRGV0YWlscykge1xuICBpZiAoIXdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbiAmJiB3aW5kb3cud2Via2l0UlRDUGVlckNvbm5lY3Rpb24pIHtcbiAgICAvLyB2ZXJ5IGJhc2ljIHN1cHBvcnQgZm9yIG9sZCB2ZXJzaW9ucy5cbiAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24gPSB3aW5kb3cud2Via2l0UlRDUGVlckNvbm5lY3Rpb247XG4gIH1cbiAgaWYgKCF3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24pIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBzaGltIGltcGxpY2l0IGNyZWF0aW9uIG9mIFJUQ1Nlc3Npb25EZXNjcmlwdGlvbi9SVENJY2VDYW5kaWRhdGVcbiAgaWYgKGJyb3dzZXJEZXRhaWxzLnZlcnNpb24gPCA1Mykge1xuICAgIFsnc2V0TG9jYWxEZXNjcmlwdGlvbicsICdzZXRSZW1vdGVEZXNjcmlwdGlvbicsICdhZGRJY2VDYW5kaWRhdGUnXVxuICAgICAgLmZvckVhY2goZnVuY3Rpb24obWV0aG9kKSB7XG4gICAgICAgIGNvbnN0IG5hdGl2ZU1ldGhvZCA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGVbbWV0aG9kXTtcbiAgICAgICAgY29uc3QgbWV0aG9kT2JqID0ge1ttZXRob2RdKCkge1xuICAgICAgICAgIGFyZ3VtZW50c1swXSA9IG5ldyAoKG1ldGhvZCA9PT0gJ2FkZEljZUNhbmRpZGF0ZScpID9cbiAgICAgICAgICAgIHdpbmRvdy5SVENJY2VDYW5kaWRhdGUgOlxuICAgICAgICAgICAgd2luZG93LlJUQ1Nlc3Npb25EZXNjcmlwdGlvbikoYXJndW1lbnRzWzBdKTtcbiAgICAgICAgICByZXR1cm4gbmF0aXZlTWV0aG9kLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH19O1xuICAgICAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlW21ldGhvZF0gPSBtZXRob2RPYmpbbWV0aG9kXTtcbiAgICAgIH0pO1xuICB9XG59XG5cbi8vIEF0dGVtcHQgdG8gZml4IE9OTiBpbiBwbGFuLWIgbW9kZS5cbmV4cG9ydCBmdW5jdGlvbiBmaXhOZWdvdGlhdGlvbk5lZWRlZCh3aW5kb3csIGJyb3dzZXJEZXRhaWxzKSB7XG4gIHV0aWxzLndyYXBQZWVyQ29ubmVjdGlvbkV2ZW50KHdpbmRvdywgJ25lZ290aWF0aW9ubmVlZGVkJywgZSA9PiB7XG4gICAgY29uc3QgcGMgPSBlLnRhcmdldDtcbiAgICBpZiAoYnJvd3NlckRldGFpbHMudmVyc2lvbiA8IDcyIHx8IChwYy5nZXRDb25maWd1cmF0aW9uICYmXG4gICAgICAgIHBjLmdldENvbmZpZ3VyYXRpb24oKS5zZHBTZW1hbnRpY3MgPT09ICdwbGFuLWInKSkge1xuICAgICAgaWYgKHBjLnNpZ25hbGluZ1N0YXRlICE9PSAnc3RhYmxlJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlO1xuICB9KTtcbn1cbiIsIi8qXG4gKiAgQ29weXJpZ2h0IChjKSAyMDE2IFRoZSBXZWJSVEMgcHJvamVjdCBhdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqICBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhIEJTRC1zdHlsZSBsaWNlbnNlXG4gKiAgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBvZiB0aGUgc291cmNlXG4gKiAgdHJlZS5cbiAqL1xuLyogZXNsaW50LWVudiBub2RlICovXG4ndXNlIHN0cmljdCc7XG5cbmltcG9ydCAqIGFzIHV0aWxzIGZyb20gJy4uL3V0aWxzJztcblxuZXhwb3J0IGZ1bmN0aW9uIHNoaW1HZXRVc2VyTWVkaWEod2luZG93LCBicm93c2VyRGV0YWlscykge1xuICBjb25zdCBuYXZpZ2F0b3IgPSB3aW5kb3cgJiYgd2luZG93Lm5hdmlnYXRvcjtcbiAgY29uc3QgTWVkaWFTdHJlYW1UcmFjayA9IHdpbmRvdyAmJiB3aW5kb3cuTWVkaWFTdHJlYW1UcmFjaztcblxuICBuYXZpZ2F0b3IuZ2V0VXNlck1lZGlhID0gZnVuY3Rpb24oY29uc3RyYWludHMsIG9uU3VjY2Vzcywgb25FcnJvcikge1xuICAgIC8vIFJlcGxhY2UgRmlyZWZveCA0NCsncyBkZXByZWNhdGlvbiB3YXJuaW5nIHdpdGggdW5wcmVmaXhlZCB2ZXJzaW9uLlxuICAgIHV0aWxzLmRlcHJlY2F0ZWQoJ25hdmlnYXRvci5nZXRVc2VyTWVkaWEnLFxuICAgICAgJ25hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhJyk7XG4gICAgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEoY29uc3RyYWludHMpLnRoZW4ob25TdWNjZXNzLCBvbkVycm9yKTtcbiAgfTtcblxuICBpZiAoIShicm93c2VyRGV0YWlscy52ZXJzaW9uID4gNTUgJiZcbiAgICAgICdhdXRvR2FpbkNvbnRyb2wnIGluIG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0U3VwcG9ydGVkQ29uc3RyYWludHMoKSkpIHtcbiAgICBjb25zdCByZW1hcCA9IGZ1bmN0aW9uKG9iaiwgYSwgYikge1xuICAgICAgaWYgKGEgaW4gb2JqICYmICEoYiBpbiBvYmopKSB7XG4gICAgICAgIG9ialtiXSA9IG9ialthXTtcbiAgICAgICAgZGVsZXRlIG9ialthXTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgY29uc3QgbmF0aXZlR2V0VXNlck1lZGlhID0gbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEuXG4gICAgICBiaW5kKG5hdmlnYXRvci5tZWRpYURldmljZXMpO1xuICAgIG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhID0gZnVuY3Rpb24oYykge1xuICAgICAgaWYgKHR5cGVvZiBjID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgYy5hdWRpbyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgYyA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoYykpO1xuICAgICAgICByZW1hcChjLmF1ZGlvLCAnYXV0b0dhaW5Db250cm9sJywgJ21vekF1dG9HYWluQ29udHJvbCcpO1xuICAgICAgICByZW1hcChjLmF1ZGlvLCAnbm9pc2VTdXBwcmVzc2lvbicsICdtb3pOb2lzZVN1cHByZXNzaW9uJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmF0aXZlR2V0VXNlck1lZGlhKGMpO1xuICAgIH07XG5cbiAgICBpZiAoTWVkaWFTdHJlYW1UcmFjayAmJiBNZWRpYVN0cmVhbVRyYWNrLnByb3RvdHlwZS5nZXRTZXR0aW5ncykge1xuICAgICAgY29uc3QgbmF0aXZlR2V0U2V0dGluZ3MgPSBNZWRpYVN0cmVhbVRyYWNrLnByb3RvdHlwZS5nZXRTZXR0aW5ncztcbiAgICAgIE1lZGlhU3RyZWFtVHJhY2sucHJvdG90eXBlLmdldFNldHRpbmdzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IG5hdGl2ZUdldFNldHRpbmdzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIHJlbWFwKG9iaiwgJ21vekF1dG9HYWluQ29udHJvbCcsICdhdXRvR2FpbkNvbnRyb2wnKTtcbiAgICAgICAgcmVtYXAob2JqLCAnbW96Tm9pc2VTdXBwcmVzc2lvbicsICdub2lzZVN1cHByZXNzaW9uJyk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmIChNZWRpYVN0cmVhbVRyYWNrICYmIE1lZGlhU3RyZWFtVHJhY2sucHJvdG90eXBlLmFwcGx5Q29uc3RyYWludHMpIHtcbiAgICAgIGNvbnN0IG5hdGl2ZUFwcGx5Q29uc3RyYWludHMgPVxuICAgICAgICBNZWRpYVN0cmVhbVRyYWNrLnByb3RvdHlwZS5hcHBseUNvbnN0cmFpbnRzO1xuICAgICAgTWVkaWFTdHJlYW1UcmFjay5wcm90b3R5cGUuYXBwbHlDb25zdHJhaW50cyA9IGZ1bmN0aW9uKGMpIHtcbiAgICAgICAgaWYgKHRoaXMua2luZCA9PT0gJ2F1ZGlvJyAmJiB0eXBlb2YgYyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICBjID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShjKSk7XG4gICAgICAgICAgcmVtYXAoYywgJ2F1dG9HYWluQ29udHJvbCcsICdtb3pBdXRvR2FpbkNvbnRyb2wnKTtcbiAgICAgICAgICByZW1hcChjLCAnbm9pc2VTdXBwcmVzc2lvbicsICdtb3pOb2lzZVN1cHByZXNzaW9uJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5hdGl2ZUFwcGx5Q29uc3RyYWludHMuYXBwbHkodGhpcywgW2NdKTtcbiAgICAgIH07XG4gICAgfVxuICB9XG59XG4iLCIvKlxuICogIENvcHlyaWdodCAoYykgMjAxOCBUaGUgYWRhcHRlci5qcyBwcm9qZWN0IGF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGEgQlNELXN0eWxlIGxpY2Vuc2VcbiAqICB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGluIHRoZSByb290IG9mIHRoZSBzb3VyY2VcbiAqICB0cmVlLlxuICovXG4vKiBlc2xpbnQtZW52IG5vZGUgKi9cbid1c2Ugc3RyaWN0JztcblxuZXhwb3J0IGZ1bmN0aW9uIHNoaW1HZXREaXNwbGF5TWVkaWEod2luZG93LCBwcmVmZXJyZWRNZWRpYVNvdXJjZSkge1xuICBpZiAod2luZG93Lm5hdmlnYXRvci5tZWRpYURldmljZXMgJiZcbiAgICAnZ2V0RGlzcGxheU1lZGlhJyBpbiB3aW5kb3cubmF2aWdhdG9yLm1lZGlhRGV2aWNlcykge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoISh3aW5kb3cubmF2aWdhdG9yLm1lZGlhRGV2aWNlcykpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgd2luZG93Lm5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0RGlzcGxheU1lZGlhID1cbiAgICBmdW5jdGlvbiBnZXREaXNwbGF5TWVkaWEoY29uc3RyYWludHMpIHtcbiAgICAgIGlmICghKGNvbnN0cmFpbnRzICYmIGNvbnN0cmFpbnRzLnZpZGVvKSkge1xuICAgICAgICBjb25zdCBlcnIgPSBuZXcgRE9NRXhjZXB0aW9uKCdnZXREaXNwbGF5TWVkaWEgd2l0aG91dCB2aWRlbyAnICtcbiAgICAgICAgICAgICdjb25zdHJhaW50cyBpcyB1bmRlZmluZWQnKTtcbiAgICAgICAgZXJyLm5hbWUgPSAnTm90Rm91bmRFcnJvcic7XG4gICAgICAgIC8vIGZyb20gaHR0cHM6Ly9oZXljYW0uZ2l0aHViLmlvL3dlYmlkbC8jaWRsLURPTUV4Y2VwdGlvbi1lcnJvci1uYW1lc1xuICAgICAgICBlcnIuY29kZSA9IDg7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnIpO1xuICAgICAgfVxuICAgICAgaWYgKGNvbnN0cmFpbnRzLnZpZGVvID09PSB0cnVlKSB7XG4gICAgICAgIGNvbnN0cmFpbnRzLnZpZGVvID0ge21lZGlhU291cmNlOiBwcmVmZXJyZWRNZWRpYVNvdXJjZX07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdHJhaW50cy52aWRlby5tZWRpYVNvdXJjZSA9IHByZWZlcnJlZE1lZGlhU291cmNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHdpbmRvdy5uYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYShjb25zdHJhaW50cyk7XG4gICAgfTtcbn1cbiIsIi8qXG4gKiAgQ29weXJpZ2h0IChjKSAyMDE2IFRoZSBXZWJSVEMgcHJvamVjdCBhdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqICBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhIEJTRC1zdHlsZSBsaWNlbnNlXG4gKiAgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBvZiB0aGUgc291cmNlXG4gKiAgdHJlZS5cbiAqL1xuLyogZXNsaW50LWVudiBub2RlICovXG4ndXNlIHN0cmljdCc7XG5cbmltcG9ydCAqIGFzIHV0aWxzIGZyb20gJy4uL3V0aWxzJztcbmV4cG9ydCB7c2hpbUdldFVzZXJNZWRpYX0gZnJvbSAnLi9nZXR1c2VybWVkaWEnO1xuZXhwb3J0IHtzaGltR2V0RGlzcGxheU1lZGlhfSBmcm9tICcuL2dldGRpc3BsYXltZWRpYSc7XG5cbmV4cG9ydCBmdW5jdGlvbiBzaGltT25UcmFjayh3aW5kb3cpIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnICYmIHdpbmRvdy5SVENUcmFja0V2ZW50ICYmXG4gICAgICAoJ3JlY2VpdmVyJyBpbiB3aW5kb3cuUlRDVHJhY2tFdmVudC5wcm90b3R5cGUpICYmXG4gICAgICAhKCd0cmFuc2NlaXZlcicgaW4gd2luZG93LlJUQ1RyYWNrRXZlbnQucHJvdG90eXBlKSkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3aW5kb3cuUlRDVHJhY2tFdmVudC5wcm90b3R5cGUsICd0cmFuc2NlaXZlcicsIHtcbiAgICAgIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHtyZWNlaXZlcjogdGhpcy5yZWNlaXZlcn07XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNoaW1QZWVyQ29ubmVjdGlvbih3aW5kb3csIGJyb3dzZXJEZXRhaWxzKSB7XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAnb2JqZWN0JyB8fFxuICAgICAgISh3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24gfHwgd2luZG93Lm1velJUQ1BlZXJDb25uZWN0aW9uKSkge1xuICAgIHJldHVybjsgLy8gcHJvYmFibHkgbWVkaWEucGVlcmNvbm5lY3Rpb24uZW5hYmxlZD1mYWxzZSBpbiBhYm91dDpjb25maWdcbiAgfVxuICBpZiAoIXdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbiAmJiB3aW5kb3cubW96UlRDUGVlckNvbm5lY3Rpb24pIHtcbiAgICAvLyB2ZXJ5IGJhc2ljIHN1cHBvcnQgZm9yIG9sZCB2ZXJzaW9ucy5cbiAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24gPSB3aW5kb3cubW96UlRDUGVlckNvbm5lY3Rpb247XG4gIH1cblxuICBpZiAoYnJvd3NlckRldGFpbHMudmVyc2lvbiA8IDUzKSB7XG4gICAgLy8gc2hpbSBhd2F5IG5lZWQgZm9yIG9ic29sZXRlIFJUQ0ljZUNhbmRpZGF0ZS9SVENTZXNzaW9uRGVzY3JpcHRpb24uXG4gICAgWydzZXRMb2NhbERlc2NyaXB0aW9uJywgJ3NldFJlbW90ZURlc2NyaXB0aW9uJywgJ2FkZEljZUNhbmRpZGF0ZSddXG4gICAgICAuZm9yRWFjaChmdW5jdGlvbihtZXRob2QpIHtcbiAgICAgICAgY29uc3QgbmF0aXZlTWV0aG9kID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZVttZXRob2RdO1xuICAgICAgICBjb25zdCBtZXRob2RPYmogPSB7W21ldGhvZF0oKSB7XG4gICAgICAgICAgYXJndW1lbnRzWzBdID0gbmV3ICgobWV0aG9kID09PSAnYWRkSWNlQ2FuZGlkYXRlJykgP1xuICAgICAgICAgICAgd2luZG93LlJUQ0ljZUNhbmRpZGF0ZSA6XG4gICAgICAgICAgICB3aW5kb3cuUlRDU2Vzc2lvbkRlc2NyaXB0aW9uKShhcmd1bWVudHNbMF0pO1xuICAgICAgICAgIHJldHVybiBuYXRpdmVNZXRob2QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfX07XG4gICAgICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGVbbWV0aG9kXSA9IG1ldGhvZE9ialttZXRob2RdO1xuICAgICAgfSk7XG4gIH1cblxuICBjb25zdCBtb2Rlcm5TdGF0c1R5cGVzID0ge1xuICAgIGluYm91bmRydHA6ICdpbmJvdW5kLXJ0cCcsXG4gICAgb3V0Ym91bmRydHA6ICdvdXRib3VuZC1ydHAnLFxuICAgIGNhbmRpZGF0ZXBhaXI6ICdjYW5kaWRhdGUtcGFpcicsXG4gICAgbG9jYWxjYW5kaWRhdGU6ICdsb2NhbC1jYW5kaWRhdGUnLFxuICAgIHJlbW90ZWNhbmRpZGF0ZTogJ3JlbW90ZS1jYW5kaWRhdGUnXG4gIH07XG5cbiAgY29uc3QgbmF0aXZlR2V0U3RhdHMgPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmdldFN0YXRzO1xuICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmdldFN0YXRzID0gZnVuY3Rpb24gZ2V0U3RhdHMoKSB7XG4gICAgY29uc3QgW3NlbGVjdG9yLCBvblN1Y2MsIG9uRXJyXSA9IGFyZ3VtZW50cztcbiAgICByZXR1cm4gbmF0aXZlR2V0U3RhdHMuYXBwbHkodGhpcywgW3NlbGVjdG9yIHx8IG51bGxdKVxuICAgICAgLnRoZW4oc3RhdHMgPT4ge1xuICAgICAgICBpZiAoYnJvd3NlckRldGFpbHMudmVyc2lvbiA8IDUzICYmICFvblN1Y2MpIHtcbiAgICAgICAgICAvLyBTaGltIG9ubHkgcHJvbWlzZSBnZXRTdGF0cyB3aXRoIHNwZWMtaHlwaGVucyBpbiB0eXBlIG5hbWVzXG4gICAgICAgICAgLy8gTGVhdmUgY2FsbGJhY2sgdmVyc2lvbiBhbG9uZTsgbWlzYyBvbGQgdXNlcyBvZiBmb3JFYWNoIGJlZm9yZSBNYXBcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgc3RhdHMuZm9yRWFjaChzdGF0ID0+IHtcbiAgICAgICAgICAgICAgc3RhdC50eXBlID0gbW9kZXJuU3RhdHNUeXBlc1tzdGF0LnR5cGVdIHx8IHN0YXQudHlwZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGlmIChlLm5hbWUgIT09ICdUeXBlRXJyb3InKSB7XG4gICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBBdm9pZCBUeXBlRXJyb3I6IFwidHlwZVwiIGlzIHJlYWQtb25seSwgaW4gb2xkIHZlcnNpb25zLiAzNC00M2lzaFxuICAgICAgICAgICAgc3RhdHMuZm9yRWFjaCgoc3RhdCwgaSkgPT4ge1xuICAgICAgICAgICAgICBzdGF0cy5zZXQoaSwgT2JqZWN0LmFzc2lnbih7fSwgc3RhdCwge1xuICAgICAgICAgICAgICAgIHR5cGU6IG1vZGVyblN0YXRzVHlwZXNbc3RhdC50eXBlXSB8fCBzdGF0LnR5cGVcbiAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdGF0cztcbiAgICAgIH0pXG4gICAgICAudGhlbihvblN1Y2MsIG9uRXJyKTtcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNoaW1TZW5kZXJHZXRTdGF0cyh3aW5kb3cpIHtcbiAgaWYgKCEodHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcgJiYgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uICYmXG4gICAgICB3aW5kb3cuUlRDUnRwU2VuZGVyKSkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAod2luZG93LlJUQ1J0cFNlbmRlciAmJiAnZ2V0U3RhdHMnIGluIHdpbmRvdy5SVENSdHBTZW5kZXIucHJvdG90eXBlKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IG9yaWdHZXRTZW5kZXJzID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5nZXRTZW5kZXJzO1xuICBpZiAob3JpZ0dldFNlbmRlcnMpIHtcbiAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmdldFNlbmRlcnMgPSBmdW5jdGlvbiBnZXRTZW5kZXJzKCkge1xuICAgICAgY29uc3Qgc2VuZGVycyA9IG9yaWdHZXRTZW5kZXJzLmFwcGx5KHRoaXMsIFtdKTtcbiAgICAgIHNlbmRlcnMuZm9yRWFjaChzZW5kZXIgPT4gc2VuZGVyLl9wYyA9IHRoaXMpO1xuICAgICAgcmV0dXJuIHNlbmRlcnM7XG4gICAgfTtcbiAgfVxuXG4gIGNvbnN0IG9yaWdBZGRUcmFjayA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuYWRkVHJhY2s7XG4gIGlmIChvcmlnQWRkVHJhY2spIHtcbiAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmFkZFRyYWNrID0gZnVuY3Rpb24gYWRkVHJhY2soKSB7XG4gICAgICBjb25zdCBzZW5kZXIgPSBvcmlnQWRkVHJhY2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHNlbmRlci5fcGMgPSB0aGlzO1xuICAgICAgcmV0dXJuIHNlbmRlcjtcbiAgICB9O1xuICB9XG4gIHdpbmRvdy5SVENSdHBTZW5kZXIucHJvdG90eXBlLmdldFN0YXRzID0gZnVuY3Rpb24gZ2V0U3RhdHMoKSB7XG4gICAgcmV0dXJuIHRoaXMudHJhY2sgPyB0aGlzLl9wYy5nZXRTdGF0cyh0aGlzLnRyYWNrKSA6XG4gICAgICBQcm9taXNlLnJlc29sdmUobmV3IE1hcCgpKTtcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNoaW1SZWNlaXZlckdldFN0YXRzKHdpbmRvdykge1xuICBpZiAoISh0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0JyAmJiB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24gJiZcbiAgICAgIHdpbmRvdy5SVENSdHBTZW5kZXIpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICh3aW5kb3cuUlRDUnRwU2VuZGVyICYmICdnZXRTdGF0cycgaW4gd2luZG93LlJUQ1J0cFJlY2VpdmVyLnByb3RvdHlwZSkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBvcmlnR2V0UmVjZWl2ZXJzID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5nZXRSZWNlaXZlcnM7XG4gIGlmIChvcmlnR2V0UmVjZWl2ZXJzKSB7XG4gICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5nZXRSZWNlaXZlcnMgPSBmdW5jdGlvbiBnZXRSZWNlaXZlcnMoKSB7XG4gICAgICBjb25zdCByZWNlaXZlcnMgPSBvcmlnR2V0UmVjZWl2ZXJzLmFwcGx5KHRoaXMsIFtdKTtcbiAgICAgIHJlY2VpdmVycy5mb3JFYWNoKHJlY2VpdmVyID0+IHJlY2VpdmVyLl9wYyA9IHRoaXMpO1xuICAgICAgcmV0dXJuIHJlY2VpdmVycztcbiAgICB9O1xuICB9XG4gIHV0aWxzLndyYXBQZWVyQ29ubmVjdGlvbkV2ZW50KHdpbmRvdywgJ3RyYWNrJywgZSA9PiB7XG4gICAgZS5yZWNlaXZlci5fcGMgPSBlLnNyY0VsZW1lbnQ7XG4gICAgcmV0dXJuIGU7XG4gIH0pO1xuICB3aW5kb3cuUlRDUnRwUmVjZWl2ZXIucHJvdG90eXBlLmdldFN0YXRzID0gZnVuY3Rpb24gZ2V0U3RhdHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BjLmdldFN0YXRzKHRoaXMudHJhY2spO1xuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2hpbVJlbW92ZVN0cmVhbSh3aW5kb3cpIHtcbiAgaWYgKCF3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24gfHxcbiAgICAgICdyZW1vdmVTdHJlYW0nIGluIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5yZW1vdmVTdHJlYW0gPVxuICAgIGZ1bmN0aW9uIHJlbW92ZVN0cmVhbShzdHJlYW0pIHtcbiAgICAgIHV0aWxzLmRlcHJlY2F0ZWQoJ3JlbW92ZVN0cmVhbScsICdyZW1vdmVUcmFjaycpO1xuICAgICAgdGhpcy5nZXRTZW5kZXJzKCkuZm9yRWFjaChzZW5kZXIgPT4ge1xuICAgICAgICBpZiAoc2VuZGVyLnRyYWNrICYmIHN0cmVhbS5nZXRUcmFja3MoKS5pbmNsdWRlcyhzZW5kZXIudHJhY2spKSB7XG4gICAgICAgICAgdGhpcy5yZW1vdmVUcmFjayhzZW5kZXIpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2hpbVJUQ0RhdGFDaGFubmVsKHdpbmRvdykge1xuICAvLyByZW5hbWUgRGF0YUNoYW5uZWwgdG8gUlRDRGF0YUNoYW5uZWwgKG5hdGl2ZSBmaXggaW4gRkY2MCk6XG4gIC8vIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTExNzM4NTFcbiAgaWYgKHdpbmRvdy5EYXRhQ2hhbm5lbCAmJiAhd2luZG93LlJUQ0RhdGFDaGFubmVsKSB7XG4gICAgd2luZG93LlJUQ0RhdGFDaGFubmVsID0gd2luZG93LkRhdGFDaGFubmVsO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzaGltQWRkVHJhbnNjZWl2ZXIod2luZG93KSB7XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJydGNIYWNrcy9hZGFwdGVyL2lzc3Vlcy85OTgjaXNzdWVjb21tZW50LTUxNjkyMTY0N1xuICAvLyBGaXJlZm94IGlnbm9yZXMgdGhlIGluaXQgc2VuZEVuY29kaW5ncyBvcHRpb25zIHBhc3NlZCB0byBhZGRUcmFuc2NlaXZlclxuICAvLyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0xMzk2OTE4XG4gIGlmICghKHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnICYmIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbikpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3Qgb3JpZ0FkZFRyYW5zY2VpdmVyID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5hZGRUcmFuc2NlaXZlcjtcbiAgaWYgKG9yaWdBZGRUcmFuc2NlaXZlcikge1xuICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuYWRkVHJhbnNjZWl2ZXIgPVxuICAgICAgZnVuY3Rpb24gYWRkVHJhbnNjZWl2ZXIoKSB7XG4gICAgICAgIHRoaXMuc2V0UGFyYW1ldGVyc1Byb21pc2VzID0gW107XG4gICAgICAgIC8vIFdlYklETCBpbnB1dCBjb2VyY2lvbiBhbmQgdmFsaWRhdGlvblxuICAgICAgICBsZXQgc2VuZEVuY29kaW5ncyA9IGFyZ3VtZW50c1sxXSAmJiBhcmd1bWVudHNbMV0uc2VuZEVuY29kaW5ncztcbiAgICAgICAgaWYgKHNlbmRFbmNvZGluZ3MgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHNlbmRFbmNvZGluZ3MgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBzZW5kRW5jb2RpbmdzID0gWy4uLnNlbmRFbmNvZGluZ3NdO1xuICAgICAgICBjb25zdCBzaG91bGRQZXJmb3JtQ2hlY2sgPSBzZW5kRW5jb2RpbmdzLmxlbmd0aCA+IDA7XG4gICAgICAgIGlmIChzaG91bGRQZXJmb3JtQ2hlY2spIHtcbiAgICAgICAgICAvLyBJZiBzZW5kRW5jb2RpbmdzIHBhcmFtcyBhcmUgcHJvdmlkZWQsIHZhbGlkYXRlIGdyYW1tYXJcbiAgICAgICAgICBzZW5kRW5jb2RpbmdzLmZvckVhY2goKGVuY29kaW5nUGFyYW0pID0+IHtcbiAgICAgICAgICAgIGlmICgncmlkJyBpbiBlbmNvZGluZ1BhcmFtKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHJpZFJlZ2V4ID0gL15bYS16MC05XXswLDE2fSQvaTtcbiAgICAgICAgICAgICAgaWYgKCFyaWRSZWdleC50ZXN0KGVuY29kaW5nUGFyYW0ucmlkKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgUklEIHZhbHVlIHByb3ZpZGVkLicpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoJ3NjYWxlUmVzb2x1dGlvbkRvd25CeScgaW4gZW5jb2RpbmdQYXJhbSkge1xuICAgICAgICAgICAgICBpZiAoIShwYXJzZUZsb2F0KGVuY29kaW5nUGFyYW0uc2NhbGVSZXNvbHV0aW9uRG93bkJ5KSA+PSAxLjApKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NjYWxlX3Jlc29sdXRpb25fZG93bl9ieSBtdXN0IGJlID49IDEuMCcpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoJ21heEZyYW1lcmF0ZScgaW4gZW5jb2RpbmdQYXJhbSkge1xuICAgICAgICAgICAgICBpZiAoIShwYXJzZUZsb2F0KGVuY29kaW5nUGFyYW0ubWF4RnJhbWVyYXRlKSA+PSAwKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdtYXhfZnJhbWVyYXRlIG11c3QgYmUgPj0gMC4wJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0cmFuc2NlaXZlciA9IG9yaWdBZGRUcmFuc2NlaXZlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICBpZiAoc2hvdWxkUGVyZm9ybUNoZWNrKSB7XG4gICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGluaXQgb3B0aW9ucyB3ZXJlIGFwcGxpZWQuIElmIG5vdCB3ZSBkbyB0aGlzIGluIGFuXG4gICAgICAgICAgLy8gYXN5bmNocm9ub3VzIHdheSBhbmQgc2F2ZSB0aGUgcHJvbWlzZSByZWZlcmVuY2UgaW4gYSBnbG9iYWwgb2JqZWN0LlxuICAgICAgICAgIC8vIFRoaXMgaXMgYW4gdWdseSBoYWNrLCBidXQgYXQgdGhlIHNhbWUgdGltZSBpcyB3YXkgbW9yZSByb2J1c3QgdGhhblxuICAgICAgICAgIC8vIGNoZWNraW5nIHRoZSBzZW5kZXIgcGFyYW1ldGVycyBiZWZvcmUgYW5kIGFmdGVyIHRoZSBjcmVhdGVPZmZlclxuICAgICAgICAgIC8vIEFsc28gbm90ZSB0aGF0IGFmdGVyIHRoZSBjcmVhdGVvZmZlciB3ZSBhcmUgbm90IDEwMCUgc3VyZSB0aGF0XG4gICAgICAgICAgLy8gdGhlIHBhcmFtcyB3ZXJlIGFzeW5jaHJvbm91c2x5IGFwcGxpZWQgc28gd2UgbWlnaHQgbWlzcyB0aGVcbiAgICAgICAgICAvLyBvcHBvcnR1bml0eSB0byByZWNyZWF0ZSBvZmZlci5cbiAgICAgICAgICBjb25zdCB7c2VuZGVyfSA9IHRyYW5zY2VpdmVyO1xuICAgICAgICAgIGNvbnN0IHBhcmFtcyA9IHNlbmRlci5nZXRQYXJhbWV0ZXJzKCk7XG4gICAgICAgICAgaWYgKCEoJ2VuY29kaW5ncycgaW4gcGFyYW1zKSB8fFxuICAgICAgICAgICAgICAvLyBBdm9pZCBiZWluZyBmb29sZWQgYnkgcGF0Y2hlZCBnZXRQYXJhbWV0ZXJzKCkgYmVsb3cuXG4gICAgICAgICAgICAgIChwYXJhbXMuZW5jb2RpbmdzLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgICAgICAgICAgT2JqZWN0LmtleXMocGFyYW1zLmVuY29kaW5nc1swXSkubGVuZ3RoID09PSAwKSkge1xuICAgICAgICAgICAgcGFyYW1zLmVuY29kaW5ncyA9IHNlbmRFbmNvZGluZ3M7XG4gICAgICAgICAgICBzZW5kZXIuc2VuZEVuY29kaW5ncyA9IHNlbmRFbmNvZGluZ3M7XG4gICAgICAgICAgICB0aGlzLnNldFBhcmFtZXRlcnNQcm9taXNlcy5wdXNoKHNlbmRlci5zZXRQYXJhbWV0ZXJzKHBhcmFtcylcbiAgICAgICAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBzZW5kZXIuc2VuZEVuY29kaW5ncztcbiAgICAgICAgICAgICAgfSkuY2F0Y2goKCkgPT4ge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBzZW5kZXIuc2VuZEVuY29kaW5ncztcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cmFuc2NlaXZlcjtcbiAgICAgIH07XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNoaW1HZXRQYXJhbWV0ZXJzKHdpbmRvdykge1xuICBpZiAoISh0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0JyAmJiB3aW5kb3cuUlRDUnRwU2VuZGVyKSkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBvcmlnR2V0UGFyYW1ldGVycyA9IHdpbmRvdy5SVENSdHBTZW5kZXIucHJvdG90eXBlLmdldFBhcmFtZXRlcnM7XG4gIGlmIChvcmlnR2V0UGFyYW1ldGVycykge1xuICAgIHdpbmRvdy5SVENSdHBTZW5kZXIucHJvdG90eXBlLmdldFBhcmFtZXRlcnMgPVxuICAgICAgZnVuY3Rpb24gZ2V0UGFyYW1ldGVycygpIHtcbiAgICAgICAgY29uc3QgcGFyYW1zID0gb3JpZ0dldFBhcmFtZXRlcnMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgaWYgKCEoJ2VuY29kaW5ncycgaW4gcGFyYW1zKSkge1xuICAgICAgICAgIHBhcmFtcy5lbmNvZGluZ3MgPSBbXS5jb25jYXQodGhpcy5zZW5kRW5jb2RpbmdzIHx8IFt7fV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgICB9O1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzaGltQ3JlYXRlT2ZmZXIod2luZG93KSB7XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJydGNIYWNrcy9hZGFwdGVyL2lzc3Vlcy85OTgjaXNzdWVjb21tZW50LTUxNjkyMTY0N1xuICAvLyBGaXJlZm94IGlnbm9yZXMgdGhlIGluaXQgc2VuZEVuY29kaW5ncyBvcHRpb25zIHBhc3NlZCB0byBhZGRUcmFuc2NlaXZlclxuICAvLyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0xMzk2OTE4XG4gIGlmICghKHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnICYmIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbikpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3Qgb3JpZ0NyZWF0ZU9mZmVyID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5jcmVhdGVPZmZlcjtcbiAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5jcmVhdGVPZmZlciA9IGZ1bmN0aW9uIGNyZWF0ZU9mZmVyKCkge1xuICAgIGlmICh0aGlzLnNldFBhcmFtZXRlcnNQcm9taXNlcyAmJiB0aGlzLnNldFBhcmFtZXRlcnNQcm9taXNlcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLmFsbCh0aGlzLnNldFBhcmFtZXRlcnNQcm9taXNlcylcbiAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgIHJldHVybiBvcmlnQ3JlYXRlT2ZmZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfSlcbiAgICAgICAgLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgICAgIHRoaXMuc2V0UGFyYW1ldGVyc1Byb21pc2VzID0gW107XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gb3JpZ0NyZWF0ZU9mZmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzaGltQ3JlYXRlQW5zd2VyKHdpbmRvdykge1xuICAvLyBodHRwczovL2dpdGh1Yi5jb20vd2VicnRjSGFja3MvYWRhcHRlci9pc3N1ZXMvOTk4I2lzc3VlY29tbWVudC01MTY5MjE2NDdcbiAgLy8gRmlyZWZveCBpZ25vcmVzIHRoZSBpbml0IHNlbmRFbmNvZGluZ3Mgb3B0aW9ucyBwYXNzZWQgdG8gYWRkVHJhbnNjZWl2ZXJcbiAgLy8gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTM5NjkxOFxuICBpZiAoISh0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0JyAmJiB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24pKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IG9yaWdDcmVhdGVBbnN3ZXIgPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmNyZWF0ZUFuc3dlcjtcbiAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5jcmVhdGVBbnN3ZXIgPSBmdW5jdGlvbiBjcmVhdGVBbnN3ZXIoKSB7XG4gICAgaWYgKHRoaXMuc2V0UGFyYW1ldGVyc1Byb21pc2VzICYmIHRoaXMuc2V0UGFyYW1ldGVyc1Byb21pc2VzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHRoaXMuc2V0UGFyYW1ldGVyc1Byb21pc2VzKVxuICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIG9yaWdDcmVhdGVBbnN3ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfSlcbiAgICAgICAgLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgICAgIHRoaXMuc2V0UGFyYW1ldGVyc1Byb21pc2VzID0gW107XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gb3JpZ0NyZWF0ZUFuc3dlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xufVxuIiwiLypcbiAqICBDb3B5cmlnaHQgKGMpIDIwMTYgVGhlIFdlYlJUQyBwcm9qZWN0IGF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGEgQlNELXN0eWxlIGxpY2Vuc2VcbiAqICB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGluIHRoZSByb290IG9mIHRoZSBzb3VyY2VcbiAqICB0cmVlLlxuICovXG4ndXNlIHN0cmljdCc7XG5pbXBvcnQgKiBhcyB1dGlscyBmcm9tICcuLi91dGlscyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBzaGltTG9jYWxTdHJlYW1zQVBJKHdpbmRvdykge1xuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ29iamVjdCcgfHwgIXdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbikge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoISgnZ2V0TG9jYWxTdHJlYW1zJyBpbiB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlKSkge1xuICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuZ2V0TG9jYWxTdHJlYW1zID1cbiAgICAgIGZ1bmN0aW9uIGdldExvY2FsU3RyZWFtcygpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9sb2NhbFN0cmVhbXMpIHtcbiAgICAgICAgICB0aGlzLl9sb2NhbFN0cmVhbXMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fbG9jYWxTdHJlYW1zO1xuICAgICAgfTtcbiAgfVxuICBpZiAoISgnYWRkU3RyZWFtJyBpbiB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlKSkge1xuICAgIGNvbnN0IF9hZGRUcmFjayA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuYWRkVHJhY2s7XG4gICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5hZGRTdHJlYW0gPSBmdW5jdGlvbiBhZGRTdHJlYW0oc3RyZWFtKSB7XG4gICAgICBpZiAoIXRoaXMuX2xvY2FsU3RyZWFtcykge1xuICAgICAgICB0aGlzLl9sb2NhbFN0cmVhbXMgPSBbXTtcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5fbG9jYWxTdHJlYW1zLmluY2x1ZGVzKHN0cmVhbSkpIHtcbiAgICAgICAgdGhpcy5fbG9jYWxTdHJlYW1zLnB1c2goc3RyZWFtKTtcbiAgICAgIH1cbiAgICAgIC8vIFRyeSB0byBlbXVsYXRlIENocm9tZSdzIGJlaGF2aW91ciBvZiBhZGRpbmcgaW4gYXVkaW8tdmlkZW8gb3JkZXIuXG4gICAgICAvLyBTYWZhcmkgb3JkZXJzIGJ5IHRyYWNrIGlkLlxuICAgICAgc3RyZWFtLmdldEF1ZGlvVHJhY2tzKCkuZm9yRWFjaCh0cmFjayA9PiBfYWRkVHJhY2suY2FsbCh0aGlzLCB0cmFjayxcbiAgICAgICAgc3RyZWFtKSk7XG4gICAgICBzdHJlYW0uZ2V0VmlkZW9UcmFja3MoKS5mb3JFYWNoKHRyYWNrID0+IF9hZGRUcmFjay5jYWxsKHRoaXMsIHRyYWNrLFxuICAgICAgICBzdHJlYW0pKTtcbiAgICB9O1xuXG4gICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5hZGRUcmFjayA9XG4gICAgICBmdW5jdGlvbiBhZGRUcmFjayh0cmFjaywgLi4uc3RyZWFtcykge1xuICAgICAgICBpZiAoc3RyZWFtcykge1xuICAgICAgICAgIHN0cmVhbXMuZm9yRWFjaCgoc3RyZWFtKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2xvY2FsU3RyZWFtcykge1xuICAgICAgICAgICAgICB0aGlzLl9sb2NhbFN0cmVhbXMgPSBbc3RyZWFtXTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIXRoaXMuX2xvY2FsU3RyZWFtcy5pbmNsdWRlcyhzdHJlYW0pKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2xvY2FsU3RyZWFtcy5wdXNoKHN0cmVhbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9hZGRUcmFjay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfTtcbiAgfVxuICBpZiAoISgncmVtb3ZlU3RyZWFtJyBpbiB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlKSkge1xuICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUucmVtb3ZlU3RyZWFtID1cbiAgICAgIGZ1bmN0aW9uIHJlbW92ZVN0cmVhbShzdHJlYW0pIHtcbiAgICAgICAgaWYgKCF0aGlzLl9sb2NhbFN0cmVhbXMpIHtcbiAgICAgICAgICB0aGlzLl9sb2NhbFN0cmVhbXMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuX2xvY2FsU3RyZWFtcy5pbmRleE9mKHN0cmVhbSk7XG4gICAgICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbG9jYWxTdHJlYW1zLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIGNvbnN0IHRyYWNrcyA9IHN0cmVhbS5nZXRUcmFja3MoKTtcbiAgICAgICAgdGhpcy5nZXRTZW5kZXJzKCkuZm9yRWFjaChzZW5kZXIgPT4ge1xuICAgICAgICAgIGlmICh0cmFja3MuaW5jbHVkZXMoc2VuZGVyLnRyYWNrKSkge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVUcmFjayhzZW5kZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9O1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzaGltUmVtb3RlU3RyZWFtc0FQSSh3aW5kb3cpIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICdvYmplY3QnIHx8ICF3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKCEoJ2dldFJlbW90ZVN0cmVhbXMnIGluIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUpKSB7XG4gICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5nZXRSZW1vdGVTdHJlYW1zID1cbiAgICAgIGZ1bmN0aW9uIGdldFJlbW90ZVN0cmVhbXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZW1vdGVTdHJlYW1zID8gdGhpcy5fcmVtb3RlU3RyZWFtcyA6IFtdO1xuICAgICAgfTtcbiAgfVxuICBpZiAoISgnb25hZGRzdHJlYW0nIGluIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUpKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUsICdvbmFkZHN0cmVhbScsIHtcbiAgICAgIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29uYWRkc3RyZWFtO1xuICAgICAgfSxcbiAgICAgIHNldChmKSB7XG4gICAgICAgIGlmICh0aGlzLl9vbmFkZHN0cmVhbSkge1xuICAgICAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignYWRkc3RyZWFtJywgdGhpcy5fb25hZGRzdHJlYW0pO1xuICAgICAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcigndHJhY2snLCB0aGlzLl9vbmFkZHN0cmVhbXBvbHkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignYWRkc3RyZWFtJywgdGhpcy5fb25hZGRzdHJlYW0gPSBmKTtcbiAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCd0cmFjaycsIHRoaXMuX29uYWRkc3RyZWFtcG9seSA9IChlKSA9PiB7XG4gICAgICAgICAgZS5zdHJlYW1zLmZvckVhY2goc3RyZWFtID0+IHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fcmVtb3RlU3RyZWFtcykge1xuICAgICAgICAgICAgICB0aGlzLl9yZW1vdGVTdHJlYW1zID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5fcmVtb3RlU3RyZWFtcy5pbmNsdWRlcyhzdHJlYW0pKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3JlbW90ZVN0cmVhbXMucHVzaChzdHJlYW0pO1xuICAgICAgICAgICAgY29uc3QgZXZlbnQgPSBuZXcgRXZlbnQoJ2FkZHN0cmVhbScpO1xuICAgICAgICAgICAgZXZlbnQuc3RyZWFtID0gc3RyZWFtO1xuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgY29uc3Qgb3JpZ1NldFJlbW90ZURlc2NyaXB0aW9uID1cbiAgICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuc2V0UmVtb3RlRGVzY3JpcHRpb247XG4gICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5zZXRSZW1vdGVEZXNjcmlwdGlvbiA9XG4gICAgICBmdW5jdGlvbiBzZXRSZW1vdGVEZXNjcmlwdGlvbigpIHtcbiAgICAgICAgY29uc3QgcGMgPSB0aGlzO1xuICAgICAgICBpZiAoIXRoaXMuX29uYWRkc3RyZWFtcG9seSkge1xuICAgICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcigndHJhY2snLCB0aGlzLl9vbmFkZHN0cmVhbXBvbHkgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICBlLnN0cmVhbXMuZm9yRWFjaChzdHJlYW0gPT4ge1xuICAgICAgICAgICAgICBpZiAoIXBjLl9yZW1vdGVTdHJlYW1zKSB7XG4gICAgICAgICAgICAgICAgcGMuX3JlbW90ZVN0cmVhbXMgPSBbXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAocGMuX3JlbW90ZVN0cmVhbXMuaW5kZXhPZihzdHJlYW0pID49IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcGMuX3JlbW90ZVN0cmVhbXMucHVzaChzdHJlYW0pO1xuICAgICAgICAgICAgICBjb25zdCBldmVudCA9IG5ldyBFdmVudCgnYWRkc3RyZWFtJyk7XG4gICAgICAgICAgICAgIGV2ZW50LnN0cmVhbSA9IHN0cmVhbTtcbiAgICAgICAgICAgICAgcGMuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3JpZ1NldFJlbW90ZURlc2NyaXB0aW9uLmFwcGx5KHBjLCBhcmd1bWVudHMpO1xuICAgICAgfTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gc2hpbUNhbGxiYWNrc0FQSSh3aW5kb3cpIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICdvYmplY3QnIHx8ICF3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgcHJvdG90eXBlID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZTtcbiAgY29uc3Qgb3JpZ0NyZWF0ZU9mZmVyID0gcHJvdG90eXBlLmNyZWF0ZU9mZmVyO1xuICBjb25zdCBvcmlnQ3JlYXRlQW5zd2VyID0gcHJvdG90eXBlLmNyZWF0ZUFuc3dlcjtcbiAgY29uc3Qgc2V0TG9jYWxEZXNjcmlwdGlvbiA9IHByb3RvdHlwZS5zZXRMb2NhbERlc2NyaXB0aW9uO1xuICBjb25zdCBzZXRSZW1vdGVEZXNjcmlwdGlvbiA9IHByb3RvdHlwZS5zZXRSZW1vdGVEZXNjcmlwdGlvbjtcbiAgY29uc3QgYWRkSWNlQ2FuZGlkYXRlID0gcHJvdG90eXBlLmFkZEljZUNhbmRpZGF0ZTtcblxuICBwcm90b3R5cGUuY3JlYXRlT2ZmZXIgPVxuICAgIGZ1bmN0aW9uIGNyZWF0ZU9mZmVyKHN1Y2Nlc3NDYWxsYmFjaywgZmFpbHVyZUNhbGxiYWNrKSB7XG4gICAgICBjb25zdCBvcHRpb25zID0gKGFyZ3VtZW50cy5sZW5ndGggPj0gMikgPyBhcmd1bWVudHNbMl0gOiBhcmd1bWVudHNbMF07XG4gICAgICBjb25zdCBwcm9taXNlID0gb3JpZ0NyZWF0ZU9mZmVyLmFwcGx5KHRoaXMsIFtvcHRpb25zXSk7XG4gICAgICBpZiAoIWZhaWx1cmVDYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICAgIH1cbiAgICAgIHByb21pc2UudGhlbihzdWNjZXNzQ2FsbGJhY2ssIGZhaWx1cmVDYWxsYmFjayk7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfTtcblxuICBwcm90b3R5cGUuY3JlYXRlQW5zd2VyID1cbiAgICBmdW5jdGlvbiBjcmVhdGVBbnN3ZXIoc3VjY2Vzc0NhbGxiYWNrLCBmYWlsdXJlQ2FsbGJhY2spIHtcbiAgICAgIGNvbnN0IG9wdGlvbnMgPSAoYXJndW1lbnRzLmxlbmd0aCA+PSAyKSA/IGFyZ3VtZW50c1syXSA6IGFyZ3VtZW50c1swXTtcbiAgICAgIGNvbnN0IHByb21pc2UgPSBvcmlnQ3JlYXRlQW5zd2VyLmFwcGx5KHRoaXMsIFtvcHRpb25zXSk7XG4gICAgICBpZiAoIWZhaWx1cmVDYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICAgIH1cbiAgICAgIHByb21pc2UudGhlbihzdWNjZXNzQ2FsbGJhY2ssIGZhaWx1cmVDYWxsYmFjayk7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfTtcblxuICBsZXQgd2l0aENhbGxiYWNrID0gZnVuY3Rpb24oZGVzY3JpcHRpb24sIHN1Y2Nlc3NDYWxsYmFjaywgZmFpbHVyZUNhbGxiYWNrKSB7XG4gICAgY29uc3QgcHJvbWlzZSA9IHNldExvY2FsRGVzY3JpcHRpb24uYXBwbHkodGhpcywgW2Rlc2NyaXB0aW9uXSk7XG4gICAgaWYgKCFmYWlsdXJlQ2FsbGJhY2spIHtcbiAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH1cbiAgICBwcm9taXNlLnRoZW4oc3VjY2Vzc0NhbGxiYWNrLCBmYWlsdXJlQ2FsbGJhY2spO1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgfTtcbiAgcHJvdG90eXBlLnNldExvY2FsRGVzY3JpcHRpb24gPSB3aXRoQ2FsbGJhY2s7XG5cbiAgd2l0aENhbGxiYWNrID0gZnVuY3Rpb24oZGVzY3JpcHRpb24sIHN1Y2Nlc3NDYWxsYmFjaywgZmFpbHVyZUNhbGxiYWNrKSB7XG4gICAgY29uc3QgcHJvbWlzZSA9IHNldFJlbW90ZURlc2NyaXB0aW9uLmFwcGx5KHRoaXMsIFtkZXNjcmlwdGlvbl0pO1xuICAgIGlmICghZmFpbHVyZUNhbGxiYWNrKSB7XG4gICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9XG4gICAgcHJvbWlzZS50aGVuKHN1Y2Nlc3NDYWxsYmFjaywgZmFpbHVyZUNhbGxiYWNrKTtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gIH07XG4gIHByb3RvdHlwZS5zZXRSZW1vdGVEZXNjcmlwdGlvbiA9IHdpdGhDYWxsYmFjaztcblxuICB3aXRoQ2FsbGJhY2sgPSBmdW5jdGlvbihjYW5kaWRhdGUsIHN1Y2Nlc3NDYWxsYmFjaywgZmFpbHVyZUNhbGxiYWNrKSB7XG4gICAgY29uc3QgcHJvbWlzZSA9IGFkZEljZUNhbmRpZGF0ZS5hcHBseSh0aGlzLCBbY2FuZGlkYXRlXSk7XG4gICAgaWYgKCFmYWlsdXJlQ2FsbGJhY2spIHtcbiAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH1cbiAgICBwcm9taXNlLnRoZW4oc3VjY2Vzc0NhbGxiYWNrLCBmYWlsdXJlQ2FsbGJhY2spO1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgfTtcbiAgcHJvdG90eXBlLmFkZEljZUNhbmRpZGF0ZSA9IHdpdGhDYWxsYmFjaztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNoaW1HZXRVc2VyTWVkaWEod2luZG93KSB7XG4gIGNvbnN0IG5hdmlnYXRvciA9IHdpbmRvdyAmJiB3aW5kb3cubmF2aWdhdG9yO1xuXG4gIGlmIChuYXZpZ2F0b3IubWVkaWFEZXZpY2VzICYmIG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKSB7XG4gICAgLy8gc2hpbSBub3QgbmVlZGVkIGluIFNhZmFyaSAxMi4xXG4gICAgY29uc3QgbWVkaWFEZXZpY2VzID0gbmF2aWdhdG9yLm1lZGlhRGV2aWNlcztcbiAgICBjb25zdCBfZ2V0VXNlck1lZGlhID0gbWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYS5iaW5kKG1lZGlhRGV2aWNlcyk7XG4gICAgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEgPSAoY29uc3RyYWludHMpID0+IHtcbiAgICAgIHJldHVybiBfZ2V0VXNlck1lZGlhKHNoaW1Db25zdHJhaW50cyhjb25zdHJhaW50cykpO1xuICAgIH07XG4gIH1cblxuICBpZiAoIW5hdmlnYXRvci5nZXRVc2VyTWVkaWEgJiYgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcyAmJlxuICAgIG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKSB7XG4gICAgbmF2aWdhdG9yLmdldFVzZXJNZWRpYSA9IGZ1bmN0aW9uIGdldFVzZXJNZWRpYShjb25zdHJhaW50cywgY2IsIGVycmNiKSB7XG4gICAgICBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYShjb25zdHJhaW50cylcbiAgICAgICAgLnRoZW4oY2IsIGVycmNiKTtcbiAgICB9LmJpbmQobmF2aWdhdG9yKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gc2hpbUNvbnN0cmFpbnRzKGNvbnN0cmFpbnRzKSB7XG4gIGlmIChjb25zdHJhaW50cyAmJiBjb25zdHJhaW50cy52aWRlbyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sXG4gICAgICBjb25zdHJhaW50cyxcbiAgICAgIHt2aWRlbzogdXRpbHMuY29tcGFjdE9iamVjdChjb25zdHJhaW50cy52aWRlbyl9XG4gICAgKTtcbiAgfVxuXG4gIHJldHVybiBjb25zdHJhaW50cztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNoaW1SVENJY2VTZXJ2ZXJVcmxzKHdpbmRvdykge1xuICBpZiAoIXdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbikge1xuICAgIHJldHVybjtcbiAgfVxuICAvLyBtaWdyYXRlIGZyb20gbm9uLXNwZWMgUlRDSWNlU2VydmVyLnVybCB0byBSVENJY2VTZXJ2ZXIudXJsc1xuICBjb25zdCBPcmlnUGVlckNvbm5lY3Rpb24gPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb247XG4gIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbiA9XG4gICAgZnVuY3Rpb24gUlRDUGVlckNvbm5lY3Rpb24ocGNDb25maWcsIHBjQ29uc3RyYWludHMpIHtcbiAgICAgIGlmIChwY0NvbmZpZyAmJiBwY0NvbmZpZy5pY2VTZXJ2ZXJzKSB7XG4gICAgICAgIGNvbnN0IG5ld0ljZVNlcnZlcnMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwY0NvbmZpZy5pY2VTZXJ2ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgbGV0IHNlcnZlciA9IHBjQ29uZmlnLmljZVNlcnZlcnNbaV07XG4gICAgICAgICAgaWYgKHNlcnZlci51cmxzID09PSB1bmRlZmluZWQgJiYgc2VydmVyLnVybCkge1xuICAgICAgICAgICAgdXRpbHMuZGVwcmVjYXRlZCgnUlRDSWNlU2VydmVyLnVybCcsICdSVENJY2VTZXJ2ZXIudXJscycpO1xuICAgICAgICAgICAgc2VydmVyID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShzZXJ2ZXIpKTtcbiAgICAgICAgICAgIHNlcnZlci51cmxzID0gc2VydmVyLnVybDtcbiAgICAgICAgICAgIGRlbGV0ZSBzZXJ2ZXIudXJsO1xuICAgICAgICAgICAgbmV3SWNlU2VydmVycy5wdXNoKHNlcnZlcik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5ld0ljZVNlcnZlcnMucHVzaChwY0NvbmZpZy5pY2VTZXJ2ZXJzW2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcGNDb25maWcuaWNlU2VydmVycyA9IG5ld0ljZVNlcnZlcnM7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IE9yaWdQZWVyQ29ubmVjdGlvbihwY0NvbmZpZywgcGNDb25zdHJhaW50cyk7XG4gICAgfTtcbiAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZSA9IE9yaWdQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGU7XG4gIC8vIHdyYXAgc3RhdGljIG1ldGhvZHMuIEN1cnJlbnRseSBqdXN0IGdlbmVyYXRlQ2VydGlmaWNhdGUuXG4gIGlmICgnZ2VuZXJhdGVDZXJ0aWZpY2F0ZScgaW4gT3JpZ1BlZXJDb25uZWN0aW9uKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbiwgJ2dlbmVyYXRlQ2VydGlmaWNhdGUnLCB7XG4gICAgICBnZXQoKSB7XG4gICAgICAgIHJldHVybiBPcmlnUGVlckNvbm5lY3Rpb24uZ2VuZXJhdGVDZXJ0aWZpY2F0ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gc2hpbVRyYWNrRXZlbnRUcmFuc2NlaXZlcih3aW5kb3cpIHtcbiAgLy8gQWRkIGV2ZW50LnRyYW5zY2VpdmVyIG1lbWJlciBvdmVyIGRlcHJlY2F0ZWQgZXZlbnQucmVjZWl2ZXJcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnICYmIHdpbmRvdy5SVENUcmFja0V2ZW50ICYmXG4gICAgICAncmVjZWl2ZXInIGluIHdpbmRvdy5SVENUcmFja0V2ZW50LnByb3RvdHlwZSAmJlxuICAgICAgISgndHJhbnNjZWl2ZXInIGluIHdpbmRvdy5SVENUcmFja0V2ZW50LnByb3RvdHlwZSkpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkod2luZG93LlJUQ1RyYWNrRXZlbnQucHJvdG90eXBlLCAndHJhbnNjZWl2ZXInLCB7XG4gICAgICBnZXQoKSB7XG4gICAgICAgIHJldHVybiB7cmVjZWl2ZXI6IHRoaXMucmVjZWl2ZXJ9O1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzaGltQ3JlYXRlT2ZmZXJMZWdhY3kod2luZG93KSB7XG4gIGNvbnN0IG9yaWdDcmVhdGVPZmZlciA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuY3JlYXRlT2ZmZXI7XG4gIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuY3JlYXRlT2ZmZXIgPVxuICAgIGZ1bmN0aW9uIGNyZWF0ZU9mZmVyKG9mZmVyT3B0aW9ucykge1xuICAgICAgaWYgKG9mZmVyT3B0aW9ucykge1xuICAgICAgICBpZiAodHlwZW9mIG9mZmVyT3B0aW9ucy5vZmZlclRvUmVjZWl2ZUF1ZGlvICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIC8vIHN1cHBvcnQgYml0IHZhbHVlc1xuICAgICAgICAgIG9mZmVyT3B0aW9ucy5vZmZlclRvUmVjZWl2ZUF1ZGlvID1cbiAgICAgICAgICAgICEhb2ZmZXJPcHRpb25zLm9mZmVyVG9SZWNlaXZlQXVkaW87XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXVkaW9UcmFuc2NlaXZlciA9IHRoaXMuZ2V0VHJhbnNjZWl2ZXJzKCkuZmluZCh0cmFuc2NlaXZlciA9PlxuICAgICAgICAgIHRyYW5zY2VpdmVyLnJlY2VpdmVyLnRyYWNrLmtpbmQgPT09ICdhdWRpbycpO1xuICAgICAgICBpZiAob2ZmZXJPcHRpb25zLm9mZmVyVG9SZWNlaXZlQXVkaW8gPT09IGZhbHNlICYmIGF1ZGlvVHJhbnNjZWl2ZXIpIHtcbiAgICAgICAgICBpZiAoYXVkaW9UcmFuc2NlaXZlci5kaXJlY3Rpb24gPT09ICdzZW5kcmVjdicpIHtcbiAgICAgICAgICAgIGlmIChhdWRpb1RyYW5zY2VpdmVyLnNldERpcmVjdGlvbikge1xuICAgICAgICAgICAgICBhdWRpb1RyYW5zY2VpdmVyLnNldERpcmVjdGlvbignc2VuZG9ubHknKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGF1ZGlvVHJhbnNjZWl2ZXIuZGlyZWN0aW9uID0gJ3NlbmRvbmx5JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKGF1ZGlvVHJhbnNjZWl2ZXIuZGlyZWN0aW9uID09PSAncmVjdm9ubHknKSB7XG4gICAgICAgICAgICBpZiAoYXVkaW9UcmFuc2NlaXZlci5zZXREaXJlY3Rpb24pIHtcbiAgICAgICAgICAgICAgYXVkaW9UcmFuc2NlaXZlci5zZXREaXJlY3Rpb24oJ2luYWN0aXZlJyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBhdWRpb1RyYW5zY2VpdmVyLmRpcmVjdGlvbiA9ICdpbmFjdGl2ZSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKG9mZmVyT3B0aW9ucy5vZmZlclRvUmVjZWl2ZUF1ZGlvID09PSB0cnVlICYmXG4gICAgICAgICAgICAhYXVkaW9UcmFuc2NlaXZlcikge1xuICAgICAgICAgIHRoaXMuYWRkVHJhbnNjZWl2ZXIoJ2F1ZGlvJywge2RpcmVjdGlvbjogJ3JlY3Zvbmx5J30pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBvZmZlck9wdGlvbnMub2ZmZXJUb1JlY2VpdmVWaWRlbyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAvLyBzdXBwb3J0IGJpdCB2YWx1ZXNcbiAgICAgICAgICBvZmZlck9wdGlvbnMub2ZmZXJUb1JlY2VpdmVWaWRlbyA9XG4gICAgICAgICAgICAhIW9mZmVyT3B0aW9ucy5vZmZlclRvUmVjZWl2ZVZpZGVvO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZpZGVvVHJhbnNjZWl2ZXIgPSB0aGlzLmdldFRyYW5zY2VpdmVycygpLmZpbmQodHJhbnNjZWl2ZXIgPT5cbiAgICAgICAgICB0cmFuc2NlaXZlci5yZWNlaXZlci50cmFjay5raW5kID09PSAndmlkZW8nKTtcbiAgICAgICAgaWYgKG9mZmVyT3B0aW9ucy5vZmZlclRvUmVjZWl2ZVZpZGVvID09PSBmYWxzZSAmJiB2aWRlb1RyYW5zY2VpdmVyKSB7XG4gICAgICAgICAgaWYgKHZpZGVvVHJhbnNjZWl2ZXIuZGlyZWN0aW9uID09PSAnc2VuZHJlY3YnKSB7XG4gICAgICAgICAgICBpZiAodmlkZW9UcmFuc2NlaXZlci5zZXREaXJlY3Rpb24pIHtcbiAgICAgICAgICAgICAgdmlkZW9UcmFuc2NlaXZlci5zZXREaXJlY3Rpb24oJ3NlbmRvbmx5Jyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB2aWRlb1RyYW5zY2VpdmVyLmRpcmVjdGlvbiA9ICdzZW5kb25seSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmICh2aWRlb1RyYW5zY2VpdmVyLmRpcmVjdGlvbiA9PT0gJ3JlY3Zvbmx5Jykge1xuICAgICAgICAgICAgaWYgKHZpZGVvVHJhbnNjZWl2ZXIuc2V0RGlyZWN0aW9uKSB7XG4gICAgICAgICAgICAgIHZpZGVvVHJhbnNjZWl2ZXIuc2V0RGlyZWN0aW9uKCdpbmFjdGl2ZScpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdmlkZW9UcmFuc2NlaXZlci5kaXJlY3Rpb24gPSAnaW5hY3RpdmUnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChvZmZlck9wdGlvbnMub2ZmZXJUb1JlY2VpdmVWaWRlbyA9PT0gdHJ1ZSAmJlxuICAgICAgICAgICAgIXZpZGVvVHJhbnNjZWl2ZXIpIHtcbiAgICAgICAgICB0aGlzLmFkZFRyYW5zY2VpdmVyKCd2aWRlbycsIHtkaXJlY3Rpb246ICdyZWN2b25seSd9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG9yaWdDcmVhdGVPZmZlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzaGltQXVkaW9Db250ZXh0KHdpbmRvdykge1xuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ29iamVjdCcgfHwgd2luZG93LkF1ZGlvQ29udGV4dCkge1xuICAgIHJldHVybjtcbiAgfVxuICB3aW5kb3cuQXVkaW9Db250ZXh0ID0gd2luZG93LndlYmtpdEF1ZGlvQ29udGV4dDtcbn1cblxuIiwiLyogZXNsaW50LWVudiBub2RlICovXG4ndXNlIHN0cmljdCc7XG5cbi8vIFNEUCBoZWxwZXJzLlxuY29uc3QgU0RQVXRpbHMgPSB7fTtcblxuLy8gR2VuZXJhdGUgYW4gYWxwaGFudW1lcmljIGlkZW50aWZpZXIgZm9yIGNuYW1lIG9yIG1pZHMuXG4vLyBUT0RPOiB1c2UgVVVJRHMgaW5zdGVhZD8gaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vamVkLzk4Mjg4M1xuU0RQVXRpbHMuZ2VuZXJhdGVJZGVudGlmaWVyID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoMiwgMTIpO1xufTtcblxuLy8gVGhlIFJUQ1AgQ05BTUUgdXNlZCBieSBhbGwgcGVlcmNvbm5lY3Rpb25zIGZyb20gdGhlIHNhbWUgSlMuXG5TRFBVdGlscy5sb2NhbENOYW1lID0gU0RQVXRpbHMuZ2VuZXJhdGVJZGVudGlmaWVyKCk7XG5cbi8vIFNwbGl0cyBTRFAgaW50byBsaW5lcywgZGVhbGluZyB3aXRoIGJvdGggQ1JMRiBhbmQgTEYuXG5TRFBVdGlscy5zcGxpdExpbmVzID0gZnVuY3Rpb24oYmxvYikge1xuICByZXR1cm4gYmxvYi50cmltKCkuc3BsaXQoJ1xcbicpLm1hcChsaW5lID0+IGxpbmUudHJpbSgpKTtcbn07XG4vLyBTcGxpdHMgU0RQIGludG8gc2Vzc2lvbnBhcnQgYW5kIG1lZGlhc2VjdGlvbnMuIEVuc3VyZXMgQ1JMRi5cblNEUFV0aWxzLnNwbGl0U2VjdGlvbnMgPSBmdW5jdGlvbihibG9iKSB7XG4gIGNvbnN0IHBhcnRzID0gYmxvYi5zcGxpdCgnXFxubT0nKTtcbiAgcmV0dXJuIHBhcnRzLm1hcCgocGFydCwgaW5kZXgpID0+IChpbmRleCA+IDAgP1xuICAgICdtPScgKyBwYXJ0IDogcGFydCkudHJpbSgpICsgJ1xcclxcbicpO1xufTtcblxuLy8gUmV0dXJucyB0aGUgc2Vzc2lvbiBkZXNjcmlwdGlvbi5cblNEUFV0aWxzLmdldERlc2NyaXB0aW9uID0gZnVuY3Rpb24oYmxvYikge1xuICBjb25zdCBzZWN0aW9ucyA9IFNEUFV0aWxzLnNwbGl0U2VjdGlvbnMoYmxvYik7XG4gIHJldHVybiBzZWN0aW9ucyAmJiBzZWN0aW9uc1swXTtcbn07XG5cbi8vIFJldHVybnMgdGhlIGluZGl2aWR1YWwgbWVkaWEgc2VjdGlvbnMuXG5TRFBVdGlscy5nZXRNZWRpYVNlY3Rpb25zID0gZnVuY3Rpb24oYmxvYikge1xuICBjb25zdCBzZWN0aW9ucyA9IFNEUFV0aWxzLnNwbGl0U2VjdGlvbnMoYmxvYik7XG4gIHNlY3Rpb25zLnNoaWZ0KCk7XG4gIHJldHVybiBzZWN0aW9ucztcbn07XG5cbi8vIFJldHVybnMgbGluZXMgdGhhdCBzdGFydCB3aXRoIGEgY2VydGFpbiBwcmVmaXguXG5TRFBVdGlscy5tYXRjaFByZWZpeCA9IGZ1bmN0aW9uKGJsb2IsIHByZWZpeCkge1xuICByZXR1cm4gU0RQVXRpbHMuc3BsaXRMaW5lcyhibG9iKS5maWx0ZXIobGluZSA9PiBsaW5lLmluZGV4T2YocHJlZml4KSA9PT0gMCk7XG59O1xuXG4vLyBQYXJzZXMgYW4gSUNFIGNhbmRpZGF0ZSBsaW5lLiBTYW1wbGUgaW5wdXQ6XG4vLyBjYW5kaWRhdGU6NzAyNzg2MzUwIDIgdWRwIDQxODE5OTAyIDguOC44LjggNjA3NjkgdHlwIHJlbGF5IHJhZGRyIDguOC44Ljhcbi8vIHJwb3J0IDU1OTk2XCJcbi8vIElucHV0IGNhbiBiZSBwcmVmaXhlZCB3aXRoIGE9LlxuU0RQVXRpbHMucGFyc2VDYW5kaWRhdGUgPSBmdW5jdGlvbihsaW5lKSB7XG4gIGxldCBwYXJ0cztcbiAgLy8gUGFyc2UgYm90aCB2YXJpYW50cy5cbiAgaWYgKGxpbmUuaW5kZXhPZignYT1jYW5kaWRhdGU6JykgPT09IDApIHtcbiAgICBwYXJ0cyA9IGxpbmUuc3Vic3RyaW5nKDEyKS5zcGxpdCgnICcpO1xuICB9IGVsc2Uge1xuICAgIHBhcnRzID0gbGluZS5zdWJzdHJpbmcoMTApLnNwbGl0KCcgJyk7XG4gIH1cblxuICBjb25zdCBjYW5kaWRhdGUgPSB7XG4gICAgZm91bmRhdGlvbjogcGFydHNbMF0sXG4gICAgY29tcG9uZW50OiB7MTogJ3J0cCcsIDI6ICdydGNwJ31bcGFydHNbMV1dIHx8IHBhcnRzWzFdLFxuICAgIHByb3RvY29sOiBwYXJ0c1syXS50b0xvd2VyQ2FzZSgpLFxuICAgIHByaW9yaXR5OiBwYXJzZUludChwYXJ0c1szXSwgMTApLFxuICAgIGlwOiBwYXJ0c1s0XSxcbiAgICBhZGRyZXNzOiBwYXJ0c1s0XSwgLy8gYWRkcmVzcyBpcyBhbiBhbGlhcyBmb3IgaXAuXG4gICAgcG9ydDogcGFyc2VJbnQocGFydHNbNV0sIDEwKSxcbiAgICAvLyBza2lwIHBhcnRzWzZdID09ICd0eXAnXG4gICAgdHlwZTogcGFydHNbN10sXG4gIH07XG5cbiAgZm9yIChsZXQgaSA9IDg7IGkgPCBwYXJ0cy5sZW5ndGg7IGkgKz0gMikge1xuICAgIHN3aXRjaCAocGFydHNbaV0pIHtcbiAgICAgIGNhc2UgJ3JhZGRyJzpcbiAgICAgICAgY2FuZGlkYXRlLnJlbGF0ZWRBZGRyZXNzID0gcGFydHNbaSArIDFdO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3Jwb3J0JzpcbiAgICAgICAgY2FuZGlkYXRlLnJlbGF0ZWRQb3J0ID0gcGFyc2VJbnQocGFydHNbaSArIDFdLCAxMCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndGNwdHlwZSc6XG4gICAgICAgIGNhbmRpZGF0ZS50Y3BUeXBlID0gcGFydHNbaSArIDFdO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3VmcmFnJzpcbiAgICAgICAgY2FuZGlkYXRlLnVmcmFnID0gcGFydHNbaSArIDFdOyAvLyBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eS5cbiAgICAgICAgY2FuZGlkYXRlLnVzZXJuYW1lRnJhZ21lbnQgPSBwYXJ0c1tpICsgMV07XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDogLy8gZXh0ZW5zaW9uIGhhbmRsaW5nLCBpbiBwYXJ0aWN1bGFyIHVmcmFnLiBEb24ndCBvdmVyd3JpdGUuXG4gICAgICAgIGlmIChjYW5kaWRhdGVbcGFydHNbaV1dID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBjYW5kaWRhdGVbcGFydHNbaV1dID0gcGFydHNbaSArIDFdO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gY2FuZGlkYXRlO1xufTtcblxuLy8gVHJhbnNsYXRlcyBhIGNhbmRpZGF0ZSBvYmplY3QgaW50byBTRFAgY2FuZGlkYXRlIGF0dHJpYnV0ZS5cbi8vIFRoaXMgZG9lcyBub3QgaW5jbHVkZSB0aGUgYT0gcHJlZml4IVxuU0RQVXRpbHMud3JpdGVDYW5kaWRhdGUgPSBmdW5jdGlvbihjYW5kaWRhdGUpIHtcbiAgY29uc3Qgc2RwID0gW107XG4gIHNkcC5wdXNoKGNhbmRpZGF0ZS5mb3VuZGF0aW9uKTtcblxuICBjb25zdCBjb21wb25lbnQgPSBjYW5kaWRhdGUuY29tcG9uZW50O1xuICBpZiAoY29tcG9uZW50ID09PSAncnRwJykge1xuICAgIHNkcC5wdXNoKDEpO1xuICB9IGVsc2UgaWYgKGNvbXBvbmVudCA9PT0gJ3J0Y3AnKSB7XG4gICAgc2RwLnB1c2goMik7XG4gIH0gZWxzZSB7XG4gICAgc2RwLnB1c2goY29tcG9uZW50KTtcbiAgfVxuICBzZHAucHVzaChjYW5kaWRhdGUucHJvdG9jb2wudG9VcHBlckNhc2UoKSk7XG4gIHNkcC5wdXNoKGNhbmRpZGF0ZS5wcmlvcml0eSk7XG4gIHNkcC5wdXNoKGNhbmRpZGF0ZS5hZGRyZXNzIHx8IGNhbmRpZGF0ZS5pcCk7XG4gIHNkcC5wdXNoKGNhbmRpZGF0ZS5wb3J0KTtcblxuICBjb25zdCB0eXBlID0gY2FuZGlkYXRlLnR5cGU7XG4gIHNkcC5wdXNoKCd0eXAnKTtcbiAgc2RwLnB1c2godHlwZSk7XG4gIGlmICh0eXBlICE9PSAnaG9zdCcgJiYgY2FuZGlkYXRlLnJlbGF0ZWRBZGRyZXNzICYmXG4gICAgICBjYW5kaWRhdGUucmVsYXRlZFBvcnQpIHtcbiAgICBzZHAucHVzaCgncmFkZHInKTtcbiAgICBzZHAucHVzaChjYW5kaWRhdGUucmVsYXRlZEFkZHJlc3MpO1xuICAgIHNkcC5wdXNoKCdycG9ydCcpO1xuICAgIHNkcC5wdXNoKGNhbmRpZGF0ZS5yZWxhdGVkUG9ydCk7XG4gIH1cbiAgaWYgKGNhbmRpZGF0ZS50Y3BUeXBlICYmIGNhbmRpZGF0ZS5wcm90b2NvbC50b0xvd2VyQ2FzZSgpID09PSAndGNwJykge1xuICAgIHNkcC5wdXNoKCd0Y3B0eXBlJyk7XG4gICAgc2RwLnB1c2goY2FuZGlkYXRlLnRjcFR5cGUpO1xuICB9XG4gIGlmIChjYW5kaWRhdGUudXNlcm5hbWVGcmFnbWVudCB8fCBjYW5kaWRhdGUudWZyYWcpIHtcbiAgICBzZHAucHVzaCgndWZyYWcnKTtcbiAgICBzZHAucHVzaChjYW5kaWRhdGUudXNlcm5hbWVGcmFnbWVudCB8fCBjYW5kaWRhdGUudWZyYWcpO1xuICB9XG4gIHJldHVybiAnY2FuZGlkYXRlOicgKyBzZHAuam9pbignICcpO1xufTtcblxuLy8gUGFyc2VzIGFuIGljZS1vcHRpb25zIGxpbmUsIHJldHVybnMgYW4gYXJyYXkgb2Ygb3B0aW9uIHRhZ3MuXG4vLyBTYW1wbGUgaW5wdXQ6XG4vLyBhPWljZS1vcHRpb25zOmZvbyBiYXJcblNEUFV0aWxzLnBhcnNlSWNlT3B0aW9ucyA9IGZ1bmN0aW9uKGxpbmUpIHtcbiAgcmV0dXJuIGxpbmUuc3Vic3RyaW5nKDE0KS5zcGxpdCgnICcpO1xufTtcblxuLy8gUGFyc2VzIGEgcnRwbWFwIGxpbmUsIHJldHVybnMgUlRDUnRwQ29kZGVjUGFyYW1ldGVycy4gU2FtcGxlIGlucHV0OlxuLy8gYT1ydHBtYXA6MTExIG9wdXMvNDgwMDAvMlxuU0RQVXRpbHMucGFyc2VSdHBNYXAgPSBmdW5jdGlvbihsaW5lKSB7XG4gIGxldCBwYXJ0cyA9IGxpbmUuc3Vic3RyaW5nKDkpLnNwbGl0KCcgJyk7XG4gIGNvbnN0IHBhcnNlZCA9IHtcbiAgICBwYXlsb2FkVHlwZTogcGFyc2VJbnQocGFydHMuc2hpZnQoKSwgMTApLCAvLyB3YXM6IGlkXG4gIH07XG5cbiAgcGFydHMgPSBwYXJ0c1swXS5zcGxpdCgnLycpO1xuXG4gIHBhcnNlZC5uYW1lID0gcGFydHNbMF07XG4gIHBhcnNlZC5jbG9ja1JhdGUgPSBwYXJzZUludChwYXJ0c1sxXSwgMTApOyAvLyB3YXM6IGNsb2NrcmF0ZVxuICBwYXJzZWQuY2hhbm5lbHMgPSBwYXJ0cy5sZW5ndGggPT09IDMgPyBwYXJzZUludChwYXJ0c1syXSwgMTApIDogMTtcbiAgLy8gbGVnYWN5IGFsaWFzLCBnb3QgcmVuYW1lZCBiYWNrIHRvIGNoYW5uZWxzIGluIE9SVEMuXG4gIHBhcnNlZC5udW1DaGFubmVscyA9IHBhcnNlZC5jaGFubmVscztcbiAgcmV0dXJuIHBhcnNlZDtcbn07XG5cbi8vIEdlbmVyYXRlcyBhIHJ0cG1hcCBsaW5lIGZyb20gUlRDUnRwQ29kZWNDYXBhYmlsaXR5IG9yXG4vLyBSVENSdHBDb2RlY1BhcmFtZXRlcnMuXG5TRFBVdGlscy53cml0ZVJ0cE1hcCA9IGZ1bmN0aW9uKGNvZGVjKSB7XG4gIGxldCBwdCA9IGNvZGVjLnBheWxvYWRUeXBlO1xuICBpZiAoY29kZWMucHJlZmVycmVkUGF5bG9hZFR5cGUgIT09IHVuZGVmaW5lZCkge1xuICAgIHB0ID0gY29kZWMucHJlZmVycmVkUGF5bG9hZFR5cGU7XG4gIH1cbiAgY29uc3QgY2hhbm5lbHMgPSBjb2RlYy5jaGFubmVscyB8fCBjb2RlYy5udW1DaGFubmVscyB8fCAxO1xuICByZXR1cm4gJ2E9cnRwbWFwOicgKyBwdCArICcgJyArIGNvZGVjLm5hbWUgKyAnLycgKyBjb2RlYy5jbG9ja1JhdGUgK1xuICAgICAgKGNoYW5uZWxzICE9PSAxID8gJy8nICsgY2hhbm5lbHMgOiAnJykgKyAnXFxyXFxuJztcbn07XG5cbi8vIFBhcnNlcyBhIGV4dG1hcCBsaW5lIChoZWFkZXJleHRlbnNpb24gZnJvbSBSRkMgNTI4NSkuIFNhbXBsZSBpbnB1dDpcbi8vIGE9ZXh0bWFwOjIgdXJuOmlldGY6cGFyYW1zOnJ0cC1oZHJleHQ6dG9mZnNldFxuLy8gYT1leHRtYXA6Mi9zZW5kb25seSB1cm46aWV0ZjpwYXJhbXM6cnRwLWhkcmV4dDp0b2Zmc2V0XG5TRFBVdGlscy5wYXJzZUV4dG1hcCA9IGZ1bmN0aW9uKGxpbmUpIHtcbiAgY29uc3QgcGFydHMgPSBsaW5lLnN1YnN0cmluZyg5KS5zcGxpdCgnICcpO1xuICByZXR1cm4ge1xuICAgIGlkOiBwYXJzZUludChwYXJ0c1swXSwgMTApLFxuICAgIGRpcmVjdGlvbjogcGFydHNbMF0uaW5kZXhPZignLycpID4gMCA/IHBhcnRzWzBdLnNwbGl0KCcvJylbMV0gOiAnc2VuZHJlY3YnLFxuICAgIHVyaTogcGFydHNbMV0sXG4gICAgYXR0cmlidXRlczogcGFydHMuc2xpY2UoMikuam9pbignICcpLFxuICB9O1xufTtcblxuLy8gR2VuZXJhdGVzIGFuIGV4dG1hcCBsaW5lIGZyb20gUlRDUnRwSGVhZGVyRXh0ZW5zaW9uUGFyYW1ldGVycyBvclxuLy8gUlRDUnRwSGVhZGVyRXh0ZW5zaW9uLlxuU0RQVXRpbHMud3JpdGVFeHRtYXAgPSBmdW5jdGlvbihoZWFkZXJFeHRlbnNpb24pIHtcbiAgcmV0dXJuICdhPWV4dG1hcDonICsgKGhlYWRlckV4dGVuc2lvbi5pZCB8fCBoZWFkZXJFeHRlbnNpb24ucHJlZmVycmVkSWQpICtcbiAgICAgIChoZWFkZXJFeHRlbnNpb24uZGlyZWN0aW9uICYmIGhlYWRlckV4dGVuc2lvbi5kaXJlY3Rpb24gIT09ICdzZW5kcmVjdidcbiAgICAgICAgPyAnLycgKyBoZWFkZXJFeHRlbnNpb24uZGlyZWN0aW9uXG4gICAgICAgIDogJycpICtcbiAgICAgICcgJyArIGhlYWRlckV4dGVuc2lvbi51cmkgK1xuICAgICAgKGhlYWRlckV4dGVuc2lvbi5hdHRyaWJ1dGVzID8gJyAnICsgaGVhZGVyRXh0ZW5zaW9uLmF0dHJpYnV0ZXMgOiAnJykgK1xuICAgICAgJ1xcclxcbic7XG59O1xuXG4vLyBQYXJzZXMgYSBmbXRwIGxpbmUsIHJldHVybnMgZGljdGlvbmFyeS4gU2FtcGxlIGlucHV0OlxuLy8gYT1mbXRwOjk2IHZicj1vbjtjbmc9b25cbi8vIEFsc28gZGVhbHMgd2l0aCB2YnI9b247IGNuZz1vblxuU0RQVXRpbHMucGFyc2VGbXRwID0gZnVuY3Rpb24obGluZSkge1xuICBjb25zdCBwYXJzZWQgPSB7fTtcbiAgbGV0IGt2O1xuICBjb25zdCBwYXJ0cyA9IGxpbmUuc3Vic3RyaW5nKGxpbmUuaW5kZXhPZignICcpICsgMSkuc3BsaXQoJzsnKTtcbiAgZm9yIChsZXQgaiA9IDA7IGogPCBwYXJ0cy5sZW5ndGg7IGorKykge1xuICAgIGt2ID0gcGFydHNbal0udHJpbSgpLnNwbGl0KCc9Jyk7XG4gICAgcGFyc2VkW2t2WzBdLnRyaW0oKV0gPSBrdlsxXTtcbiAgfVxuICByZXR1cm4gcGFyc2VkO1xufTtcblxuLy8gR2VuZXJhdGVzIGEgZm10cCBsaW5lIGZyb20gUlRDUnRwQ29kZWNDYXBhYmlsaXR5IG9yIFJUQ1J0cENvZGVjUGFyYW1ldGVycy5cblNEUFV0aWxzLndyaXRlRm10cCA9IGZ1bmN0aW9uKGNvZGVjKSB7XG4gIGxldCBsaW5lID0gJyc7XG4gIGxldCBwdCA9IGNvZGVjLnBheWxvYWRUeXBlO1xuICBpZiAoY29kZWMucHJlZmVycmVkUGF5bG9hZFR5cGUgIT09IHVuZGVmaW5lZCkge1xuICAgIHB0ID0gY29kZWMucHJlZmVycmVkUGF5bG9hZFR5cGU7XG4gIH1cbiAgaWYgKGNvZGVjLnBhcmFtZXRlcnMgJiYgT2JqZWN0LmtleXMoY29kZWMucGFyYW1ldGVycykubGVuZ3RoKSB7XG4gICAgY29uc3QgcGFyYW1zID0gW107XG4gICAgT2JqZWN0LmtleXMoY29kZWMucGFyYW1ldGVycykuZm9yRWFjaChwYXJhbSA9PiB7XG4gICAgICBpZiAoY29kZWMucGFyYW1ldGVyc1twYXJhbV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwYXJhbXMucHVzaChwYXJhbSArICc9JyArIGNvZGVjLnBhcmFtZXRlcnNbcGFyYW1dKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcmFtcy5wdXNoKHBhcmFtKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBsaW5lICs9ICdhPWZtdHA6JyArIHB0ICsgJyAnICsgcGFyYW1zLmpvaW4oJzsnKSArICdcXHJcXG4nO1xuICB9XG4gIHJldHVybiBsaW5lO1xufTtcblxuLy8gUGFyc2VzIGEgcnRjcC1mYiBsaW5lLCByZXR1cm5zIFJUQ1BSdGNwRmVlZGJhY2sgb2JqZWN0LiBTYW1wbGUgaW5wdXQ6XG4vLyBhPXJ0Y3AtZmI6OTggbmFjayBycHNpXG5TRFBVdGlscy5wYXJzZVJ0Y3BGYiA9IGZ1bmN0aW9uKGxpbmUpIHtcbiAgY29uc3QgcGFydHMgPSBsaW5lLnN1YnN0cmluZyhsaW5lLmluZGV4T2YoJyAnKSArIDEpLnNwbGl0KCcgJyk7XG4gIHJldHVybiB7XG4gICAgdHlwZTogcGFydHMuc2hpZnQoKSxcbiAgICBwYXJhbWV0ZXI6IHBhcnRzLmpvaW4oJyAnKSxcbiAgfTtcbn07XG5cbi8vIEdlbmVyYXRlIGE9cnRjcC1mYiBsaW5lcyBmcm9tIFJUQ1J0cENvZGVjQ2FwYWJpbGl0eSBvciBSVENSdHBDb2RlY1BhcmFtZXRlcnMuXG5TRFBVdGlscy53cml0ZVJ0Y3BGYiA9IGZ1bmN0aW9uKGNvZGVjKSB7XG4gIGxldCBsaW5lcyA9ICcnO1xuICBsZXQgcHQgPSBjb2RlYy5wYXlsb2FkVHlwZTtcbiAgaWYgKGNvZGVjLnByZWZlcnJlZFBheWxvYWRUeXBlICE9PSB1bmRlZmluZWQpIHtcbiAgICBwdCA9IGNvZGVjLnByZWZlcnJlZFBheWxvYWRUeXBlO1xuICB9XG4gIGlmIChjb2RlYy5ydGNwRmVlZGJhY2sgJiYgY29kZWMucnRjcEZlZWRiYWNrLmxlbmd0aCkge1xuICAgIC8vIEZJWE1FOiBzcGVjaWFsIGhhbmRsaW5nIGZvciB0cnItaW50P1xuICAgIGNvZGVjLnJ0Y3BGZWVkYmFjay5mb3JFYWNoKGZiID0+IHtcbiAgICAgIGxpbmVzICs9ICdhPXJ0Y3AtZmI6JyArIHB0ICsgJyAnICsgZmIudHlwZSArXG4gICAgICAoZmIucGFyYW1ldGVyICYmIGZiLnBhcmFtZXRlci5sZW5ndGggPyAnICcgKyBmYi5wYXJhbWV0ZXIgOiAnJykgK1xuICAgICAgICAgICdcXHJcXG4nO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBsaW5lcztcbn07XG5cbi8vIFBhcnNlcyBhIFJGQyA1NTc2IHNzcmMgbWVkaWEgYXR0cmlidXRlLiBTYW1wbGUgaW5wdXQ6XG4vLyBhPXNzcmM6MzczNTkyODU1OSBjbmFtZTpzb21ldGhpbmdcblNEUFV0aWxzLnBhcnNlU3NyY01lZGlhID0gZnVuY3Rpb24obGluZSkge1xuICBjb25zdCBzcCA9IGxpbmUuaW5kZXhPZignICcpO1xuICBjb25zdCBwYXJ0cyA9IHtcbiAgICBzc3JjOiBwYXJzZUludChsaW5lLnN1YnN0cmluZyg3LCBzcCksIDEwKSxcbiAgfTtcbiAgY29uc3QgY29sb24gPSBsaW5lLmluZGV4T2YoJzonLCBzcCk7XG4gIGlmIChjb2xvbiA+IC0xKSB7XG4gICAgcGFydHMuYXR0cmlidXRlID0gbGluZS5zdWJzdHJpbmcoc3AgKyAxLCBjb2xvbik7XG4gICAgcGFydHMudmFsdWUgPSBsaW5lLnN1YnN0cmluZyhjb2xvbiArIDEpO1xuICB9IGVsc2Uge1xuICAgIHBhcnRzLmF0dHJpYnV0ZSA9IGxpbmUuc3Vic3RyaW5nKHNwICsgMSk7XG4gIH1cbiAgcmV0dXJuIHBhcnRzO1xufTtcblxuLy8gUGFyc2UgYSBzc3JjLWdyb3VwIGxpbmUgKHNlZSBSRkMgNTU3NikuIFNhbXBsZSBpbnB1dDpcbi8vIGE9c3NyYy1ncm91cDpzZW1hbnRpY3MgMTIgMzRcblNEUFV0aWxzLnBhcnNlU3NyY0dyb3VwID0gZnVuY3Rpb24obGluZSkge1xuICBjb25zdCBwYXJ0cyA9IGxpbmUuc3Vic3RyaW5nKDEzKS5zcGxpdCgnICcpO1xuICByZXR1cm4ge1xuICAgIHNlbWFudGljczogcGFydHMuc2hpZnQoKSxcbiAgICBzc3JjczogcGFydHMubWFwKHNzcmMgPT4gcGFyc2VJbnQoc3NyYywgMTApKSxcbiAgfTtcbn07XG5cbi8vIEV4dHJhY3RzIHRoZSBNSUQgKFJGQyA1ODg4KSBmcm9tIGEgbWVkaWEgc2VjdGlvbi5cbi8vIFJldHVybnMgdGhlIE1JRCBvciB1bmRlZmluZWQgaWYgbm8gbWlkIGxpbmUgd2FzIGZvdW5kLlxuU0RQVXRpbHMuZ2V0TWlkID0gZnVuY3Rpb24obWVkaWFTZWN0aW9uKSB7XG4gIGNvbnN0IG1pZCA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KG1lZGlhU2VjdGlvbiwgJ2E9bWlkOicpWzBdO1xuICBpZiAobWlkKSB7XG4gICAgcmV0dXJuIG1pZC5zdWJzdHJpbmcoNik7XG4gIH1cbn07XG5cbi8vIFBhcnNlcyBhIGZpbmdlcnByaW50IGxpbmUgZm9yIERUTFMtU1JUUC5cblNEUFV0aWxzLnBhcnNlRmluZ2VycHJpbnQgPSBmdW5jdGlvbihsaW5lKSB7XG4gIGNvbnN0IHBhcnRzID0gbGluZS5zdWJzdHJpbmcoMTQpLnNwbGl0KCcgJyk7XG4gIHJldHVybiB7XG4gICAgYWxnb3JpdGhtOiBwYXJ0c1swXS50b0xvd2VyQ2FzZSgpLCAvLyBhbGdvcml0aG0gaXMgY2FzZS1zZW5zaXRpdmUgaW4gRWRnZS5cbiAgICB2YWx1ZTogcGFydHNbMV0udG9VcHBlckNhc2UoKSwgLy8gdGhlIGRlZmluaXRpb24gaXMgdXBwZXItY2FzZSBpbiBSRkMgNDU3Mi5cbiAgfTtcbn07XG5cbi8vIEV4dHJhY3RzIERUTFMgcGFyYW1ldGVycyBmcm9tIFNEUCBtZWRpYSBzZWN0aW9uIG9yIHNlc3Npb25wYXJ0LlxuLy8gRklYTUU6IGZvciBjb25zaXN0ZW5jeSB3aXRoIG90aGVyIGZ1bmN0aW9ucyB0aGlzIHNob3VsZCBvbmx5XG4vLyAgIGdldCB0aGUgZmluZ2VycHJpbnQgbGluZSBhcyBpbnB1dC4gU2VlIGFsc28gZ2V0SWNlUGFyYW1ldGVycy5cblNEUFV0aWxzLmdldER0bHNQYXJhbWV0ZXJzID0gZnVuY3Rpb24obWVkaWFTZWN0aW9uLCBzZXNzaW9ucGFydCkge1xuICBjb25zdCBsaW5lcyA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KG1lZGlhU2VjdGlvbiArIHNlc3Npb25wYXJ0LFxuICAgICdhPWZpbmdlcnByaW50OicpO1xuICAvLyBOb3RlOiBhPXNldHVwIGxpbmUgaXMgaWdub3JlZCBzaW5jZSB3ZSB1c2UgdGhlICdhdXRvJyByb2xlIGluIEVkZ2UuXG4gIHJldHVybiB7XG4gICAgcm9sZTogJ2F1dG8nLFxuICAgIGZpbmdlcnByaW50czogbGluZXMubWFwKFNEUFV0aWxzLnBhcnNlRmluZ2VycHJpbnQpLFxuICB9O1xufTtcblxuLy8gU2VyaWFsaXplcyBEVExTIHBhcmFtZXRlcnMgdG8gU0RQLlxuU0RQVXRpbHMud3JpdGVEdGxzUGFyYW1ldGVycyA9IGZ1bmN0aW9uKHBhcmFtcywgc2V0dXBUeXBlKSB7XG4gIGxldCBzZHAgPSAnYT1zZXR1cDonICsgc2V0dXBUeXBlICsgJ1xcclxcbic7XG4gIHBhcmFtcy5maW5nZXJwcmludHMuZm9yRWFjaChmcCA9PiB7XG4gICAgc2RwICs9ICdhPWZpbmdlcnByaW50OicgKyBmcC5hbGdvcml0aG0gKyAnICcgKyBmcC52YWx1ZSArICdcXHJcXG4nO1xuICB9KTtcbiAgcmV0dXJuIHNkcDtcbn07XG5cbi8vIFBhcnNlcyBhPWNyeXB0byBsaW5lcyBpbnRvXG4vLyAgIGh0dHBzOi8vcmF3Z2l0LmNvbS9hYm9iYS9lZGdlcnRjL21hc3Rlci9tc29ydGMtcnM0Lmh0bWwjZGljdGlvbmFyeS1ydGNzcnRwc2Rlc3BhcmFtZXRlcnMtbWVtYmVyc1xuU0RQVXRpbHMucGFyc2VDcnlwdG9MaW5lID0gZnVuY3Rpb24obGluZSkge1xuICBjb25zdCBwYXJ0cyA9IGxpbmUuc3Vic3RyaW5nKDkpLnNwbGl0KCcgJyk7XG4gIHJldHVybiB7XG4gICAgdGFnOiBwYXJzZUludChwYXJ0c1swXSwgMTApLFxuICAgIGNyeXB0b1N1aXRlOiBwYXJ0c1sxXSxcbiAgICBrZXlQYXJhbXM6IHBhcnRzWzJdLFxuICAgIHNlc3Npb25QYXJhbXM6IHBhcnRzLnNsaWNlKDMpLFxuICB9O1xufTtcblxuU0RQVXRpbHMud3JpdGVDcnlwdG9MaW5lID0gZnVuY3Rpb24ocGFyYW1ldGVycykge1xuICByZXR1cm4gJ2E9Y3J5cHRvOicgKyBwYXJhbWV0ZXJzLnRhZyArICcgJyArXG4gICAgcGFyYW1ldGVycy5jcnlwdG9TdWl0ZSArICcgJyArXG4gICAgKHR5cGVvZiBwYXJhbWV0ZXJzLmtleVBhcmFtcyA9PT0gJ29iamVjdCdcbiAgICAgID8gU0RQVXRpbHMud3JpdGVDcnlwdG9LZXlQYXJhbXMocGFyYW1ldGVycy5rZXlQYXJhbXMpXG4gICAgICA6IHBhcmFtZXRlcnMua2V5UGFyYW1zKSArXG4gICAgKHBhcmFtZXRlcnMuc2Vzc2lvblBhcmFtcyA/ICcgJyArIHBhcmFtZXRlcnMuc2Vzc2lvblBhcmFtcy5qb2luKCcgJykgOiAnJykgK1xuICAgICdcXHJcXG4nO1xufTtcblxuLy8gUGFyc2VzIHRoZSBjcnlwdG8ga2V5IHBhcmFtZXRlcnMgaW50b1xuLy8gICBodHRwczovL3Jhd2dpdC5jb20vYWJvYmEvZWRnZXJ0Yy9tYXN0ZXIvbXNvcnRjLXJzNC5odG1sI3J0Y3NydHBrZXlwYXJhbSpcblNEUFV0aWxzLnBhcnNlQ3J5cHRvS2V5UGFyYW1zID0gZnVuY3Rpb24oa2V5UGFyYW1zKSB7XG4gIGlmIChrZXlQYXJhbXMuaW5kZXhPZignaW5saW5lOicpICE9PSAwKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3QgcGFydHMgPSBrZXlQYXJhbXMuc3Vic3RyaW5nKDcpLnNwbGl0KCd8Jyk7XG4gIHJldHVybiB7XG4gICAga2V5TWV0aG9kOiAnaW5saW5lJyxcbiAgICBrZXlTYWx0OiBwYXJ0c1swXSxcbiAgICBsaWZlVGltZTogcGFydHNbMV0sXG4gICAgbWtpVmFsdWU6IHBhcnRzWzJdID8gcGFydHNbMl0uc3BsaXQoJzonKVswXSA6IHVuZGVmaW5lZCxcbiAgICBta2lMZW5ndGg6IHBhcnRzWzJdID8gcGFydHNbMl0uc3BsaXQoJzonKVsxXSA6IHVuZGVmaW5lZCxcbiAgfTtcbn07XG5cblNEUFV0aWxzLndyaXRlQ3J5cHRvS2V5UGFyYW1zID0gZnVuY3Rpb24oa2V5UGFyYW1zKSB7XG4gIHJldHVybiBrZXlQYXJhbXMua2V5TWV0aG9kICsgJzonXG4gICAgKyBrZXlQYXJhbXMua2V5U2FsdCArXG4gICAgKGtleVBhcmFtcy5saWZlVGltZSA/ICd8JyArIGtleVBhcmFtcy5saWZlVGltZSA6ICcnKSArXG4gICAgKGtleVBhcmFtcy5ta2lWYWx1ZSAmJiBrZXlQYXJhbXMubWtpTGVuZ3RoXG4gICAgICA/ICd8JyArIGtleVBhcmFtcy5ta2lWYWx1ZSArICc6JyArIGtleVBhcmFtcy5ta2lMZW5ndGhcbiAgICAgIDogJycpO1xufTtcblxuLy8gRXh0cmFjdHMgYWxsIFNERVMgcGFyYW1ldGVycy5cblNEUFV0aWxzLmdldENyeXB0b1BhcmFtZXRlcnMgPSBmdW5jdGlvbihtZWRpYVNlY3Rpb24sIHNlc3Npb25wYXJ0KSB7XG4gIGNvbnN0IGxpbmVzID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgobWVkaWFTZWN0aW9uICsgc2Vzc2lvbnBhcnQsXG4gICAgJ2E9Y3J5cHRvOicpO1xuICByZXR1cm4gbGluZXMubWFwKFNEUFV0aWxzLnBhcnNlQ3J5cHRvTGluZSk7XG59O1xuXG4vLyBQYXJzZXMgSUNFIGluZm9ybWF0aW9uIGZyb20gU0RQIG1lZGlhIHNlY3Rpb24gb3Igc2Vzc2lvbnBhcnQuXG4vLyBGSVhNRTogZm9yIGNvbnNpc3RlbmN5IHdpdGggb3RoZXIgZnVuY3Rpb25zIHRoaXMgc2hvdWxkIG9ubHlcbi8vICAgZ2V0IHRoZSBpY2UtdWZyYWcgYW5kIGljZS1wd2QgbGluZXMgYXMgaW5wdXQuXG5TRFBVdGlscy5nZXRJY2VQYXJhbWV0ZXJzID0gZnVuY3Rpb24obWVkaWFTZWN0aW9uLCBzZXNzaW9ucGFydCkge1xuICBjb25zdCB1ZnJhZyA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KG1lZGlhU2VjdGlvbiArIHNlc3Npb25wYXJ0LFxuICAgICdhPWljZS11ZnJhZzonKVswXTtcbiAgY29uc3QgcHdkID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgobWVkaWFTZWN0aW9uICsgc2Vzc2lvbnBhcnQsXG4gICAgJ2E9aWNlLXB3ZDonKVswXTtcbiAgaWYgKCEodWZyYWcgJiYgcHdkKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiB7XG4gICAgdXNlcm5hbWVGcmFnbWVudDogdWZyYWcuc3Vic3RyaW5nKDEyKSxcbiAgICBwYXNzd29yZDogcHdkLnN1YnN0cmluZygxMCksXG4gIH07XG59O1xuXG4vLyBTZXJpYWxpemVzIElDRSBwYXJhbWV0ZXJzIHRvIFNEUC5cblNEUFV0aWxzLndyaXRlSWNlUGFyYW1ldGVycyA9IGZ1bmN0aW9uKHBhcmFtcykge1xuICBsZXQgc2RwID0gJ2E9aWNlLXVmcmFnOicgKyBwYXJhbXMudXNlcm5hbWVGcmFnbWVudCArICdcXHJcXG4nICtcbiAgICAgICdhPWljZS1wd2Q6JyArIHBhcmFtcy5wYXNzd29yZCArICdcXHJcXG4nO1xuICBpZiAocGFyYW1zLmljZUxpdGUpIHtcbiAgICBzZHAgKz0gJ2E9aWNlLWxpdGVcXHJcXG4nO1xuICB9XG4gIHJldHVybiBzZHA7XG59O1xuXG4vLyBQYXJzZXMgdGhlIFNEUCBtZWRpYSBzZWN0aW9uIGFuZCByZXR1cm5zIFJUQ1J0cFBhcmFtZXRlcnMuXG5TRFBVdGlscy5wYXJzZVJ0cFBhcmFtZXRlcnMgPSBmdW5jdGlvbihtZWRpYVNlY3Rpb24pIHtcbiAgY29uc3QgZGVzY3JpcHRpb24gPSB7XG4gICAgY29kZWNzOiBbXSxcbiAgICBoZWFkZXJFeHRlbnNpb25zOiBbXSxcbiAgICBmZWNNZWNoYW5pc21zOiBbXSxcbiAgICBydGNwOiBbXSxcbiAgfTtcbiAgY29uc3QgbGluZXMgPSBTRFBVdGlscy5zcGxpdExpbmVzKG1lZGlhU2VjdGlvbik7XG4gIGNvbnN0IG1saW5lID0gbGluZXNbMF0uc3BsaXQoJyAnKTtcbiAgZGVzY3JpcHRpb24ucHJvZmlsZSA9IG1saW5lWzJdO1xuICBmb3IgKGxldCBpID0gMzsgaSA8IG1saW5lLmxlbmd0aDsgaSsrKSB7IC8vIGZpbmQgYWxsIGNvZGVjcyBmcm9tIG1saW5lWzMuLl1cbiAgICBjb25zdCBwdCA9IG1saW5lW2ldO1xuICAgIGNvbnN0IHJ0cG1hcGxpbmUgPSBTRFBVdGlscy5tYXRjaFByZWZpeChcbiAgICAgIG1lZGlhU2VjdGlvbiwgJ2E9cnRwbWFwOicgKyBwdCArICcgJylbMF07XG4gICAgaWYgKHJ0cG1hcGxpbmUpIHtcbiAgICAgIGNvbnN0IGNvZGVjID0gU0RQVXRpbHMucGFyc2VSdHBNYXAocnRwbWFwbGluZSk7XG4gICAgICBjb25zdCBmbXRwcyA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KFxuICAgICAgICBtZWRpYVNlY3Rpb24sICdhPWZtdHA6JyArIHB0ICsgJyAnKTtcbiAgICAgIC8vIE9ubHkgdGhlIGZpcnN0IGE9Zm10cDo8cHQ+IGlzIGNvbnNpZGVyZWQuXG4gICAgICBjb2RlYy5wYXJhbWV0ZXJzID0gZm10cHMubGVuZ3RoID8gU0RQVXRpbHMucGFyc2VGbXRwKGZtdHBzWzBdKSA6IHt9O1xuICAgICAgY29kZWMucnRjcEZlZWRiYWNrID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgoXG4gICAgICAgIG1lZGlhU2VjdGlvbiwgJ2E9cnRjcC1mYjonICsgcHQgKyAnICcpXG4gICAgICAgIC5tYXAoU0RQVXRpbHMucGFyc2VSdGNwRmIpO1xuICAgICAgZGVzY3JpcHRpb24uY29kZWNzLnB1c2goY29kZWMpO1xuICAgICAgLy8gcGFyc2UgRkVDIG1lY2hhbmlzbXMgZnJvbSBydHBtYXAgbGluZXMuXG4gICAgICBzd2l0Y2ggKGNvZGVjLm5hbWUudG9VcHBlckNhc2UoKSkge1xuICAgICAgICBjYXNlICdSRUQnOlxuICAgICAgICBjYXNlICdVTFBGRUMnOlxuICAgICAgICAgIGRlc2NyaXB0aW9uLmZlY01lY2hhbmlzbXMucHVzaChjb2RlYy5uYW1lLnRvVXBwZXJDYXNlKCkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OiAvLyBvbmx5IFJFRCBhbmQgVUxQRkVDIGFyZSByZWNvZ25pemVkIGFzIEZFQyBtZWNoYW5pc21zLlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24sICdhPWV4dG1hcDonKS5mb3JFYWNoKGxpbmUgPT4ge1xuICAgIGRlc2NyaXB0aW9uLmhlYWRlckV4dGVuc2lvbnMucHVzaChTRFBVdGlscy5wYXJzZUV4dG1hcChsaW5lKSk7XG4gIH0pO1xuICBjb25zdCB3aWxkY2FyZFJ0Y3BGYiA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KG1lZGlhU2VjdGlvbiwgJ2E9cnRjcC1mYjoqICcpXG4gICAgLm1hcChTRFBVdGlscy5wYXJzZVJ0Y3BGYik7XG4gIGRlc2NyaXB0aW9uLmNvZGVjcy5mb3JFYWNoKGNvZGVjID0+IHtcbiAgICB3aWxkY2FyZFJ0Y3BGYi5mb3JFYWNoKGZiPT4ge1xuICAgICAgY29uc3QgZHVwbGljYXRlID0gY29kZWMucnRjcEZlZWRiYWNrLmZpbmQoZXhpc3RpbmdGZWVkYmFjayA9PiB7XG4gICAgICAgIHJldHVybiBleGlzdGluZ0ZlZWRiYWNrLnR5cGUgPT09IGZiLnR5cGUgJiZcbiAgICAgICAgICBleGlzdGluZ0ZlZWRiYWNrLnBhcmFtZXRlciA9PT0gZmIucGFyYW1ldGVyO1xuICAgICAgfSk7XG4gICAgICBpZiAoIWR1cGxpY2F0ZSkge1xuICAgICAgICBjb2RlYy5ydGNwRmVlZGJhY2sucHVzaChmYik7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuICAvLyBGSVhNRTogcGFyc2UgcnRjcC5cbiAgcmV0dXJuIGRlc2NyaXB0aW9uO1xufTtcblxuLy8gR2VuZXJhdGVzIHBhcnRzIG9mIHRoZSBTRFAgbWVkaWEgc2VjdGlvbiBkZXNjcmliaW5nIHRoZSBjYXBhYmlsaXRpZXMgL1xuLy8gcGFyYW1ldGVycy5cblNEUFV0aWxzLndyaXRlUnRwRGVzY3JpcHRpb24gPSBmdW5jdGlvbihraW5kLCBjYXBzKSB7XG4gIGxldCBzZHAgPSAnJztcblxuICAvLyBCdWlsZCB0aGUgbWxpbmUuXG4gIHNkcCArPSAnbT0nICsga2luZCArICcgJztcbiAgc2RwICs9IGNhcHMuY29kZWNzLmxlbmd0aCA+IDAgPyAnOScgOiAnMCc7IC8vIHJlamVjdCBpZiBubyBjb2RlY3MuXG4gIHNkcCArPSAnICcgKyAoY2Fwcy5wcm9maWxlIHx8ICdVRFAvVExTL1JUUC9TQVZQRicpICsgJyAnO1xuICBzZHAgKz0gY2Fwcy5jb2RlY3MubWFwKGNvZGVjID0+IHtcbiAgICBpZiAoY29kZWMucHJlZmVycmVkUGF5bG9hZFR5cGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGNvZGVjLnByZWZlcnJlZFBheWxvYWRUeXBlO1xuICAgIH1cbiAgICByZXR1cm4gY29kZWMucGF5bG9hZFR5cGU7XG4gIH0pLmpvaW4oJyAnKSArICdcXHJcXG4nO1xuXG4gIHNkcCArPSAnYz1JTiBJUDQgMC4wLjAuMFxcclxcbic7XG4gIHNkcCArPSAnYT1ydGNwOjkgSU4gSVA0IDAuMC4wLjBcXHJcXG4nO1xuXG4gIC8vIEFkZCBhPXJ0cG1hcCBsaW5lcyBmb3IgZWFjaCBjb2RlYy4gQWxzbyBmbXRwIGFuZCBydGNwLWZiLlxuICBjYXBzLmNvZGVjcy5mb3JFYWNoKGNvZGVjID0+IHtcbiAgICBzZHAgKz0gU0RQVXRpbHMud3JpdGVSdHBNYXAoY29kZWMpO1xuICAgIHNkcCArPSBTRFBVdGlscy53cml0ZUZtdHAoY29kZWMpO1xuICAgIHNkcCArPSBTRFBVdGlscy53cml0ZVJ0Y3BGYihjb2RlYyk7XG4gIH0pO1xuICBsZXQgbWF4cHRpbWUgPSAwO1xuICBjYXBzLmNvZGVjcy5mb3JFYWNoKGNvZGVjID0+IHtcbiAgICBpZiAoY29kZWMubWF4cHRpbWUgPiBtYXhwdGltZSkge1xuICAgICAgbWF4cHRpbWUgPSBjb2RlYy5tYXhwdGltZTtcbiAgICB9XG4gIH0pO1xuICBpZiAobWF4cHRpbWUgPiAwKSB7XG4gICAgc2RwICs9ICdhPW1heHB0aW1lOicgKyBtYXhwdGltZSArICdcXHJcXG4nO1xuICB9XG5cbiAgaWYgKGNhcHMuaGVhZGVyRXh0ZW5zaW9ucykge1xuICAgIGNhcHMuaGVhZGVyRXh0ZW5zaW9ucy5mb3JFYWNoKGV4dGVuc2lvbiA9PiB7XG4gICAgICBzZHAgKz0gU0RQVXRpbHMud3JpdGVFeHRtYXAoZXh0ZW5zaW9uKTtcbiAgICB9KTtcbiAgfVxuICAvLyBGSVhNRTogd3JpdGUgZmVjTWVjaGFuaXNtcy5cbiAgcmV0dXJuIHNkcDtcbn07XG5cbi8vIFBhcnNlcyB0aGUgU0RQIG1lZGlhIHNlY3Rpb24gYW5kIHJldHVybnMgYW4gYXJyYXkgb2Zcbi8vIFJUQ1J0cEVuY29kaW5nUGFyYW1ldGVycy5cblNEUFV0aWxzLnBhcnNlUnRwRW5jb2RpbmdQYXJhbWV0ZXJzID0gZnVuY3Rpb24obWVkaWFTZWN0aW9uKSB7XG4gIGNvbnN0IGVuY29kaW5nUGFyYW1ldGVycyA9IFtdO1xuICBjb25zdCBkZXNjcmlwdGlvbiA9IFNEUFV0aWxzLnBhcnNlUnRwUGFyYW1ldGVycyhtZWRpYVNlY3Rpb24pO1xuICBjb25zdCBoYXNSZWQgPSBkZXNjcmlwdGlvbi5mZWNNZWNoYW5pc21zLmluZGV4T2YoJ1JFRCcpICE9PSAtMTtcbiAgY29uc3QgaGFzVWxwZmVjID0gZGVzY3JpcHRpb24uZmVjTWVjaGFuaXNtcy5pbmRleE9mKCdVTFBGRUMnKSAhPT0gLTE7XG5cbiAgLy8gZmlsdGVyIGE9c3NyYzouLi4gY25hbWU6LCBpZ25vcmUgUGxhbkItbXNpZFxuICBjb25zdCBzc3JjcyA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KG1lZGlhU2VjdGlvbiwgJ2E9c3NyYzonKVxuICAgIC5tYXAobGluZSA9PiBTRFBVdGlscy5wYXJzZVNzcmNNZWRpYShsaW5lKSlcbiAgICAuZmlsdGVyKHBhcnRzID0+IHBhcnRzLmF0dHJpYnV0ZSA9PT0gJ2NuYW1lJyk7XG4gIGNvbnN0IHByaW1hcnlTc3JjID0gc3NyY3MubGVuZ3RoID4gMCAmJiBzc3Jjc1swXS5zc3JjO1xuICBsZXQgc2Vjb25kYXJ5U3NyYztcblxuICBjb25zdCBmbG93cyA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KG1lZGlhU2VjdGlvbiwgJ2E9c3NyYy1ncm91cDpGSUQnKVxuICAgIC5tYXAobGluZSA9PiB7XG4gICAgICBjb25zdCBwYXJ0cyA9IGxpbmUuc3Vic3RyaW5nKDE3KS5zcGxpdCgnICcpO1xuICAgICAgcmV0dXJuIHBhcnRzLm1hcChwYXJ0ID0+IHBhcnNlSW50KHBhcnQsIDEwKSk7XG4gICAgfSk7XG4gIGlmIChmbG93cy5sZW5ndGggPiAwICYmIGZsb3dzWzBdLmxlbmd0aCA+IDEgJiYgZmxvd3NbMF1bMF0gPT09IHByaW1hcnlTc3JjKSB7XG4gICAgc2Vjb25kYXJ5U3NyYyA9IGZsb3dzWzBdWzFdO1xuICB9XG5cbiAgZGVzY3JpcHRpb24uY29kZWNzLmZvckVhY2goY29kZWMgPT4ge1xuICAgIGlmIChjb2RlYy5uYW1lLnRvVXBwZXJDYXNlKCkgPT09ICdSVFgnICYmIGNvZGVjLnBhcmFtZXRlcnMuYXB0KSB7XG4gICAgICBsZXQgZW5jUGFyYW0gPSB7XG4gICAgICAgIHNzcmM6IHByaW1hcnlTc3JjLFxuICAgICAgICBjb2RlY1BheWxvYWRUeXBlOiBwYXJzZUludChjb2RlYy5wYXJhbWV0ZXJzLmFwdCwgMTApLFxuICAgICAgfTtcbiAgICAgIGlmIChwcmltYXJ5U3NyYyAmJiBzZWNvbmRhcnlTc3JjKSB7XG4gICAgICAgIGVuY1BhcmFtLnJ0eCA9IHtzc3JjOiBzZWNvbmRhcnlTc3JjfTtcbiAgICAgIH1cbiAgICAgIGVuY29kaW5nUGFyYW1ldGVycy5wdXNoKGVuY1BhcmFtKTtcbiAgICAgIGlmIChoYXNSZWQpIHtcbiAgICAgICAgZW5jUGFyYW0gPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGVuY1BhcmFtKSk7XG4gICAgICAgIGVuY1BhcmFtLmZlYyA9IHtcbiAgICAgICAgICBzc3JjOiBwcmltYXJ5U3NyYyxcbiAgICAgICAgICBtZWNoYW5pc206IGhhc1VscGZlYyA/ICdyZWQrdWxwZmVjJyA6ICdyZWQnLFxuICAgICAgICB9O1xuICAgICAgICBlbmNvZGluZ1BhcmFtZXRlcnMucHVzaChlbmNQYXJhbSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgaWYgKGVuY29kaW5nUGFyYW1ldGVycy5sZW5ndGggPT09IDAgJiYgcHJpbWFyeVNzcmMpIHtcbiAgICBlbmNvZGluZ1BhcmFtZXRlcnMucHVzaCh7XG4gICAgICBzc3JjOiBwcmltYXJ5U3NyYyxcbiAgICB9KTtcbiAgfVxuXG4gIC8vIHdlIHN1cHBvcnQgYm90aCBiPUFTIGFuZCBiPVRJQVMgYnV0IGludGVycHJldCBBUyBhcyBUSUFTLlxuICBsZXQgYmFuZHdpZHRoID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgobWVkaWFTZWN0aW9uLCAnYj0nKTtcbiAgaWYgKGJhbmR3aWR0aC5sZW5ndGgpIHtcbiAgICBpZiAoYmFuZHdpZHRoWzBdLmluZGV4T2YoJ2I9VElBUzonKSA9PT0gMCkge1xuICAgICAgYmFuZHdpZHRoID0gcGFyc2VJbnQoYmFuZHdpZHRoWzBdLnN1YnN0cmluZyg3KSwgMTApO1xuICAgIH0gZWxzZSBpZiAoYmFuZHdpZHRoWzBdLmluZGV4T2YoJ2I9QVM6JykgPT09IDApIHtcbiAgICAgIC8vIHVzZSBmb3JtdWxhIGZyb20gSlNFUCB0byBjb252ZXJ0IGI9QVMgdG8gVElBUyB2YWx1ZS5cbiAgICAgIGJhbmR3aWR0aCA9IHBhcnNlSW50KGJhbmR3aWR0aFswXS5zdWJzdHJpbmcoNSksIDEwKSAqIDEwMDAgKiAwLjk1XG4gICAgICAgICAgLSAoNTAgKiA0MCAqIDgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBiYW5kd2lkdGggPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGVuY29kaW5nUGFyYW1ldGVycy5mb3JFYWNoKHBhcmFtcyA9PiB7XG4gICAgICBwYXJhbXMubWF4Qml0cmF0ZSA9IGJhbmR3aWR0aDtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gZW5jb2RpbmdQYXJhbWV0ZXJzO1xufTtcblxuLy8gcGFyc2VzIGh0dHA6Ly9kcmFmdC5vcnRjLm9yZy8jcnRjcnRjcHBhcmFtZXRlcnMqXG5TRFBVdGlscy5wYXJzZVJ0Y3BQYXJhbWV0ZXJzID0gZnVuY3Rpb24obWVkaWFTZWN0aW9uKSB7XG4gIGNvbnN0IHJ0Y3BQYXJhbWV0ZXJzID0ge307XG5cbiAgLy8gR2V0cyB0aGUgZmlyc3QgU1NSQy4gTm90ZSB0aGF0IHdpdGggUlRYIHRoZXJlIG1pZ2h0IGJlIG11bHRpcGxlXG4gIC8vIFNTUkNzLlxuICBjb25zdCByZW1vdGVTc3JjID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgobWVkaWFTZWN0aW9uLCAnYT1zc3JjOicpXG4gICAgLm1hcChsaW5lID0+IFNEUFV0aWxzLnBhcnNlU3NyY01lZGlhKGxpbmUpKVxuICAgIC5maWx0ZXIob2JqID0+IG9iai5hdHRyaWJ1dGUgPT09ICdjbmFtZScpWzBdO1xuICBpZiAocmVtb3RlU3NyYykge1xuICAgIHJ0Y3BQYXJhbWV0ZXJzLmNuYW1lID0gcmVtb3RlU3NyYy52YWx1ZTtcbiAgICBydGNwUGFyYW1ldGVycy5zc3JjID0gcmVtb3RlU3NyYy5zc3JjO1xuICB9XG5cbiAgLy8gRWRnZSB1c2VzIHRoZSBjb21wb3VuZCBhdHRyaWJ1dGUgaW5zdGVhZCBvZiByZWR1Y2VkU2l6ZVxuICAvLyBjb21wb3VuZCBpcyAhcmVkdWNlZFNpemVcbiAgY29uc3QgcnNpemUgPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24sICdhPXJ0Y3AtcnNpemUnKTtcbiAgcnRjcFBhcmFtZXRlcnMucmVkdWNlZFNpemUgPSByc2l6ZS5sZW5ndGggPiAwO1xuICBydGNwUGFyYW1ldGVycy5jb21wb3VuZCA9IHJzaXplLmxlbmd0aCA9PT0gMDtcblxuICAvLyBwYXJzZXMgdGhlIHJ0Y3AtbXV4IGF0dHLRlmJ1dGUuXG4gIC8vIE5vdGUgdGhhdCBFZGdlIGRvZXMgbm90IHN1cHBvcnQgdW5tdXhlZCBSVENQLlxuICBjb25zdCBtdXggPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24sICdhPXJ0Y3AtbXV4Jyk7XG4gIHJ0Y3BQYXJhbWV0ZXJzLm11eCA9IG11eC5sZW5ndGggPiAwO1xuXG4gIHJldHVybiBydGNwUGFyYW1ldGVycztcbn07XG5cblNEUFV0aWxzLndyaXRlUnRjcFBhcmFtZXRlcnMgPSBmdW5jdGlvbihydGNwUGFyYW1ldGVycykge1xuICBsZXQgc2RwID0gJyc7XG4gIGlmIChydGNwUGFyYW1ldGVycy5yZWR1Y2VkU2l6ZSkge1xuICAgIHNkcCArPSAnYT1ydGNwLXJzaXplXFxyXFxuJztcbiAgfVxuICBpZiAocnRjcFBhcmFtZXRlcnMubXV4KSB7XG4gICAgc2RwICs9ICdhPXJ0Y3AtbXV4XFxyXFxuJztcbiAgfVxuICBpZiAocnRjcFBhcmFtZXRlcnMuc3NyYyAhPT0gdW5kZWZpbmVkICYmIHJ0Y3BQYXJhbWV0ZXJzLmNuYW1lKSB7XG4gICAgc2RwICs9ICdhPXNzcmM6JyArIHJ0Y3BQYXJhbWV0ZXJzLnNzcmMgK1xuICAgICAgJyBjbmFtZTonICsgcnRjcFBhcmFtZXRlcnMuY25hbWUgKyAnXFxyXFxuJztcbiAgfVxuICByZXR1cm4gc2RwO1xufTtcblxuXG4vLyBwYXJzZXMgZWl0aGVyIGE9bXNpZDogb3IgYT1zc3JjOi4uLiBtc2lkIGxpbmVzIGFuZCByZXR1cm5zXG4vLyB0aGUgaWQgb2YgdGhlIE1lZGlhU3RyZWFtIGFuZCBNZWRpYVN0cmVhbVRyYWNrLlxuU0RQVXRpbHMucGFyc2VNc2lkID0gZnVuY3Rpb24obWVkaWFTZWN0aW9uKSB7XG4gIGxldCBwYXJ0cztcbiAgY29uc3Qgc3BlYyA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KG1lZGlhU2VjdGlvbiwgJ2E9bXNpZDonKTtcbiAgaWYgKHNwZWMubGVuZ3RoID09PSAxKSB7XG4gICAgcGFydHMgPSBzcGVjWzBdLnN1YnN0cmluZyg3KS5zcGxpdCgnICcpO1xuICAgIHJldHVybiB7c3RyZWFtOiBwYXJ0c1swXSwgdHJhY2s6IHBhcnRzWzFdfTtcbiAgfVxuICBjb25zdCBwbGFuQiA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KG1lZGlhU2VjdGlvbiwgJ2E9c3NyYzonKVxuICAgIC5tYXAobGluZSA9PiBTRFBVdGlscy5wYXJzZVNzcmNNZWRpYShsaW5lKSlcbiAgICAuZmlsdGVyKG1zaWRQYXJ0cyA9PiBtc2lkUGFydHMuYXR0cmlidXRlID09PSAnbXNpZCcpO1xuICBpZiAocGxhbkIubGVuZ3RoID4gMCkge1xuICAgIHBhcnRzID0gcGxhbkJbMF0udmFsdWUuc3BsaXQoJyAnKTtcbiAgICByZXR1cm4ge3N0cmVhbTogcGFydHNbMF0sIHRyYWNrOiBwYXJ0c1sxXX07XG4gIH1cbn07XG5cbi8vIFNDVFBcbi8vIHBhcnNlcyBkcmFmdC1pZXRmLW1tdXNpYy1zY3RwLXNkcC0yNiBmaXJzdCBhbmQgZmFsbHMgYmFja1xuLy8gdG8gZHJhZnQtaWV0Zi1tbXVzaWMtc2N0cC1zZHAtMDVcblNEUFV0aWxzLnBhcnNlU2N0cERlc2NyaXB0aW9uID0gZnVuY3Rpb24obWVkaWFTZWN0aW9uKSB7XG4gIGNvbnN0IG1saW5lID0gU0RQVXRpbHMucGFyc2VNTGluZShtZWRpYVNlY3Rpb24pO1xuICBjb25zdCBtYXhTaXplTGluZSA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KG1lZGlhU2VjdGlvbiwgJ2E9bWF4LW1lc3NhZ2Utc2l6ZTonKTtcbiAgbGV0IG1heE1lc3NhZ2VTaXplO1xuICBpZiAobWF4U2l6ZUxpbmUubGVuZ3RoID4gMCkge1xuICAgIG1heE1lc3NhZ2VTaXplID0gcGFyc2VJbnQobWF4U2l6ZUxpbmVbMF0uc3Vic3RyaW5nKDE5KSwgMTApO1xuICB9XG4gIGlmIChpc05hTihtYXhNZXNzYWdlU2l6ZSkpIHtcbiAgICBtYXhNZXNzYWdlU2l6ZSA9IDY1NTM2O1xuICB9XG4gIGNvbnN0IHNjdHBQb3J0ID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgobWVkaWFTZWN0aW9uLCAnYT1zY3RwLXBvcnQ6Jyk7XG4gIGlmIChzY3RwUG9ydC5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBvcnQ6IHBhcnNlSW50KHNjdHBQb3J0WzBdLnN1YnN0cmluZygxMiksIDEwKSxcbiAgICAgIHByb3RvY29sOiBtbGluZS5mbXQsXG4gICAgICBtYXhNZXNzYWdlU2l6ZSxcbiAgICB9O1xuICB9XG4gIGNvbnN0IHNjdHBNYXBMaW5lcyA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KG1lZGlhU2VjdGlvbiwgJ2E9c2N0cG1hcDonKTtcbiAgaWYgKHNjdHBNYXBMaW5lcy5sZW5ndGggPiAwKSB7XG4gICAgY29uc3QgcGFydHMgPSBzY3RwTWFwTGluZXNbMF1cbiAgICAgIC5zdWJzdHJpbmcoMTApXG4gICAgICAuc3BsaXQoJyAnKTtcbiAgICByZXR1cm4ge1xuICAgICAgcG9ydDogcGFyc2VJbnQocGFydHNbMF0sIDEwKSxcbiAgICAgIHByb3RvY29sOiBwYXJ0c1sxXSxcbiAgICAgIG1heE1lc3NhZ2VTaXplLFxuICAgIH07XG4gIH1cbn07XG5cbi8vIFNDVFBcbi8vIG91dHB1dHMgdGhlIGRyYWZ0LWlldGYtbW11c2ljLXNjdHAtc2RwLTI2IHZlcnNpb24gdGhhdCBhbGwgYnJvd3NlcnNcbi8vIHN1cHBvcnQgYnkgbm93IHJlY2VpdmluZyBpbiB0aGlzIGZvcm1hdCwgdW5sZXNzIHdlIG9yaWdpbmFsbHkgcGFyc2VkXG4vLyBhcyB0aGUgZHJhZnQtaWV0Zi1tbXVzaWMtc2N0cC1zZHAtMDUgZm9ybWF0IChpbmRpY2F0ZWQgYnkgdGhlIG0tbGluZVxuLy8gcHJvdG9jb2wgb2YgRFRMUy9TQ1RQIC0tIHdpdGhvdXQgVURQLyBvciBUQ1AvKVxuU0RQVXRpbHMud3JpdGVTY3RwRGVzY3JpcHRpb24gPSBmdW5jdGlvbihtZWRpYSwgc2N0cCkge1xuICBsZXQgb3V0cHV0ID0gW107XG4gIGlmIChtZWRpYS5wcm90b2NvbCAhPT0gJ0RUTFMvU0NUUCcpIHtcbiAgICBvdXRwdXQgPSBbXG4gICAgICAnbT0nICsgbWVkaWEua2luZCArICcgOSAnICsgbWVkaWEucHJvdG9jb2wgKyAnICcgKyBzY3RwLnByb3RvY29sICsgJ1xcclxcbicsXG4gICAgICAnYz1JTiBJUDQgMC4wLjAuMFxcclxcbicsXG4gICAgICAnYT1zY3RwLXBvcnQ6JyArIHNjdHAucG9ydCArICdcXHJcXG4nLFxuICAgIF07XG4gIH0gZWxzZSB7XG4gICAgb3V0cHV0ID0gW1xuICAgICAgJ209JyArIG1lZGlhLmtpbmQgKyAnIDkgJyArIG1lZGlhLnByb3RvY29sICsgJyAnICsgc2N0cC5wb3J0ICsgJ1xcclxcbicsXG4gICAgICAnYz1JTiBJUDQgMC4wLjAuMFxcclxcbicsXG4gICAgICAnYT1zY3RwbWFwOicgKyBzY3RwLnBvcnQgKyAnICcgKyBzY3RwLnByb3RvY29sICsgJyA2NTUzNVxcclxcbicsXG4gICAgXTtcbiAgfVxuICBpZiAoc2N0cC5tYXhNZXNzYWdlU2l6ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgb3V0cHV0LnB1c2goJ2E9bWF4LW1lc3NhZ2Utc2l6ZTonICsgc2N0cC5tYXhNZXNzYWdlU2l6ZSArICdcXHJcXG4nKTtcbiAgfVxuICByZXR1cm4gb3V0cHV0LmpvaW4oJycpO1xufTtcblxuLy8gR2VuZXJhdGUgYSBzZXNzaW9uIElEIGZvciBTRFAuXG4vLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvZHJhZnQtaWV0Zi1ydGN3ZWItanNlcC0yMCNzZWN0aW9uLTUuMi4xXG4vLyByZWNvbW1lbmRzIHVzaW5nIGEgY3J5cHRvZ3JhcGhpY2FsbHkgcmFuZG9tICt2ZSA2NC1iaXQgdmFsdWVcbi8vIGJ1dCByaWdodCBub3cgdGhpcyBzaG91bGQgYmUgYWNjZXB0YWJsZSBhbmQgd2l0aGluIHRoZSByaWdodCByYW5nZVxuU0RQVXRpbHMuZ2VuZXJhdGVTZXNzaW9uSWQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoKS5zdWJzdHIoMiwgMjIpO1xufTtcblxuLy8gV3JpdGUgYm9pbGVyIHBsYXRlIGZvciBzdGFydCBvZiBTRFBcbi8vIHNlc3NJZCBhcmd1bWVudCBpcyBvcHRpb25hbCAtIGlmIG5vdCBzdXBwbGllZCBpdCB3aWxsXG4vLyBiZSBnZW5lcmF0ZWQgcmFuZG9tbHlcbi8vIHNlc3NWZXJzaW9uIGlzIG9wdGlvbmFsIGFuZCBkZWZhdWx0cyB0byAyXG4vLyBzZXNzVXNlciBpcyBvcHRpb25hbCBhbmQgZGVmYXVsdHMgdG8gJ3RoaXNpc2FkYXB0ZXJvcnRjJ1xuU0RQVXRpbHMud3JpdGVTZXNzaW9uQm9pbGVycGxhdGUgPSBmdW5jdGlvbihzZXNzSWQsIHNlc3NWZXIsIHNlc3NVc2VyKSB7XG4gIGxldCBzZXNzaW9uSWQ7XG4gIGNvbnN0IHZlcnNpb24gPSBzZXNzVmVyICE9PSB1bmRlZmluZWQgPyBzZXNzVmVyIDogMjtcbiAgaWYgKHNlc3NJZCkge1xuICAgIHNlc3Npb25JZCA9IHNlc3NJZDtcbiAgfSBlbHNlIHtcbiAgICBzZXNzaW9uSWQgPSBTRFBVdGlscy5nZW5lcmF0ZVNlc3Npb25JZCgpO1xuICB9XG4gIGNvbnN0IHVzZXIgPSBzZXNzVXNlciB8fCAndGhpc2lzYWRhcHRlcm9ydGMnO1xuICAvLyBGSVhNRTogc2Vzcy1pZCBzaG91bGQgYmUgYW4gTlRQIHRpbWVzdGFtcC5cbiAgcmV0dXJuICd2PTBcXHJcXG4nICtcbiAgICAgICdvPScgKyB1c2VyICsgJyAnICsgc2Vzc2lvbklkICsgJyAnICsgdmVyc2lvbiArXG4gICAgICAgICcgSU4gSVA0IDEyNy4wLjAuMVxcclxcbicgK1xuICAgICAgJ3M9LVxcclxcbicgK1xuICAgICAgJ3Q9MCAwXFxyXFxuJztcbn07XG5cbi8vIEdldHMgdGhlIGRpcmVjdGlvbiBmcm9tIHRoZSBtZWRpYVNlY3Rpb24gb3IgdGhlIHNlc3Npb25wYXJ0LlxuU0RQVXRpbHMuZ2V0RGlyZWN0aW9uID0gZnVuY3Rpb24obWVkaWFTZWN0aW9uLCBzZXNzaW9ucGFydCkge1xuICAvLyBMb29rIGZvciBzZW5kcmVjdiwgc2VuZG9ubHksIHJlY3Zvbmx5LCBpbmFjdGl2ZSwgZGVmYXVsdCB0byBzZW5kcmVjdi5cbiAgY29uc3QgbGluZXMgPSBTRFBVdGlscy5zcGxpdExpbmVzKG1lZGlhU2VjdGlvbik7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICBzd2l0Y2ggKGxpbmVzW2ldKSB7XG4gICAgICBjYXNlICdhPXNlbmRyZWN2JzpcbiAgICAgIGNhc2UgJ2E9c2VuZG9ubHknOlxuICAgICAgY2FzZSAnYT1yZWN2b25seSc6XG4gICAgICBjYXNlICdhPWluYWN0aXZlJzpcbiAgICAgICAgcmV0dXJuIGxpbmVzW2ldLnN1YnN0cmluZygyKTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIC8vIEZJWE1FOiBXaGF0IHNob3VsZCBoYXBwZW4gaGVyZT9cbiAgICB9XG4gIH1cbiAgaWYgKHNlc3Npb25wYXJ0KSB7XG4gICAgcmV0dXJuIFNEUFV0aWxzLmdldERpcmVjdGlvbihzZXNzaW9ucGFydCk7XG4gIH1cbiAgcmV0dXJuICdzZW5kcmVjdic7XG59O1xuXG5TRFBVdGlscy5nZXRLaW5kID0gZnVuY3Rpb24obWVkaWFTZWN0aW9uKSB7XG4gIGNvbnN0IGxpbmVzID0gU0RQVXRpbHMuc3BsaXRMaW5lcyhtZWRpYVNlY3Rpb24pO1xuICBjb25zdCBtbGluZSA9IGxpbmVzWzBdLnNwbGl0KCcgJyk7XG4gIHJldHVybiBtbGluZVswXS5zdWJzdHJpbmcoMik7XG59O1xuXG5TRFBVdGlscy5pc1JlamVjdGVkID0gZnVuY3Rpb24obWVkaWFTZWN0aW9uKSB7XG4gIHJldHVybiBtZWRpYVNlY3Rpb24uc3BsaXQoJyAnLCAyKVsxXSA9PT0gJzAnO1xufTtcblxuU0RQVXRpbHMucGFyc2VNTGluZSA9IGZ1bmN0aW9uKG1lZGlhU2VjdGlvbikge1xuICBjb25zdCBsaW5lcyA9IFNEUFV0aWxzLnNwbGl0TGluZXMobWVkaWFTZWN0aW9uKTtcbiAgY29uc3QgcGFydHMgPSBsaW5lc1swXS5zdWJzdHJpbmcoMikuc3BsaXQoJyAnKTtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBwYXJ0c1swXSxcbiAgICBwb3J0OiBwYXJzZUludChwYXJ0c1sxXSwgMTApLFxuICAgIHByb3RvY29sOiBwYXJ0c1syXSxcbiAgICBmbXQ6IHBhcnRzLnNsaWNlKDMpLmpvaW4oJyAnKSxcbiAgfTtcbn07XG5cblNEUFV0aWxzLnBhcnNlT0xpbmUgPSBmdW5jdGlvbihtZWRpYVNlY3Rpb24pIHtcbiAgY29uc3QgbGluZSA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KG1lZGlhU2VjdGlvbiwgJ289JylbMF07XG4gIGNvbnN0IHBhcnRzID0gbGluZS5zdWJzdHJpbmcoMikuc3BsaXQoJyAnKTtcbiAgcmV0dXJuIHtcbiAgICB1c2VybmFtZTogcGFydHNbMF0sXG4gICAgc2Vzc2lvbklkOiBwYXJ0c1sxXSxcbiAgICBzZXNzaW9uVmVyc2lvbjogcGFyc2VJbnQocGFydHNbMl0sIDEwKSxcbiAgICBuZXRUeXBlOiBwYXJ0c1szXSxcbiAgICBhZGRyZXNzVHlwZTogcGFydHNbNF0sXG4gICAgYWRkcmVzczogcGFydHNbNV0sXG4gIH07XG59O1xuXG4vLyBhIHZlcnkgbmFpdmUgaW50ZXJwcmV0YXRpb24gb2YgYSB2YWxpZCBTRFAuXG5TRFBVdGlscy5pc1ZhbGlkU0RQID0gZnVuY3Rpb24oYmxvYikge1xuICBpZiAodHlwZW9mIGJsb2IgIT09ICdzdHJpbmcnIHx8IGJsb2IubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IGxpbmVzID0gU0RQVXRpbHMuc3BsaXRMaW5lcyhibG9iKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChsaW5lc1tpXS5sZW5ndGggPCAyIHx8IGxpbmVzW2ldLmNoYXJBdCgxKSAhPT0gJz0nKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIFRPRE86IGNoZWNrIHRoZSBtb2RpZmllciBhIGJpdCBtb3JlLlxuICB9XG4gIHJldHVybiB0cnVlO1xufTtcblxuLy8gRXhwb3NlIHB1YmxpYyBtZXRob2RzLlxuaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gU0RQVXRpbHM7XG59XG4iLCIvKlxuICogIENvcHlyaWdodCAoYykgMjAxNyBUaGUgV2ViUlRDIHByb2plY3QgYXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiAgVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYSBCU0Qtc3R5bGUgbGljZW5zZVxuICogIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3Qgb2YgdGhlIHNvdXJjZVxuICogIHRyZWUuXG4gKi9cbi8qIGVzbGludC1lbnYgbm9kZSAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgU0RQVXRpbHMgZnJvbSAnc2RwJztcbmltcG9ydCAqIGFzIHV0aWxzIGZyb20gJy4vdXRpbHMnO1xuXG5leHBvcnQgZnVuY3Rpb24gc2hpbVJUQ0ljZUNhbmRpZGF0ZSh3aW5kb3cpIHtcbiAgLy8gZm91bmRhdGlvbiBpcyBhcmJpdHJhcmlseSBjaG9zZW4gYXMgYW4gaW5kaWNhdG9yIGZvciBmdWxsIHN1cHBvcnQgZm9yXG4gIC8vIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJydGMtcGMvI3J0Y2ljZWNhbmRpZGF0ZS1pbnRlcmZhY2VcbiAgaWYgKCF3aW5kb3cuUlRDSWNlQ2FuZGlkYXRlIHx8ICh3aW5kb3cuUlRDSWNlQ2FuZGlkYXRlICYmICdmb3VuZGF0aW9uJyBpblxuICAgICAgd2luZG93LlJUQ0ljZUNhbmRpZGF0ZS5wcm90b3R5cGUpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3QgTmF0aXZlUlRDSWNlQ2FuZGlkYXRlID0gd2luZG93LlJUQ0ljZUNhbmRpZGF0ZTtcbiAgd2luZG93LlJUQ0ljZUNhbmRpZGF0ZSA9IGZ1bmN0aW9uIFJUQ0ljZUNhbmRpZGF0ZShhcmdzKSB7XG4gICAgLy8gUmVtb3ZlIHRoZSBhPSB3aGljaCBzaG91bGRuJ3QgYmUgcGFydCBvZiB0aGUgY2FuZGlkYXRlIHN0cmluZy5cbiAgICBpZiAodHlwZW9mIGFyZ3MgPT09ICdvYmplY3QnICYmIGFyZ3MuY2FuZGlkYXRlICYmXG4gICAgICAgIGFyZ3MuY2FuZGlkYXRlLmluZGV4T2YoJ2E9JykgPT09IDApIHtcbiAgICAgIGFyZ3MgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGFyZ3MpKTtcbiAgICAgIGFyZ3MuY2FuZGlkYXRlID0gYXJncy5jYW5kaWRhdGUuc3Vic3RyaW5nKDIpO1xuICAgIH1cblxuICAgIGlmIChhcmdzLmNhbmRpZGF0ZSAmJiBhcmdzLmNhbmRpZGF0ZS5sZW5ndGgpIHtcbiAgICAgIC8vIEF1Z21lbnQgdGhlIG5hdGl2ZSBjYW5kaWRhdGUgd2l0aCB0aGUgcGFyc2VkIGZpZWxkcy5cbiAgICAgIGNvbnN0IG5hdGl2ZUNhbmRpZGF0ZSA9IG5ldyBOYXRpdmVSVENJY2VDYW5kaWRhdGUoYXJncyk7XG4gICAgICBjb25zdCBwYXJzZWRDYW5kaWRhdGUgPSBTRFBVdGlscy5wYXJzZUNhbmRpZGF0ZShhcmdzLmNhbmRpZGF0ZSk7XG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJzZWRDYW5kaWRhdGUpIHtcbiAgICAgICAgaWYgKCEoa2V5IGluIG5hdGl2ZUNhbmRpZGF0ZSkpIHtcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobmF0aXZlQ2FuZGlkYXRlLCBrZXksXG4gICAgICAgICAgICB7dmFsdWU6IHBhcnNlZENhbmRpZGF0ZVtrZXldfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gT3ZlcnJpZGUgc2VyaWFsaXplciB0byBub3Qgc2VyaWFsaXplIHRoZSBleHRyYSBhdHRyaWJ1dGVzLlxuICAgICAgbmF0aXZlQ2FuZGlkYXRlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBjYW5kaWRhdGU6IG5hdGl2ZUNhbmRpZGF0ZS5jYW5kaWRhdGUsXG4gICAgICAgICAgc2RwTWlkOiBuYXRpdmVDYW5kaWRhdGUuc2RwTWlkLFxuICAgICAgICAgIHNkcE1MaW5lSW5kZXg6IG5hdGl2ZUNhbmRpZGF0ZS5zZHBNTGluZUluZGV4LFxuICAgICAgICAgIHVzZXJuYW1lRnJhZ21lbnQ6IG5hdGl2ZUNhbmRpZGF0ZS51c2VybmFtZUZyYWdtZW50LFxuICAgICAgICB9O1xuICAgICAgfTtcbiAgICAgIHJldHVybiBuYXRpdmVDYW5kaWRhdGU7XG4gICAgfVxuICAgIHJldHVybiBuZXcgTmF0aXZlUlRDSWNlQ2FuZGlkYXRlKGFyZ3MpO1xuICB9O1xuICB3aW5kb3cuUlRDSWNlQ2FuZGlkYXRlLnByb3RvdHlwZSA9IE5hdGl2ZVJUQ0ljZUNhbmRpZGF0ZS5wcm90b3R5cGU7XG5cbiAgLy8gSG9vayB1cCB0aGUgYXVnbWVudGVkIGNhbmRpZGF0ZSBpbiBvbmljZWNhbmRpZGF0ZSBhbmRcbiAgLy8gYWRkRXZlbnRMaXN0ZW5lcignaWNlY2FuZGlkYXRlJywgLi4uKVxuICB1dGlscy53cmFwUGVlckNvbm5lY3Rpb25FdmVudCh3aW5kb3csICdpY2VjYW5kaWRhdGUnLCBlID0+IHtcbiAgICBpZiAoZS5jYW5kaWRhdGUpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCAnY2FuZGlkYXRlJywge1xuICAgICAgICB2YWx1ZTogbmV3IHdpbmRvdy5SVENJY2VDYW5kaWRhdGUoZS5jYW5kaWRhdGUpLFxuICAgICAgICB3cml0YWJsZTogJ2ZhbHNlJ1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBlO1xuICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNoaW1SVENJY2VDYW5kaWRhdGVSZWxheVByb3RvY29sKHdpbmRvdykge1xuICBpZiAoIXdpbmRvdy5SVENJY2VDYW5kaWRhdGUgfHwgKHdpbmRvdy5SVENJY2VDYW5kaWRhdGUgJiYgJ3JlbGF5UHJvdG9jb2wnIGluXG4gICAgICB3aW5kb3cuUlRDSWNlQ2FuZGlkYXRlLnByb3RvdHlwZSkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBIb29rIHVwIHRoZSBhdWdtZW50ZWQgY2FuZGlkYXRlIGluIG9uaWNlY2FuZGlkYXRlIGFuZFxuICAvLyBhZGRFdmVudExpc3RlbmVyKCdpY2VjYW5kaWRhdGUnLCAuLi4pXG4gIHV0aWxzLndyYXBQZWVyQ29ubmVjdGlvbkV2ZW50KHdpbmRvdywgJ2ljZWNhbmRpZGF0ZScsIGUgPT4ge1xuICAgIGlmIChlLmNhbmRpZGF0ZSkge1xuICAgICAgY29uc3QgcGFyc2VkQ2FuZGlkYXRlID0gU0RQVXRpbHMucGFyc2VDYW5kaWRhdGUoZS5jYW5kaWRhdGUuY2FuZGlkYXRlKTtcbiAgICAgIGlmIChwYXJzZWRDYW5kaWRhdGUudHlwZSA9PT0gJ3JlbGF5Jykge1xuICAgICAgICAvLyBUaGlzIGlzIGEgbGlid2VicnRjLXNwZWNpZmljIG1hcHBpbmcgb2YgbG9jYWwgdHlwZSBwcmVmZXJlbmNlXG4gICAgICAgIC8vIHRvIHJlbGF5UHJvdG9jb2wuXG4gICAgICAgIGUuY2FuZGlkYXRlLnJlbGF5UHJvdG9jb2wgPSB7XG4gICAgICAgICAgMDogJ3RscycsXG4gICAgICAgICAgMTogJ3RjcCcsXG4gICAgICAgICAgMjogJ3VkcCcsXG4gICAgICAgIH1bcGFyc2VkQ2FuZGlkYXRlLnByaW9yaXR5ID4+IDI0XTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGU7XG4gIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2hpbU1heE1lc3NhZ2VTaXplKHdpbmRvdywgYnJvd3NlckRldGFpbHMpIHtcbiAgaWYgKCF3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24pIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoISgnc2N0cCcgaW4gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZSkpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkod2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZSwgJ3NjdHAnLCB7XG4gICAgICBnZXQoKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdGhpcy5fc2N0cCA9PT0gJ3VuZGVmaW5lZCcgPyBudWxsIDogdGhpcy5fc2N0cDtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGNvbnN0IHNjdHBJbkRlc2NyaXB0aW9uID0gZnVuY3Rpb24oZGVzY3JpcHRpb24pIHtcbiAgICBpZiAoIWRlc2NyaXB0aW9uIHx8ICFkZXNjcmlwdGlvbi5zZHApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3Qgc2VjdGlvbnMgPSBTRFBVdGlscy5zcGxpdFNlY3Rpb25zKGRlc2NyaXB0aW9uLnNkcCk7XG4gICAgc2VjdGlvbnMuc2hpZnQoKTtcbiAgICByZXR1cm4gc2VjdGlvbnMuc29tZShtZWRpYVNlY3Rpb24gPT4ge1xuICAgICAgY29uc3QgbUxpbmUgPSBTRFBVdGlscy5wYXJzZU1MaW5lKG1lZGlhU2VjdGlvbik7XG4gICAgICByZXR1cm4gbUxpbmUgJiYgbUxpbmUua2luZCA9PT0gJ2FwcGxpY2F0aW9uJ1xuICAgICAgICAgICYmIG1MaW5lLnByb3RvY29sLmluZGV4T2YoJ1NDVFAnKSAhPT0gLTE7XG4gICAgfSk7XG4gIH07XG5cbiAgY29uc3QgZ2V0UmVtb3RlRmlyZWZveFZlcnNpb24gPSBmdW5jdGlvbihkZXNjcmlwdGlvbikge1xuICAgIC8vIFRPRE86IElzIHRoZXJlIGEgYmV0dGVyIHNvbHV0aW9uIGZvciBkZXRlY3RpbmcgRmlyZWZveD9cbiAgICBjb25zdCBtYXRjaCA9IGRlc2NyaXB0aW9uLnNkcC5tYXRjaCgvbW96aWxsYS4uLlRISVNfSVNfU0RQQVJUQS0oXFxkKykvKTtcbiAgICBpZiAobWF0Y2ggPT09IG51bGwgfHwgbWF0Y2gubGVuZ3RoIDwgMikge1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICBjb25zdCB2ZXJzaW9uID0gcGFyc2VJbnQobWF0Y2hbMV0sIDEwKTtcbiAgICAvLyBUZXN0IGZvciBOYU4gKHllcywgdGhpcyBpcyB1Z2x5KVxuICAgIHJldHVybiB2ZXJzaW9uICE9PSB2ZXJzaW9uID8gLTEgOiB2ZXJzaW9uO1xuICB9O1xuXG4gIGNvbnN0IGdldENhblNlbmRNYXhNZXNzYWdlU2l6ZSA9IGZ1bmN0aW9uKHJlbW90ZUlzRmlyZWZveCkge1xuICAgIC8vIEV2ZXJ5IGltcGxlbWVudGF0aW9uIHdlIGtub3cgY2FuIHNlbmQgYXQgbGVhc3QgNjQgS2lCLlxuICAgIC8vIE5vdGU6IEFsdGhvdWdoIENocm9tZSBpcyB0ZWNobmljYWxseSBhYmxlIHRvIHNlbmQgdXAgdG8gMjU2IEtpQiwgdGhlXG4gICAgLy8gICAgICAgZGF0YSBkb2VzIG5vdCByZWFjaCB0aGUgb3RoZXIgcGVlciByZWxpYWJseS5cbiAgICAvLyAgICAgICBTZWU6IGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC93ZWJydGMvaXNzdWVzL2RldGFpbD9pZD04NDE5XG4gICAgbGV0IGNhblNlbmRNYXhNZXNzYWdlU2l6ZSA9IDY1NTM2O1xuICAgIGlmIChicm93c2VyRGV0YWlscy5icm93c2VyID09PSAnZmlyZWZveCcpIHtcbiAgICAgIGlmIChicm93c2VyRGV0YWlscy52ZXJzaW9uIDwgNTcpIHtcbiAgICAgICAgaWYgKHJlbW90ZUlzRmlyZWZveCA9PT0gLTEpIHtcbiAgICAgICAgICAvLyBGRiA8IDU3IHdpbGwgc2VuZCBpbiAxNiBLaUIgY2h1bmtzIHVzaW5nIHRoZSBkZXByZWNhdGVkIFBQSURcbiAgICAgICAgICAvLyBmcmFnbWVudGF0aW9uLlxuICAgICAgICAgIGNhblNlbmRNYXhNZXNzYWdlU2l6ZSA9IDE2Mzg0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIEhvd2V2ZXIsIG90aGVyIEZGIChhbmQgUkFXUlRDKSBjYW4gcmVhc3NlbWJsZSBQUElELWZyYWdtZW50ZWRcbiAgICAgICAgICAvLyBtZXNzYWdlcy4gVGh1cywgc3VwcG9ydGluZyB+MiBHaUIgd2hlbiBzZW5kaW5nLlxuICAgICAgICAgIGNhblNlbmRNYXhNZXNzYWdlU2l6ZSA9IDIxNDc0ODM2Mzc7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoYnJvd3NlckRldGFpbHMudmVyc2lvbiA8IDYwKSB7XG4gICAgICAgIC8vIEN1cnJlbnRseSwgYWxsIEZGID49IDU3IHdpbGwgcmVzZXQgdGhlIHJlbW90ZSBtYXhpbXVtIG1lc3NhZ2Ugc2l6ZVxuICAgICAgICAvLyB0byB0aGUgZGVmYXVsdCB2YWx1ZSB3aGVuIGEgZGF0YSBjaGFubmVsIGlzIGNyZWF0ZWQgYXQgYSBsYXRlclxuICAgICAgICAvLyBzdGFnZS4gOihcbiAgICAgICAgLy8gU2VlOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0xNDI2ODMxXG4gICAgICAgIGNhblNlbmRNYXhNZXNzYWdlU2l6ZSA9XG4gICAgICAgICAgYnJvd3NlckRldGFpbHMudmVyc2lvbiA9PT0gNTcgPyA2NTUzNSA6IDY1NTM2O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRkYgPj0gNjAgc3VwcG9ydHMgc2VuZGluZyB+MiBHaUJcbiAgICAgICAgY2FuU2VuZE1heE1lc3NhZ2VTaXplID0gMjE0NzQ4MzYzNztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNhblNlbmRNYXhNZXNzYWdlU2l6ZTtcbiAgfTtcblxuICBjb25zdCBnZXRNYXhNZXNzYWdlU2l6ZSA9IGZ1bmN0aW9uKGRlc2NyaXB0aW9uLCByZW1vdGVJc0ZpcmVmb3gpIHtcbiAgICAvLyBOb3RlOiA2NTUzNiBieXRlcyBpcyB0aGUgZGVmYXVsdCB2YWx1ZSBmcm9tIHRoZSBTRFAgc3BlYy4gQWxzbyxcbiAgICAvLyAgICAgICBldmVyeSBpbXBsZW1lbnRhdGlvbiB3ZSBrbm93IHN1cHBvcnRzIHJlY2VpdmluZyA2NTUzNiBieXRlcy5cbiAgICBsZXQgbWF4TWVzc2FnZVNpemUgPSA2NTUzNjtcblxuICAgIC8vIEZGIDU3IGhhcyBhIHNsaWdodGx5IGluY29ycmVjdCBkZWZhdWx0IHJlbW90ZSBtYXggbWVzc2FnZSBzaXplLCBzb1xuICAgIC8vIHdlIG5lZWQgdG8gYWRqdXN0IGl0IGhlcmUgdG8gYXZvaWQgYSBmYWlsdXJlIHdoZW4gc2VuZGluZy5cbiAgICAvLyBTZWU6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTE0MjU2OTdcbiAgICBpZiAoYnJvd3NlckRldGFpbHMuYnJvd3NlciA9PT0gJ2ZpcmVmb3gnXG4gICAgICAgICAmJiBicm93c2VyRGV0YWlscy52ZXJzaW9uID09PSA1Nykge1xuICAgICAgbWF4TWVzc2FnZVNpemUgPSA2NTUzNTtcbiAgICB9XG5cbiAgICBjb25zdCBtYXRjaCA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KGRlc2NyaXB0aW9uLnNkcCxcbiAgICAgICdhPW1heC1tZXNzYWdlLXNpemU6Jyk7XG4gICAgaWYgKG1hdGNoLmxlbmd0aCA+IDApIHtcbiAgICAgIG1heE1lc3NhZ2VTaXplID0gcGFyc2VJbnQobWF0Y2hbMF0uc3Vic3RyaW5nKDE5KSwgMTApO1xuICAgIH0gZWxzZSBpZiAoYnJvd3NlckRldGFpbHMuYnJvd3NlciA9PT0gJ2ZpcmVmb3gnICYmXG4gICAgICAgICAgICAgICAgcmVtb3RlSXNGaXJlZm94ICE9PSAtMSkge1xuICAgICAgLy8gSWYgdGhlIG1heGltdW0gbWVzc2FnZSBzaXplIGlzIG5vdCBwcmVzZW50IGluIHRoZSByZW1vdGUgU0RQIGFuZFxuICAgICAgLy8gYm90aCBsb2NhbCBhbmQgcmVtb3RlIGFyZSBGaXJlZm94LCB0aGUgcmVtb3RlIHBlZXIgY2FuIHJlY2VpdmVcbiAgICAgIC8vIH4yIEdpQi5cbiAgICAgIG1heE1lc3NhZ2VTaXplID0gMjE0NzQ4MzYzNztcbiAgICB9XG4gICAgcmV0dXJuIG1heE1lc3NhZ2VTaXplO1xuICB9O1xuXG4gIGNvbnN0IG9yaWdTZXRSZW1vdGVEZXNjcmlwdGlvbiA9XG4gICAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLnNldFJlbW90ZURlc2NyaXB0aW9uO1xuICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLnNldFJlbW90ZURlc2NyaXB0aW9uID1cbiAgICBmdW5jdGlvbiBzZXRSZW1vdGVEZXNjcmlwdGlvbigpIHtcbiAgICAgIHRoaXMuX3NjdHAgPSBudWxsO1xuICAgICAgLy8gQ2hyb21lIGRlY2lkZWQgdG8gbm90IGV4cG9zZSAuc2N0cCBpbiBwbGFuLWIgbW9kZS5cbiAgICAgIC8vIEFzIHVzdWFsLCBhZGFwdGVyLmpzIGhhcyB0byBkbyBhbiAndWdseSB3b3Jha2Fyb3VuZCdcbiAgICAgIC8vIHRvIGNvdmVyIHVwIHRoZSBtZXNzLlxuICAgICAgaWYgKGJyb3dzZXJEZXRhaWxzLmJyb3dzZXIgPT09ICdjaHJvbWUnICYmIGJyb3dzZXJEZXRhaWxzLnZlcnNpb24gPj0gNzYpIHtcbiAgICAgICAgY29uc3Qge3NkcFNlbWFudGljc30gPSB0aGlzLmdldENvbmZpZ3VyYXRpb24oKTtcbiAgICAgICAgaWYgKHNkcFNlbWFudGljcyA9PT0gJ3BsYW4tYicpIHtcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3NjdHAnLCB7XG4gICAgICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0eXBlb2YgdGhpcy5fc2N0cCA9PT0gJ3VuZGVmaW5lZCcgPyBudWxsIDogdGhpcy5fc2N0cDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChzY3RwSW5EZXNjcmlwdGlvbihhcmd1bWVudHNbMF0pKSB7XG4gICAgICAgIC8vIENoZWNrIGlmIHRoZSByZW1vdGUgaXMgRkYuXG4gICAgICAgIGNvbnN0IGlzRmlyZWZveCA9IGdldFJlbW90ZUZpcmVmb3hWZXJzaW9uKGFyZ3VtZW50c1swXSk7XG5cbiAgICAgICAgLy8gR2V0IHRoZSBtYXhpbXVtIG1lc3NhZ2Ugc2l6ZSB0aGUgbG9jYWwgcGVlciBpcyBjYXBhYmxlIG9mIHNlbmRpbmdcbiAgICAgICAgY29uc3QgY2FuU2VuZE1NUyA9IGdldENhblNlbmRNYXhNZXNzYWdlU2l6ZShpc0ZpcmVmb3gpO1xuXG4gICAgICAgIC8vIEdldCB0aGUgbWF4aW11bSBtZXNzYWdlIHNpemUgb2YgdGhlIHJlbW90ZSBwZWVyLlxuICAgICAgICBjb25zdCByZW1vdGVNTVMgPSBnZXRNYXhNZXNzYWdlU2l6ZShhcmd1bWVudHNbMF0sIGlzRmlyZWZveCk7XG5cbiAgICAgICAgLy8gRGV0ZXJtaW5lIGZpbmFsIG1heGltdW0gbWVzc2FnZSBzaXplXG4gICAgICAgIGxldCBtYXhNZXNzYWdlU2l6ZTtcbiAgICAgICAgaWYgKGNhblNlbmRNTVMgPT09IDAgJiYgcmVtb3RlTU1TID09PSAwKSB7XG4gICAgICAgICAgbWF4TWVzc2FnZVNpemUgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgICAgIH0gZWxzZSBpZiAoY2FuU2VuZE1NUyA9PT0gMCB8fCByZW1vdGVNTVMgPT09IDApIHtcbiAgICAgICAgICBtYXhNZXNzYWdlU2l6ZSA9IE1hdGgubWF4KGNhblNlbmRNTVMsIHJlbW90ZU1NUyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbWF4TWVzc2FnZVNpemUgPSBNYXRoLm1pbihjYW5TZW5kTU1TLCByZW1vdGVNTVMpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ3JlYXRlIGEgZHVtbXkgUlRDU2N0cFRyYW5zcG9ydCBvYmplY3QgYW5kIHRoZSAnbWF4TWVzc2FnZVNpemUnXG4gICAgICAgIC8vIGF0dHJpYnV0ZS5cbiAgICAgICAgY29uc3Qgc2N0cCA9IHt9O1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc2N0cCwgJ21heE1lc3NhZ2VTaXplJywge1xuICAgICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiBtYXhNZXNzYWdlU2l6ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9zY3RwID0gc2N0cDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG9yaWdTZXRSZW1vdGVEZXNjcmlwdGlvbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzaGltU2VuZFRocm93VHlwZUVycm9yKHdpbmRvdykge1xuICBpZiAoISh3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24gJiZcbiAgICAgICdjcmVhdGVEYXRhQ2hhbm5lbCcgaW4gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZSkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBOb3RlOiBBbHRob3VnaCBGaXJlZm94ID49IDU3IGhhcyBhIG5hdGl2ZSBpbXBsZW1lbnRhdGlvbiwgdGhlIG1heGltdW1cbiAgLy8gICAgICAgbWVzc2FnZSBzaXplIGNhbiBiZSByZXNldCBmb3IgYWxsIGRhdGEgY2hhbm5lbHMgYXQgYSBsYXRlciBzdGFnZS5cbiAgLy8gICAgICAgU2VlOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0xNDI2ODMxXG5cbiAgZnVuY3Rpb24gd3JhcERjU2VuZChkYywgcGMpIHtcbiAgICBjb25zdCBvcmlnRGF0YUNoYW5uZWxTZW5kID0gZGMuc2VuZDtcbiAgICBkYy5zZW5kID0gZnVuY3Rpb24gc2VuZCgpIHtcbiAgICAgIGNvbnN0IGRhdGEgPSBhcmd1bWVudHNbMF07XG4gICAgICBjb25zdCBsZW5ndGggPSBkYXRhLmxlbmd0aCB8fCBkYXRhLnNpemUgfHwgZGF0YS5ieXRlTGVuZ3RoO1xuICAgICAgaWYgKGRjLnJlYWR5U3RhdGUgPT09ICdvcGVuJyAmJlxuICAgICAgICAgIHBjLnNjdHAgJiYgbGVuZ3RoID4gcGMuc2N0cC5tYXhNZXNzYWdlU2l6ZSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdNZXNzYWdlIHRvbyBsYXJnZSAoY2FuIHNlbmQgYSBtYXhpbXVtIG9mICcgK1xuICAgICAgICAgIHBjLnNjdHAubWF4TWVzc2FnZVNpemUgKyAnIGJ5dGVzKScpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9yaWdEYXRhQ2hhbm5lbFNlbmQuYXBwbHkoZGMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfVxuICBjb25zdCBvcmlnQ3JlYXRlRGF0YUNoYW5uZWwgPVxuICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuY3JlYXRlRGF0YUNoYW5uZWw7XG4gIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuY3JlYXRlRGF0YUNoYW5uZWwgPVxuICAgIGZ1bmN0aW9uIGNyZWF0ZURhdGFDaGFubmVsKCkge1xuICAgICAgY29uc3QgZGF0YUNoYW5uZWwgPSBvcmlnQ3JlYXRlRGF0YUNoYW5uZWwuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHdyYXBEY1NlbmQoZGF0YUNoYW5uZWwsIHRoaXMpO1xuICAgICAgcmV0dXJuIGRhdGFDaGFubmVsO1xuICAgIH07XG4gIHV0aWxzLndyYXBQZWVyQ29ubmVjdGlvbkV2ZW50KHdpbmRvdywgJ2RhdGFjaGFubmVsJywgZSA9PiB7XG4gICAgd3JhcERjU2VuZChlLmNoYW5uZWwsIGUudGFyZ2V0KTtcbiAgICByZXR1cm4gZTtcbiAgfSk7XG59XG5cblxuLyogc2hpbXMgUlRDQ29ubmVjdGlvblN0YXRlIGJ5IHByZXRlbmRpbmcgaXQgaXMgdGhlIHNhbWUgYXMgaWNlQ29ubmVjdGlvblN0YXRlLlxuICogU2VlIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC93ZWJydGMvaXNzdWVzL2RldGFpbD9pZD02MTQ1I2MxMlxuICogZm9yIHdoeSB0aGlzIGlzIGEgdmFsaWQgaGFjayBpbiBDaHJvbWUuIEluIEZpcmVmb3ggaXQgaXMgc2xpZ2h0bHkgaW5jb3JyZWN0XG4gKiBzaW5jZSBEVExTIGZhaWx1cmVzIHdvdWxkIGJlIGhpZGRlbi4gU2VlXG4gKiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0xMjY1ODI3XG4gKiBmb3IgdGhlIEZpcmVmb3ggdHJhY2tpbmcgYnVnLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc2hpbUNvbm5lY3Rpb25TdGF0ZSh3aW5kb3cpIHtcbiAgaWYgKCF3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24gfHxcbiAgICAgICdjb25uZWN0aW9uU3RhdGUnIGluIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgcHJvdG8gPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvdG8sICdjb25uZWN0aW9uU3RhdGUnLCB7XG4gICAgZ2V0KCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY29tcGxldGVkOiAnY29ubmVjdGVkJyxcbiAgICAgICAgY2hlY2tpbmc6ICdjb25uZWN0aW5nJ1xuICAgICAgfVt0aGlzLmljZUNvbm5lY3Rpb25TdGF0ZV0gfHwgdGhpcy5pY2VDb25uZWN0aW9uU3RhdGU7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3RvLCAnb25jb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCB7XG4gICAgZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX29uY29ubmVjdGlvbnN0YXRlY2hhbmdlIHx8IG51bGw7XG4gICAgfSxcbiAgICBzZXQoY2IpIHtcbiAgICAgIGlmICh0aGlzLl9vbmNvbm5lY3Rpb25zdGF0ZWNoYW5nZSkge1xuICAgICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Nvbm5lY3Rpb25zdGF0ZWNoYW5nZScsXG4gICAgICAgICAgdGhpcy5fb25jb25uZWN0aW9uc3RhdGVjaGFuZ2UpO1xuICAgICAgICBkZWxldGUgdGhpcy5fb25jb25uZWN0aW9uc3RhdGVjaGFuZ2U7XG4gICAgICB9XG4gICAgICBpZiAoY2IpIHtcbiAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLFxuICAgICAgICAgIHRoaXMuX29uY29ubmVjdGlvbnN0YXRlY2hhbmdlID0gY2IpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG5cbiAgWydzZXRMb2NhbERlc2NyaXB0aW9uJywgJ3NldFJlbW90ZURlc2NyaXB0aW9uJ10uZm9yRWFjaCgobWV0aG9kKSA9PiB7XG4gICAgY29uc3Qgb3JpZ01ldGhvZCA9IHByb3RvW21ldGhvZF07XG4gICAgcHJvdG9bbWV0aG9kXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCF0aGlzLl9jb25uZWN0aW9uc3RhdGVjaGFuZ2Vwb2x5KSB7XG4gICAgICAgIHRoaXMuX2Nvbm5lY3Rpb25zdGF0ZWNoYW5nZXBvbHkgPSBlID0+IHtcbiAgICAgICAgICBjb25zdCBwYyA9IGUudGFyZ2V0O1xuICAgICAgICAgIGlmIChwYy5fbGFzdENvbm5lY3Rpb25TdGF0ZSAhPT0gcGMuY29ubmVjdGlvblN0YXRlKSB7XG4gICAgICAgICAgICBwYy5fbGFzdENvbm5lY3Rpb25TdGF0ZSA9IHBjLmNvbm5lY3Rpb25TdGF0ZTtcbiAgICAgICAgICAgIGNvbnN0IG5ld0V2ZW50ID0gbmV3IEV2ZW50KCdjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCBlKTtcbiAgICAgICAgICAgIHBjLmRpc3BhdGNoRXZlbnQobmV3RXZlbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdpY2Vjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLFxuICAgICAgICAgIHRoaXMuX2Nvbm5lY3Rpb25zdGF0ZWNoYW5nZXBvbHkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9yaWdNZXRob2QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZUV4dG1hcEFsbG93TWl4ZWQod2luZG93LCBicm93c2VyRGV0YWlscykge1xuICAvKiByZW1vdmUgYT1leHRtYXAtYWxsb3ctbWl4ZWQgZm9yIHdlYnJ0Yy5vcmcgPCBNNzEgKi9cbiAgaWYgKCF3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGJyb3dzZXJEZXRhaWxzLmJyb3dzZXIgPT09ICdjaHJvbWUnICYmIGJyb3dzZXJEZXRhaWxzLnZlcnNpb24gPj0gNzEpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGJyb3dzZXJEZXRhaWxzLmJyb3dzZXIgPT09ICdzYWZhcmknICYmIGJyb3dzZXJEZXRhaWxzLnZlcnNpb24gPj0gNjA1KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IG5hdGl2ZVNSRCA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuc2V0UmVtb3RlRGVzY3JpcHRpb247XG4gIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuc2V0UmVtb3RlRGVzY3JpcHRpb24gPVxuICBmdW5jdGlvbiBzZXRSZW1vdGVEZXNjcmlwdGlvbihkZXNjKSB7XG4gICAgaWYgKGRlc2MgJiYgZGVzYy5zZHAgJiYgZGVzYy5zZHAuaW5kZXhPZignXFxuYT1leHRtYXAtYWxsb3ctbWl4ZWQnKSAhPT0gLTEpIHtcbiAgICAgIGNvbnN0IHNkcCA9IGRlc2Muc2RwLnNwbGl0KCdcXG4nKS5maWx0ZXIoKGxpbmUpID0+IHtcbiAgICAgICAgcmV0dXJuIGxpbmUudHJpbSgpICE9PSAnYT1leHRtYXAtYWxsb3ctbWl4ZWQnO1xuICAgICAgfSkuam9pbignXFxuJyk7XG4gICAgICAvLyBTYWZhcmkgZW5mb3JjZXMgcmVhZC1vbmx5LW5lc3Mgb2YgUlRDU2Vzc2lvbkRlc2NyaXB0aW9uIGZpZWxkcy5cbiAgICAgIGlmICh3aW5kb3cuUlRDU2Vzc2lvbkRlc2NyaXB0aW9uICYmXG4gICAgICAgICAgZGVzYyBpbnN0YW5jZW9mIHdpbmRvdy5SVENTZXNzaW9uRGVzY3JpcHRpb24pIHtcbiAgICAgICAgYXJndW1lbnRzWzBdID0gbmV3IHdpbmRvdy5SVENTZXNzaW9uRGVzY3JpcHRpb24oe1xuICAgICAgICAgIHR5cGU6IGRlc2MudHlwZSxcbiAgICAgICAgICBzZHAsXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVzYy5zZHAgPSBzZHA7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuYXRpdmVTUkQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNoaW1BZGRJY2VDYW5kaWRhdGVOdWxsT3JFbXB0eSh3aW5kb3csIGJyb3dzZXJEZXRhaWxzKSB7XG4gIC8vIFN1cHBvcnQgZm9yIGFkZEljZUNhbmRpZGF0ZShudWxsIG9yIHVuZGVmaW5lZClcbiAgLy8gYXMgd2VsbCBhcyBhZGRJY2VDYW5kaWRhdGUoe2NhbmRpZGF0ZTogXCJcIiwgLi4ufSlcbiAgLy8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9OTc4NTgyXG4gIC8vIE5vdGU6IG11c3QgYmUgY2FsbGVkIGJlZm9yZSBvdGhlciBwb2x5ZmlsbHMgd2hpY2ggY2hhbmdlIHRoZSBzaWduYXR1cmUuXG4gIGlmICghKHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbiAmJiB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlKSkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBuYXRpdmVBZGRJY2VDYW5kaWRhdGUgPVxuICAgICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5hZGRJY2VDYW5kaWRhdGU7XG4gIGlmICghbmF0aXZlQWRkSWNlQ2FuZGlkYXRlIHx8IG5hdGl2ZUFkZEljZUNhbmRpZGF0ZS5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5hZGRJY2VDYW5kaWRhdGUgPVxuICAgIGZ1bmN0aW9uIGFkZEljZUNhbmRpZGF0ZSgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzWzBdKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHNbMV0pIHtcbiAgICAgICAgICBhcmd1bWVudHNbMV0uYXBwbHkobnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgfVxuICAgICAgLy8gRmlyZWZveCA2OCsgZW1pdHMgYW5kIHByb2Nlc3NlcyB7Y2FuZGlkYXRlOiBcIlwiLCAuLi59LCBpZ25vcmVcbiAgICAgIC8vIGluIG9sZGVyIHZlcnNpb25zLlxuICAgICAgLy8gTmF0aXZlIHN1cHBvcnQgZm9yIGlnbm9yaW5nIGV4aXN0cyBmb3IgQ2hyb21lIE03NysuXG4gICAgICAvLyBTYWZhcmkgaWdub3JlcyBhcyB3ZWxsLCBleGFjdCB2ZXJzaW9uIHVua25vd24gYnV0IHdvcmtzIGluIHRoZSBzYW1lXG4gICAgICAvLyB2ZXJzaW9uIHRoYXQgYWxzbyBpZ25vcmVzIGFkZEljZUNhbmRpZGF0ZShudWxsKS5cbiAgICAgIGlmICgoKGJyb3dzZXJEZXRhaWxzLmJyb3dzZXIgPT09ICdjaHJvbWUnICYmIGJyb3dzZXJEZXRhaWxzLnZlcnNpb24gPCA3OClcbiAgICAgICAgICAgfHwgKGJyb3dzZXJEZXRhaWxzLmJyb3dzZXIgPT09ICdmaXJlZm94J1xuICAgICAgICAgICAgICAgJiYgYnJvd3NlckRldGFpbHMudmVyc2lvbiA8IDY4KVxuICAgICAgICAgICB8fCAoYnJvd3NlckRldGFpbHMuYnJvd3NlciA9PT0gJ3NhZmFyaScpKVxuICAgICAgICAgICYmIGFyZ3VtZW50c1swXSAmJiBhcmd1bWVudHNbMF0uY2FuZGlkYXRlID09PSAnJykge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmF0aXZlQWRkSWNlQ2FuZGlkYXRlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbn1cblxuLy8gTm90ZTogTWFrZSBzdXJlIHRvIGNhbGwgdGhpcyBhaGVhZCBvZiBBUElzIHRoYXQgbW9kaWZ5XG4vLyBzZXRMb2NhbERlc2NyaXB0aW9uLmxlbmd0aFxuZXhwb3J0IGZ1bmN0aW9uIHNoaW1QYXJhbWV0ZXJsZXNzU2V0TG9jYWxEZXNjcmlwdGlvbih3aW5kb3csIGJyb3dzZXJEZXRhaWxzKSB7XG4gIGlmICghKHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbiAmJiB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlKSkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBuYXRpdmVTZXRMb2NhbERlc2NyaXB0aW9uID1cbiAgICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuc2V0TG9jYWxEZXNjcmlwdGlvbjtcbiAgaWYgKCFuYXRpdmVTZXRMb2NhbERlc2NyaXB0aW9uIHx8IG5hdGl2ZVNldExvY2FsRGVzY3JpcHRpb24ubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuc2V0TG9jYWxEZXNjcmlwdGlvbiA9XG4gICAgZnVuY3Rpb24gc2V0TG9jYWxEZXNjcmlwdGlvbigpIHtcbiAgICAgIGxldCBkZXNjID0gYXJndW1lbnRzWzBdIHx8IHt9O1xuICAgICAgaWYgKHR5cGVvZiBkZXNjICE9PSAnb2JqZWN0JyB8fCAoZGVzYy50eXBlICYmIGRlc2Muc2RwKSkge1xuICAgICAgICByZXR1cm4gbmF0aXZlU2V0TG9jYWxEZXNjcmlwdGlvbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgICAgLy8gVGhlIHJlbWFpbmluZyBzdGVwcyBzaG91bGQgdGVjaG5pY2FsbHkgaGFwcGVuIHdoZW4gU0xEIGNvbWVzIG9mZiB0aGVcbiAgICAgIC8vIFJUQ1BlZXJDb25uZWN0aW9uJ3Mgb3BlcmF0aW9ucyBjaGFpbiAobm90IGFoZWFkIG9mIGdvaW5nIG9uIGl0KSwgYnV0XG4gICAgICAvLyB0aGlzIGlzIHRvbyBkaWZmaWN1bHQgdG8gc2hpbS4gSW5zdGVhZCwgdGhpcyBzaGltIG9ubHkgY292ZXJzIHRoZVxuICAgICAgLy8gY29tbW9uIGNhc2Ugd2hlcmUgdGhlIG9wZXJhdGlvbnMgY2hhaW4gaXMgZW1wdHkuIFRoaXMgaXMgaW1wZXJmZWN0LCBidXRcbiAgICAgIC8vIHNob3VsZCBjb3ZlciBtYW55IGNhc2VzLiBSYXRpb25hbGU6IEV2ZW4gaWYgd2UgY2FuJ3QgcmVkdWNlIHRoZSBnbGFyZVxuICAgICAgLy8gd2luZG93IHRvIHplcm8gb24gaW1wZXJmZWN0IGltcGxlbWVudGF0aW9ucywgdGhlcmUncyB2YWx1ZSBpbiB0YXBwaW5nXG4gICAgICAvLyBpbnRvIHRoZSBwZXJmZWN0IG5lZ290aWF0aW9uIHBhdHRlcm4gdGhhdCBzZXZlcmFsIGJyb3dzZXJzIHN1cHBvcnQuXG4gICAgICBkZXNjID0ge3R5cGU6IGRlc2MudHlwZSwgc2RwOiBkZXNjLnNkcH07XG4gICAgICBpZiAoIWRlc2MudHlwZSkge1xuICAgICAgICBzd2l0Y2ggKHRoaXMuc2lnbmFsaW5nU3RhdGUpIHtcbiAgICAgICAgICBjYXNlICdzdGFibGUnOlxuICAgICAgICAgIGNhc2UgJ2hhdmUtbG9jYWwtb2ZmZXInOlxuICAgICAgICAgIGNhc2UgJ2hhdmUtcmVtb3RlLXByYW5zd2VyJzpcbiAgICAgICAgICAgIGRlc2MudHlwZSA9ICdvZmZlcic7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgZGVzYy50eXBlID0gJ2Fuc3dlcic7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGRlc2Muc2RwIHx8IChkZXNjLnR5cGUgIT09ICdvZmZlcicgJiYgZGVzYy50eXBlICE9PSAnYW5zd2VyJykpIHtcbiAgICAgICAgcmV0dXJuIG5hdGl2ZVNldExvY2FsRGVzY3JpcHRpb24uYXBwbHkodGhpcywgW2Rlc2NdKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGZ1bmMgPSBkZXNjLnR5cGUgPT09ICdvZmZlcicgPyB0aGlzLmNyZWF0ZU9mZmVyIDogdGhpcy5jcmVhdGVBbnN3ZXI7XG4gICAgICByZXR1cm4gZnVuYy5hcHBseSh0aGlzKVxuICAgICAgICAudGhlbihkID0+IG5hdGl2ZVNldExvY2FsRGVzY3JpcHRpb24uYXBwbHkodGhpcywgW2RdKSk7XG4gICAgfTtcbn1cbiIsIi8qXG4gKiAgQ29weXJpZ2h0IChjKSAyMDE2IFRoZSBXZWJSVEMgcHJvamVjdCBhdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqICBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhIEJTRC1zdHlsZSBsaWNlbnNlXG4gKiAgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBvZiB0aGUgc291cmNlXG4gKiAgdHJlZS5cbiAqL1xuaW1wb3J0ICogYXMgdXRpbHMgZnJvbSAnLi91dGlscyc7XG5cbi8vIEJyb3dzZXIgc2hpbXMuXG5pbXBvcnQgKiBhcyBjaHJvbWVTaGltIGZyb20gJy4vY2hyb21lL2Nocm9tZV9zaGltJztcbmltcG9ydCAqIGFzIGZpcmVmb3hTaGltIGZyb20gJy4vZmlyZWZveC9maXJlZm94X3NoaW0nO1xuaW1wb3J0ICogYXMgc2FmYXJpU2hpbSBmcm9tICcuL3NhZmFyaS9zYWZhcmlfc2hpbSc7XG5pbXBvcnQgKiBhcyBjb21tb25TaGltIGZyb20gJy4vY29tbW9uX3NoaW0nO1xuaW1wb3J0ICogYXMgc2RwIGZyb20gJ3NkcCc7XG5cbi8vIFNoaW1taW5nIHN0YXJ0cyBoZXJlLlxuZXhwb3J0IGZ1bmN0aW9uIGFkYXB0ZXJGYWN0b3J5KHt3aW5kb3d9ID0ge30sIG9wdGlvbnMgPSB7XG4gIHNoaW1DaHJvbWU6IHRydWUsXG4gIHNoaW1GaXJlZm94OiB0cnVlLFxuICBzaGltU2FmYXJpOiB0cnVlLFxufSkge1xuICAvLyBVdGlscy5cbiAgY29uc3QgbG9nZ2luZyA9IHV0aWxzLmxvZztcbiAgY29uc3QgYnJvd3NlckRldGFpbHMgPSB1dGlscy5kZXRlY3RCcm93c2VyKHdpbmRvdyk7XG5cbiAgY29uc3QgYWRhcHRlciA9IHtcbiAgICBicm93c2VyRGV0YWlscyxcbiAgICBjb21tb25TaGltLFxuICAgIGV4dHJhY3RWZXJzaW9uOiB1dGlscy5leHRyYWN0VmVyc2lvbixcbiAgICBkaXNhYmxlTG9nOiB1dGlscy5kaXNhYmxlTG9nLFxuICAgIGRpc2FibGVXYXJuaW5nczogdXRpbHMuZGlzYWJsZVdhcm5pbmdzLFxuICAgIC8vIEV4cG9zZSBzZHAgYXMgYSBjb252ZW5pZW5jZS4gRm9yIHByb2R1Y3Rpb24gYXBwcyBpbmNsdWRlIGRpcmVjdGx5LlxuICAgIHNkcCxcbiAgfTtcblxuICAvLyBTaGltIGJyb3dzZXIgaWYgZm91bmQuXG4gIHN3aXRjaCAoYnJvd3NlckRldGFpbHMuYnJvd3Nlcikge1xuICAgIGNhc2UgJ2Nocm9tZSc6XG4gICAgICBpZiAoIWNocm9tZVNoaW0gfHwgIWNocm9tZVNoaW0uc2hpbVBlZXJDb25uZWN0aW9uIHx8XG4gICAgICAgICAgIW9wdGlvbnMuc2hpbUNocm9tZSkge1xuICAgICAgICBsb2dnaW5nKCdDaHJvbWUgc2hpbSBpcyBub3QgaW5jbHVkZWQgaW4gdGhpcyBhZGFwdGVyIHJlbGVhc2UuJyk7XG4gICAgICAgIHJldHVybiBhZGFwdGVyO1xuICAgICAgfVxuICAgICAgaWYgKGJyb3dzZXJEZXRhaWxzLnZlcnNpb24gPT09IG51bGwpIHtcbiAgICAgICAgbG9nZ2luZygnQ2hyb21lIHNoaW0gY2FuIG5vdCBkZXRlcm1pbmUgdmVyc2lvbiwgbm90IHNoaW1taW5nLicpO1xuICAgICAgICByZXR1cm4gYWRhcHRlcjtcbiAgICAgIH1cbiAgICAgIGxvZ2dpbmcoJ2FkYXB0ZXIuanMgc2hpbW1pbmcgY2hyb21lLicpO1xuICAgICAgLy8gRXhwb3J0IHRvIHRoZSBhZGFwdGVyIGdsb2JhbCBvYmplY3QgdmlzaWJsZSBpbiB0aGUgYnJvd3Nlci5cbiAgICAgIGFkYXB0ZXIuYnJvd3NlclNoaW0gPSBjaHJvbWVTaGltO1xuXG4gICAgICAvLyBNdXN0IGJlIGNhbGxlZCBiZWZvcmUgc2hpbVBlZXJDb25uZWN0aW9uLlxuICAgICAgY29tbW9uU2hpbS5zaGltQWRkSWNlQ2FuZGlkYXRlTnVsbE9yRW1wdHkod2luZG93LCBicm93c2VyRGV0YWlscyk7XG4gICAgICBjb21tb25TaGltLnNoaW1QYXJhbWV0ZXJsZXNzU2V0TG9jYWxEZXNjcmlwdGlvbih3aW5kb3csIGJyb3dzZXJEZXRhaWxzKTtcblxuICAgICAgY2hyb21lU2hpbS5zaGltR2V0VXNlck1lZGlhKHdpbmRvdywgYnJvd3NlckRldGFpbHMpO1xuICAgICAgY2hyb21lU2hpbS5zaGltTWVkaWFTdHJlYW0od2luZG93LCBicm93c2VyRGV0YWlscyk7XG4gICAgICBjaHJvbWVTaGltLnNoaW1QZWVyQ29ubmVjdGlvbih3aW5kb3csIGJyb3dzZXJEZXRhaWxzKTtcbiAgICAgIGNocm9tZVNoaW0uc2hpbU9uVHJhY2sod2luZG93LCBicm93c2VyRGV0YWlscyk7XG4gICAgICBjaHJvbWVTaGltLnNoaW1BZGRUcmFja1JlbW92ZVRyYWNrKHdpbmRvdywgYnJvd3NlckRldGFpbHMpO1xuICAgICAgY2hyb21lU2hpbS5zaGltR2V0U2VuZGVyc1dpdGhEdG1mKHdpbmRvdywgYnJvd3NlckRldGFpbHMpO1xuICAgICAgY2hyb21lU2hpbS5zaGltR2V0U3RhdHMod2luZG93LCBicm93c2VyRGV0YWlscyk7XG4gICAgICBjaHJvbWVTaGltLnNoaW1TZW5kZXJSZWNlaXZlckdldFN0YXRzKHdpbmRvdywgYnJvd3NlckRldGFpbHMpO1xuICAgICAgY2hyb21lU2hpbS5maXhOZWdvdGlhdGlvbk5lZWRlZCh3aW5kb3csIGJyb3dzZXJEZXRhaWxzKTtcblxuICAgICAgY29tbW9uU2hpbS5zaGltUlRDSWNlQ2FuZGlkYXRlKHdpbmRvdywgYnJvd3NlckRldGFpbHMpO1xuICAgICAgY29tbW9uU2hpbS5zaGltUlRDSWNlQ2FuZGlkYXRlUmVsYXlQcm90b2NvbCh3aW5kb3csIGJyb3dzZXJEZXRhaWxzKTtcbiAgICAgIGNvbW1vblNoaW0uc2hpbUNvbm5lY3Rpb25TdGF0ZSh3aW5kb3csIGJyb3dzZXJEZXRhaWxzKTtcbiAgICAgIGNvbW1vblNoaW0uc2hpbU1heE1lc3NhZ2VTaXplKHdpbmRvdywgYnJvd3NlckRldGFpbHMpO1xuICAgICAgY29tbW9uU2hpbS5zaGltU2VuZFRocm93VHlwZUVycm9yKHdpbmRvdywgYnJvd3NlckRldGFpbHMpO1xuICAgICAgY29tbW9uU2hpbS5yZW1vdmVFeHRtYXBBbGxvd01peGVkKHdpbmRvdywgYnJvd3NlckRldGFpbHMpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnZmlyZWZveCc6XG4gICAgICBpZiAoIWZpcmVmb3hTaGltIHx8ICFmaXJlZm94U2hpbS5zaGltUGVlckNvbm5lY3Rpb24gfHxcbiAgICAgICAgICAhb3B0aW9ucy5zaGltRmlyZWZveCkge1xuICAgICAgICBsb2dnaW5nKCdGaXJlZm94IHNoaW0gaXMgbm90IGluY2x1ZGVkIGluIHRoaXMgYWRhcHRlciByZWxlYXNlLicpO1xuICAgICAgICByZXR1cm4gYWRhcHRlcjtcbiAgICAgIH1cbiAgICAgIGxvZ2dpbmcoJ2FkYXB0ZXIuanMgc2hpbW1pbmcgZmlyZWZveC4nKTtcbiAgICAgIC8vIEV4cG9ydCB0byB0aGUgYWRhcHRlciBnbG9iYWwgb2JqZWN0IHZpc2libGUgaW4gdGhlIGJyb3dzZXIuXG4gICAgICBhZGFwdGVyLmJyb3dzZXJTaGltID0gZmlyZWZveFNoaW07XG5cbiAgICAgIC8vIE11c3QgYmUgY2FsbGVkIGJlZm9yZSBzaGltUGVlckNvbm5lY3Rpb24uXG4gICAgICBjb21tb25TaGltLnNoaW1BZGRJY2VDYW5kaWRhdGVOdWxsT3JFbXB0eSh3aW5kb3csIGJyb3dzZXJEZXRhaWxzKTtcbiAgICAgIGNvbW1vblNoaW0uc2hpbVBhcmFtZXRlcmxlc3NTZXRMb2NhbERlc2NyaXB0aW9uKHdpbmRvdywgYnJvd3NlckRldGFpbHMpO1xuXG4gICAgICBmaXJlZm94U2hpbS5zaGltR2V0VXNlck1lZGlhKHdpbmRvdywgYnJvd3NlckRldGFpbHMpO1xuICAgICAgZmlyZWZveFNoaW0uc2hpbVBlZXJDb25uZWN0aW9uKHdpbmRvdywgYnJvd3NlckRldGFpbHMpO1xuICAgICAgZmlyZWZveFNoaW0uc2hpbU9uVHJhY2sod2luZG93LCBicm93c2VyRGV0YWlscyk7XG4gICAgICBmaXJlZm94U2hpbS5zaGltUmVtb3ZlU3RyZWFtKHdpbmRvdywgYnJvd3NlckRldGFpbHMpO1xuICAgICAgZmlyZWZveFNoaW0uc2hpbVNlbmRlckdldFN0YXRzKHdpbmRvdywgYnJvd3NlckRldGFpbHMpO1xuICAgICAgZmlyZWZveFNoaW0uc2hpbVJlY2VpdmVyR2V0U3RhdHMod2luZG93LCBicm93c2VyRGV0YWlscyk7XG4gICAgICBmaXJlZm94U2hpbS5zaGltUlRDRGF0YUNoYW5uZWwod2luZG93LCBicm93c2VyRGV0YWlscyk7XG4gICAgICBmaXJlZm94U2hpbS5zaGltQWRkVHJhbnNjZWl2ZXIod2luZG93LCBicm93c2VyRGV0YWlscyk7XG4gICAgICBmaXJlZm94U2hpbS5zaGltR2V0UGFyYW1ldGVycyh3aW5kb3csIGJyb3dzZXJEZXRhaWxzKTtcbiAgICAgIGZpcmVmb3hTaGltLnNoaW1DcmVhdGVPZmZlcih3aW5kb3csIGJyb3dzZXJEZXRhaWxzKTtcbiAgICAgIGZpcmVmb3hTaGltLnNoaW1DcmVhdGVBbnN3ZXIod2luZG93LCBicm93c2VyRGV0YWlscyk7XG5cbiAgICAgIGNvbW1vblNoaW0uc2hpbVJUQ0ljZUNhbmRpZGF0ZSh3aW5kb3csIGJyb3dzZXJEZXRhaWxzKTtcbiAgICAgIGNvbW1vblNoaW0uc2hpbUNvbm5lY3Rpb25TdGF0ZSh3aW5kb3csIGJyb3dzZXJEZXRhaWxzKTtcbiAgICAgIGNvbW1vblNoaW0uc2hpbU1heE1lc3NhZ2VTaXplKHdpbmRvdywgYnJvd3NlckRldGFpbHMpO1xuICAgICAgY29tbW9uU2hpbS5zaGltU2VuZFRocm93VHlwZUVycm9yKHdpbmRvdywgYnJvd3NlckRldGFpbHMpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnc2FmYXJpJzpcbiAgICAgIGlmICghc2FmYXJpU2hpbSB8fCAhb3B0aW9ucy5zaGltU2FmYXJpKSB7XG4gICAgICAgIGxvZ2dpbmcoJ1NhZmFyaSBzaGltIGlzIG5vdCBpbmNsdWRlZCBpbiB0aGlzIGFkYXB0ZXIgcmVsZWFzZS4nKTtcbiAgICAgICAgcmV0dXJuIGFkYXB0ZXI7XG4gICAgICB9XG4gICAgICBsb2dnaW5nKCdhZGFwdGVyLmpzIHNoaW1taW5nIHNhZmFyaS4nKTtcbiAgICAgIC8vIEV4cG9ydCB0byB0aGUgYWRhcHRlciBnbG9iYWwgb2JqZWN0IHZpc2libGUgaW4gdGhlIGJyb3dzZXIuXG4gICAgICBhZGFwdGVyLmJyb3dzZXJTaGltID0gc2FmYXJpU2hpbTtcblxuICAgICAgLy8gTXVzdCBiZSBjYWxsZWQgYmVmb3JlIHNoaW1DYWxsYmFja0FQSS5cbiAgICAgIGNvbW1vblNoaW0uc2hpbUFkZEljZUNhbmRpZGF0ZU51bGxPckVtcHR5KHdpbmRvdywgYnJvd3NlckRldGFpbHMpO1xuICAgICAgY29tbW9uU2hpbS5zaGltUGFyYW1ldGVybGVzc1NldExvY2FsRGVzY3JpcHRpb24od2luZG93LCBicm93c2VyRGV0YWlscyk7XG5cbiAgICAgIHNhZmFyaVNoaW0uc2hpbVJUQ0ljZVNlcnZlclVybHMod2luZG93LCBicm93c2VyRGV0YWlscyk7XG4gICAgICBzYWZhcmlTaGltLnNoaW1DcmVhdGVPZmZlckxlZ2FjeSh3aW5kb3csIGJyb3dzZXJEZXRhaWxzKTtcbiAgICAgIHNhZmFyaVNoaW0uc2hpbUNhbGxiYWNrc0FQSSh3aW5kb3csIGJyb3dzZXJEZXRhaWxzKTtcbiAgICAgIHNhZmFyaVNoaW0uc2hpbUxvY2FsU3RyZWFtc0FQSSh3aW5kb3csIGJyb3dzZXJEZXRhaWxzKTtcbiAgICAgIHNhZmFyaVNoaW0uc2hpbVJlbW90ZVN0cmVhbXNBUEkod2luZG93LCBicm93c2VyRGV0YWlscyk7XG4gICAgICBzYWZhcmlTaGltLnNoaW1UcmFja0V2ZW50VHJhbnNjZWl2ZXIod2luZG93LCBicm93c2VyRGV0YWlscyk7XG4gICAgICBzYWZhcmlTaGltLnNoaW1HZXRVc2VyTWVkaWEod2luZG93LCBicm93c2VyRGV0YWlscyk7XG4gICAgICBzYWZhcmlTaGltLnNoaW1BdWRpb0NvbnRleHQod2luZG93LCBicm93c2VyRGV0YWlscyk7XG5cbiAgICAgIGNvbW1vblNoaW0uc2hpbVJUQ0ljZUNhbmRpZGF0ZSh3aW5kb3csIGJyb3dzZXJEZXRhaWxzKTtcbiAgICAgIGNvbW1vblNoaW0uc2hpbVJUQ0ljZUNhbmRpZGF0ZVJlbGF5UHJvdG9jb2wod2luZG93LCBicm93c2VyRGV0YWlscyk7XG4gICAgICBjb21tb25TaGltLnNoaW1NYXhNZXNzYWdlU2l6ZSh3aW5kb3csIGJyb3dzZXJEZXRhaWxzKTtcbiAgICAgIGNvbW1vblNoaW0uc2hpbVNlbmRUaHJvd1R5cGVFcnJvcih3aW5kb3csIGJyb3dzZXJEZXRhaWxzKTtcbiAgICAgIGNvbW1vblNoaW0ucmVtb3ZlRXh0bWFwQWxsb3dNaXhlZCh3aW5kb3csIGJyb3dzZXJEZXRhaWxzKTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBsb2dnaW5nKCdVbnN1cHBvcnRlZCBicm93c2VyIScpO1xuICAgICAgYnJlYWs7XG4gIH1cblxuICByZXR1cm4gYWRhcHRlcjtcbn1cbiIsIi8qXG4gKiAgQ29weXJpZ2h0IChjKSAyMDE2IFRoZSBXZWJSVEMgcHJvamVjdCBhdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqICBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhIEJTRC1zdHlsZSBsaWNlbnNlXG4gKiAgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBvZiB0aGUgc291cmNlXG4gKiAgdHJlZS5cbiAqL1xuLyogZXNsaW50LWVudiBub2RlICovXG5cbid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHthZGFwdGVyRmFjdG9yeX0gZnJvbSAnLi9hZGFwdGVyX2ZhY3RvcnkuanMnO1xuXG5jb25zdCBhZGFwdGVyID1cbiAgYWRhcHRlckZhY3Rvcnkoe3dpbmRvdzogdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiB3aW5kb3d9KTtcbmV4cG9ydCBkZWZhdWx0IGFkYXB0ZXI7XG4iLCJpbXBvcnQgdHlwZSB7IEtleVByb3ZpZGVyT3B0aW9ucyB9IGZyb20gJy4vdHlwZXMnO1xuXG5leHBvcnQgY29uc3QgRU5DUllQVElPTl9BTEdPUklUSE0gPSAnQUVTLUdDTSc7XG5cbi8vIFdlIHVzZSBhIHJpbmdidWZmZXIgb2Yga2V5cyBzbyB3ZSBjYW4gY2hhbmdlIHRoZW0gYW5kIHN0aWxsIGRlY29kZSBwYWNrZXRzIHRoYXQgd2VyZVxuLy8gZW5jcnlwdGVkIHdpdGggYW4gb2xkIGtleS4gV2UgdXNlIGEgc2l6ZSBvZiAxNiB3aGljaCBjb3JyZXNwb25kcyB0byB0aGUgZm91ciBiaXRzXG4vLyBpbiB0aGUgZnJhbWUgdHJhaWxlci5cbmV4cG9ydCBjb25zdCBLRVlSSU5HX1NJWkUgPSAxNjtcblxuLy8gSG93IG1hbnkgY29uc2VjdXRpdmUgZnJhbWVzIGNhbiBmYWlsIGRlY3J5cHRpbmcgYmVmb3JlIGEgcGFydGljdWxhciBrZXkgZ2V0cyBtYXJrZWQgYXMgaW52YWxpZFxuZXhwb3J0IGNvbnN0IERFQ1JZUFRJT05fRkFJTFVSRV9UT0xFUkFOQ0UgPSAxMDtcblxuLy8gV2UgY29weSB0aGUgZmlyc3QgYnl0ZXMgb2YgdGhlIFZQOCBwYXlsb2FkIHVuZW5jcnlwdGVkLlxuLy8gRm9yIGtleWZyYW1lcyB0aGlzIGlzIDEwIGJ5dGVzLCBmb3Igbm9uLWtleWZyYW1lcyAoZGVsdGEpIDMuIFNlZVxuLy8gICBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNjM4NiNzZWN0aW9uLTkuMVxuLy8gVGhpcyBhbGxvd3MgdGhlIGJyaWRnZSB0byBjb250aW51ZSBkZXRlY3Rpbmcga2V5ZnJhbWVzIChvbmx5IG9uZSBieXRlIG5lZWRlZCBpbiB0aGUgSlZCKVxuLy8gYW5kIGlzIGFsc28gYSBiaXQgZWFzaWVyIGZvciB0aGUgVlA4IGRlY29kZXIgKGkuZS4gaXQgZ2VuZXJhdGVzIGZ1bm55IGdhcmJhZ2UgcGljdHVyZXNcbi8vIGluc3RlYWQgb2YgYmVpbmcgdW5hYmxlIHRvIGRlY29kZSkuXG4vLyBUaGlzIGlzIGEgYml0IGZvciBzaG93IGFuZCB3ZSBtaWdodCB3YW50IHRvIHJlZHVjZSB0byAxIHVuY29uZGl0aW9uYWxseSBpbiB0aGUgZmluYWwgdmVyc2lvbi5cbi8vXG4vLyBGb3IgYXVkaW8gKHdoZXJlIGZyYW1lLnR5cGUgaXMgbm90IHNldCkgd2UgZG8gbm90IGVuY3J5cHQgdGhlIG9wdXMgVE9DIGJ5dGU6XG4vLyAgIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM2NzE2I3NlY3Rpb24tMy4xXG5leHBvcnQgY29uc3QgVU5FTkNSWVBURURfQllURVMgPSB7XG4gIGtleTogMTAsXG4gIGRlbHRhOiAzLFxuICBhdWRpbzogMSwgLy8gZnJhbWUudHlwZSBpcyBub3Qgc2V0IG9uIGF1ZGlvLCBzbyB0aGlzIGlzIHNldCBtYW51YWxseVxuICBlbXB0eTogMCxcbn0gYXMgY29uc3Q7XG5cbi8qIFdlIHVzZSBhIDEyIGJ5dGUgYml0IElWLiBUaGlzIGlzIHNpZ25hbGxlZCBpbiBwbGFpbiB0b2dldGhlciB3aXRoIHRoZVxuIHBhY2tldC4gU2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9TdWJ0bGVDcnlwdG8vZW5jcnlwdCNwYXJhbWV0ZXJzICovXG5leHBvcnQgY29uc3QgSVZfTEVOR1RIID0gMTI7XG5cbi8vIGZsYWcgc2V0IHRvIGluZGljYXRlIHRoYXQgZTJlZSBoYXMgYmVlbiBzZXR1cCBmb3Igc2VuZGVyL3JlY2VpdmVyO1xuZXhwb3J0IGNvbnN0IEUyRUVfRkxBRyA9ICdsa19lMmVlJztcblxuZXhwb3J0IGNvbnN0IFNBTFQgPSAnTEtGcmFtZUVuY3J5cHRpb25LZXknO1xuXG5leHBvcnQgY29uc3QgS0VZX1BST1ZJREVSX0RFRkFVTFRTOiBLZXlQcm92aWRlck9wdGlvbnMgPSB7XG4gIHNoYXJlZEtleTogZmFsc2UsXG4gIHJhdGNoZXRTYWx0OiBTQUxULFxuICByYXRjaGV0V2luZG93U2l6ZTogOCxcbiAgZmFpbHVyZVRvbGVyYW5jZTogREVDUllQVElPTl9GQUlMVVJFX1RPTEVSQU5DRSxcbn0gYXMgY29uc3Q7XG5cbmV4cG9ydCBjb25zdCBNQVhfU0lGX0NPVU5UID0gMTAwO1xuZXhwb3J0IGNvbnN0IE1BWF9TSUZfRFVSQVRJT04gPSAyMDAwO1xuIiwiaW1wb3J0IHR5cGUgUGFydGljaXBhbnQgZnJvbSAnLi4vcm9vbS9wYXJ0aWNpcGFudC9QYXJ0aWNpcGFudCc7XG5pbXBvcnQgdHlwZSB7IENyeXB0b3JFcnJvciB9IGZyb20gJy4vZXJyb3JzJztcbmltcG9ydCB0eXBlIHsgS2V5SW5mbyB9IGZyb20gJy4vdHlwZXMnO1xuXG5leHBvcnQgZW51bSBLZXlQcm92aWRlckV2ZW50IHtcbiAgU2V0S2V5ID0gJ3NldEtleScsXG4gIFJhdGNoZXRSZXF1ZXN0ID0gJ3JhdGNoZXRSZXF1ZXN0JyxcbiAgS2V5UmF0Y2hldGVkID0gJ2tleVJhdGNoZXRlZCcsXG59XG5cbmV4cG9ydCB0eXBlIEtleVByb3ZpZGVyQ2FsbGJhY2tzID0ge1xuICBbS2V5UHJvdmlkZXJFdmVudC5TZXRLZXldOiAoa2V5SW5mbzogS2V5SW5mbykgPT4gdm9pZDtcbiAgW0tleVByb3ZpZGVyRXZlbnQuUmF0Y2hldFJlcXVlc3RdOiAocGFydGljaXBhbnRJZGVudGl0eT86IHN0cmluZywga2V5SW5kZXg/OiBudW1iZXIpID0+IHZvaWQ7XG4gIFtLZXlQcm92aWRlckV2ZW50LktleVJhdGNoZXRlZF06IChtYXRlcmlhbDogQ3J5cHRvS2V5LCBrZXlJbmRleD86IG51bWJlcikgPT4gdm9pZDtcbn07XG5cbmV4cG9ydCBlbnVtIEtleUhhbmRsZXJFdmVudCB7XG4gIEtleVJhdGNoZXRlZCA9ICdrZXlSYXRjaGV0ZWQnLFxufVxuXG5leHBvcnQgdHlwZSBQYXJ0aWNpcGFudEtleUhhbmRsZXJDYWxsYmFja3MgPSB7XG4gIFtLZXlIYW5kbGVyRXZlbnQuS2V5UmF0Y2hldGVkXTogKFxuICAgIG1hdGVyaWFsOiBDcnlwdG9LZXksXG4gICAgcGFydGljaXBhbnRJZGVudGl0eTogc3RyaW5nLFxuICAgIGtleUluZGV4PzogbnVtYmVyLFxuICApID0+IHZvaWQ7XG59O1xuXG5leHBvcnQgZW51bSBFbmNyeXB0aW9uRXZlbnQge1xuICBQYXJ0aWNpcGFudEVuY3J5cHRpb25TdGF0dXNDaGFuZ2VkID0gJ3BhcnRpY2lwYW50RW5jcnlwdGlvblN0YXR1c0NoYW5nZWQnLFxuICBFbmNyeXB0aW9uRXJyb3IgPSAnZW5jcnlwdGlvbkVycm9yJyxcbn1cblxuZXhwb3J0IHR5cGUgRTJFRU1hbmFnZXJDYWxsYmFja3MgPSB7XG4gIFtFbmNyeXB0aW9uRXZlbnQuUGFydGljaXBhbnRFbmNyeXB0aW9uU3RhdHVzQ2hhbmdlZF06IChcbiAgICBlbmFibGVkOiBib29sZWFuLFxuICAgIHBhcnRpY2lwYW50OiBQYXJ0aWNpcGFudCxcbiAgKSA9PiB2b2lkO1xuICBbRW5jcnlwdGlvbkV2ZW50LkVuY3J5cHRpb25FcnJvcl06IChlcnJvcjogRXJyb3IpID0+IHZvaWQ7XG59O1xuXG5leHBvcnQgdHlwZSBDcnlwdG9yQ2FsbGJhY2tzID0ge1xuICBbQ3J5cHRvckV2ZW50LkVycm9yXTogKGVycm9yOiBDcnlwdG9yRXJyb3IpID0+IHZvaWQ7XG59O1xuXG5leHBvcnQgZW51bSBDcnlwdG9yRXZlbnQge1xuICBFcnJvciA9ICdjcnlwdG9yRXJyb3InLFxufVxuIiwiaW1wb3J0IHsgRU5DUllQVElPTl9BTEdPUklUSE0gfSBmcm9tICcuL2NvbnN0YW50cyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0UyRUVTdXBwb3J0ZWQoKSB7XG4gIHJldHVybiBpc0luc2VydGFibGVTdHJlYW1TdXBwb3J0ZWQoKSB8fCBpc1NjcmlwdFRyYW5zZm9ybVN1cHBvcnRlZCgpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNTY3JpcHRUcmFuc2Zvcm1TdXBwb3J0ZWQoKSB7XG4gIC8vIEB0cy1pZ25vcmVcbiAgcmV0dXJuIHR5cGVvZiB3aW5kb3cuUlRDUnRwU2NyaXB0VHJhbnNmb3JtICE9PSAndW5kZWZpbmVkJztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzSW5zZXJ0YWJsZVN0cmVhbVN1cHBvcnRlZCgpIHtcbiAgcmV0dXJuIChcbiAgICB0eXBlb2Ygd2luZG93LlJUQ1J0cFNlbmRlciAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgdHlwZW9mIHdpbmRvdy5SVENSdHBTZW5kZXIucHJvdG90eXBlLmNyZWF0ZUVuY29kZWRTdHJlYW1zICE9PSAndW5kZWZpbmVkJ1xuICApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNWaWRlb0ZyYW1lKFxuICBmcmFtZTogUlRDRW5jb2RlZEF1ZGlvRnJhbWUgfCBSVENFbmNvZGVkVmlkZW9GcmFtZSxcbik6IGZyYW1lIGlzIFJUQ0VuY29kZWRWaWRlb0ZyYW1lIHtcbiAgcmV0dXJuICd0eXBlJyBpbiBmcmFtZTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGltcG9ydEtleShcbiAga2V5Qnl0ZXM6IFVpbnQ4QXJyYXkgfCBBcnJheUJ1ZmZlcixcbiAgYWxnb3JpdGhtOiBzdHJpbmcgfCB7IG5hbWU6IHN0cmluZyB9ID0geyBuYW1lOiBFTkNSWVBUSU9OX0FMR09SSVRITSB9LFxuICB1c2FnZTogJ2Rlcml2ZScgfCAnZW5jcnlwdCcgPSAnZW5jcnlwdCcsXG4pIHtcbiAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1N1YnRsZUNyeXB0by9pbXBvcnRLZXlcbiAgcmV0dXJuIGNyeXB0by5zdWJ0bGUuaW1wb3J0S2V5KFxuICAgICdyYXcnLFxuICAgIGtleUJ5dGVzLFxuICAgIGFsZ29yaXRobSxcbiAgICBmYWxzZSxcbiAgICB1c2FnZSA9PT0gJ2Rlcml2ZScgPyBbJ2Rlcml2ZUJpdHMnLCAnZGVyaXZlS2V5J10gOiBbJ2VuY3J5cHQnLCAnZGVjcnlwdCddLFxuICApO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY3JlYXRlS2V5TWF0ZXJpYWxGcm9tU3RyaW5nKHBhc3N3b3JkOiBzdHJpbmcpIHtcbiAgbGV0IGVuYyA9IG5ldyBUZXh0RW5jb2RlcigpO1xuXG4gIGNvbnN0IGtleU1hdGVyaWFsID0gYXdhaXQgY3J5cHRvLnN1YnRsZS5pbXBvcnRLZXkoXG4gICAgJ3JhdycsXG4gICAgZW5jLmVuY29kZShwYXNzd29yZCksXG4gICAge1xuICAgICAgbmFtZTogJ1BCS0RGMicsXG4gICAgfSxcbiAgICBmYWxzZSxcbiAgICBbJ2Rlcml2ZUJpdHMnLCAnZGVyaXZlS2V5J10sXG4gICk7XG5cbiAgcmV0dXJuIGtleU1hdGVyaWFsO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY3JlYXRlS2V5TWF0ZXJpYWxGcm9tQnVmZmVyKGNyeXB0b0J1ZmZlcjogQXJyYXlCdWZmZXIpIHtcbiAgY29uc3Qga2V5TWF0ZXJpYWwgPSBhd2FpdCBjcnlwdG8uc3VidGxlLmltcG9ydEtleSgncmF3JywgY3J5cHRvQnVmZmVyLCAnSEtERicsIGZhbHNlLCBbXG4gICAgJ2Rlcml2ZUJpdHMnLFxuICAgICdkZXJpdmVLZXknLFxuICBdKTtcblxuICByZXR1cm4ga2V5TWF0ZXJpYWw7XG59XG5cbmZ1bmN0aW9uIGdldEFsZ29PcHRpb25zKGFsZ29yaXRobU5hbWU6IHN0cmluZywgc2FsdDogc3RyaW5nKSB7XG4gIGNvbnN0IHRleHRFbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG4gIGNvbnN0IGVuY29kZWRTYWx0ID0gdGV4dEVuY29kZXIuZW5jb2RlKHNhbHQpO1xuICBzd2l0Y2ggKGFsZ29yaXRobU5hbWUpIHtcbiAgICBjYXNlICdIS0RGJzpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5hbWU6ICdIS0RGJyxcbiAgICAgICAgc2FsdDogZW5jb2RlZFNhbHQsXG4gICAgICAgIGhhc2g6ICdTSEEtMjU2JyxcbiAgICAgICAgaW5mbzogbmV3IEFycmF5QnVmZmVyKDEyOCksXG4gICAgICB9O1xuICAgIGNhc2UgJ1BCS0RGMic6IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5hbWU6ICdQQktERjInLFxuICAgICAgICBzYWx0OiBlbmNvZGVkU2FsdCxcbiAgICAgICAgaGFzaDogJ1NIQS0yNTYnLFxuICAgICAgICBpdGVyYXRpb25zOiAxMDAwMDAsXG4gICAgICB9O1xuICAgIH1cbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBhbGdvcml0aG0gJHthbGdvcml0aG1OYW1lfSBpcyBjdXJyZW50bHkgdW5zdXBwb3J0ZWRgKTtcbiAgfVxufVxuXG4vKipcbiAqIERlcml2ZXMgYSBzZXQgb2Yga2V5cyBmcm9tIHRoZSBtYXN0ZXIga2V5LlxuICogU2VlIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9kcmFmdC1vbWFyYS1zZnJhbWUtMDAjc2VjdGlvbi00LjMuMVxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZGVyaXZlS2V5cyhtYXRlcmlhbDogQ3J5cHRvS2V5LCBzYWx0OiBzdHJpbmcpIHtcbiAgY29uc3QgYWxnb3JpdGhtT3B0aW9ucyA9IGdldEFsZ29PcHRpb25zKG1hdGVyaWFsLmFsZ29yaXRobS5uYW1lLCBzYWx0KTtcblxuICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvU3VidGxlQ3J5cHRvL2Rlcml2ZUtleSNIS0RGXG4gIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9Ia2RmUGFyYW1zXG4gIGNvbnN0IGVuY3J5cHRpb25LZXkgPSBhd2FpdCBjcnlwdG8uc3VidGxlLmRlcml2ZUtleShcbiAgICBhbGdvcml0aG1PcHRpb25zLFxuICAgIG1hdGVyaWFsLFxuICAgIHtcbiAgICAgIG5hbWU6IEVOQ1JZUFRJT05fQUxHT1JJVEhNLFxuICAgICAgbGVuZ3RoOiAxMjgsXG4gICAgfSxcbiAgICBmYWxzZSxcbiAgICBbJ2VuY3J5cHQnLCAnZGVjcnlwdCddLFxuICApO1xuXG4gIHJldHVybiB7IG1hdGVyaWFsLCBlbmNyeXB0aW9uS2V5IH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVFMkVFS2V5KCk6IFVpbnQ4QXJyYXkge1xuICByZXR1cm4gd2luZG93LmNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQ4QXJyYXkoMzIpKTtcbn1cblxuLyoqXG4gKiBSYXRjaGV0cyBhIGtleS4gU2VlXG4gKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvZHJhZnQtb21hcmEtc2ZyYW1lLTAwI3NlY3Rpb24tNC4zLjUuMVxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmF0Y2hldChtYXRlcmlhbDogQ3J5cHRvS2V5LCBzYWx0OiBzdHJpbmcpOiBQcm9taXNlPEFycmF5QnVmZmVyPiB7XG4gIGNvbnN0IGFsZ29yaXRobU9wdGlvbnMgPSBnZXRBbGdvT3B0aW9ucyhtYXRlcmlhbC5hbGdvcml0aG0ubmFtZSwgc2FsdCk7XG5cbiAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1N1YnRsZUNyeXB0by9kZXJpdmVCaXRzXG4gIHJldHVybiBjcnlwdG8uc3VidGxlLmRlcml2ZUJpdHMoYWxnb3JpdGhtT3B0aW9ucywgbWF0ZXJpYWwsIDI1Nik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBuZWVkc1Jic3BVbmVzY2FwaW5nKGZyYW1lRGF0YTogVWludDhBcnJheSkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGZyYW1lRGF0YS5sZW5ndGggLSAzOyBpKyspIHtcbiAgICBpZiAoZnJhbWVEYXRhW2ldID09IDAgJiYgZnJhbWVEYXRhW2kgKyAxXSA9PSAwICYmIGZyYW1lRGF0YVtpICsgMl0gPT0gMykgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VSYnNwKHN0cmVhbTogVWludDhBcnJheSk6IFVpbnQ4QXJyYXkge1xuICBjb25zdCBkYXRhT3V0OiBudW1iZXJbXSA9IFtdO1xuICB2YXIgbGVuZ3RoID0gc3RyZWFtLmxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHJlYW0ubGVuZ3RoOyApIHtcbiAgICAvLyBCZSBjYXJlZnVsIGFib3V0IG92ZXIvdW5kZXJmbG93IGhlcmUuIGJ5dGVfbGVuZ3RoXyAtIDMgY2FuIHVuZGVyZmxvdywgYW5kXG4gICAgLy8gaSArIDMgY2FuIG92ZXJmbG93LCBidXQgYnl0ZV9sZW5ndGhfIC0gaSBjYW4ndCwgYmVjYXVzZSBpIDwgYnl0ZV9sZW5ndGhfXG4gICAgLy8gYWJvdmUsIGFuZCB0aGF0IGV4cHJlc3Npb24gd2lsbCBwcm9kdWNlIHRoZSBudW1iZXIgb2YgYnl0ZXMgbGVmdCBpblxuICAgIC8vIHRoZSBzdHJlYW0gaW5jbHVkaW5nIHRoZSBieXRlIGF0IGkuXG4gICAgaWYgKGxlbmd0aCAtIGkgPj0gMyAmJiAhc3RyZWFtW2ldICYmICFzdHJlYW1baSArIDFdICYmIHN0cmVhbVtpICsgMl0gPT0gMykge1xuICAgICAgLy8gVHdvIHJic3AgYnl0ZXMuXG4gICAgICBkYXRhT3V0LnB1c2goc3RyZWFtW2krK10pO1xuICAgICAgZGF0YU91dC5wdXNoKHN0cmVhbVtpKytdKTtcbiAgICAgIC8vIFNraXAgdGhlIGVtdWxhdGlvbiBieXRlLlxuICAgICAgaSsrO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTaW5nbGUgcmJzcCBieXRlLlxuICAgICAgZGF0YU91dC5wdXNoKHN0cmVhbVtpKytdKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGRhdGFPdXQpO1xufVxuXG5jb25zdCBrWmVyb3NJblN0YXJ0U2VxdWVuY2UgPSAyO1xuY29uc3Qga0VtdWxhdGlvbkJ5dGUgPSAzO1xuXG5leHBvcnQgZnVuY3Rpb24gd3JpdGVSYnNwKGRhdGFfaW46IFVpbnQ4QXJyYXkpOiBVaW50OEFycmF5IHtcbiAgY29uc3QgZGF0YU91dDogbnVtYmVyW10gPSBbXTtcbiAgdmFyIG51bUNvbnNlY3V0aXZlWmVyb3MgPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGFfaW4ubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgYnl0ZSA9IGRhdGFfaW5baV07XG4gICAgaWYgKGJ5dGUgPD0ga0VtdWxhdGlvbkJ5dGUgJiYgbnVtQ29uc2VjdXRpdmVaZXJvcyA+PSBrWmVyb3NJblN0YXJ0U2VxdWVuY2UpIHtcbiAgICAgIC8vIE5lZWQgdG8gZXNjYXBlLlxuICAgICAgZGF0YU91dC5wdXNoKGtFbXVsYXRpb25CeXRlKTtcbiAgICAgIG51bUNvbnNlY3V0aXZlWmVyb3MgPSAwO1xuICAgIH1cbiAgICBkYXRhT3V0LnB1c2goYnl0ZSk7XG4gICAgaWYgKGJ5dGUgPT0gMCkge1xuICAgICAgKytudW1Db25zZWN1dGl2ZVplcm9zO1xuICAgIH0gZWxzZSB7XG4gICAgICBudW1Db25zZWN1dGl2ZVplcm9zID0gMDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGRhdGFPdXQpO1xufVxuIiwiaW1wb3J0IHsgRXZlbnRFbWl0dGVyIH0gZnJvbSAnZXZlbnRzJztcbmltcG9ydCB0eXBlIFR5cGVkRXZlbnRFbWl0dGVyIGZyb20gJ3R5cGVkLWVtaXR0ZXInO1xuaW1wb3J0IGxvZyBmcm9tICcuLi9sb2dnZXInO1xuaW1wb3J0IHsgS0VZX1BST1ZJREVSX0RFRkFVTFRTIH0gZnJvbSAnLi9jb25zdGFudHMnO1xuaW1wb3J0IHsgdHlwZSBLZXlQcm92aWRlckNhbGxiYWNrcywgS2V5UHJvdmlkZXJFdmVudCB9IGZyb20gJy4vZXZlbnRzJztcbmltcG9ydCB0eXBlIHsgS2V5SW5mbywgS2V5UHJvdmlkZXJPcHRpb25zIH0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQgeyBjcmVhdGVLZXlNYXRlcmlhbEZyb21CdWZmZXIsIGNyZWF0ZUtleU1hdGVyaWFsRnJvbVN0cmluZyB9IGZyb20gJy4vdXRpbHMnO1xuXG4vKipcbiAqIEBleHBlcmltZW50YWxcbiAqL1xuZXhwb3J0IGNsYXNzIEJhc2VLZXlQcm92aWRlciBleHRlbmRzIChFdmVudEVtaXR0ZXIgYXMgbmV3ICgpID0+IFR5cGVkRXZlbnRFbWl0dGVyPEtleVByb3ZpZGVyQ2FsbGJhY2tzPikge1xuICBwcml2YXRlIGtleUluZm9NYXA6IE1hcDxzdHJpbmcsIEtleUluZm8+O1xuXG4gIHByaXZhdGUgb3B0aW9uczogS2V5UHJvdmlkZXJPcHRpb25zO1xuXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnM6IFBhcnRpYWw8S2V5UHJvdmlkZXJPcHRpb25zPiA9IHt9KSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmtleUluZm9NYXAgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5vcHRpb25zID0geyAuLi5LRVlfUFJPVklERVJfREVGQVVMVFMsIC4uLm9wdGlvbnMgfTtcbiAgICB0aGlzLm9uKEtleVByb3ZpZGVyRXZlbnQuS2V5UmF0Y2hldGVkLCB0aGlzLm9uS2V5UmF0Y2hldGVkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBjYWxsYmFjayB0byBpbnZva2Ugb25jZSBhIGtleSBoYXMgYmVlbiBzZXQgZm9yIGEgcGFydGljaXBhbnRcbiAgICogQHBhcmFtIGtleVxuICAgKiBAcGFyYW0gcGFydGljaXBhbnRJZGVudGl0eVxuICAgKiBAcGFyYW0ga2V5SW5kZXhcbiAgICovXG4gIHByb3RlY3RlZCBvblNldEVuY3J5cHRpb25LZXkoa2V5OiBDcnlwdG9LZXksIHBhcnRpY2lwYW50SWRlbnRpdHk/OiBzdHJpbmcsIGtleUluZGV4PzogbnVtYmVyKSB7XG4gICAgY29uc3Qga2V5SW5mbzogS2V5SW5mbyA9IHsga2V5LCBwYXJ0aWNpcGFudElkZW50aXR5LCBrZXlJbmRleCB9O1xuICAgIHRoaXMua2V5SW5mb01hcC5zZXQoYCR7cGFydGljaXBhbnRJZGVudGl0eSA/PyAnc2hhcmVkJ30tJHtrZXlJbmRleCA/PyAwfWAsIGtleUluZm8pO1xuICAgIHRoaXMuZW1pdChLZXlQcm92aWRlckV2ZW50LlNldEtleSwga2V5SW5mbyk7XG4gIH1cblxuICAvKipcbiAgICogY2FsbGJhY2sgYmVpbmcgaW52b2tlZCBhZnRlciBhIHJhdGNoZXQgcmVxdWVzdCBoYXMgYmVlbiBwZXJmb3JtZWQgb24gYSBwYXJ0aWNpcGFudFxuICAgKiB0aGF0IHN1cmZhY2VzIHRoZSBuZXcga2V5IG1hdGVyaWFsLlxuICAgKiBAcGFyYW0gbWF0ZXJpYWxcbiAgICogQHBhcmFtIGtleUluZGV4XG4gICAqL1xuICBwcm90ZWN0ZWQgb25LZXlSYXRjaGV0ZWQgPSAobWF0ZXJpYWw6IENyeXB0b0tleSwga2V5SW5kZXg/OiBudW1iZXIpID0+IHtcbiAgICBsb2cuZGVidWcoJ2tleSByYXRjaGV0ZWQgZXZlbnQgcmVjZWl2ZWQnLCB7IG1hdGVyaWFsLCBrZXlJbmRleCB9KTtcbiAgfTtcblxuICBnZXRLZXlzKCkge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMua2V5SW5mb01hcC52YWx1ZXMoKSk7XG4gIH1cblxuICBnZXRPcHRpb25zKCkge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnM7XG4gIH1cblxuICByYXRjaGV0S2V5KHBhcnRpY2lwYW50SWRlbnRpdHk/OiBzdHJpbmcsIGtleUluZGV4PzogbnVtYmVyKSB7XG4gICAgdGhpcy5lbWl0KEtleVByb3ZpZGVyRXZlbnQuUmF0Y2hldFJlcXVlc3QsIHBhcnRpY2lwYW50SWRlbnRpdHksIGtleUluZGV4KTtcbiAgfVxufVxuXG4vKipcbiAqIEEgYmFzaWMgS2V5UHJvdmlkZXIgaW1wbGVtZW50YXRpb24gaW50ZW5kZWQgZm9yIGEgc2luZ2xlIHNoYXJlZFxuICogcGFzc3BocmFzZSBiZXR3ZWVuIGFsbCBwYXJ0aWNpcGFudHNcbiAqIEBleHBlcmltZW50YWxcbiAqL1xuZXhwb3J0IGNsYXNzIEV4dGVybmFsRTJFRUtleVByb3ZpZGVyIGV4dGVuZHMgQmFzZUtleVByb3ZpZGVyIHtcbiAgcmF0Y2hldEludGVydmFsOiBudW1iZXIgfCB1bmRlZmluZWQ7XG5cbiAgY29uc3RydWN0b3Iob3B0aW9uczogUGFydGlhbDxPbWl0PEtleVByb3ZpZGVyT3B0aW9ucywgJ3NoYXJlZEtleSc+PiA9IHt9KSB7XG4gICAgY29uc3Qgb3B0czogUGFydGlhbDxLZXlQcm92aWRlck9wdGlvbnM+ID0ge1xuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIHNoYXJlZEtleTogdHJ1ZSxcbiAgICAgIC8vIGZvciBhIHNoYXJlZCBrZXkgcHJvdmlkZXIgZmFpbGluZyB0byBkZWNyeXB0IGZvciBhIHNwZWNpZmljIHBhcnRpY2lwYW50XG4gICAgICAvLyBzaG91bGQgbm90IG1hcmsgdGhlIGtleSBhcyBpbnZhbGlkLCBzbyB3ZSBhY2NlcHQgd3Jvbmcga2V5cyBmb3JldmVyXG4gICAgICAvLyBhbmQgd29uJ3QgdHJ5IHRvIGF1dG8tcmF0Y2hldFxuICAgICAgcmF0Y2hldFdpbmRvd1NpemU6IDAsXG4gICAgICBmYWlsdXJlVG9sZXJhbmNlOiAtMSxcbiAgICB9O1xuICAgIHN1cGVyKG9wdHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFjY2VwdHMgYSBwYXNzcGhyYXNlIHRoYXQncyB1c2VkIHRvIGNyZWF0ZSB0aGUgY3J5cHRvIGtleXMuXG4gICAqIFdoZW4gcGFzc2luZyBpbiBhIHN0cmluZywgUEJLREYyIGlzIHVzZWQuXG4gICAqIFdoZW4gcGFzc2luZyBpbiBhbiBBcnJheSBidWZmZXIgb2YgY3J5cHRvZ3JhcGhpY2FsbHkgcmFuZG9tIG51bWJlcnMsIEhLREYgaXMgYmVpbmcgdXNlZC4gKHJlY29tbWVuZGVkKVxuICAgKiBAcGFyYW0ga2V5XG4gICAqL1xuICBhc3luYyBzZXRLZXkoa2V5OiBzdHJpbmcgfCBBcnJheUJ1ZmZlcikge1xuICAgIGNvbnN0IGRlcml2ZWRLZXkgPVxuICAgICAgdHlwZW9mIGtleSA9PT0gJ3N0cmluZydcbiAgICAgICAgPyBhd2FpdCBjcmVhdGVLZXlNYXRlcmlhbEZyb21TdHJpbmcoa2V5KVxuICAgICAgICA6IGF3YWl0IGNyZWF0ZUtleU1hdGVyaWFsRnJvbUJ1ZmZlcihrZXkpO1xuICAgIHRoaXMub25TZXRFbmNyeXB0aW9uS2V5KGRlcml2ZWRLZXkpO1xuICB9XG59XG4iLCJleHBvcnQgY2xhc3MgTGl2ZWtpdEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb2RlOiBudW1iZXI7XG5cbiAgY29uc3RydWN0b3IoY29kZTogbnVtYmVyLCBtZXNzYWdlPzogc3RyaW5nKSB7XG4gICAgc3VwZXIobWVzc2FnZSB8fCAnYW4gZXJyb3IgaGFzIG9jY3VyZWQnKTtcbiAgICB0aGlzLmNvZGUgPSBjb2RlO1xuICB9XG59XG5cbmV4cG9ydCBjb25zdCBlbnVtIENvbm5lY3Rpb25FcnJvclJlYXNvbiB7XG4gIE5vdEFsbG93ZWQsXG4gIFNlcnZlclVucmVhY2hhYmxlLFxuICBJbnRlcm5hbEVycm9yLFxuICBDYW5jZWxsZWQsXG4gIExlYXZlUmVxdWVzdCxcbn1cblxuZXhwb3J0IGNsYXNzIENvbm5lY3Rpb25FcnJvciBleHRlbmRzIExpdmVraXRFcnJvciB7XG4gIHN0YXR1cz86IG51bWJlcjtcblxuICByZWFzb24/OiBDb25uZWN0aW9uRXJyb3JSZWFzb247XG5cbiAgY29uc3RydWN0b3IobWVzc2FnZT86IHN0cmluZywgcmVhc29uPzogQ29ubmVjdGlvbkVycm9yUmVhc29uLCBzdGF0dXM/OiBudW1iZXIpIHtcbiAgICBzdXBlcigxLCBtZXNzYWdlKTtcbiAgICB0aGlzLnN0YXR1cyA9IHN0YXR1cztcbiAgICB0aGlzLnJlYXNvbiA9IHJlYXNvbjtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgRGV2aWNlVW5zdXBwb3J0ZWRFcnJvciBleHRlbmRzIExpdmVraXRFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2U/OiBzdHJpbmcpIHtcbiAgICBzdXBlcigyMSwgbWVzc2FnZSA/PyAnZGV2aWNlIGlzIHVuc3VwcG9ydGVkJyk7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIFRyYWNrSW52YWxpZEVycm9yIGV4dGVuZHMgTGl2ZWtpdEVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZT86IHN0cmluZykge1xuICAgIHN1cGVyKDIwLCBtZXNzYWdlID8/ICd0cmFjayBpcyBpbnZhbGlkJyk7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIFVuc3VwcG9ydGVkU2VydmVyIGV4dGVuZHMgTGl2ZWtpdEVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZT86IHN0cmluZykge1xuICAgIHN1cGVyKDEwLCBtZXNzYWdlID8/ICd1bnN1cHBvcnRlZCBzZXJ2ZXInKTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgVW5leHBlY3RlZENvbm5lY3Rpb25TdGF0ZSBleHRlbmRzIExpdmVraXRFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2U/OiBzdHJpbmcpIHtcbiAgICBzdXBlcigxMiwgbWVzc2FnZSA/PyAndW5leHBlY3RlZCBjb25uZWN0aW9uIHN0YXRlJyk7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIE5lZ290aWF0aW9uRXJyb3IgZXh0ZW5kcyBMaXZla2l0RXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlPzogc3RyaW5nKSB7XG4gICAgc3VwZXIoMTMsIG1lc3NhZ2UgPz8gJ3VuYWJsZSB0byBuZWdvdGlhdGUnKTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgUHVibGlzaERhdGFFcnJvciBleHRlbmRzIExpdmVraXRFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2U/OiBzdHJpbmcpIHtcbiAgICBzdXBlcigxMywgbWVzc2FnZSA/PyAndW5hYmxlIHRvIHB1Ymxpc2ggZGF0YScpO1xuICB9XG59XG5cbmV4cG9ydCBlbnVtIE1lZGlhRGV2aWNlRmFpbHVyZSB7XG4gIC8vIHVzZXIgcmVqZWN0ZWQgcGVybWlzc2lvbnNcbiAgUGVybWlzc2lvbkRlbmllZCA9ICdQZXJtaXNzaW9uRGVuaWVkJyxcbiAgLy8gZGV2aWNlIGlzIG5vdCBhdmFpbGFibGVcbiAgTm90Rm91bmQgPSAnTm90Rm91bmQnLFxuICAvLyBkZXZpY2UgaXMgaW4gdXNlLiBPbiBXaW5kb3dzLCBvbmx5IGEgc2luZ2xlIHRhYiBtYXkgZ2V0IGFjY2VzcyB0byBhIGRldmljZSBhdCBhIHRpbWUuXG4gIERldmljZUluVXNlID0gJ0RldmljZUluVXNlJyxcbiAgT3RoZXIgPSAnT3RoZXInLFxufVxuXG5leHBvcnQgbmFtZXNwYWNlIE1lZGlhRGV2aWNlRmFpbHVyZSB7XG4gIGV4cG9ydCBmdW5jdGlvbiBnZXRGYWlsdXJlKGVycm9yOiBhbnkpOiBNZWRpYURldmljZUZhaWx1cmUgfCB1bmRlZmluZWQge1xuICAgIGlmIChlcnJvciAmJiAnbmFtZScgaW4gZXJyb3IpIHtcbiAgICAgIGlmIChlcnJvci5uYW1lID09PSAnTm90Rm91bmRFcnJvcicgfHwgZXJyb3IubmFtZSA9PT0gJ0RldmljZXNOb3RGb3VuZEVycm9yJykge1xuICAgICAgICByZXR1cm4gTWVkaWFEZXZpY2VGYWlsdXJlLk5vdEZvdW5kO1xuICAgICAgfVxuICAgICAgaWYgKGVycm9yLm5hbWUgPT09ICdOb3RBbGxvd2VkRXJyb3InIHx8IGVycm9yLm5hbWUgPT09ICdQZXJtaXNzaW9uRGVuaWVkRXJyb3InKSB7XG4gICAgICAgIHJldHVybiBNZWRpYURldmljZUZhaWx1cmUuUGVybWlzc2lvbkRlbmllZDtcbiAgICAgIH1cbiAgICAgIGlmIChlcnJvci5uYW1lID09PSAnTm90UmVhZGFibGVFcnJvcicgfHwgZXJyb3IubmFtZSA9PT0gJ1RyYWNrU3RhcnRFcnJvcicpIHtcbiAgICAgICAgcmV0dXJuIE1lZGlhRGV2aWNlRmFpbHVyZS5EZXZpY2VJblVzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBNZWRpYURldmljZUZhaWx1cmUuT3RoZXI7XG4gICAgfVxuICB9XG59XG4iLCIvKipcbiAqIEV2ZW50cyBhcmUgdGhlIHByaW1hcnkgd2F5IExpdmVLaXQgbm90aWZpZXMgeW91ciBhcHBsaWNhdGlvbiBvZiBjaGFuZ2VzLlxuICpcbiAqIFRoZSBmb2xsb3dpbmcgYXJlIGV2ZW50cyBlbWl0dGVkIGJ5IFtbUm9vbV1dLCBsaXN0ZW4gdG8gcm9vbSBldmVudHMgbGlrZVxuICpcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIHJvb20ub24oUm9vbUV2ZW50LlRyYWNrUHVibGlzaGVkLCAodHJhY2ssIHB1YmxpY2F0aW9uLCBwYXJ0aWNpcGFudCkgPT4ge30pXG4gKiBgYGBcbiAqL1xuXG5leHBvcnQgZW51bSBSb29tRXZlbnQge1xuICAvKipcbiAgICogV2hlbiB0aGUgY29ubmVjdGlvbiB0byB0aGUgc2VydmVyIGhhcyBiZWVuIGVzdGFibGlzaGVkXG4gICAqL1xuICBDb25uZWN0ZWQgPSAnY29ubmVjdGVkJyxcblxuICAvKipcbiAgICogV2hlbiB0aGUgY29ubmVjdGlvbiB0byB0aGUgc2VydmVyIGhhcyBiZWVuIGludGVycnVwdGVkIGFuZCBpdCdzIGF0dGVtcHRpbmdcbiAgICogdG8gcmVjb25uZWN0LlxuICAgKi9cbiAgUmVjb25uZWN0aW5nID0gJ3JlY29ubmVjdGluZycsXG5cbiAgLyoqXG4gICAqIEZpcmVzIHdoZW4gYSByZWNvbm5lY3Rpb24gaGFzIGJlZW4gc3VjY2Vzc2Z1bC5cbiAgICovXG4gIFJlY29ubmVjdGVkID0gJ3JlY29ubmVjdGVkJyxcblxuICAvKipcbiAgICogV2hlbiBkaXNjb25uZWN0ZWQgZnJvbSByb29tLiBUaGlzIGZpcmVzIHdoZW4gcm9vbS5kaXNjb25uZWN0KCkgaXMgY2FsbGVkIG9yXG4gICAqIHdoZW4gYW4gdW5yZWNvdmVyYWJsZSBjb25uZWN0aW9uIGlzc3VlIGhhZCBvY2N1cmVkXG4gICAqL1xuICBEaXNjb25uZWN0ZWQgPSAnZGlzY29ubmVjdGVkJyxcblxuICAvKipcbiAgICogV2hlbmV2ZXIgdGhlIGNvbm5lY3Rpb24gc3RhdGUgb2YgdGhlIHJvb20gY2hhbmdlc1xuICAgKlxuICAgKiBhcmdzOiAoW1tDb25uZWN0aW9uU3RhdGVdXSlcbiAgICovXG4gIENvbm5lY3Rpb25TdGF0ZUNoYW5nZWQgPSAnY29ubmVjdGlvblN0YXRlQ2hhbmdlZCcsXG5cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIFN0YXRlQ2hhbmdlZCBoYXMgYmVlbiByZW5hbWVkIHRvIENvbm5lY3Rpb25TdGF0ZUNoYW5nZWRcbiAgICovXG4gIFN0YXRlQ2hhbmdlZCA9ICdjb25uZWN0aW9uU3RhdGVDaGFuZ2VkJyxcblxuICAvKipcbiAgICogV2hlbiBpbnB1dCBvciBvdXRwdXQgZGV2aWNlcyBvbiB0aGUgbWFjaGluZSBoYXZlIGNoYW5nZWQuXG4gICAqL1xuICBNZWRpYURldmljZXNDaGFuZ2VkID0gJ21lZGlhRGV2aWNlc0NoYW5nZWQnLFxuXG4gIC8qKlxuICAgKiBXaGVuIGEgW1tSZW1vdGVQYXJ0aWNpcGFudF1dIGpvaW5zICphZnRlciogdGhlIGxvY2FsXG4gICAqIHBhcnRpY2lwYW50LiBJdCB3aWxsIG5vdCBlbWl0IGV2ZW50cyBmb3IgcGFydGljaXBhbnRzIHRoYXQgYXJlIGFscmVhZHlcbiAgICogaW4gdGhlIHJvb21cbiAgICpcbiAgICogYXJnczogKFtbUmVtb3RlUGFydGljaXBhbnRdXSlcbiAgICovXG4gIFBhcnRpY2lwYW50Q29ubmVjdGVkID0gJ3BhcnRpY2lwYW50Q29ubmVjdGVkJyxcblxuICAvKipcbiAgICogV2hlbiBhIFtbUmVtb3RlUGFydGljaXBhbnRdXSBsZWF2ZXMgKmFmdGVyKiB0aGUgbG9jYWxcbiAgICogcGFydGljaXBhbnQgaGFzIGpvaW5lZC5cbiAgICpcbiAgICogYXJnczogKFtbUmVtb3RlUGFydGljaXBhbnRdXSlcbiAgICovXG4gIFBhcnRpY2lwYW50RGlzY29ubmVjdGVkID0gJ3BhcnRpY2lwYW50RGlzY29ubmVjdGVkJyxcblxuICAvKipcbiAgICogV2hlbiBhIG5ldyB0cmFjayBpcyBwdWJsaXNoZWQgdG8gcm9vbSAqYWZ0ZXIqIHRoZSBsb2NhbFxuICAgKiBwYXJ0aWNpcGFudCBoYXMgam9pbmVkLiBJdCB3aWxsIG5vdCBmaXJlIGZvciB0cmFja3MgdGhhdCBhcmUgYWxyZWFkeSBwdWJsaXNoZWQuXG4gICAqXG4gICAqIEEgdHJhY2sgcHVibGlzaGVkIGRvZXNuJ3QgbWVhbiB0aGUgcGFydGljaXBhbnQgaGFzIHN1YnNjcmliZWQgdG8gaXQuIEl0J3NcbiAgICogc2ltcGx5IHJlZmxlY3RpbmcgdGhlIHN0YXRlIG9mIHRoZSByb29tLlxuICAgKlxuICAgKiBhcmdzOiAoW1tSZW1vdGVUcmFja1B1YmxpY2F0aW9uXV0sIFtbUmVtb3RlUGFydGljaXBhbnRdXSlcbiAgICovXG4gIFRyYWNrUHVibGlzaGVkID0gJ3RyYWNrUHVibGlzaGVkJyxcblxuICAvKipcbiAgICogVGhlIFtbTG9jYWxQYXJ0aWNpcGFudF1dIGhhcyBzdWJzY3JpYmVkIHRvIGEgbmV3IHRyYWNrLiBUaGlzIGV2ZW50IHdpbGwgKiphbHdheXMqKlxuICAgKiBmaXJlIGFzIGxvbmcgYXMgbmV3IHRyYWNrcyBhcmUgcmVhZHkgZm9yIHVzZS5cbiAgICpcbiAgICogYXJnczogKFtbUmVtb3RlVHJhY2tdXSwgW1tSZW1vdGVUcmFja1B1YmxpY2F0aW9uXV0sIFtbUmVtb3RlUGFydGljaXBhbnRdXSlcbiAgICovXG4gIFRyYWNrU3Vic2NyaWJlZCA9ICd0cmFja1N1YnNjcmliZWQnLFxuXG4gIC8qKlxuICAgKiBDb3VsZCBub3Qgc3Vic2NyaWJlIHRvIGEgdHJhY2tcbiAgICpcbiAgICogYXJnczogKHRyYWNrIHNpZCwgW1tSZW1vdGVQYXJ0aWNpcGFudF1dKVxuICAgKi9cbiAgVHJhY2tTdWJzY3JpcHRpb25GYWlsZWQgPSAndHJhY2tTdWJzY3JpcHRpb25GYWlsZWQnLFxuXG4gIC8qKlxuICAgKiBBIFtbUmVtb3RlUGFydGljaXBhbnRdXSBoYXMgdW5wdWJsaXNoZWQgYSB0cmFja1xuICAgKlxuICAgKiBhcmdzOiAoW1tSZW1vdGVUcmFja1B1YmxpY2F0aW9uXV0sIFtbUmVtb3RlUGFydGljaXBhbnRdXSlcbiAgICovXG4gIFRyYWNrVW5wdWJsaXNoZWQgPSAndHJhY2tVbnB1Ymxpc2hlZCcsXG5cbiAgLyoqXG4gICAqIEEgc3Vic2NyaWJlZCB0cmFjayBpcyBubyBsb25nZXIgYXZhaWxhYmxlLiBDbGllbnRzIHNob3VsZCBsaXN0ZW4gdG8gdGhpc1xuICAgKiBldmVudCBhbmQgZW5zdXJlIHRoZXkgZGV0YWNoIHRyYWNrcy5cbiAgICpcbiAgICogYXJnczogKFtbVHJhY2tdXSwgW1tSZW1vdGVUcmFja1B1YmxpY2F0aW9uXV0sIFtbUmVtb3RlUGFydGljaXBhbnRdXSlcbiAgICovXG4gIFRyYWNrVW5zdWJzY3JpYmVkID0gJ3RyYWNrVW5zdWJzY3JpYmVkJyxcblxuICAvKipcbiAgICogQSB0cmFjayB0aGF0IHdhcyBtdXRlZCwgZmlyZXMgb24gYm90aCBbW1JlbW90ZVBhcnRpY2lwYW50XV1zIGFuZCBbW0xvY2FsUGFydGljaXBhbnRdXVxuICAgKlxuICAgKiBhcmdzOiAoW1tUcmFja1B1YmxpY2F0aW9uXV0sIFtbUGFydGljaXBhbnRdXSlcbiAgICovXG4gIFRyYWNrTXV0ZWQgPSAndHJhY2tNdXRlZCcsXG5cbiAgLyoqXG4gICAqIEEgdHJhY2sgdGhhdCB3YXMgdW5tdXRlZCwgZmlyZXMgb24gYm90aCBbW1JlbW90ZVBhcnRpY2lwYW50XV1zIGFuZCBbW0xvY2FsUGFydGljaXBhbnRdXVxuICAgKlxuICAgKiBhcmdzOiAoW1tUcmFja1B1YmxpY2F0aW9uXV0sIFtbUGFydGljaXBhbnRdXSlcbiAgICovXG4gIFRyYWNrVW5tdXRlZCA9ICd0cmFja1VubXV0ZWQnLFxuXG4gIC8qKlxuICAgKiBBIGxvY2FsIHRyYWNrIHdhcyBwdWJsaXNoZWQgc3VjY2Vzc2Z1bGx5LiBUaGlzIGV2ZW50IGlzIGhlbHBmdWwgdG8ga25vd1xuICAgKiB3aGVuIHRvIHVwZGF0ZSB5b3VyIGxvY2FsIFVJIHdpdGggdGhlIG5ld2x5IHB1Ymxpc2hlZCB0cmFjay5cbiAgICpcbiAgICogYXJnczogKFtbTG9jYWxUcmFja1B1YmxpY2F0aW9uXV0sIFtbTG9jYWxQYXJ0aWNpcGFudF1dKVxuICAgKi9cbiAgTG9jYWxUcmFja1B1Ymxpc2hlZCA9ICdsb2NhbFRyYWNrUHVibGlzaGVkJyxcblxuICAvKipcbiAgICogQSBsb2NhbCB0cmFjayB3YXMgdW5wdWJsaXNoZWQuIFRoaXMgZXZlbnQgaXMgaGVscGZ1bCB0byBrbm93IHdoZW4gdG8gcmVtb3ZlXG4gICAqIHRoZSBsb2NhbCB0cmFjayBmcm9tIHlvdXIgVUkuXG4gICAqXG4gICAqIFdoZW4gYSB1c2VyIHN0b3BzIHNoYXJpbmcgdGhlaXIgc2NyZWVuIGJ5IHByZXNzaW5nIFwiRW5kXCIgb24gdGhlIGJyb3dzZXIgVUksXG4gICAqIHRoaXMgZXZlbnQgd2lsbCBhbHNvIGZpcmUuXG4gICAqXG4gICAqIGFyZ3M6IChbW0xvY2FsVHJhY2tQdWJsaWNhdGlvbl1dLCBbW0xvY2FsUGFydGljaXBhbnRdXSlcbiAgICovXG4gIExvY2FsVHJhY2tVbnB1Ymxpc2hlZCA9ICdsb2NhbFRyYWNrVW5wdWJsaXNoZWQnLFxuXG4gIC8qKlxuICAgKiBXaGVuIGEgbG9jYWwgYXVkaW8gdHJhY2sgaXMgcHVibGlzaGVkIHRoZSBTREsgY2hlY2tzIHdoZXRoZXIgdGhlcmUgaXMgY29tcGxldGUgc2lsZW5jZVxuICAgKiBvbiB0aGF0IHRyYWNrIGFuZCBlbWl0cyB0aGUgTG9jYWxBdWRpb1NpbGVuY2VEZXRlY3RlZCBldmVudCBpbiB0aGF0IGNhc2UuXG4gICAqIFRoaXMgYWxsb3dzIGZvciBhcHBsaWNhdGlvbnMgdG8gc2hvdyBVSSBpbmZvcm1pbmcgdXNlcnMgdGhhdCB0aGV5IG1pZ2h0IGhhdmUgdG9cbiAgICogcmVzZXQgdGhlaXIgYXVkaW8gaGFyZHdhcmUgb3IgY2hlY2sgZm9yIHByb3BlciBkZXZpY2UgY29ubmVjdGl2aXR5LlxuICAgKi9cbiAgTG9jYWxBdWRpb1NpbGVuY2VEZXRlY3RlZCA9ICdsb2NhbEF1ZGlvU2lsZW5jZURldGVjdGVkJyxcblxuICAvKipcbiAgICogQWN0aXZlIHNwZWFrZXJzIGNoYW5nZWQuIExpc3Qgb2Ygc3BlYWtlcnMgYXJlIG9yZGVyZWQgYnkgdGhlaXIgYXVkaW8gbGV2ZWwuXG4gICAqIGxvdWRlc3Qgc3BlYWtlcnMgZmlyc3QuIFRoaXMgd2lsbCBpbmNsdWRlIHRoZSBMb2NhbFBhcnRpY2lwYW50IHRvby5cbiAgICpcbiAgICogU3BlYWtlciB1cGRhdGVzIGFyZSBzZW50IG9ubHkgdG8gdGhlIHB1Ymxpc2hpbmcgcGFydGljaXBhbnQgYW5kIHRoZWlyIHN1YnNjcmliZXJzLlxuICAgKlxuICAgKiBhcmdzOiAoQXJyYXk8W1tQYXJ0aWNpcGFudF1dPilcbiAgICovXG4gIEFjdGl2ZVNwZWFrZXJzQ2hhbmdlZCA9ICdhY3RpdmVTcGVha2Vyc0NoYW5nZWQnLFxuXG4gIC8qKlxuICAgKiBQYXJ0aWNpcGFudCBtZXRhZGF0YSBpcyBhIHNpbXBsZSB3YXkgZm9yIGFwcC1zcGVjaWZpYyBzdGF0ZSB0byBiZSBwdXNoZWQgdG9cbiAgICogYWxsIHVzZXJzLlxuICAgKiBXaGVuIFJvb21TZXJ2aWNlLlVwZGF0ZVBhcnRpY2lwYW50TWV0YWRhdGEgaXMgY2FsbGVkIHRvIGNoYW5nZSBhIHBhcnRpY2lwYW50J3NcbiAgICogc3RhdGUsICphbGwqICBwYXJ0aWNpcGFudHMgaW4gdGhlIHJvb20gd2lsbCBmaXJlIHRoaXMgZXZlbnQuXG4gICAqXG4gICAqIGFyZ3M6IChwcmV2TWV0YWRhdGE6IHN0cmluZywgW1tQYXJ0aWNpcGFudF1dKVxuICAgKlxuICAgKi9cbiAgUGFydGljaXBhbnRNZXRhZGF0YUNoYW5nZWQgPSAncGFydGljaXBhbnRNZXRhZGF0YUNoYW5nZWQnLFxuXG4gIC8qKlxuICAgKiBQYXJ0aWNpcGFudCdzIGRpc3BsYXkgbmFtZSBjaGFuZ2VkXG4gICAqXG4gICAqIGFyZ3M6IChuYW1lOiBzdHJpbmcsIFtbUGFydGljaXBhbnRdXSlcbiAgICpcbiAgICovXG4gIFBhcnRpY2lwYW50TmFtZUNoYW5nZWQgPSAncGFydGljaXBhbnROYW1lQ2hhbmdlZCcsXG5cbiAgLyoqXG4gICAqIFJvb20gbWV0YWRhdGEgaXMgYSBzaW1wbGUgd2F5IGZvciBhcHAtc3BlY2lmaWMgc3RhdGUgdG8gYmUgcHVzaGVkIHRvXG4gICAqIGFsbCB1c2Vycy5cbiAgICogV2hlbiBSb29tU2VydmljZS5VcGRhdGVSb29tTWV0YWRhdGEgaXMgY2FsbGVkIHRvIGNoYW5nZSBhIHJvb20ncyBzdGF0ZSxcbiAgICogKmFsbCogIHBhcnRpY2lwYW50cyBpbiB0aGUgcm9vbSB3aWxsIGZpcmUgdGhpcyBldmVudC5cbiAgICpcbiAgICogYXJnczogKHN0cmluZylcbiAgICovXG4gIFJvb21NZXRhZGF0YUNoYW5nZWQgPSAncm9vbU1ldGFkYXRhQ2hhbmdlZCcsXG5cbiAgLyoqXG4gICAqIERhdGEgcmVjZWl2ZWQgZnJvbSBhbm90aGVyIHBhcnRpY2lwYW50LlxuICAgKiBEYXRhIHBhY2tldHMgcHJvdmlkZXMgdGhlIGFiaWxpdHkgdG8gdXNlIExpdmVLaXQgdG8gc2VuZC9yZWNlaXZlIGFyYml0cmFyeSBwYXlsb2Fkcy5cbiAgICogQWxsIHBhcnRpY2lwYW50cyBpbiB0aGUgcm9vbSB3aWxsIHJlY2VpdmUgdGhlIG1lc3NhZ2VzIHNlbnQgdG8gdGhlIHJvb20uXG4gICAqXG4gICAqIGFyZ3M6IChwYXlsb2FkOiBVaW50OEFycmF5LCBwYXJ0aWNpcGFudDogW1tQYXJ0aWNpcGFudF1dLCBraW5kOiBbW0RhdGFQYWNrZXRfS2luZF1dLCB0b3BpYz86IHN0cmluZylcbiAgICovXG4gIERhdGFSZWNlaXZlZCA9ICdkYXRhUmVjZWl2ZWQnLFxuXG4gIC8qKlxuICAgKiBDb25uZWN0aW9uIHF1YWxpdHkgd2FzIGNoYW5nZWQgZm9yIGEgUGFydGljaXBhbnQuIEl0J2xsIHJlY2VpdmUgdXBkYXRlc1xuICAgKiBmcm9tIHRoZSBsb2NhbCBwYXJ0aWNpcGFudCwgYXMgd2VsbCBhcyBhbnkgW1tSZW1vdGVQYXJ0aWNpcGFudF1dcyB0aGF0IHdlIGFyZVxuICAgKiBzdWJzY3JpYmVkIHRvLlxuICAgKlxuICAgKiBhcmdzOiAoY29ubmVjdGlvblF1YWxpdHk6IFtbQ29ubmVjdGlvblF1YWxpdHldXSwgcGFydGljaXBhbnQ6IFtbUGFydGljaXBhbnRdXSlcbiAgICovXG4gIENvbm5lY3Rpb25RdWFsaXR5Q2hhbmdlZCA9ICdjb25uZWN0aW9uUXVhbGl0eUNoYW5nZWQnLFxuXG4gIC8qKlxuICAgKiBTdHJlYW1TdGF0ZSBpbmRpY2F0ZXMgaWYgYSBzdWJzY3JpYmVkIChyZW1vdGUpIHRyYWNrIGhhcyBiZWVuIHBhdXNlZCBieSB0aGUgU0ZVXG4gICAqICh0eXBpY2FsbHkgdGhpcyBoYXBwZW5zIGJlY2F1c2Ugb2Ygc3Vic2NyaWJlcidzIGJhbmR3aWR0aCBjb25zdHJhaW50cylcbiAgICpcbiAgICogV2hlbiBiYW5kd2lkdGggY29uZGl0aW9ucyBhbGxvdywgdGhlIHRyYWNrIHdpbGwgYmUgcmVzdW1lZCBhdXRvbWF0aWNhbGx5LlxuICAgKiBUcmFja1N0cmVhbVN0YXRlQ2hhbmdlZCB3aWxsIGFsc28gYmUgZW1pdHRlZCB3aGVuIHRoYXQgaGFwcGVucy5cbiAgICpcbiAgICogYXJnczogKHB1YjogW1tSZW1vdGVUcmFja1B1YmxpY2F0aW9uXV0sIHN0cmVhbVN0YXRlOiBbW1RyYWNrLlN0cmVhbVN0YXRlXV0sXG4gICAqICAgICAgICBwYXJ0aWNpcGFudDogW1tSZW1vdGVQYXJ0aWNpcGFudF1dKVxuICAgKi9cbiAgVHJhY2tTdHJlYW1TdGF0ZUNoYW5nZWQgPSAndHJhY2tTdHJlYW1TdGF0ZUNoYW5nZWQnLFxuXG4gIC8qKlxuICAgKiBPbmUgb2Ygc3Vic2NyaWJlZCB0cmFja3MgaGF2ZSBjaGFuZ2VkIGl0cyBwZXJtaXNzaW9ucyBmb3IgdGhlIGN1cnJlbnRcbiAgICogcGFydGljaXBhbnQuIElmIHBlcm1pc3Npb24gd2FzIHJldm9rZWQsIHRoZW4gdGhlIHRyYWNrIHdpbGwgbm8gbG9uZ2VyXG4gICAqIGJlIHN1YnNjcmliZWQuIElmIHBlcm1pc3Npb24gd2FzIGdyYW50ZWQsIGEgVHJhY2tTdWJzY3JpYmVkIGV2ZW50IHdpbGxcbiAgICogYmUgZW1pdHRlZC5cbiAgICpcbiAgICogYXJnczogKHB1YjogW1tSZW1vdGVUcmFja1B1YmxpY2F0aW9uXV0sXG4gICAqICAgICAgICBzdGF0dXM6IFtbVHJhY2tQdWJsaWNhdGlvbi5QZXJtaXNzaW9uU3RhdHVzXV0sXG4gICAqICAgICAgICBwYXJ0aWNpcGFudDogW1tSZW1vdGVQYXJ0aWNpcGFudF1dKVxuICAgKi9cbiAgVHJhY2tTdWJzY3JpcHRpb25QZXJtaXNzaW9uQ2hhbmdlZCA9ICd0cmFja1N1YnNjcmlwdGlvblBlcm1pc3Npb25DaGFuZ2VkJyxcblxuICAvKipcbiAgICogT25lIG9mIHN1YnNjcmliZWQgdHJhY2tzIGhhdmUgY2hhbmdlZCBpdHMgc3RhdHVzIGZvciB0aGUgY3VycmVudFxuICAgKiBwYXJ0aWNpcGFudC5cbiAgICpcbiAgICogYXJnczogKHB1YjogW1tSZW1vdGVUcmFja1B1YmxpY2F0aW9uXV0sXG4gICAqICAgICAgICBzdGF0dXM6IFtbVHJhY2tQdWJsaWNhdGlvbi5TdWJzY3JpcHRpb25TdGF0dXNdXSxcbiAgICogICAgICAgIHBhcnRpY2lwYW50OiBbW1JlbW90ZVBhcnRpY2lwYW50XV0pXG4gICAqL1xuICBUcmFja1N1YnNjcmlwdGlvblN0YXR1c0NoYW5nZWQgPSAndHJhY2tTdWJzY3JpcHRpb25TdGF0dXNDaGFuZ2VkJyxcblxuICAvKipcbiAgICogTGl2ZUtpdCB3aWxsIGF0dGVtcHQgdG8gYXV0b3BsYXkgYWxsIGF1ZGlvIHRyYWNrcyB3aGVuIHlvdSBhdHRhY2ggdGhlbSB0b1xuICAgKiBhdWRpbyBlbGVtZW50cy4gSG93ZXZlciwgaWYgdGhhdCBmYWlscywgd2UnbGwgbm90aWZ5IHlvdSB2aWEgQXVkaW9QbGF5YmFja1N0YXR1c0NoYW5nZWQuXG4gICAqIGBSb29tLmNhblBsYXliYWNrQXVkaW9gIHdpbGwgaW5kaWNhdGUgaWYgYXVkaW8gcGxheWJhY2sgaXMgcGVybWl0dGVkLlxuICAgKi9cbiAgQXVkaW9QbGF5YmFja1N0YXR1c0NoYW5nZWQgPSAnYXVkaW9QbGF5YmFja0NoYW5nZWQnLFxuXG4gIC8qKlxuICAgKiBMaXZlS2l0IHdpbGwgYXR0ZW1wdCB0byBhdXRvcGxheSBhbGwgdmlkZW8gdHJhY2tzIHdoZW4geW91IGF0dGFjaCB0aGVtIHRvXG4gICAqIGEgdmlkZW8gZWxlbWVudC4gSG93ZXZlciwgaWYgdGhhdCBmYWlscywgd2UnbGwgbm90aWZ5IHlvdSB2aWEgVmlkZW9QbGF5YmFja1N0YXR1c0NoYW5nZWQuXG4gICAqIENhbGxpbmcgYHJvb20uc3RhcnRWaWRlbygpYCBpbiBhIHVzZXIgZ2VzdHVyZSBldmVudCBoYW5kbGVyIHdpbGwgcmVzdW1lIHRoZSB2aWRlbyBwbGF5YmFjay5cbiAgICovXG4gIFZpZGVvUGxheWJhY2tTdGF0dXNDaGFuZ2VkID0gJ3ZpZGVvUGxheWJhY2tDaGFuZ2VkJyxcblxuICAvKipcbiAgICogV2hlbiB3ZSBoYXZlIGVuY291bnRlcmVkIGFuIGVycm9yIHdoaWxlIGF0dGVtcHRpbmcgdG8gY3JlYXRlIGEgdHJhY2suXG4gICAqIFRoZSBlcnJvcnMgdGFrZSBwbGFjZSBpbiBnZXRVc2VyTWVkaWEoKS5cbiAgICogVXNlIE1lZGlhRGV2aWNlRmFpbHVyZS5nZXRGYWlsdXJlKGVycm9yKSB0byBnZXQgdGhlIHJlYXNvbiBvZiBmYWlsdXJlLlxuICAgKiBbW0xvY2FsUGFydGljaXBhbnQubGFzdENhbWVyYUVycm9yXV0gYW5kIFtbTG9jYWxQYXJ0aWNpcGFudC5sYXN0TWljcm9waG9uZUVycm9yXV1cbiAgICogd2lsbCBpbmRpY2F0ZSBpZiBpdCBoYWQgYW4gZXJyb3Igd2hpbGUgY3JlYXRpbmcgdGhlIGF1ZGlvIG9yIHZpZGVvIHRyYWNrIHJlc3BlY3RpdmVseS5cbiAgICpcbiAgICogYXJnczogKGVycm9yOiBFcnJvcilcbiAgICovXG4gIE1lZGlhRGV2aWNlc0Vycm9yID0gJ21lZGlhRGV2aWNlc0Vycm9yJyxcblxuICAvKipcbiAgICogQSBwYXJ0aWNpcGFudCdzIHBlcm1pc3Npb24gaGFzIGNoYW5nZWQuIEN1cnJlbnRseSBvbmx5IGZpcmVkIG9uIExvY2FsUGFydGljaXBhbnQuXG4gICAqIGFyZ3M6IChwcmV2UGVybWlzc2lvbnM6IFtbUGFydGljaXBhbnRQZXJtaXNzaW9uXV0sIHBhcnRpY2lwYW50OiBbW1BhcnRpY2lwYW50XV0pXG4gICAqL1xuICBQYXJ0aWNpcGFudFBlcm1pc3Npb25zQ2hhbmdlZCA9ICdwYXJ0aWNpcGFudFBlcm1pc3Npb25zQ2hhbmdlZCcsXG5cbiAgLyoqXG4gICAqIFNpZ25hbCBjb25uZWN0ZWQsIGNhbiBwdWJsaXNoIHRyYWNrcy5cbiAgICovXG4gIFNpZ25hbENvbm5lY3RlZCA9ICdzaWduYWxDb25uZWN0ZWQnLFxuXG4gIC8qKlxuICAgKiBSZWNvcmRpbmcgb2YgYSByb29tIGhhcyBzdGFydGVkL3N0b3BwZWQuIFJvb20uaXNSZWNvcmRpbmcgd2lsbCBiZSB1cGRhdGVkIHRvby5cbiAgICogYXJnczogKGlzUmVjb3JkaW5nOiBib29sZWFuKVxuICAgKi9cbiAgUmVjb3JkaW5nU3RhdHVzQ2hhbmdlZCA9ICdyZWNvcmRpbmdTdGF0dXNDaGFuZ2VkJyxcblxuICBQYXJ0aWNpcGFudEVuY3J5cHRpb25TdGF0dXNDaGFuZ2VkID0gJ3BhcnRpY2lwYW50RW5jcnlwdGlvblN0YXR1c0NoYW5nZWQnLFxuXG4gIEVuY3J5cHRpb25FcnJvciA9ICdlbmNyeXB0aW9uRXJyb3InLFxuICAvKipcbiAgICogRW1pdHMgd2hlbmV2ZXIgdGhlIGN1cnJlbnQgYnVmZmVyIHN0YXR1cyBvZiBhIGRhdGEgY2hhbm5lbCBjaGFuZ2VzXG4gICAqIGFyZ3M6IChpc0xvdzogYm9vbGVhbiwga2luZDogW1tEYXRhUGFja2V0X0tpbmRdXSlcbiAgICovXG4gIERDQnVmZmVyU3RhdHVzQ2hhbmdlZCA9ICdkY0J1ZmZlclN0YXR1c0NoYW5nZWQnLFxuXG4gIC8qKlxuICAgKiBUcmlnZ2VyZWQgYnkgYSBjYWxsIHRvIHJvb20uc3dpdGNoQWN0aXZlRGV2aWNlXG4gICAqIGFyZ3M6IChraW5kOiBNZWRpYURldmljZUtpbmQsIGRldmljZUlkOiBzdHJpbmcpXG4gICAqL1xuICBBY3RpdmVEZXZpY2VDaGFuZ2VkID0gJ2FjdGl2ZURldmljZUNoYW5nZWQnLFxufVxuXG5leHBvcnQgZW51bSBQYXJ0aWNpcGFudEV2ZW50IHtcbiAgLyoqXG4gICAqIFdoZW4gYSBuZXcgdHJhY2sgaXMgcHVibGlzaGVkIHRvIHJvb20gKmFmdGVyKiB0aGUgbG9jYWxcbiAgICogcGFydGljaXBhbnQgaGFzIGpvaW5lZC4gSXQgd2lsbCBub3QgZmlyZSBmb3IgdHJhY2tzIHRoYXQgYXJlIGFscmVhZHkgcHVibGlzaGVkLlxuICAgKlxuICAgKiBBIHRyYWNrIHB1Ymxpc2hlZCBkb2Vzbid0IG1lYW4gdGhlIHBhcnRpY2lwYW50IGhhcyBzdWJzY3JpYmVkIHRvIGl0LiBJdCdzXG4gICAqIHNpbXBseSByZWZsZWN0aW5nIHRoZSBzdGF0ZSBvZiB0aGUgcm9vbS5cbiAgICpcbiAgICogYXJnczogKFtbUmVtb3RlVHJhY2tQdWJsaWNhdGlvbl1dKVxuICAgKi9cbiAgVHJhY2tQdWJsaXNoZWQgPSAndHJhY2tQdWJsaXNoZWQnLFxuXG4gIC8qKlxuICAgKiBTdWNjZXNzZnVsbHkgc3Vic2NyaWJlZCB0byB0aGUgW1tSZW1vdGVQYXJ0aWNpcGFudF1dJ3MgdHJhY2suXG4gICAqIFRoaXMgZXZlbnQgd2lsbCAqKmFsd2F5cyoqIGZpcmUgYXMgbG9uZyBhcyBuZXcgdHJhY2tzIGFyZSByZWFkeSBmb3IgdXNlLlxuICAgKlxuICAgKiBhcmdzOiAoW1tSZW1vdGVUcmFja11dLCBbW1JlbW90ZVRyYWNrUHVibGljYXRpb25dXSlcbiAgICovXG4gIFRyYWNrU3Vic2NyaWJlZCA9ICd0cmFja1N1YnNjcmliZWQnLFxuXG4gIC8qKlxuICAgKiBDb3VsZCBub3Qgc3Vic2NyaWJlIHRvIGEgdHJhY2tcbiAgICpcbiAgICogYXJnczogKHRyYWNrIHNpZClcbiAgICovXG4gIFRyYWNrU3Vic2NyaXB0aW9uRmFpbGVkID0gJ3RyYWNrU3Vic2NyaXB0aW9uRmFpbGVkJyxcblxuICAvKipcbiAgICogQSBbW1JlbW90ZVBhcnRpY2lwYW50XV0gaGFzIHVucHVibGlzaGVkIGEgdHJhY2tcbiAgICpcbiAgICogYXJnczogKFtbUmVtb3RlVHJhY2tQdWJsaWNhdGlvbl1dKVxuICAgKi9cbiAgVHJhY2tVbnB1Ymxpc2hlZCA9ICd0cmFja1VucHVibGlzaGVkJyxcblxuICAvKipcbiAgICogQSBzdWJzY3JpYmVkIHRyYWNrIGlzIG5vIGxvbmdlciBhdmFpbGFibGUuIENsaWVudHMgc2hvdWxkIGxpc3RlbiB0byB0aGlzXG4gICAqIGV2ZW50IGFuZCBlbnN1cmUgdGhleSBkZXRhY2ggdHJhY2tzLlxuICAgKlxuICAgKiBhcmdzOiAoW1tSZW1vdGVUcmFja11dLCBbW1JlbW90ZVRyYWNrUHVibGljYXRpb25dXSlcbiAgICovXG4gIFRyYWNrVW5zdWJzY3JpYmVkID0gJ3RyYWNrVW5zdWJzY3JpYmVkJyxcblxuICAvKipcbiAgICogQSB0cmFjayB0aGF0IHdhcyBtdXRlZCwgZmlyZXMgb24gYm90aCBbW1JlbW90ZVBhcnRpY2lwYW50XV1zIGFuZCBbW0xvY2FsUGFydGljaXBhbnRdXVxuICAgKlxuICAgKiBhcmdzOiAoW1tUcmFja1B1YmxpY2F0aW9uXV0pXG4gICAqL1xuICBUcmFja011dGVkID0gJ3RyYWNrTXV0ZWQnLFxuXG4gIC8qKlxuICAgKiBBIHRyYWNrIHRoYXQgd2FzIHVubXV0ZWQsIGZpcmVzIG9uIGJvdGggW1tSZW1vdGVQYXJ0aWNpcGFudF1dcyBhbmQgW1tMb2NhbFBhcnRpY2lwYW50XV1cbiAgICpcbiAgICogYXJnczogKFtbVHJhY2tQdWJsaWNhdGlvbl1dKVxuICAgKi9cbiAgVHJhY2tVbm11dGVkID0gJ3RyYWNrVW5tdXRlZCcsXG5cbiAgLyoqXG4gICAqIEEgbG9jYWwgdHJhY2sgd2FzIHB1Ymxpc2hlZCBzdWNjZXNzZnVsbHkuIFRoaXMgZXZlbnQgaXMgaGVscGZ1bCB0byBrbm93XG4gICAqIHdoZW4gdG8gdXBkYXRlIHlvdXIgbG9jYWwgVUkgd2l0aCB0aGUgbmV3bHkgcHVibGlzaGVkIHRyYWNrLlxuICAgKlxuICAgKiBhcmdzOiAoW1tMb2NhbFRyYWNrUHVibGljYXRpb25dXSlcbiAgICovXG4gIExvY2FsVHJhY2tQdWJsaXNoZWQgPSAnbG9jYWxUcmFja1B1Ymxpc2hlZCcsXG5cbiAgLyoqXG4gICAqIEEgbG9jYWwgdHJhY2sgd2FzIHVucHVibGlzaGVkLiBUaGlzIGV2ZW50IGlzIGhlbHBmdWwgdG8ga25vdyB3aGVuIHRvIHJlbW92ZVxuICAgKiB0aGUgbG9jYWwgdHJhY2sgZnJvbSB5b3VyIFVJLlxuICAgKlxuICAgKiBXaGVuIGEgdXNlciBzdG9wcyBzaGFyaW5nIHRoZWlyIHNjcmVlbiBieSBwcmVzc2luZyBcIkVuZFwiIG9uIHRoZSBicm93c2VyIFVJLFxuICAgKiB0aGlzIGV2ZW50IHdpbGwgYWxzbyBmaXJlLlxuICAgKlxuICAgKiBhcmdzOiAoW1tMb2NhbFRyYWNrUHVibGljYXRpb25dXSlcbiAgICovXG4gIExvY2FsVHJhY2tVbnB1Ymxpc2hlZCA9ICdsb2NhbFRyYWNrVW5wdWJsaXNoZWQnLFxuXG4gIC8qKlxuICAgKiBQYXJ0aWNpcGFudCBtZXRhZGF0YSBpcyBhIHNpbXBsZSB3YXkgZm9yIGFwcC1zcGVjaWZpYyBzdGF0ZSB0byBiZSBwdXNoZWQgdG9cbiAgICogYWxsIHVzZXJzLlxuICAgKiBXaGVuIFJvb21TZXJ2aWNlLlVwZGF0ZVBhcnRpY2lwYW50TWV0YWRhdGEgaXMgY2FsbGVkIHRvIGNoYW5nZSBhIHBhcnRpY2lwYW50J3NcbiAgICogc3RhdGUsICphbGwqICBwYXJ0aWNpcGFudHMgaW4gdGhlIHJvb20gd2lsbCBmaXJlIHRoaXMgZXZlbnQuXG4gICAqIFRvIGFjY2VzcyB0aGUgY3VycmVudCBtZXRhZGF0YSwgc2VlIFtbUGFydGljaXBhbnQubWV0YWRhdGFdXS5cbiAgICpcbiAgICogYXJnczogKHByZXZNZXRhZGF0YTogc3RyaW5nKVxuICAgKlxuICAgKi9cbiAgUGFydGljaXBhbnRNZXRhZGF0YUNoYW5nZWQgPSAncGFydGljaXBhbnRNZXRhZGF0YUNoYW5nZWQnLFxuXG4gIC8qKlxuICAgKiBQYXJ0aWNpcGFudCdzIGRpc3BsYXkgbmFtZSBjaGFuZ2VkXG4gICAqXG4gICAqIGFyZ3M6IChuYW1lOiBzdHJpbmcsIFtbUGFydGljaXBhbnRdXSlcbiAgICpcbiAgICovXG4gIFBhcnRpY2lwYW50TmFtZUNoYW5nZWQgPSAncGFydGljaXBhbnROYW1lQ2hhbmdlZCcsXG5cbiAgLyoqXG4gICAqIERhdGEgcmVjZWl2ZWQgZnJvbSB0aGlzIHBhcnRpY2lwYW50IGFzIHNlbmRlci5cbiAgICogRGF0YSBwYWNrZXRzIHByb3ZpZGVzIHRoZSBhYmlsaXR5IHRvIHVzZSBMaXZlS2l0IHRvIHNlbmQvcmVjZWl2ZSBhcmJpdHJhcnkgcGF5bG9hZHMuXG4gICAqIEFsbCBwYXJ0aWNpcGFudHMgaW4gdGhlIHJvb20gd2lsbCByZWNlaXZlIHRoZSBtZXNzYWdlcyBzZW50IHRvIHRoZSByb29tLlxuICAgKlxuICAgKiBhcmdzOiAocGF5bG9hZDogVWludDhBcnJheSwga2luZDogW1tEYXRhUGFja2V0X0tpbmRdXSlcbiAgICovXG4gIERhdGFSZWNlaXZlZCA9ICdkYXRhUmVjZWl2ZWQnLFxuXG4gIC8qKlxuICAgKiBIYXMgc3BlYWtpbmcgc3RhdHVzIGNoYW5nZWQgZm9yIHRoZSBjdXJyZW50IHBhcnRpY2lwYW50XG4gICAqXG4gICAqIGFyZ3M6IChzcGVha2luZzogYm9vbGVhbilcbiAgICovXG4gIElzU3BlYWtpbmdDaGFuZ2VkID0gJ2lzU3BlYWtpbmdDaGFuZ2VkJyxcblxuICAvKipcbiAgICogQ29ubmVjdGlvbiBxdWFsaXR5IHdhcyBjaGFuZ2VkIGZvciBhIFBhcnRpY2lwYW50LiBJdCdsbCByZWNlaXZlIHVwZGF0ZXNcbiAgICogZnJvbSB0aGUgbG9jYWwgcGFydGljaXBhbnQsIGFzIHdlbGwgYXMgYW55IFtbUmVtb3RlUGFydGljaXBhbnRdXXMgdGhhdCB3ZSBhcmVcbiAgICogc3Vic2NyaWJlZCB0by5cbiAgICpcbiAgICogYXJnczogKGNvbm5lY3Rpb25RdWFsaXR5OiBbW0Nvbm5lY3Rpb25RdWFsaXR5XV0pXG4gICAqL1xuICBDb25uZWN0aW9uUXVhbGl0eUNoYW5nZWQgPSAnY29ubmVjdGlvblF1YWxpdHlDaGFuZ2VkJyxcblxuICAvKipcbiAgICogU3RyZWFtU3RhdGUgaW5kaWNhdGVzIGlmIGEgc3Vic2NyaWJlZCB0cmFjayBoYXMgYmVlbiBwYXVzZWQgYnkgdGhlIFNGVVxuICAgKiAodHlwaWNhbGx5IHRoaXMgaGFwcGVucyBiZWNhdXNlIG9mIHN1YnNjcmliZXIncyBiYW5kd2lkdGggY29uc3RyYWludHMpXG4gICAqXG4gICAqIFdoZW4gYmFuZHdpZHRoIGNvbmRpdGlvbnMgYWxsb3csIHRoZSB0cmFjayB3aWxsIGJlIHJlc3VtZWQgYXV0b21hdGljYWxseS5cbiAgICogVHJhY2tTdHJlYW1TdGF0ZUNoYW5nZWQgd2lsbCBhbHNvIGJlIGVtaXR0ZWQgd2hlbiB0aGF0IGhhcHBlbnMuXG4gICAqXG4gICAqIGFyZ3M6IChwdWI6IFtbUmVtb3RlVHJhY2tQdWJsaWNhdGlvbl1dLCBzdHJlYW1TdGF0ZTogW1tUcmFjay5TdHJlYW1TdGF0ZV1dKVxuICAgKi9cbiAgVHJhY2tTdHJlYW1TdGF0ZUNoYW5nZWQgPSAndHJhY2tTdHJlYW1TdGF0ZUNoYW5nZWQnLFxuXG4gIC8qKlxuICAgKiBPbmUgb2Ygc3Vic2NyaWJlZCB0cmFja3MgaGF2ZSBjaGFuZ2VkIGl0cyBwZXJtaXNzaW9ucyBmb3IgdGhlIGN1cnJlbnRcbiAgICogcGFydGljaXBhbnQuIElmIHBlcm1pc3Npb24gd2FzIHJldm9rZWQsIHRoZW4gdGhlIHRyYWNrIHdpbGwgbm8gbG9uZ2VyXG4gICAqIGJlIHN1YnNjcmliZWQuIElmIHBlcm1pc3Npb24gd2FzIGdyYW50ZWQsIGEgVHJhY2tTdWJzY3JpYmVkIGV2ZW50IHdpbGxcbiAgICogYmUgZW1pdHRlZC5cbiAgICpcbiAgICogYXJnczogKHB1YjogW1tSZW1vdGVUcmFja1B1YmxpY2F0aW9uXV0sXG4gICAqICAgICAgICBzdGF0dXM6IFtbVHJhY2tQdWJsaWNhdGlvbi5TdWJzY3JpcHRpb25TdGF0dXNdXSlcbiAgICovXG4gIFRyYWNrU3Vic2NyaXB0aW9uUGVybWlzc2lvbkNoYW5nZWQgPSAndHJhY2tTdWJzY3JpcHRpb25QZXJtaXNzaW9uQ2hhbmdlZCcsXG5cbiAgLyoqXG4gICAqIE9uZSBvZiB0aGUgcmVtb3RlIHBhcnRpY2lwYW50cyBwdWJsaWNhdGlvbnMgaGFzIGNoYW5nZWQgaXRzIHN1YnNjcmlwdGlvbiBzdGF0dXMuXG4gICAqXG4gICAqL1xuICBUcmFja1N1YnNjcmlwdGlvblN0YXR1c0NoYW5nZWQgPSAndHJhY2tTdWJzY3JpcHRpb25TdGF0dXNDaGFuZ2VkJyxcblxuICAvLyBmaXJlZCBvbmx5IG9uIExvY2FsUGFydGljaXBhbnRcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBNZWRpYURldmljZXNFcnJvciA9ICdtZWRpYURldmljZXNFcnJvcicsXG5cbiAgLy8gZmlyZWQgb25seSBvbiBMb2NhbFBhcnRpY2lwYW50XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgQXVkaW9TdHJlYW1BY3F1aXJlZCA9ICdhdWRpb1N0cmVhbUFjcXVpcmVkJyxcblxuICAvKipcbiAgICogQSBwYXJ0aWNpcGFudCdzIHBlcm1pc3Npb24gaGFzIGNoYW5nZWQuIEN1cnJlbnRseSBvbmx5IGZpcmVkIG9uIExvY2FsUGFydGljaXBhbnQuXG4gICAqIGFyZ3M6IChwcmV2UGVybWlzc2lvbnM6IFtbUGFydGljaXBhbnRQZXJtaXNzaW9uXV0pXG4gICAqL1xuICBQYXJ0aWNpcGFudFBlcm1pc3Npb25zQ2hhbmdlZCA9ICdwYXJ0aWNpcGFudFBlcm1pc3Npb25zQ2hhbmdlZCcsXG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBQQ1RyYWNrQWRkZWQgPSAncGNUcmFja0FkZGVkJyxcbn1cblxuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGVudW0gRW5naW5lRXZlbnQge1xuICBUcmFuc3BvcnRzQ3JlYXRlZCA9ICd0cmFuc3BvcnRzQ3JlYXRlZCcsXG4gIENvbm5lY3RlZCA9ICdjb25uZWN0ZWQnLFxuICBEaXNjb25uZWN0ZWQgPSAnZGlzY29ubmVjdGVkJyxcbiAgUmVzdW1pbmcgPSAncmVzdW1pbmcnLFxuICBSZXN1bWVkID0gJ3Jlc3VtZWQnLFxuICBSZXN0YXJ0aW5nID0gJ3Jlc3RhcnRpbmcnLFxuICBSZXN0YXJ0ZWQgPSAncmVzdGFydGVkJyxcbiAgU2lnbmFsUmVzdW1lZCA9ICdzaWduYWxSZXN1bWVkJyxcbiAgU2lnbmFsUmVzdGFydGVkID0gJ3NpZ25hbFJlc3RhcnRlZCcsXG4gIENsb3NpbmcgPSAnY2xvc2luZycsXG4gIE1lZGlhVHJhY2tBZGRlZCA9ICdtZWRpYVRyYWNrQWRkZWQnLFxuICBBY3RpdmVTcGVha2Vyc1VwZGF0ZSA9ICdhY3RpdmVTcGVha2Vyc1VwZGF0ZScsXG4gIERhdGFQYWNrZXRSZWNlaXZlZCA9ICdkYXRhUGFja2V0UmVjZWl2ZWQnLFxuICBSVFBWaWRlb01hcFVwZGF0ZSA9ICdydHBWaWRlb01hcFVwZGF0ZScsXG4gIERDQnVmZmVyU3RhdHVzQ2hhbmdlZCA9ICdkY0J1ZmZlclN0YXR1c0NoYW5nZWQnLFxuICBQYXJ0aWNpcGFudFVwZGF0ZSA9ICdwYXJ0aWNpcGFudFVwZGF0ZScsXG4gIFJvb21VcGRhdGUgPSAncm9vbVVwZGF0ZScsXG4gIFNwZWFrZXJzQ2hhbmdlZCA9ICdzcGVha2Vyc0NoYW5nZWQnLFxuICBTdHJlYW1TdGF0ZUNoYW5nZWQgPSAnc3RyZWFtU3RhdGVDaGFuZ2VkJyxcbiAgQ29ubmVjdGlvblF1YWxpdHlVcGRhdGUgPSAnY29ubmVjdGlvblF1YWxpdHlVcGRhdGUnLFxuICBTdWJzY3JpcHRpb25FcnJvciA9ICdzdWJzY3JpcHRpb25FcnJvcicsXG4gIFN1YnNjcmlwdGlvblBlcm1pc3Npb25VcGRhdGUgPSAnc3Vic2NyaXB0aW9uUGVybWlzc2lvblVwZGF0ZScsXG4gIFJlbW90ZU11dGUgPSAncmVtb3RlTXV0ZScsXG4gIFN1YnNjcmliZWRRdWFsaXR5VXBkYXRlID0gJ3N1YnNjcmliZWRRdWFsaXR5VXBkYXRlJyxcbiAgTG9jYWxUcmFja1VucHVibGlzaGVkID0gJ2xvY2FsVHJhY2tVbnB1Ymxpc2hlZCcsXG59XG5cbmV4cG9ydCBlbnVtIFRyYWNrRXZlbnQge1xuICBNZXNzYWdlID0gJ21lc3NhZ2UnLFxuICBNdXRlZCA9ICdtdXRlZCcsXG4gIFVubXV0ZWQgPSAndW5tdXRlZCcsXG4gIC8qKlxuICAgKiBPbmx5IGZpcmVzIG9uIExvY2FsVHJhY2tzXG4gICAqL1xuICBSZXN0YXJ0ZWQgPSAncmVzdGFydGVkJyxcbiAgRW5kZWQgPSAnZW5kZWQnLFxuICBTdWJzY3JpYmVkID0gJ3N1YnNjcmliZWQnLFxuICBVbnN1YnNjcmliZWQgPSAndW5zdWJzY3JpYmVkJyxcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBVcGRhdGVTZXR0aW5ncyA9ICd1cGRhdGVTZXR0aW5ncycsXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgVXBkYXRlU3Vic2NyaXB0aW9uID0gJ3VwZGF0ZVN1YnNjcmlwdGlvbicsXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgQXVkaW9QbGF5YmFja1N0YXJ0ZWQgPSAnYXVkaW9QbGF5YmFja1N0YXJ0ZWQnLFxuICAvKiogQGludGVybmFsICovXG4gIEF1ZGlvUGxheWJhY2tGYWlsZWQgPSAnYXVkaW9QbGF5YmFja0ZhaWxlZCcsXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogT25seSBmaXJlcyBvbiBMb2NhbEF1ZGlvVHJhY2sgaW5zdGFuY2VzXG4gICAqL1xuICBBdWRpb1NpbGVuY2VEZXRlY3RlZCA9ICdhdWRpb1NpbGVuY2VEZXRlY3RlZCcsXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgVmlzaWJpbGl0eUNoYW5nZWQgPSAndmlzaWJpbGl0eUNoYW5nZWQnLFxuICAvKiogQGludGVybmFsICovXG4gIFZpZGVvRGltZW5zaW9uc0NoYW5nZWQgPSAndmlkZW9EaW1lbnNpb25zQ2hhbmdlZCcsXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgVmlkZW9QbGF5YmFja1N0YXJ0ZWQgPSAndmlkZW9QbGF5YmFja1N0YXJ0ZWQnLFxuICAvKiogQGludGVybmFsICovXG4gIFZpZGVvUGxheWJhY2tGYWlsZWQgPSAndmlkZW9QbGF5YmFja0ZhaWxlZCcsXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgRWxlbWVudEF0dGFjaGVkID0gJ2VsZW1lbnRBdHRhY2hlZCcsXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgRWxlbWVudERldGFjaGVkID0gJ2VsZW1lbnREZXRhY2hlZCcsXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogT25seSBmaXJlcyBvbiBMb2NhbFRyYWNrc1xuICAgKi9cbiAgVXBzdHJlYW1QYXVzZWQgPSAndXBzdHJlYW1QYXVzZWQnLFxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqIE9ubHkgZmlyZXMgb24gTG9jYWxUcmFja3NcbiAgICovXG4gIFVwc3RyZWFtUmVzdW1lZCA9ICd1cHN0cmVhbVJlc3VtZWQnLFxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqIEZpcmVzIG9uIFJlbW90ZVRyYWNrUHVibGljYXRpb25cbiAgICovXG4gIFN1YnNjcmlwdGlvblBlcm1pc3Npb25DaGFuZ2VkID0gJ3N1YnNjcmlwdGlvblBlcm1pc3Npb25DaGFuZ2VkJyxcbiAgLyoqXG4gICAqIEZpcmVzIG9uIFJlbW90ZVRyYWNrUHVibGljYXRpb25cbiAgICovXG4gIFN1YnNjcmlwdGlvblN0YXR1c0NoYW5nZWQgPSAnc3Vic2NyaXB0aW9uU3RhdHVzQ2hhbmdlZCcsXG4gIC8qKlxuICAgKiBGaXJlcyBvbiBSZW1vdGVUcmFja1B1YmxpY2F0aW9uXG4gICAqL1xuICBTdWJzY3JpcHRpb25GYWlsZWQgPSAnc3Vic2NyaXB0aW9uRmFpbGVkJyxcbn1cbiIsImZ1bmN0aW9uIHIocixlLG4pe3ZhciBpLHQsbzt2b2lkIDA9PT1lJiYoZT01MCksdm9pZCAwPT09biYmKG49e30pO3ZhciBhPW51bGwhPShpPW4uaXNJbW1lZGlhdGUpJiZpLHU9bnVsbCE9KHQ9bi5jYWxsYmFjaykmJnQsYz1uLm1heFdhaXQsdj1EYXRlLm5vdygpLGw9W107ZnVuY3Rpb24gZigpe2lmKHZvaWQgMCE9PWMpe3ZhciByPURhdGUubm93KCktdjtpZihyK2U+PWMpcmV0dXJuIGMtcn1yZXR1cm4gZX12YXIgZD1mdW5jdGlvbigpe3ZhciBlPVtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKSxuPXRoaXM7cmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKGksdCl7dmFyIGM9YSYmdm9pZCAwPT09bztpZih2b2lkIDAhPT1vJiZjbGVhclRpbWVvdXQobyksbz1zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7aWYobz12b2lkIDAsdj1EYXRlLm5vdygpLCFhKXt2YXIgaT1yLmFwcGx5KG4sZSk7dSYmdShpKSxsLmZvckVhY2goZnVuY3Rpb24ocil7cmV0dXJuKDAsci5yZXNvbHZlKShpKX0pLGw9W119fSxmKCkpLGMpe3ZhciBkPXIuYXBwbHkobixlKTtyZXR1cm4gdSYmdShkKSxpKGQpfWwucHVzaCh7cmVzb2x2ZTppLHJlamVjdDp0fSl9KX07cmV0dXJuIGQuY2FuY2VsPWZ1bmN0aW9uKHIpe3ZvaWQgMCE9PW8mJmNsZWFyVGltZW91dChvKSxsLmZvckVhY2goZnVuY3Rpb24oZSl7cmV0dXJuKDAsZS5yZWplY3QpKHIpfSksbD1bXX0sZH1leHBvcnR7ciBhcyBkZWJvdW5jZX07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5lc20uanMubWFwXG4iLCIvLyB0aW55LCBzaW1wbGlmaWVkIHZlcnNpb24gb2YgaHR0cHM6Ly9naXRodWIuY29tL2xhbmNlZGlrc29uL2Jvd3Nlci9ibG9iL21hc3Rlci9zcmMvcGFyc2VyLWJyb3dzZXJzLmpzXG4vLyByZWR1Y2VkIHRvIG9ubHkgZGlmZmVyZW50aWF0ZSBDaHJvbWUoaXVtKSBiYXNlZCBicm93c2VycyAvIEZpcmVmb3ggLyBTYWZhcmlcblxuY29uc3QgY29tbW9uVmVyc2lvbklkZW50aWZpZXIgPSAvdmVyc2lvblxcLyhcXGQrKFxcLj9fP1xcZCspKykvaTtcblxuZXhwb3J0IHR5cGUgRGV0ZWN0YWJsZUJyb3dzZXIgPSAnQ2hyb21lJyB8ICdGaXJlZm94JyB8ICdTYWZhcmknO1xuZXhwb3J0IHR5cGUgRGV0ZWN0YWJsZU9TID0gJ2lPUycgfCAnbWFjT1MnO1xuXG5leHBvcnQgdHlwZSBCcm93c2VyRGV0YWlscyA9IHtcbiAgbmFtZTogRGV0ZWN0YWJsZUJyb3dzZXI7XG4gIHZlcnNpb246IHN0cmluZztcbiAgb3M/OiBEZXRlY3RhYmxlT1M7XG59O1xuXG5sZXQgYnJvd3NlckRldGFpbHM6IEJyb3dzZXJEZXRhaWxzIHwgdW5kZWZpbmVkO1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0QnJvd3Nlcih1c2VyQWdlbnQ/OiBzdHJpbmcsIGZvcmNlID0gdHJ1ZSkge1xuICBpZiAodHlwZW9mIHVzZXJBZ2VudCA9PT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIG5hdmlnYXRvciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgdWEgPSAodXNlckFnZW50ID8/IG5hdmlnYXRvci51c2VyQWdlbnQpLnRvTG93ZXJDYXNlKCk7XG4gIGlmIChicm93c2VyRGV0YWlscyA9PT0gdW5kZWZpbmVkIHx8IGZvcmNlKSB7XG4gICAgY29uc3QgYnJvd3NlciA9IGJyb3dzZXJzTGlzdC5maW5kKCh7IHRlc3QgfSkgPT4gdGVzdC50ZXN0KHVhKSk7XG4gICAgYnJvd3NlckRldGFpbHMgPSBicm93c2VyPy5kZXNjcmliZSh1YSk7XG4gIH1cbiAgcmV0dXJuIGJyb3dzZXJEZXRhaWxzO1xufVxuXG5jb25zdCBicm93c2Vyc0xpc3QgPSBbXG4gIHtcbiAgICB0ZXN0OiAvZmlyZWZveHxpY2V3ZWFzZWx8Znhpb3MvaSxcbiAgICBkZXNjcmliZSh1YTogc3RyaW5nKSB7XG4gICAgICBjb25zdCBicm93c2VyOiBCcm93c2VyRGV0YWlscyA9IHtcbiAgICAgICAgbmFtZTogJ0ZpcmVmb3gnLFxuICAgICAgICB2ZXJzaW9uOiBnZXRNYXRjaCgvKD86ZmlyZWZveHxpY2V3ZWFzZWx8Znhpb3MpW1xccy9dKFxcZCsoXFwuP18/XFxkKykrKS9pLCB1YSksXG4gICAgICAgIG9zOiB1YS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKCdmeGlvcycpID8gJ2lPUycgOiB1bmRlZmluZWQsXG4gICAgICB9O1xuICAgICAgcmV0dXJuIGJyb3dzZXI7XG4gICAgfSxcbiAgfSxcbiAge1xuICAgIHRlc3Q6IC9jaHJvbXxjcmlvc3xjcm1vL2ksXG4gICAgZGVzY3JpYmUodWE6IHN0cmluZykge1xuICAgICAgY29uc3QgYnJvd3NlcjogQnJvd3NlckRldGFpbHMgPSB7XG4gICAgICAgIG5hbWU6ICdDaHJvbWUnLFxuICAgICAgICB2ZXJzaW9uOiBnZXRNYXRjaCgvKD86Y2hyb21lfGNocm9taXVtfGNyaW9zfGNybW8pXFwvKFxcZCsoXFwuP18/XFxkKykrKS9pLCB1YSksXG4gICAgICAgIG9zOiB1YS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKCdjcmlvcycpID8gJ2lPUycgOiB1bmRlZmluZWQsXG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gYnJvd3NlcjtcbiAgICB9LFxuICB9LFxuICAvKiBTYWZhcmkgKi9cbiAge1xuICAgIHRlc3Q6IC9zYWZhcml8YXBwbGV3ZWJraXQvaSxcbiAgICBkZXNjcmliZSh1YTogc3RyaW5nKSB7XG4gICAgICBjb25zdCBicm93c2VyOiBCcm93c2VyRGV0YWlscyA9IHtcbiAgICAgICAgbmFtZTogJ1NhZmFyaScsXG4gICAgICAgIHZlcnNpb246IGdldE1hdGNoKGNvbW1vblZlcnNpb25JZGVudGlmaWVyLCB1YSksXG4gICAgICAgIG9zOiB1YS5pbmNsdWRlcygnbW9iaWxlLycpID8gJ2lPUycgOiAnbWFjT1MnLFxuICAgICAgfTtcblxuICAgICAgcmV0dXJuIGJyb3dzZXI7XG4gICAgfSxcbiAgfSxcbl07XG5cbmZ1bmN0aW9uIGdldE1hdGNoKGV4cDogUmVnRXhwLCB1YTogc3RyaW5nLCBpZCA9IDEpIHtcbiAgY29uc3QgbWF0Y2ggPSB1YS5tYXRjaChleHApO1xuICByZXR1cm4gKG1hdGNoICYmIG1hdGNoLmxlbmd0aCA+PSBpZCAmJiBtYXRjaFtpZF0pIHx8ICcnO1xufVxuIiwiaW1wb3J0IHsgdmVyc2lvbiBhcyB2IH0gZnJvbSAnLi4vcGFja2FnZS5qc29uJztcblxuZXhwb3J0IGNvbnN0IHZlcnNpb24gPSB2O1xuZXhwb3J0IGNvbnN0IHByb3RvY29sVmVyc2lvbiA9IDExO1xuIiwiLyoqXG4gKiBUaW1lcnMgdGhhdCBjYW4gYmUgb3ZlcnJpZGRlbiB3aXRoIHBsYXRmb3JtIHNwZWNpZmljIGltcGxlbWVudGF0aW9uc1xuICogdGhhdCBlbnN1cmUgdGhhdCB0aGV5IGFyZSBmaXJlZC4gVGhlc2Ugc2hvdWxkIGJlIHVzZWQgd2hlbiBpdCBpcyBjcml0aWNhbFxuICogdGhhdCB0aGUgdGltZXIgZmlyZXMgb24gdGltZS5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ3JpdGljYWxUaW1lcnMge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWltcGxpZWQtZXZhbFxuICBzdGF0aWMgc2V0VGltZW91dCA9ICguLi5hcmdzOiBQYXJhbWV0ZXJzPHR5cGVvZiBzZXRUaW1lb3V0PikgPT4gc2V0VGltZW91dCguLi5hcmdzKTtcblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWltcGxpZWQtZXZhbFxuICBzdGF0aWMgc2V0SW50ZXJ2YWwgPSAoLi4uYXJnczogUGFyYW1ldGVyczx0eXBlb2Ygc2V0SW50ZXJ2YWw+KSA9PiBzZXRJbnRlcnZhbCguLi5hcmdzKTtcblxuICBzdGF0aWMgY2xlYXJUaW1lb3V0ID0gKC4uLmFyZ3M6IFBhcmFtZXRlcnM8dHlwZW9mIGNsZWFyVGltZW91dD4pID0+IGNsZWFyVGltZW91dCguLi5hcmdzKTtcblxuICBzdGF0aWMgY2xlYXJJbnRlcnZhbCA9ICguLi5hcmdzOiBQYXJhbWV0ZXJzPHR5cGVvZiBjbGVhckludGVydmFsPikgPT4gY2xlYXJJbnRlcnZhbCguLi5hcmdzKTtcbn1cbiIsImltcG9ydCB0eXBlIHsgVHJhY2sgfSBmcm9tICcuL1RyYWNrJztcblxuZXhwb3J0IGludGVyZmFjZSBUcmFja1B1Ymxpc2hEZWZhdWx0cyB7XG4gIC8qKlxuICAgKiBlbmNvZGluZyBwYXJhbWV0ZXJzIGZvciBjYW1lcmEgdHJhY2tcbiAgICovXG4gIHZpZGVvRW5jb2Rpbmc/OiBWaWRlb0VuY29kaW5nO1xuXG4gIC8qKlxuICAgKiBNdWx0aS1jb2RlYyBTaW11bGNhc3RcbiAgICogVlA5IGFuZCBBVjEgYXJlIG5vdCBzdXBwb3J0ZWQgYnkgYWxsIGJyb3dzZXIgY2xpZW50cy4gV2hlbiBiYWNrdXBDb2RlYyBpc1xuICAgKiBzZXQsIHdoZW4gYW4gaW5jb21wYXRpYmxlIGNsaWVudCBhdHRlbXB0cyB0byBzdWJzY3JpYmUgdG8gdGhlIHRyYWNrLCBMaXZlS2l0XG4gICAqIHdpbGwgYXV0b21hdGljYWxseSBwdWJsaXNoIGEgc2Vjb25kYXJ5IHRyYWNrIGVuY29kZWQgd2l0aCB0aGUgYmFja3VwIGNvZGVjLlxuICAgKlxuICAgKiBZb3UgY291bGQgY3VzdG9taXplIHNwZWNpZmljIGVuY29kaW5nIHBhcmFtZXRlcnMgb2YgdGhlIGJhY2t1cCB0cmFjayBieVxuICAgKiBleHBsaWNpdGx5IHNldHRpbmcgY29kZWMgYW5kIGVuY29kaW5nIGZpZWxkcy5cbiAgICpcbiAgICogRGVmYXVsdHMgdG8gYHRydWVgXG4gICAqL1xuICBiYWNrdXBDb2RlYz86IHRydWUgfCBmYWxzZSB8IHsgY29kZWM6IEJhY2t1cFZpZGVvQ29kZWM7IGVuY29kaW5nPzogVmlkZW9FbmNvZGluZyB9O1xuXG4gIC8qKlxuICAgKiBlbmNvZGluZyBwYXJhbWV0ZXJzIGZvciBzY3JlZW4gc2hhcmUgdHJhY2tcbiAgICovXG4gIHNjcmVlblNoYXJlRW5jb2Rpbmc/OiBWaWRlb0VuY29kaW5nO1xuXG4gIC8qKlxuICAgKiBjb2RlYywgZGVmYXVsdHMgdG8gdnA4OyBmb3Igc3ZjIGNvZGVjcywgYXV0byBlbmFibGUgdnA4XG4gICAqIGFzIGJhY2t1cC4gKFRCRClcbiAgICovXG4gIHZpZGVvQ29kZWM/OiBWaWRlb0NvZGVjO1xuXG4gIC8qKlxuICAgKiBtYXggYXVkaW8gYml0cmF0ZSwgZGVmYXVsdHMgdG8gW1tBdWRpb1ByZXNldHMubXVzaWNdXVxuICAgKiBAZGVwcmVjYXRlZCB1c2UgYGF1ZGlvUHJlc2V0YCBpbnN0ZWFkXG4gICAqL1xuICBhdWRpb0JpdHJhdGU/OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIHdoaWNoIGF1ZGlvIHByZXNldCBzaG91bGQgYmUgdXNlZCBmb3IgcHVibGlzaGluZyAoYXVkaW8pIHRyYWNrc1xuICAgKiBkZWZhdWx0cyB0byBbW0F1ZGlvUHJlc2V0cy5tdXNpY11dXG4gICAqL1xuICBhdWRpb1ByZXNldD86IEF1ZGlvUHJlc2V0O1xuXG4gIC8qKlxuICAgKiBkdHggKERpc2NvbnRpbnVvdXMgVHJhbnNtaXNzaW9uIG9mIGF1ZGlvKSwgZW5hYmxlZCBieSBkZWZhdWx0IGZvciBtb25vIHRyYWNrcy5cbiAgICovXG4gIGR0eD86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIHJlZCAoUmVkdW5kYW50IEF1ZGlvIERhdGEpLCBlbmFibGVkIGJ5IGRlZmF1bHQgZm9yIG1vbm8gdHJhY2tzLlxuICAgKi9cbiAgcmVkPzogYm9vbGVhbjtcblxuICAvKipcbiAgICogcHVibGlzaCB0cmFjayBpbiBzdGVyZW8gbW9kZSAob3Igc2V0IHRvIGZhbHNlIHRvIGRpc2FibGUpLiBkZWZhdWx0cyBkZXRlcm1pbmVkIGJ5IGNhcHR1cmUgY2hhbm5lbCBjb3VudC5cbiAgICovXG4gIGZvcmNlU3RlcmVvPzogYm9vbGVhbjtcblxuICAvKipcbiAgICogdXNlIHNpbXVsY2FzdCwgZGVmYXVsdHMgdG8gdHJ1ZS5cbiAgICogV2hlbiB1c2luZyBzaW11bGNhc3QsIExpdmVLaXQgd2lsbCBwdWJsaXNoIHVwIHRvIHRocmVlIHZlcnNpb25zIG9mIHRoZSBzdHJlYW1cbiAgICogYXQgdmFyaW91cyByZXNvbHV0aW9ucy5cbiAgICovXG4gIHNpbXVsY2FzdD86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIHNjYWxhYmlsaXR5IG1vZGUgZm9yIHN2YyBjb2RlY3MsIGRlZmF1bHRzIHRvICdMM1QzJy5cbiAgICogZm9yIHN2YyBjb2RlY3MsIHNpbXVsY2FzdCBpcyBkaXNhYmxlZC5cbiAgICovXG4gIHNjYWxhYmlsaXR5TW9kZT86IFNjYWxhYmlsaXR5TW9kZTtcblxuICAvKipcbiAgICogVXAgdG8gdHdvIGFkZGl0aW9uYWwgc2ltdWxjYXN0IGxheWVycyB0byBwdWJsaXNoIGluIGFkZGl0aW9uIHRvIHRoZSBvcmlnaW5hbFxuICAgKiBUcmFjay5cbiAgICogV2hlbiBsZWZ0IGJsYW5rLCBpdCBkZWZhdWx0cyB0byBoMTgwLCBoMzYwLlxuICAgKiBJZiBhIFNWQyBjb2RlYyBpcyB1c2VkIChWUDkgb3IgQVYxKSwgdGhpcyBmaWVsZCBoYXMgbm8gZWZmZWN0LlxuICAgKlxuICAgKiBUbyBwdWJsaXNoIHRocmVlIHRvdGFsIGxheWVycywgeW91IHdvdWxkIHNwZWNpZnk6XG4gICAqIHtcbiAgICogICB2aWRlb0VuY29kaW5nOiB7Li4ufSwgLy8gZW5jb2Rpbmcgb2YgdGhlIHByaW1hcnkgbGF5ZXJcbiAgICogICB2aWRlb1NpbXVsY2FzdExheWVyczogW1xuICAgKiAgICAgVmlkZW9QcmVzZXRzLmg1NDAsXG4gICAqICAgICBWaWRlb1ByZXNldHMuaDIxNixcbiAgICogICBdLFxuICAgKiB9XG4gICAqL1xuICB2aWRlb1NpbXVsY2FzdExheWVycz86IEFycmF5PFZpZGVvUHJlc2V0PjtcblxuICAvKipcbiAgICogY3VzdG9tIHZpZGVvIHNpbXVsY2FzdCBsYXllcnMgZm9yIHNjcmVlbiB0cmFja3NcbiAgICogTm90ZTogdGhlIGxheWVycyBuZWVkIHRvIGJlIG9yZGVyZWQgZnJvbSBsb3dlc3QgdG8gaGlnaGVzdCBxdWFsaXR5XG4gICAqL1xuICBzY3JlZW5TaGFyZVNpbXVsY2FzdExheWVycz86IEFycmF5PFZpZGVvUHJlc2V0PjtcblxuICAvKipcbiAgICogRm9yIGxvY2FsIHRyYWNrcywgc3RvcCB0aGUgdW5kZXJseWluZyBNZWRpYVN0cmVhbVRyYWNrIHdoZW4gdGhlIHRyYWNrIGlzIG11dGVkIChvciBwYXVzZWQpXG4gICAqIG9uIHNvbWUgcGxhdGZvcm1zLCB0aGlzIG9wdGlvbiBpcyBuZWNlc3NhcnkgdG8gZGlzYWJsZSB0aGUgbWljcm9waG9uZSByZWNvcmRpbmcgaW5kaWNhdG9yLlxuICAgKiBOb3RlOiB3aGVuIHRoaXMgaXMgZW5hYmxlZCwgYW5kIEJUIGRldmljZXMgYXJlIGNvbm5lY3RlZCwgdGhleSB3aWxsIHRyYW5zaXRpb24gYmV0d2VlblxuICAgKiBwcm9maWxlcyAoZS5nLiBIRlAgdG8gQTJEUCkgYW5kIHRoZXJlIHdpbGwgYmUgYW4gYXVkaWJsZSBkaWZmZXJlbmNlIGluIHBsYXliYWNrLlxuICAgKlxuICAgKiBkZWZhdWx0cyB0byBmYWxzZVxuICAgKi9cbiAgc3RvcE1pY1RyYWNrT25NdXRlPzogYm9vbGVhbjtcbn1cblxuLyoqXG4gKiBPcHRpb25zIHdoZW4gcHVibGlzaGluZyB0cmFja3NcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBUcmFja1B1Ymxpc2hPcHRpb25zIGV4dGVuZHMgVHJhY2tQdWJsaXNoRGVmYXVsdHMge1xuICAvKipcbiAgICogc2V0IGEgdHJhY2sgbmFtZVxuICAgKi9cbiAgbmFtZT86IHN0cmluZztcblxuICAvKipcbiAgICogU291cmNlIG9mIHRyYWNrLCBjYW1lcmEsIG1pY3JvcGhvbmUsIG9yIHNjcmVlblxuICAgKi9cbiAgc291cmNlPzogVHJhY2suU291cmNlO1xuXG4gIC8qKlxuICAgKiBTZXQgc3RyZWFtIG5hbWUgZm9yIHRoZSB0cmFjay4gQXVkaW8gYW5kIHZpZGVvIHRyYWNrcyB3aXRoIHRoZSBzYW1lIHN0cmVhbSBuYW1lXG4gICAqIHdpbGwgYmUgcGxhY2VkIGluIHRoZSBzYW1lIGBNZWRpYVN0cmVhbWAgYW5kIG9mZmVyIGJldHRlciBzeW5jaHJvbml6YXRpb24uXG4gICAqIEJ5IGRlZmF1bHQsIGNhbWVyYSBhbmQgbWljcm9waG9uZSB3aWxsIGJlIHBsYWNlZCBpbiBhIHN0cmVhbTsgYXMgd291bGQgc2NyZWVuX3NoYXJlIGFuZCBzY3JlZW5fc2hhcmVfYXVkaW9cbiAgICovXG4gIHN0cmVhbT86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBDcmVhdGVMb2NhbFRyYWNrc09wdGlvbnMge1xuICAvKipcbiAgICogYXVkaW8gdHJhY2sgb3B0aW9ucywgdHJ1ZSB0byBjcmVhdGUgd2l0aCBkZWZhdWx0cy4gZmFsc2UgaWYgYXVkaW8gc2hvdWxkbid0IGJlIGNyZWF0ZWRcbiAgICogZGVmYXVsdCB0cnVlXG4gICAqL1xuICBhdWRpbz86IGJvb2xlYW4gfCBBdWRpb0NhcHR1cmVPcHRpb25zO1xuXG4gIC8qKlxuICAgKiB2aWRlbyB0cmFjayBvcHRpb25zLCB0cnVlIHRvIGNyZWF0ZSB3aXRoIGRlZmF1bHRzLiBmYWxzZSBpZiB2aWRlbyBzaG91bGRuJ3QgYmUgY3JlYXRlZFxuICAgKiBkZWZhdWx0IHRydWVcbiAgICovXG4gIHZpZGVvPzogYm9vbGVhbiB8IFZpZGVvQ2FwdHVyZU9wdGlvbnM7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVmlkZW9DYXB0dXJlT3B0aW9ucyB7XG4gIC8qKlxuICAgKiBBIENvbnN0cmFpbkRPTVN0cmluZyBvYmplY3Qgc3BlY2lmeWluZyBhIGRldmljZSBJRCBvciBhbiBhcnJheSBvZiBkZXZpY2VcbiAgICogSURzIHdoaWNoIGFyZSBhY2NlcHRhYmxlIGFuZC9vciByZXF1aXJlZC5cbiAgICovXG4gIGRldmljZUlkPzogQ29uc3RyYWluRE9NU3RyaW5nO1xuXG4gIC8qKlxuICAgKiBhIGZhY2luZyBvciBhbiBhcnJheSBvZiBmYWNpbmdzIHdoaWNoIGFyZSBhY2NlcHRhYmxlIGFuZC9vciByZXF1aXJlZC5cbiAgICovXG4gIGZhY2luZ01vZGU/OiAndXNlcicgfCAnZW52aXJvbm1lbnQnIHwgJ2xlZnQnIHwgJ3JpZ2h0JztcblxuICByZXNvbHV0aW9uPzogVmlkZW9SZXNvbHV0aW9uO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFNjcmVlblNoYXJlQ2FwdHVyZU9wdGlvbnMge1xuICAvKipcbiAgICogdHJ1ZSB0byBjYXB0dXJlIGF1ZGlvIHNoYXJlZC4gYnJvd3NlciBzdXBwb3J0IGZvciBhdWRpbyBjYXB0dXJpbmcgaW5cbiAgICogc2NyZWVuc2hhcmUgaXMgbGltaXRlZDogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL01lZGlhRGV2aWNlcy9nZXREaXNwbGF5TWVkaWEjYnJvd3Nlcl9jb21wYXRpYmlsaXR5XG4gICAqL1xuICBhdWRpbz86IGJvb2xlYW4gfCBBdWRpb0NhcHR1cmVPcHRpb25zO1xuXG4gIC8qKlxuICAgKiBvbmx5IGFsbG93cyBmb3IgJ3RydWUnIGFuZCBjaHJvbWUgYWxsb3dzIGZvciBhZGRpdGlvbmFsIG9wdGlvbnMgdG8gYmUgcGFzc2VkIGluXG4gICAqIGh0dHBzOi8vZGV2ZWxvcGVyLmNocm9tZS5jb20vZG9jcy93ZWItcGxhdGZvcm0vc2NyZWVuLXNoYXJpbmctY29udHJvbHMvI2Rpc3BsYXlTdXJmYWNlXG4gICAqL1xuICB2aWRlbz86IHRydWUgfCB7IGRpc3BsYXlTdXJmYWNlPzogJ3dpbmRvdycgfCAnYnJvd3NlcicgfCAnbW9uaXRvcicgfTtcblxuICAvKipcbiAgICogY2FwdHVyZSByZXNvbHV0aW9uLCBkZWZhdWx0cyB0byAxMDgwIGZvciBhbGwgYnJvd3NlcnMgb3RoZXIgdGhhbiBTYWZhcmlcbiAgICogT24gU2FmYXJpIDE3LCBkZWZhdWx0IHJlc29sdXRpb24gaXMgbm90IGNhcHBlZCwgZHVlIHRvIGEgYnVnLCBzcGVjaWZ5aW5nXG4gICAqIGFueSByZXNvbHV0aW9uIGF0IGFsbCB3b3VsZCBsZWFkIHRvIGEgbG93LXJlc29sdXRpb24gY2FwdHVyZS5cbiAgICogaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTI2MzAxNVxuICAgKi9cbiAgcmVzb2x1dGlvbj86IFZpZGVvUmVzb2x1dGlvbjtcblxuICAvKiogYSBDYXB0dXJlQ29udHJvbGxlciBvYmplY3QgaW5zdGFuY2UgY29udGFpbmluZyBtZXRob2RzIHRoYXQgY2FuIGJlIHVzZWQgdG8gZnVydGhlciBtYW5pcHVsYXRlIHRoZSBjYXB0dXJlIHNlc3Npb24gaWYgaW5jbHVkZWQuICovXG4gIGNvbnRyb2xsZXI/OiB1bmtub3duOyAvLyBUT0RPIHJlcGxhY2UgdHlwZSB3aXRoIENhcHR1cmVDb250cm9sbGVyIG9uY2UgaXQgbGFuZHMgaW4gVHlwZVNjcmlwdFxuXG4gIC8qKiBzcGVjaWZpZXMgd2hldGhlciB0aGUgYnJvd3NlciBzaG91bGQgYWxsb3cgdGhlIHVzZXIgdG8gc2VsZWN0IHRoZSBjdXJyZW50IHRhYiBmb3IgY2FwdHVyZSAqL1xuICBzZWxmQnJvd3NlclN1cmZhY2U/OiAnaW5jbHVkZScgfCAnZXhjbHVkZSc7XG5cbiAgLyoqIHNwZWNpZmllcyB3aGV0aGVyIHRoZSBicm93c2VyIHNob3VsZCBkaXNwbGF5IGEgY29udHJvbCB0byBhbGxvdyB0aGUgdXNlciB0byBkeW5hbWljYWxseSBzd2l0Y2ggdGhlIHNoYXJlZCB0YWIgZHVyaW5nIHNjcmVlbi1zaGFyaW5nLiAqL1xuICBzdXJmYWNlU3dpdGNoaW5nPzogJ2luY2x1ZGUnIHwgJ2V4Y2x1ZGUnO1xuXG4gIC8qKiBzcGVjaWZpZXMgd2hldGhlciB0aGUgYnJvd3NlciBzaG91bGQgaW5jbHVkZSB0aGUgc3lzdGVtIGF1ZGlvIGFtb25nIHRoZSBwb3NzaWJsZSBhdWRpbyBzb3VyY2VzIG9mZmVyZWQgdG8gdGhlIHVzZXIgKi9cbiAgc3lzdGVtQXVkaW8/OiAnaW5jbHVkZScgfCAnZXhjbHVkZSc7XG5cbiAgLyoqIHNwZWNpZnkgdGhlIHR5cGUgb2YgY29udGVudCwgc2VlOiBodHRwczovL3d3dy53My5vcmcvVFIvbXN0LWNvbnRlbnQtaGludC8jdmlkZW8tY29udGVudC1oaW50cyAqL1xuICBjb250ZW50SGludD86ICdkZXRhaWwnIHwgJ3RleHQnIHwgJ21vdGlvbic7XG5cbiAgLyoqXG4gICAqIEV4cGVyaW1lbnRhbCBvcHRpb24gdG8gY29udHJvbCB3aGV0aGVyIHRoZSBhdWRpbyBwbGF5aW5nIGluIGEgdGFiIHdpbGwgY29udGludWUgdG8gYmUgcGxheWVkIG91dCBvZiBhIHVzZXInc1xuICAgKiBsb2NhbCBzcGVha2VycyB3aGVuIHRoZSB0YWIgaXMgY2FwdHVyZWQuXG4gICAqL1xuICBzdXBwcmVzc0xvY2FsQXVkaW9QbGF5YmFjaz86IGJvb2xlYW47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQXVkaW9DYXB0dXJlT3B0aW9ucyB7XG4gIC8qKlxuICAgKiBzcGVjaWZpZXMgd2hldGhlciBhdXRvbWF0aWMgZ2FpbiBjb250cm9sIGlzIHByZWZlcnJlZCBhbmQvb3IgcmVxdWlyZWRcbiAgICovXG4gIGF1dG9HYWluQ29udHJvbD86IENvbnN0cmFpbkJvb2xlYW47XG5cbiAgLyoqXG4gICAqIHRoZSBjaGFubmVsIGNvdW50IG9yIHJhbmdlIG9mIGNoYW5uZWwgY291bnRzIHdoaWNoIGFyZSBhY2NlcHRhYmxlIGFuZC9vciByZXF1aXJlZFxuICAgKi9cbiAgY2hhbm5lbENvdW50PzogQ29uc3RyYWluVUxvbmc7XG5cbiAgLyoqXG4gICAqIEEgQ29uc3RyYWluRE9NU3RyaW5nIG9iamVjdCBzcGVjaWZ5aW5nIGEgZGV2aWNlIElEIG9yIGFuIGFycmF5IG9mIGRldmljZVxuICAgKiBJRHMgd2hpY2ggYXJlIGFjY2VwdGFibGUgYW5kL29yIHJlcXVpcmVkLlxuICAgKi9cbiAgZGV2aWNlSWQ/OiBDb25zdHJhaW5ET01TdHJpbmc7XG5cbiAgLyoqXG4gICAqIHdoZXRoZXIgb3Igbm90IGVjaG8gY2FuY2VsbGF0aW9uIGlzIHByZWZlcnJlZCBhbmQvb3IgcmVxdWlyZWRcbiAgICovXG4gIGVjaG9DYW5jZWxsYXRpb24/OiBDb25zdHJhaW5Cb29sZWFuO1xuXG4gIC8qKlxuICAgKiB0aGUgbGF0ZW5jeSBvciByYW5nZSBvZiBsYXRlbmNpZXMgd2hpY2ggYXJlIGFjY2VwdGFibGUgYW5kL29yIHJlcXVpcmVkLlxuICAgKi9cbiAgbGF0ZW5jeT86IENvbnN0cmFpbkRvdWJsZTtcblxuICAvKipcbiAgICogd2hldGhlciBub2lzZSBzdXBwcmVzc2lvbiBpcyBwcmVmZXJyZWQgYW5kL29yIHJlcXVpcmVkLlxuICAgKi9cbiAgbm9pc2VTdXBwcmVzc2lvbj86IENvbnN0cmFpbkJvb2xlYW47XG5cbiAgLyoqXG4gICAqIHRoZSBzYW1wbGUgcmF0ZSBvciByYW5nZSBvZiBzYW1wbGUgcmF0ZXMgd2hpY2ggYXJlIGFjY2VwdGFibGUgYW5kL29yIHJlcXVpcmVkLlxuICAgKi9cbiAgc2FtcGxlUmF0ZT86IENvbnN0cmFpblVMb25nO1xuXG4gIC8qKlxuICAgKiBzYW1wbGUgc2l6ZSBvciByYW5nZSBvZiBzYW1wbGUgc2l6ZXMgd2hpY2ggYXJlIGFjY2VwdGFibGUgYW5kL29yIHJlcXVpcmVkLlxuICAgKi9cbiAgc2FtcGxlU2l6ZT86IENvbnN0cmFpblVMb25nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEF1ZGlvT3V0cHV0T3B0aW9ucyB7XG4gIC8qKlxuICAgKiBkZXZpY2VJZCB0byBvdXRwdXQgYXVkaW9cbiAgICpcbiAgICogT25seSBzdXBwb3J0ZWQgb24gYnJvd3NlcnMgd2hlcmUgYHNldFNpbmtJZGAgaXMgYXZhaWxhYmxlXG4gICAqL1xuICBkZXZpY2VJZD86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBWaWRlb1Jlc29sdXRpb24ge1xuICB3aWR0aDogbnVtYmVyO1xuICBoZWlnaHQ6IG51bWJlcjtcbiAgZnJhbWVSYXRlPzogbnVtYmVyO1xuICBhc3BlY3RSYXRpbz86IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBWaWRlb0VuY29kaW5nIHtcbiAgbWF4Qml0cmF0ZTogbnVtYmVyO1xuICBtYXhGcmFtZXJhdGU/OiBudW1iZXI7XG4gIHByaW9yaXR5PzogUlRDUHJpb3JpdHlUeXBlO1xufVxuXG5leHBvcnQgY2xhc3MgVmlkZW9QcmVzZXQge1xuICBlbmNvZGluZzogVmlkZW9FbmNvZGluZztcblxuICB3aWR0aDogbnVtYmVyO1xuXG4gIGhlaWdodDogbnVtYmVyO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHdpZHRoOiBudW1iZXIsXG4gICAgaGVpZ2h0OiBudW1iZXIsXG4gICAgbWF4Qml0cmF0ZTogbnVtYmVyLFxuICAgIG1heEZyYW1lcmF0ZT86IG51bWJlcixcbiAgICBwcmlvcml0eT86IFJUQ1ByaW9yaXR5VHlwZSxcbiAgKSB7XG4gICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIHRoaXMuZW5jb2RpbmcgPSB7XG4gICAgICBtYXhCaXRyYXRlLFxuICAgICAgbWF4RnJhbWVyYXRlLFxuICAgICAgcHJpb3JpdHksXG4gICAgfTtcbiAgfVxuXG4gIGdldCByZXNvbHV0aW9uKCk6IFZpZGVvUmVzb2x1dGlvbiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHdpZHRoOiB0aGlzLndpZHRoLFxuICAgICAgaGVpZ2h0OiB0aGlzLmhlaWdodCxcbiAgICAgIGZyYW1lUmF0ZTogdGhpcy5lbmNvZGluZy5tYXhGcmFtZXJhdGUsXG4gICAgICBhc3BlY3RSYXRpbzogdGhpcy53aWR0aCAvIHRoaXMuaGVpZ2h0LFxuICAgIH07XG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBBdWRpb1ByZXNldCB7XG4gIG1heEJpdHJhdGU6IG51bWJlcjtcbiAgcHJpb3JpdHk/OiBSVENQcmlvcml0eVR5cGU7XG59XG5cbmNvbnN0IGJhY2t1cENvZGVjcyA9IFsndnA4JywgJ2gyNjQnXSBhcyBjb25zdDtcblxuZXhwb3J0IGNvbnN0IHZpZGVvQ29kZWNzID0gWyd2cDgnLCAnaDI2NCcsICd2cDknLCAnYXYxJ10gYXMgY29uc3Q7XG5cbmV4cG9ydCB0eXBlIFZpZGVvQ29kZWMgPSAodHlwZW9mIHZpZGVvQ29kZWNzKVtudW1iZXJdO1xuXG5leHBvcnQgdHlwZSBCYWNrdXBWaWRlb0NvZGVjID0gKHR5cGVvZiBiYWNrdXBDb2RlY3MpW251bWJlcl07XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0JhY2t1cENvZGVjKGNvZGVjOiBzdHJpbmcpOiBjb2RlYyBpcyBCYWNrdXBWaWRlb0NvZGVjIHtcbiAgcmV0dXJuICEhYmFja3VwQ29kZWNzLmZpbmQoKGJhY2t1cCkgPT4gYmFja3VwID09PSBjb2RlYyk7XG59XG5cbi8qKlxuICogc2NhbGFiaWxpdHkgbW9kZXMgZm9yIHN2Yy5cbiAqL1xuZXhwb3J0IHR5cGUgU2NhbGFiaWxpdHlNb2RlID0gJ0wxVDMnIHwgJ0wyVDMnIHwgJ0wyVDNfS0VZJyB8ICdMM1QzJyB8ICdMM1QzX0tFWSc7XG5cbmV4cG9ydCBuYW1lc3BhY2UgQXVkaW9QcmVzZXRzIHtcbiAgZXhwb3J0IGNvbnN0IHRlbGVwaG9uZTogQXVkaW9QcmVzZXQgPSB7XG4gICAgbWF4Qml0cmF0ZTogMTJfMDAwLFxuICB9O1xuICBleHBvcnQgY29uc3Qgc3BlZWNoOiBBdWRpb1ByZXNldCA9IHtcbiAgICBtYXhCaXRyYXRlOiAyMF8wMDAsXG4gIH07XG4gIGV4cG9ydCBjb25zdCBtdXNpYzogQXVkaW9QcmVzZXQgPSB7XG4gICAgbWF4Qml0cmF0ZTogMzJfMDAwLFxuICB9O1xuICBleHBvcnQgY29uc3QgbXVzaWNTdGVyZW86IEF1ZGlvUHJlc2V0ID0ge1xuICAgIG1heEJpdHJhdGU6IDQ4XzAwMCxcbiAgfTtcbiAgZXhwb3J0IGNvbnN0IG11c2ljSGlnaFF1YWxpdHk6IEF1ZGlvUHJlc2V0ID0ge1xuICAgIG1heEJpdHJhdGU6IDY0XzAwMCxcbiAgfTtcbiAgZXhwb3J0IGNvbnN0IG11c2ljSGlnaFF1YWxpdHlTdGVyZW86IEF1ZGlvUHJlc2V0ID0ge1xuICAgIG1heEJpdHJhdGU6IDk2XzAwMCxcbiAgfTtcbn1cblxuLyoqXG4gKiBTYW5lIHByZXNldHMgZm9yIHZpZGVvIHJlc29sdXRpb24vZW5jb2RpbmdcbiAqL1xuZXhwb3J0IGNvbnN0IFZpZGVvUHJlc2V0cyA9IHtcbiAgaDkwOiBuZXcgVmlkZW9QcmVzZXQoMTYwLCA5MCwgOTBfMDAwLCAyMCksXG4gIGgxODA6IG5ldyBWaWRlb1ByZXNldCgzMjAsIDE4MCwgMTYwXzAwMCwgMjApLFxuICBoMjE2OiBuZXcgVmlkZW9QcmVzZXQoMzg0LCAyMTYsIDE4MF8wMDAsIDIwKSxcbiAgaDM2MDogbmV3IFZpZGVvUHJlc2V0KDY0MCwgMzYwLCA0NTBfMDAwLCAyMCksXG4gIGg1NDA6IG5ldyBWaWRlb1ByZXNldCg5NjAsIDU0MCwgODAwXzAwMCwgMjUpLFxuICBoNzIwOiBuZXcgVmlkZW9QcmVzZXQoMTI4MCwgNzIwLCAxXzcwMF8wMDAsIDMwKSxcbiAgaDEwODA6IG5ldyBWaWRlb1ByZXNldCgxOTIwLCAxMDgwLCAzXzAwMF8wMDAsIDMwKSxcbiAgaDE0NDA6IG5ldyBWaWRlb1ByZXNldCgyNTYwLCAxNDQwLCA1XzAwMF8wMDAsIDMwKSxcbiAgaDIxNjA6IG5ldyBWaWRlb1ByZXNldCgzODQwLCAyMTYwLCA4XzAwMF8wMDAsIDMwKSxcbn0gYXMgY29uc3Q7XG5cbi8qKlxuICogRm91ciBieSB0aHJlZSBwcmVzZXRzXG4gKi9cbmV4cG9ydCBjb25zdCBWaWRlb1ByZXNldHM0MyA9IHtcbiAgaDEyMDogbmV3IFZpZGVvUHJlc2V0KDE2MCwgMTIwLCA3MF8wMDAsIDIwKSxcbiAgaDE4MDogbmV3IFZpZGVvUHJlc2V0KDI0MCwgMTgwLCAxMjVfMDAwLCAyMCksXG4gIGgyNDA6IG5ldyBWaWRlb1ByZXNldCgzMjAsIDI0MCwgMTQwXzAwMCwgMjApLFxuICBoMzYwOiBuZXcgVmlkZW9QcmVzZXQoNDgwLCAzNjAsIDMzMF8wMDAsIDIwKSxcbiAgaDQ4MDogbmV3IFZpZGVvUHJlc2V0KDY0MCwgNDgwLCA1MDBfMDAwLCAyMCksXG4gIGg1NDA6IG5ldyBWaWRlb1ByZXNldCg3MjAsIDU0MCwgNjAwXzAwMCwgMjUpLFxuICBoNzIwOiBuZXcgVmlkZW9QcmVzZXQoOTYwLCA3MjAsIDFfMzAwXzAwMCwgMzApLFxuICBoMTA4MDogbmV3IFZpZGVvUHJlc2V0KDE0NDAsIDEwODAsIDJfMzAwXzAwMCwgMzApLFxuICBoMTQ0MDogbmV3IFZpZGVvUHJlc2V0KDE5MjAsIDE0NDAsIDNfODAwXzAwMCwgMzApLFxufSBhcyBjb25zdDtcblxuZXhwb3J0IGNvbnN0IFNjcmVlblNoYXJlUHJlc2V0cyA9IHtcbiAgaDM2MGZwczM6IG5ldyBWaWRlb1ByZXNldCg2NDAsIDM2MCwgMjAwXzAwMCwgMywgJ21lZGl1bScpLFxuICBoMzYwZnBzMTU6IG5ldyBWaWRlb1ByZXNldCg2NDAsIDM2MCwgNDAwXzAwMCwgMTUsICdtZWRpdW0nKSxcbiAgaDcyMGZwczU6IG5ldyBWaWRlb1ByZXNldCgxMjgwLCA3MjAsIDgwMF8wMDAsIDUsICdtZWRpdW0nKSxcbiAgaDcyMGZwczE1OiBuZXcgVmlkZW9QcmVzZXQoMTI4MCwgNzIwLCAxXzUwMF8wMDAsIDE1LCAnbWVkaXVtJyksXG4gIGg3MjBmcHMzMDogbmV3IFZpZGVvUHJlc2V0KDEyODAsIDcyMCwgMl8wMDBfMDAwLCAzMCwgJ21lZGl1bScpLFxuICBoMTA4MGZwczE1OiBuZXcgVmlkZW9QcmVzZXQoMTkyMCwgMTA4MCwgMl81MDBfMDAwLCAxNSwgJ21lZGl1bScpLFxuICBoMTA4MGZwczMwOiBuZXcgVmlkZW9QcmVzZXQoMTkyMCwgMTA4MCwgNV8wMDBfMDAwLCAzMCwgJ21lZGl1bScpLFxuICAvLyBvcmlnaW5hbCByZXNvbHV0aW9uLCB3aXRob3V0IHJlc2l6aW5nXG4gIG9yaWdpbmFsOiBuZXcgVmlkZW9QcmVzZXQoMCwgMCwgN18wMDBfMDAwLCAzMCwgJ21lZGl1bScpLFxufSBhcyBjb25zdDtcbiIsIi8vIENvcHlyaWdodCAyMDIzIExpdmVLaXQsIEluYy5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbi8vIEBnZW5lcmF0ZWQgYnkgcHJvdG9jLWdlbi1lcyB2MS40LjIgd2l0aCBwYXJhbWV0ZXIgXCJ0YXJnZXQ9dHNcIlxuLy8gQGdlbmVyYXRlZCBmcm9tIGZpbGUgbGl2ZWtpdF9ydGMucHJvdG8gKHBhY2thZ2UgbGl2ZWtpdCwgc3ludGF4IHByb3RvMylcbi8qIGVzbGludC1kaXNhYmxlICovXG4vLyBAdHMtbm9jaGVja1xuXG5pbXBvcnQgdHlwZSB7IEJpbmFyeVJlYWRPcHRpb25zLCBGaWVsZExpc3QsIEpzb25SZWFkT3B0aW9ucywgSnNvblZhbHVlLCBQYXJ0aWFsTWVzc2FnZSwgUGxhaW5NZXNzYWdlIH0gZnJvbSBcIkBidWZidWlsZC9wcm90b2J1ZlwiO1xuaW1wb3J0IHsgTWVzc2FnZSwgcHJvdG8zLCBwcm90b0ludDY0IH0gZnJvbSBcIkBidWZidWlsZC9wcm90b2J1ZlwiO1xuaW1wb3J0IHsgQ2xpZW50Q29uZmlndXJhdGlvbiwgQ29ubmVjdGlvblF1YWxpdHksIERpc2Nvbm5lY3RSZWFzb24sIEVuY3J5cHRpb25fVHlwZSwgUGFydGljaXBhbnRJbmZvLCBQYXJ0aWNpcGFudFRyYWNrcywgUm9vbSwgU2VydmVySW5mbywgU3BlYWtlckluZm8sIFN1YnNjcmlwdGlvbkVycm9yLCBUcmFja0luZm8sIFRyYWNrU291cmNlLCBUcmFja1R5cGUsIFZpZGVvTGF5ZXIsIFZpZGVvUXVhbGl0eSB9IGZyb20gXCIuL2xpdmVraXRfbW9kZWxzX3BiLmpzXCI7XG5cbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIGVudW0gbGl2ZWtpdC5TaWduYWxUYXJnZXRcbiAqL1xuZXhwb3J0IGVudW0gU2lnbmFsVGFyZ2V0IHtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBQVUJMSVNIRVIgPSAwO1xuICAgKi9cbiAgUFVCTElTSEVSID0gMCxcblxuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGVudW0gdmFsdWU6IFNVQlNDUklCRVIgPSAxO1xuICAgKi9cbiAgU1VCU0NSSUJFUiA9IDEsXG59XG4vLyBSZXRyaWV2ZSBlbnVtIG1ldGFkYXRhIHdpdGg6IHByb3RvMy5nZXRFbnVtVHlwZShTaWduYWxUYXJnZXQpXG5wcm90bzMudXRpbC5zZXRFbnVtVHlwZShTaWduYWxUYXJnZXQsIFwibGl2ZWtpdC5TaWduYWxUYXJnZXRcIiwgW1xuICB7IG5vOiAwLCBuYW1lOiBcIlBVQkxJU0hFUlwiIH0sXG4gIHsgbm86IDEsIG5hbWU6IFwiU1VCU0NSSUJFUlwiIH0sXG5dKTtcblxuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gZW51bSBsaXZla2l0LlN0cmVhbVN0YXRlXG4gKi9cbmV4cG9ydCBlbnVtIFN0cmVhbVN0YXRlIHtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBBQ1RJVkUgPSAwO1xuICAgKi9cbiAgQUNUSVZFID0gMCxcblxuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGVudW0gdmFsdWU6IFBBVVNFRCA9IDE7XG4gICAqL1xuICBQQVVTRUQgPSAxLFxufVxuLy8gUmV0cmlldmUgZW51bSBtZXRhZGF0YSB3aXRoOiBwcm90bzMuZ2V0RW51bVR5cGUoU3RyZWFtU3RhdGUpXG5wcm90bzMudXRpbC5zZXRFbnVtVHlwZShTdHJlYW1TdGF0ZSwgXCJsaXZla2l0LlN0cmVhbVN0YXRlXCIsIFtcbiAgeyBubzogMCwgbmFtZTogXCJBQ1RJVkVcIiB9LFxuICB7IG5vOiAxLCBuYW1lOiBcIlBBVVNFRFwiIH0sXG5dKTtcblxuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gZW51bSBsaXZla2l0LkNhbmRpZGF0ZVByb3RvY29sXG4gKi9cbmV4cG9ydCBlbnVtIENhbmRpZGF0ZVByb3RvY29sIHtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBVRFAgPSAwO1xuICAgKi9cbiAgVURQID0gMCxcblxuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGVudW0gdmFsdWU6IFRDUCA9IDE7XG4gICAqL1xuICBUQ1AgPSAxLFxuXG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZW51bSB2YWx1ZTogVExTID0gMjtcbiAgICovXG4gIFRMUyA9IDIsXG59XG4vLyBSZXRyaWV2ZSBlbnVtIG1ldGFkYXRhIHdpdGg6IHByb3RvMy5nZXRFbnVtVHlwZShDYW5kaWRhdGVQcm90b2NvbClcbnByb3RvMy51dGlsLnNldEVudW1UeXBlKENhbmRpZGF0ZVByb3RvY29sLCBcImxpdmVraXQuQ2FuZGlkYXRlUHJvdG9jb2xcIiwgW1xuICB7IG5vOiAwLCBuYW1lOiBcIlVEUFwiIH0sXG4gIHsgbm86IDEsIG5hbWU6IFwiVENQXCIgfSxcbiAgeyBubzogMiwgbmFtZTogXCJUTFNcIiB9LFxuXSk7XG5cbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgbGl2ZWtpdC5TaWduYWxSZXF1ZXN0XG4gKi9cbmV4cG9ydCBjbGFzcyBTaWduYWxSZXF1ZXN0IGV4dGVuZHMgTWVzc2FnZTxTaWduYWxSZXF1ZXN0PiB7XG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gb25lb2YgbGl2ZWtpdC5TaWduYWxSZXF1ZXN0Lm1lc3NhZ2VcbiAgICovXG4gIG1lc3NhZ2U6IHtcbiAgICAvKipcbiAgICAgKiBpbml0aWFsIGpvaW4gZXhjaGFuZ2UsIGZvciBwdWJsaXNoZXJcbiAgICAgKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogbGl2ZWtpdC5TZXNzaW9uRGVzY3JpcHRpb24gb2ZmZXIgPSAxO1xuICAgICAqL1xuICAgIHZhbHVlOiBTZXNzaW9uRGVzY3JpcHRpb247XG4gICAgY2FzZTogXCJvZmZlclwiO1xuICB9IHwge1xuICAgIC8qKlxuICAgICAqIHBhcnRpY2lwYW50IGFuc3dlcmluZyBwdWJsaXNoZXIgb2ZmZXJcbiAgICAgKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogbGl2ZWtpdC5TZXNzaW9uRGVzY3JpcHRpb24gYW5zd2VyID0gMjtcbiAgICAgKi9cbiAgICB2YWx1ZTogU2Vzc2lvbkRlc2NyaXB0aW9uO1xuICAgIGNhc2U6IFwiYW5zd2VyXCI7XG4gIH0gfCB7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBsaXZla2l0LlRyaWNrbGVSZXF1ZXN0IHRyaWNrbGUgPSAzO1xuICAgICAqL1xuICAgIHZhbHVlOiBUcmlja2xlUmVxdWVzdDtcbiAgICBjYXNlOiBcInRyaWNrbGVcIjtcbiAgfSB8IHtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGxpdmVraXQuQWRkVHJhY2tSZXF1ZXN0IGFkZF90cmFjayA9IDQ7XG4gICAgICovXG4gICAgdmFsdWU6IEFkZFRyYWNrUmVxdWVzdDtcbiAgICBjYXNlOiBcImFkZFRyYWNrXCI7XG4gIH0gfCB7XG4gICAgLyoqXG4gICAgICogbXV0ZSB0aGUgcGFydGljaXBhbnQncyBwdWJsaXNoZWQgdHJhY2tzXG4gICAgICpcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGxpdmVraXQuTXV0ZVRyYWNrUmVxdWVzdCBtdXRlID0gNTtcbiAgICAgKi9cbiAgICB2YWx1ZTogTXV0ZVRyYWNrUmVxdWVzdDtcbiAgICBjYXNlOiBcIm11dGVcIjtcbiAgfSB8IHtcbiAgICAvKipcbiAgICAgKiBTdWJzY3JpYmUgb3IgdW5zdWJzY3JpYmUgZnJvbSB0cmFja3NcbiAgICAgKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogbGl2ZWtpdC5VcGRhdGVTdWJzY3JpcHRpb24gc3Vic2NyaXB0aW9uID0gNjtcbiAgICAgKi9cbiAgICB2YWx1ZTogVXBkYXRlU3Vic2NyaXB0aW9uO1xuICAgIGNhc2U6IFwic3Vic2NyaXB0aW9uXCI7XG4gIH0gfCB7XG4gICAgLyoqXG4gICAgICogVXBkYXRlIHNldHRpbmdzIG9mIHN1YnNjcmliZWQgdHJhY2tzXG4gICAgICpcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGxpdmVraXQuVXBkYXRlVHJhY2tTZXR0aW5ncyB0cmFja19zZXR0aW5nID0gNztcbiAgICAgKi9cbiAgICB2YWx1ZTogVXBkYXRlVHJhY2tTZXR0aW5ncztcbiAgICBjYXNlOiBcInRyYWNrU2V0dGluZ1wiO1xuICB9IHwge1xuICAgIC8qKlxuICAgICAqIEltbWVkaWF0ZWx5IHRlcm1pbmF0ZSBzZXNzaW9uXG4gICAgICpcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGxpdmVraXQuTGVhdmVSZXF1ZXN0IGxlYXZlID0gODtcbiAgICAgKi9cbiAgICB2YWx1ZTogTGVhdmVSZXF1ZXN0O1xuICAgIGNhc2U6IFwibGVhdmVcIjtcbiAgfSB8IHtcbiAgICAvKipcbiAgICAgKiBVcGRhdGUgcHVibGlzaGVkIHZpZGVvIGxheWVyc1xuICAgICAqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBsaXZla2l0LlVwZGF0ZVZpZGVvTGF5ZXJzIHVwZGF0ZV9sYXllcnMgPSAxMDtcbiAgICAgKi9cbiAgICB2YWx1ZTogVXBkYXRlVmlkZW9MYXllcnM7XG4gICAgY2FzZTogXCJ1cGRhdGVMYXllcnNcIjtcbiAgfSB8IHtcbiAgICAvKipcbiAgICAgKiBVcGRhdGUgc3Vic2NyaWJlciBwZXJtaXNzaW9uc1xuICAgICAqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBsaXZla2l0LlN1YnNjcmlwdGlvblBlcm1pc3Npb24gc3Vic2NyaXB0aW9uX3Blcm1pc3Npb24gPSAxMTtcbiAgICAgKi9cbiAgICB2YWx1ZTogU3Vic2NyaXB0aW9uUGVybWlzc2lvbjtcbiAgICBjYXNlOiBcInN1YnNjcmlwdGlvblBlcm1pc3Npb25cIjtcbiAgfSB8IHtcbiAgICAvKipcbiAgICAgKiBzeW5jIGNsaWVudCdzIHN1YnNjcmliZSBzdGF0ZSB0byBzZXJ2ZXIgZHVyaW5nIHJlY29ubmVjdFxuICAgICAqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBsaXZla2l0LlN5bmNTdGF0ZSBzeW5jX3N0YXRlID0gMTI7XG4gICAgICovXG4gICAgdmFsdWU6IFN5bmNTdGF0ZTtcbiAgICBjYXNlOiBcInN5bmNTdGF0ZVwiO1xuICB9IHwge1xuICAgIC8qKlxuICAgICAqIFNpbXVsYXRlIGNvbmRpdGlvbnMsIGZvciBjbGllbnQgdmFsaWRhdGlvbnNcbiAgICAgKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogbGl2ZWtpdC5TaW11bGF0ZVNjZW5hcmlvIHNpbXVsYXRlID0gMTM7XG4gICAgICovXG4gICAgdmFsdWU6IFNpbXVsYXRlU2NlbmFyaW87XG4gICAgY2FzZTogXCJzaW11bGF0ZVwiO1xuICB9IHwge1xuICAgIC8qKlxuICAgICAqIGNsaWVudCB0cmlnZ2VyZWQgcGluZyB0byBzZXJ2ZXJcbiAgICAgKlxuICAgICAqIGRlcHJlY2F0ZWQgYnkgcGluZ19yZXEgKG1lc3NhZ2UgUGluZylcbiAgICAgKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogaW50NjQgcGluZyA9IDE0O1xuICAgICAqL1xuICAgIHZhbHVlOiBiaWdpbnQ7XG4gICAgY2FzZTogXCJwaW5nXCI7XG4gIH0gfCB7XG4gICAgLyoqXG4gICAgICogdXBkYXRlIGEgcGFydGljaXBhbnQncyBvd24gbWV0YWRhdGEgYW5kL29yIG5hbWVcbiAgICAgKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogbGl2ZWtpdC5VcGRhdGVQYXJ0aWNpcGFudE1ldGFkYXRhIHVwZGF0ZV9tZXRhZGF0YSA9IDE1O1xuICAgICAqL1xuICAgIHZhbHVlOiBVcGRhdGVQYXJ0aWNpcGFudE1ldGFkYXRhO1xuICAgIGNhc2U6IFwidXBkYXRlTWV0YWRhdGFcIjtcbiAgfSB8IHtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGxpdmVraXQuUGluZyBwaW5nX3JlcSA9IDE2O1xuICAgICAqL1xuICAgIHZhbHVlOiBQaW5nO1xuICAgIGNhc2U6IFwicGluZ1JlcVwiO1xuICB9IHwgeyBjYXNlOiB1bmRlZmluZWQ7IHZhbHVlPzogdW5kZWZpbmVkIH0gPSB7IGNhc2U6IHVuZGVmaW5lZCB9O1xuXG4gIGNvbnN0cnVjdG9yKGRhdGE/OiBQYXJ0aWFsTWVzc2FnZTxTaWduYWxSZXF1ZXN0Pikge1xuICAgIHN1cGVyKCk7XG4gICAgcHJvdG8zLnV0aWwuaW5pdFBhcnRpYWwoZGF0YSwgdGhpcyk7XG4gIH1cblxuICBzdGF0aWMgcmVhZG9ubHkgcnVudGltZTogdHlwZW9mIHByb3RvMyA9IHByb3RvMztcbiAgc3RhdGljIHJlYWRvbmx5IHR5cGVOYW1lID0gXCJsaXZla2l0LlNpZ25hbFJlcXVlc3RcIjtcbiAgc3RhdGljIHJlYWRvbmx5IGZpZWxkczogRmllbGRMaXN0ID0gcHJvdG8zLnV0aWwubmV3RmllbGRMaXN0KCgpID0+IFtcbiAgICB7IG5vOiAxLCBuYW1lOiBcIm9mZmVyXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBTZXNzaW9uRGVzY3JpcHRpb24sIG9uZW9mOiBcIm1lc3NhZ2VcIiB9LFxuICAgIHsgbm86IDIsIG5hbWU6IFwiYW5zd2VyXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBTZXNzaW9uRGVzY3JpcHRpb24sIG9uZW9mOiBcIm1lc3NhZ2VcIiB9LFxuICAgIHsgbm86IDMsIG5hbWU6IFwidHJpY2tsZVwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogVHJpY2tsZVJlcXVlc3QsIG9uZW9mOiBcIm1lc3NhZ2VcIiB9LFxuICAgIHsgbm86IDQsIG5hbWU6IFwiYWRkX3RyYWNrXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBBZGRUcmFja1JlcXVlc3QsIG9uZW9mOiBcIm1lc3NhZ2VcIiB9LFxuICAgIHsgbm86IDUsIG5hbWU6IFwibXV0ZVwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogTXV0ZVRyYWNrUmVxdWVzdCwgb25lb2Y6IFwibWVzc2FnZVwiIH0sXG4gICAgeyBubzogNiwgbmFtZTogXCJzdWJzY3JpcHRpb25cIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFVwZGF0ZVN1YnNjcmlwdGlvbiwgb25lb2Y6IFwibWVzc2FnZVwiIH0sXG4gICAgeyBubzogNywgbmFtZTogXCJ0cmFja19zZXR0aW5nXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBVcGRhdGVUcmFja1NldHRpbmdzLCBvbmVvZjogXCJtZXNzYWdlXCIgfSxcbiAgICB7IG5vOiA4LCBuYW1lOiBcImxlYXZlXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBMZWF2ZVJlcXVlc3QsIG9uZW9mOiBcIm1lc3NhZ2VcIiB9LFxuICAgIHsgbm86IDEwLCBuYW1lOiBcInVwZGF0ZV9sYXllcnNcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFVwZGF0ZVZpZGVvTGF5ZXJzLCBvbmVvZjogXCJtZXNzYWdlXCIgfSxcbiAgICB7IG5vOiAxMSwgbmFtZTogXCJzdWJzY3JpcHRpb25fcGVybWlzc2lvblwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogU3Vic2NyaXB0aW9uUGVybWlzc2lvbiwgb25lb2Y6IFwibWVzc2FnZVwiIH0sXG4gICAgeyBubzogMTIsIG5hbWU6IFwic3luY19zdGF0ZVwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogU3luY1N0YXRlLCBvbmVvZjogXCJtZXNzYWdlXCIgfSxcbiAgICB7IG5vOiAxMywgbmFtZTogXCJzaW11bGF0ZVwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogU2ltdWxhdGVTY2VuYXJpbywgb25lb2Y6IFwibWVzc2FnZVwiIH0sXG4gICAgeyBubzogMTQsIG5hbWU6IFwicGluZ1wiLCBraW5kOiBcInNjYWxhclwiLCBUOiAzIC8qIFNjYWxhclR5cGUuSU5UNjQgKi8sIG9uZW9mOiBcIm1lc3NhZ2VcIiB9LFxuICAgIHsgbm86IDE1LCBuYW1lOiBcInVwZGF0ZV9tZXRhZGF0YVwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogVXBkYXRlUGFydGljaXBhbnRNZXRhZGF0YSwgb25lb2Y6IFwibWVzc2FnZVwiIH0sXG4gICAgeyBubzogMTYsIG5hbWU6IFwicGluZ19yZXFcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFBpbmcsIG9uZW9mOiBcIm1lc3NhZ2VcIiB9LFxuICBdKTtcblxuICBzdGF0aWMgZnJvbUJpbmFyeShieXRlczogVWludDhBcnJheSwgb3B0aW9ucz86IFBhcnRpYWw8QmluYXJ5UmVhZE9wdGlvbnM+KTogU2lnbmFsUmVxdWVzdCB7XG4gICAgcmV0dXJuIG5ldyBTaWduYWxSZXF1ZXN0KCkuZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucyk7XG4gIH1cblxuICBzdGF0aWMgZnJvbUpzb24oanNvblZhbHVlOiBKc29uVmFsdWUsIG9wdGlvbnM/OiBQYXJ0aWFsPEpzb25SZWFkT3B0aW9ucz4pOiBTaWduYWxSZXF1ZXN0IHtcbiAgICByZXR1cm4gbmV3IFNpZ25hbFJlcXVlc3QoKS5mcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpO1xuICB9XG5cbiAgc3RhdGljIGZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmc6IHN0cmluZywgb3B0aW9ucz86IFBhcnRpYWw8SnNvblJlYWRPcHRpb25zPik6IFNpZ25hbFJlcXVlc3Qge1xuICAgIHJldHVybiBuZXcgU2lnbmFsUmVxdWVzdCgpLmZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpO1xuICB9XG5cbiAgc3RhdGljIGVxdWFscyhhOiBTaWduYWxSZXF1ZXN0IHwgUGxhaW5NZXNzYWdlPFNpZ25hbFJlcXVlc3Q+IHwgdW5kZWZpbmVkLCBiOiBTaWduYWxSZXF1ZXN0IHwgUGxhaW5NZXNzYWdlPFNpZ25hbFJlcXVlc3Q+IHwgdW5kZWZpbmVkKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHByb3RvMy51dGlsLmVxdWFscyhTaWduYWxSZXF1ZXN0LCBhLCBiKTtcbiAgfVxufVxuXG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBtZXNzYWdlIGxpdmVraXQuU2lnbmFsUmVzcG9uc2VcbiAqL1xuZXhwb3J0IGNsYXNzIFNpZ25hbFJlc3BvbnNlIGV4dGVuZHMgTWVzc2FnZTxTaWduYWxSZXNwb25zZT4ge1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIG9uZW9mIGxpdmVraXQuU2lnbmFsUmVzcG9uc2UubWVzc2FnZVxuICAgKi9cbiAgbWVzc2FnZToge1xuICAgIC8qKlxuICAgICAqIHNlbnQgd2hlbiBqb2luIGlzIGFjY2VwdGVkXG4gICAgICpcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGxpdmVraXQuSm9pblJlc3BvbnNlIGpvaW4gPSAxO1xuICAgICAqL1xuICAgIHZhbHVlOiBKb2luUmVzcG9uc2U7XG4gICAgY2FzZTogXCJqb2luXCI7XG4gIH0gfCB7XG4gICAgLyoqXG4gICAgICogc2VudCB3aGVuIHNlcnZlciBhbnN3ZXJzIHB1Ymxpc2hlclxuICAgICAqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBsaXZla2l0LlNlc3Npb25EZXNjcmlwdGlvbiBhbnN3ZXIgPSAyO1xuICAgICAqL1xuICAgIHZhbHVlOiBTZXNzaW9uRGVzY3JpcHRpb247XG4gICAgY2FzZTogXCJhbnN3ZXJcIjtcbiAgfSB8IHtcbiAgICAvKipcbiAgICAgKiBzZW50IHdoZW4gc2VydmVyIGlzIHNlbmRpbmcgc3Vic2NyaWJlciBhbiBvZmZlclxuICAgICAqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBsaXZla2l0LlNlc3Npb25EZXNjcmlwdGlvbiBvZmZlciA9IDM7XG4gICAgICovXG4gICAgdmFsdWU6IFNlc3Npb25EZXNjcmlwdGlvbjtcbiAgICBjYXNlOiBcIm9mZmVyXCI7XG4gIH0gfCB7XG4gICAgLyoqXG4gICAgICogc2VudCB3aGVuIGFuIElDRSBjYW5kaWRhdGUgaXMgYXZhaWxhYmxlXG4gICAgICpcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGxpdmVraXQuVHJpY2tsZVJlcXVlc3QgdHJpY2tsZSA9IDQ7XG4gICAgICovXG4gICAgdmFsdWU6IFRyaWNrbGVSZXF1ZXN0O1xuICAgIGNhc2U6IFwidHJpY2tsZVwiO1xuICB9IHwge1xuICAgIC8qKlxuICAgICAqIHNlbnQgd2hlbiBwYXJ0aWNpcGFudHMgaW4gdGhlIHJvb20gaGFzIGNoYW5nZWRcbiAgICAgKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogbGl2ZWtpdC5QYXJ0aWNpcGFudFVwZGF0ZSB1cGRhdGUgPSA1O1xuICAgICAqL1xuICAgIHZhbHVlOiBQYXJ0aWNpcGFudFVwZGF0ZTtcbiAgICBjYXNlOiBcInVwZGF0ZVwiO1xuICB9IHwge1xuICAgIC8qKlxuICAgICAqIHNlbnQgdG8gdGhlIHBhcnRpY2lwYW50IHdoZW4gdGhlaXIgdHJhY2sgaGFzIGJlZW4gcHVibGlzaGVkXG4gICAgICpcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGxpdmVraXQuVHJhY2tQdWJsaXNoZWRSZXNwb25zZSB0cmFja19wdWJsaXNoZWQgPSA2O1xuICAgICAqL1xuICAgIHZhbHVlOiBUcmFja1B1Ymxpc2hlZFJlc3BvbnNlO1xuICAgIGNhc2U6IFwidHJhY2tQdWJsaXNoZWRcIjtcbiAgfSB8IHtcbiAgICAvKipcbiAgICAgKiBJbW1lZGlhdGVseSB0ZXJtaW5hdGUgc2Vzc2lvblxuICAgICAqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBsaXZla2l0LkxlYXZlUmVxdWVzdCBsZWF2ZSA9IDg7XG4gICAgICovXG4gICAgdmFsdWU6IExlYXZlUmVxdWVzdDtcbiAgICBjYXNlOiBcImxlYXZlXCI7XG4gIH0gfCB7XG4gICAgLyoqXG4gICAgICogc2VydmVyIGluaXRpYXRlZCBtdXRlXG4gICAgICpcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGxpdmVraXQuTXV0ZVRyYWNrUmVxdWVzdCBtdXRlID0gOTtcbiAgICAgKi9cbiAgICB2YWx1ZTogTXV0ZVRyYWNrUmVxdWVzdDtcbiAgICBjYXNlOiBcIm11dGVcIjtcbiAgfSB8IHtcbiAgICAvKipcbiAgICAgKiBpbmRpY2F0ZXMgY2hhbmdlcyB0byBzcGVha2VyIHN0YXR1cywgaW5jbHVkaW5nIHdoZW4gdGhleSd2ZSBnb25lIHRvIG5vdCBzcGVha2luZ1xuICAgICAqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBsaXZla2l0LlNwZWFrZXJzQ2hhbmdlZCBzcGVha2Vyc19jaGFuZ2VkID0gMTA7XG4gICAgICovXG4gICAgdmFsdWU6IFNwZWFrZXJzQ2hhbmdlZDtcbiAgICBjYXNlOiBcInNwZWFrZXJzQ2hhbmdlZFwiO1xuICB9IHwge1xuICAgIC8qKlxuICAgICAqIHNlbnQgd2hlbiBtZXRhZGF0YSBvZiB0aGUgcm9vbSBoYXMgY2hhbmdlZFxuICAgICAqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBsaXZla2l0LlJvb21VcGRhdGUgcm9vbV91cGRhdGUgPSAxMTtcbiAgICAgKi9cbiAgICB2YWx1ZTogUm9vbVVwZGF0ZTtcbiAgICBjYXNlOiBcInJvb21VcGRhdGVcIjtcbiAgfSB8IHtcbiAgICAvKipcbiAgICAgKiB3aGVuIGNvbm5lY3Rpb24gcXVhbGl0eSBjaGFuZ2VkXG4gICAgICpcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGxpdmVraXQuQ29ubmVjdGlvblF1YWxpdHlVcGRhdGUgY29ubmVjdGlvbl9xdWFsaXR5ID0gMTI7XG4gICAgICovXG4gICAgdmFsdWU6IENvbm5lY3Rpb25RdWFsaXR5VXBkYXRlO1xuICAgIGNhc2U6IFwiY29ubmVjdGlvblF1YWxpdHlcIjtcbiAgfSB8IHtcbiAgICAvKipcbiAgICAgKiB3aGVuIHN0cmVhbWVkIHRyYWNrcyBzdGF0ZSBjaGFuZ2VkLCB1c2VkIHRvIG5vdGlmeSB3aGVuIGFueSBvZiB0aGUgc3RyZWFtcyB3ZXJlIHBhdXNlZCBkdWUgdG9cbiAgICAgKiBjb25nZXN0aW9uXG4gICAgICpcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGxpdmVraXQuU3RyZWFtU3RhdGVVcGRhdGUgc3RyZWFtX3N0YXRlX3VwZGF0ZSA9IDEzO1xuICAgICAqL1xuICAgIHZhbHVlOiBTdHJlYW1TdGF0ZVVwZGF0ZTtcbiAgICBjYXNlOiBcInN0cmVhbVN0YXRlVXBkYXRlXCI7XG4gIH0gfCB7XG4gICAgLyoqXG4gICAgICogd2hlbiBtYXggc3Vic2NyaWJlIHF1YWxpdHkgY2hhbmdlZCwgdXNlZCBieSBkeW5hbWljIGJyb2FkY2FzdGluZyB0byBkaXNhYmxlIHVudXNlZCBsYXllcnNcbiAgICAgKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogbGl2ZWtpdC5TdWJzY3JpYmVkUXVhbGl0eVVwZGF0ZSBzdWJzY3JpYmVkX3F1YWxpdHlfdXBkYXRlID0gMTQ7XG4gICAgICovXG4gICAgdmFsdWU6IFN1YnNjcmliZWRRdWFsaXR5VXBkYXRlO1xuICAgIGNhc2U6IFwic3Vic2NyaWJlZFF1YWxpdHlVcGRhdGVcIjtcbiAgfSB8IHtcbiAgICAvKipcbiAgICAgKiB3aGVuIHN1YnNjcmlwdGlvbiBwZXJtaXNzaW9uIGNoYW5nZWRcbiAgICAgKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogbGl2ZWtpdC5TdWJzY3JpcHRpb25QZXJtaXNzaW9uVXBkYXRlIHN1YnNjcmlwdGlvbl9wZXJtaXNzaW9uX3VwZGF0ZSA9IDE1O1xuICAgICAqL1xuICAgIHZhbHVlOiBTdWJzY3JpcHRpb25QZXJtaXNzaW9uVXBkYXRlO1xuICAgIGNhc2U6IFwic3Vic2NyaXB0aW9uUGVybWlzc2lvblVwZGF0ZVwiO1xuICB9IHwge1xuICAgIC8qKlxuICAgICAqIHVwZGF0ZSB0aGUgdG9rZW4gdGhlIGNsaWVudCB3YXMgdXNpbmcsIHRvIHByZXZlbnQgYW4gYWN0aXZlIGNsaWVudCBmcm9tIHVzaW5nIGFuIGV4cGlyZWQgdG9rZW5cbiAgICAgKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogc3RyaW5nIHJlZnJlc2hfdG9rZW4gPSAxNjtcbiAgICAgKi9cbiAgICB2YWx1ZTogc3RyaW5nO1xuICAgIGNhc2U6IFwicmVmcmVzaFRva2VuXCI7XG4gIH0gfCB7XG4gICAgLyoqXG4gICAgICogc2VydmVyIGluaXRpYXRlZCB0cmFjayB1bnB1Ymxpc2hcbiAgICAgKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogbGl2ZWtpdC5UcmFja1VucHVibGlzaGVkUmVzcG9uc2UgdHJhY2tfdW5wdWJsaXNoZWQgPSAxNztcbiAgICAgKi9cbiAgICB2YWx1ZTogVHJhY2tVbnB1Ymxpc2hlZFJlc3BvbnNlO1xuICAgIGNhc2U6IFwidHJhY2tVbnB1Ymxpc2hlZFwiO1xuICB9IHwge1xuICAgIC8qKlxuICAgICAqIHJlc3BvbmQgdG8gcGluZ1xuICAgICAqXG4gICAgICogZGVwcmVjYXRlZCBieSBwb25nX3Jlc3AgKG1lc3NhZ2UgUG9uZylcbiAgICAgKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogaW50NjQgcG9uZyA9IDE4O1xuICAgICAqL1xuICAgIHZhbHVlOiBiaWdpbnQ7XG4gICAgY2FzZTogXCJwb25nXCI7XG4gIH0gfCB7XG4gICAgLyoqXG4gICAgICogc2VudCB3aGVuIGNsaWVudCByZWNvbm5lY3RzXG4gICAgICpcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGxpdmVraXQuUmVjb25uZWN0UmVzcG9uc2UgcmVjb25uZWN0ID0gMTk7XG4gICAgICovXG4gICAgdmFsdWU6IFJlY29ubmVjdFJlc3BvbnNlO1xuICAgIGNhc2U6IFwicmVjb25uZWN0XCI7XG4gIH0gfCB7XG4gICAgLyoqXG4gICAgICogcmVzcG9uZCB0byBQaW5nXG4gICAgICpcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGxpdmVraXQuUG9uZyBwb25nX3Jlc3AgPSAyMDtcbiAgICAgKi9cbiAgICB2YWx1ZTogUG9uZztcbiAgICBjYXNlOiBcInBvbmdSZXNwXCI7XG4gIH0gfCB7XG4gICAgLyoqXG4gICAgICogU3Vic2NyaXB0aW9uIHJlc3BvbnNlLCBjbGllbnQgc2hvdWxkIG5vdCBleHBlY3QgYW55IG1lZGlhIGZyb20gdGhpcyBzdWJzY3JpcHRpb24gaWYgaXQgZmFpbHNcbiAgICAgKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogbGl2ZWtpdC5TdWJzY3JpcHRpb25SZXNwb25zZSBzdWJzY3JpcHRpb25fcmVzcG9uc2UgPSAyMTtcbiAgICAgKi9cbiAgICB2YWx1ZTogU3Vic2NyaXB0aW9uUmVzcG9uc2U7XG4gICAgY2FzZTogXCJzdWJzY3JpcHRpb25SZXNwb25zZVwiO1xuICB9IHwgeyBjYXNlOiB1bmRlZmluZWQ7IHZhbHVlPzogdW5kZWZpbmVkIH0gPSB7IGNhc2U6IHVuZGVmaW5lZCB9O1xuXG4gIGNvbnN0cnVjdG9yKGRhdGE/OiBQYXJ0aWFsTWVzc2FnZTxTaWduYWxSZXNwb25zZT4pIHtcbiAgICBzdXBlcigpO1xuICAgIHByb3RvMy51dGlsLmluaXRQYXJ0aWFsKGRhdGEsIHRoaXMpO1xuICB9XG5cbiAgc3RhdGljIHJlYWRvbmx5IHJ1bnRpbWU6IHR5cGVvZiBwcm90bzMgPSBwcm90bzM7XG4gIHN0YXRpYyByZWFkb25seSB0eXBlTmFtZSA9IFwibGl2ZWtpdC5TaWduYWxSZXNwb25zZVwiO1xuICBzdGF0aWMgcmVhZG9ubHkgZmllbGRzOiBGaWVsZExpc3QgPSBwcm90bzMudXRpbC5uZXdGaWVsZExpc3QoKCkgPT4gW1xuICAgIHsgbm86IDEsIG5hbWU6IFwiam9pblwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogSm9pblJlc3BvbnNlLCBvbmVvZjogXCJtZXNzYWdlXCIgfSxcbiAgICB7IG5vOiAyLCBuYW1lOiBcImFuc3dlclwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogU2Vzc2lvbkRlc2NyaXB0aW9uLCBvbmVvZjogXCJtZXNzYWdlXCIgfSxcbiAgICB7IG5vOiAzLCBuYW1lOiBcIm9mZmVyXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBTZXNzaW9uRGVzY3JpcHRpb24sIG9uZW9mOiBcIm1lc3NhZ2VcIiB9LFxuICAgIHsgbm86IDQsIG5hbWU6IFwidHJpY2tsZVwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogVHJpY2tsZVJlcXVlc3QsIG9uZW9mOiBcIm1lc3NhZ2VcIiB9LFxuICAgIHsgbm86IDUsIG5hbWU6IFwidXBkYXRlXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBQYXJ0aWNpcGFudFVwZGF0ZSwgb25lb2Y6IFwibWVzc2FnZVwiIH0sXG4gICAgeyBubzogNiwgbmFtZTogXCJ0cmFja19wdWJsaXNoZWRcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFRyYWNrUHVibGlzaGVkUmVzcG9uc2UsIG9uZW9mOiBcIm1lc3NhZ2VcIiB9LFxuICAgIHsgbm86IDgsIG5hbWU6IFwibGVhdmVcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IExlYXZlUmVxdWVzdCwgb25lb2Y6IFwibWVzc2FnZVwiIH0sXG4gICAgeyBubzogOSwgbmFtZTogXCJtdXRlXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBNdXRlVHJhY2tSZXF1ZXN0LCBvbmVvZjogXCJtZXNzYWdlXCIgfSxcbiAgICB7IG5vOiAxMCwgbmFtZTogXCJzcGVha2Vyc19jaGFuZ2VkXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBTcGVha2Vyc0NoYW5nZWQsIG9uZW9mOiBcIm1lc3NhZ2VcIiB9LFxuICAgIHsgbm86IDExLCBuYW1lOiBcInJvb21fdXBkYXRlXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBSb29tVXBkYXRlLCBvbmVvZjogXCJtZXNzYWdlXCIgfSxcbiAgICB7IG5vOiAxMiwgbmFtZTogXCJjb25uZWN0aW9uX3F1YWxpdHlcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IENvbm5lY3Rpb25RdWFsaXR5VXBkYXRlLCBvbmVvZjogXCJtZXNzYWdlXCIgfSxcbiAgICB7IG5vOiAxMywgbmFtZTogXCJzdHJlYW1fc3RhdGVfdXBkYXRlXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBTdHJlYW1TdGF0ZVVwZGF0ZSwgb25lb2Y6IFwibWVzc2FnZVwiIH0sXG4gICAgeyBubzogMTQsIG5hbWU6IFwic3Vic2NyaWJlZF9xdWFsaXR5X3VwZGF0ZVwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogU3Vic2NyaWJlZFF1YWxpdHlVcGRhdGUsIG9uZW9mOiBcIm1lc3NhZ2VcIiB9LFxuICAgIHsgbm86IDE1LCBuYW1lOiBcInN1YnNjcmlwdGlvbl9wZXJtaXNzaW9uX3VwZGF0ZVwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogU3Vic2NyaXB0aW9uUGVybWlzc2lvblVwZGF0ZSwgb25lb2Y6IFwibWVzc2FnZVwiIH0sXG4gICAgeyBubzogMTYsIG5hbWU6IFwicmVmcmVzaF90b2tlblwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovLCBvbmVvZjogXCJtZXNzYWdlXCIgfSxcbiAgICB7IG5vOiAxNywgbmFtZTogXCJ0cmFja191bnB1Ymxpc2hlZFwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogVHJhY2tVbnB1Ymxpc2hlZFJlc3BvbnNlLCBvbmVvZjogXCJtZXNzYWdlXCIgfSxcbiAgICB7IG5vOiAxOCwgbmFtZTogXCJwb25nXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDMgLyogU2NhbGFyVHlwZS5JTlQ2NCAqLywgb25lb2Y6IFwibWVzc2FnZVwiIH0sXG4gICAgeyBubzogMTksIG5hbWU6IFwicmVjb25uZWN0XCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBSZWNvbm5lY3RSZXNwb25zZSwgb25lb2Y6IFwibWVzc2FnZVwiIH0sXG4gICAgeyBubzogMjAsIG5hbWU6IFwicG9uZ19yZXNwXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBQb25nLCBvbmVvZjogXCJtZXNzYWdlXCIgfSxcbiAgICB7IG5vOiAyMSwgbmFtZTogXCJzdWJzY3JpcHRpb25fcmVzcG9uc2VcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFN1YnNjcmlwdGlvblJlc3BvbnNlLCBvbmVvZjogXCJtZXNzYWdlXCIgfSxcbiAgXSk7XG5cbiAgc3RhdGljIGZyb21CaW5hcnkoYnl0ZXM6IFVpbnQ4QXJyYXksIG9wdGlvbnM/OiBQYXJ0aWFsPEJpbmFyeVJlYWRPcHRpb25zPik6IFNpZ25hbFJlc3BvbnNlIHtcbiAgICByZXR1cm4gbmV3IFNpZ25hbFJlc3BvbnNlKCkuZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucyk7XG4gIH1cblxuICBzdGF0aWMgZnJvbUpzb24oanNvblZhbHVlOiBKc29uVmFsdWUsIG9wdGlvbnM/OiBQYXJ0aWFsPEpzb25SZWFkT3B0aW9ucz4pOiBTaWduYWxSZXNwb25zZSB7XG4gICAgcmV0dXJuIG5ldyBTaWduYWxSZXNwb25zZSgpLmZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucyk7XG4gIH1cblxuICBzdGF0aWMgZnJvbUpzb25TdHJpbmcoanNvblN0cmluZzogc3RyaW5nLCBvcHRpb25zPzogUGFydGlhbDxKc29uUmVhZE9wdGlvbnM+KTogU2lnbmFsUmVzcG9uc2Uge1xuICAgIHJldHVybiBuZXcgU2lnbmFsUmVzcG9uc2UoKS5mcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKTtcbiAgfVxuXG4gIHN0YXRpYyBlcXVhbHMoYTogU2lnbmFsUmVzcG9uc2UgfCBQbGFpbk1lc3NhZ2U8U2lnbmFsUmVzcG9uc2U+IHwgdW5kZWZpbmVkLCBiOiBTaWduYWxSZXNwb25zZSB8IFBsYWluTWVzc2FnZTxTaWduYWxSZXNwb25zZT4gfCB1bmRlZmluZWQpOiBib29sZWFuIHtcbiAgICByZXR1cm4gcHJvdG8zLnV0aWwuZXF1YWxzKFNpZ25hbFJlc3BvbnNlLCBhLCBiKTtcbiAgfVxufVxuXG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBtZXNzYWdlIGxpdmVraXQuU2ltdWxjYXN0Q29kZWNcbiAqL1xuZXhwb3J0IGNsYXNzIFNpbXVsY2FzdENvZGVjIGV4dGVuZHMgTWVzc2FnZTxTaW11bGNhc3RDb2RlYz4ge1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBzdHJpbmcgY29kZWMgPSAxO1xuICAgKi9cbiAgY29kZWMgPSBcIlwiO1xuXG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHN0cmluZyBjaWQgPSAyO1xuICAgKi9cbiAgY2lkID0gXCJcIjtcblxuICBjb25zdHJ1Y3RvcihkYXRhPzogUGFydGlhbE1lc3NhZ2U8U2ltdWxjYXN0Q29kZWM+KSB7XG4gICAgc3VwZXIoKTtcbiAgICBwcm90bzMudXRpbC5pbml0UGFydGlhbChkYXRhLCB0aGlzKTtcbiAgfVxuXG4gIHN0YXRpYyByZWFkb25seSBydW50aW1lOiB0eXBlb2YgcHJvdG8zID0gcHJvdG8zO1xuICBzdGF0aWMgcmVhZG9ubHkgdHlwZU5hbWUgPSBcImxpdmVraXQuU2ltdWxjYXN0Q29kZWNcIjtcbiAgc3RhdGljIHJlYWRvbmx5IGZpZWxkczogRmllbGRMaXN0ID0gcHJvdG8zLnV0aWwubmV3RmllbGRMaXN0KCgpID0+IFtcbiAgICB7IG5vOiAxLCBuYW1lOiBcImNvZGVjXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi8gfSxcbiAgICB7IG5vOiAyLCBuYW1lOiBcImNpZFwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovIH0sXG4gIF0pO1xuXG4gIHN0YXRpYyBmcm9tQmluYXJ5KGJ5dGVzOiBVaW50OEFycmF5LCBvcHRpb25zPzogUGFydGlhbDxCaW5hcnlSZWFkT3B0aW9ucz4pOiBTaW11bGNhc3RDb2RlYyB7XG4gICAgcmV0dXJuIG5ldyBTaW11bGNhc3RDb2RlYygpLmZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpO1xuICB9XG5cbiAgc3RhdGljIGZyb21Kc29uKGpzb25WYWx1ZTogSnNvblZhbHVlLCBvcHRpb25zPzogUGFydGlhbDxKc29uUmVhZE9wdGlvbnM+KTogU2ltdWxjYXN0Q29kZWMge1xuICAgIHJldHVybiBuZXcgU2ltdWxjYXN0Q29kZWMoKS5mcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpO1xuICB9XG5cbiAgc3RhdGljIGZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmc6IHN0cmluZywgb3B0aW9ucz86IFBhcnRpYWw8SnNvblJlYWRPcHRpb25zPik6IFNpbXVsY2FzdENvZGVjIHtcbiAgICByZXR1cm4gbmV3IFNpbXVsY2FzdENvZGVjKCkuZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucyk7XG4gIH1cblxuICBzdGF0aWMgZXF1YWxzKGE6IFNpbXVsY2FzdENvZGVjIHwgUGxhaW5NZXNzYWdlPFNpbXVsY2FzdENvZGVjPiB8IHVuZGVmaW5lZCwgYjogU2ltdWxjYXN0Q29kZWMgfCBQbGFpbk1lc3NhZ2U8U2ltdWxjYXN0Q29kZWM+IHwgdW5kZWZpbmVkKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHByb3RvMy51dGlsLmVxdWFscyhTaW11bGNhc3RDb2RlYywgYSwgYik7XG4gIH1cbn1cblxuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBsaXZla2l0LkFkZFRyYWNrUmVxdWVzdFxuICovXG5leHBvcnQgY2xhc3MgQWRkVHJhY2tSZXF1ZXN0IGV4dGVuZHMgTWVzc2FnZTxBZGRUcmFja1JlcXVlc3Q+IHtcbiAgLyoqXG4gICAqIGNsaWVudCBJRCBvZiB0cmFjaywgdG8gbWF0Y2ggaXQgd2hlbiBSVEMgdHJhY2sgaXMgcmVjZWl2ZWRcbiAgICpcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBzdHJpbmcgY2lkID0gMTtcbiAgICovXG4gIGNpZCA9IFwiXCI7XG5cbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogc3RyaW5nIG5hbWUgPSAyO1xuICAgKi9cbiAgbmFtZSA9IFwiXCI7XG5cbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogbGl2ZWtpdC5UcmFja1R5cGUgdHlwZSA9IDM7XG4gICAqL1xuICB0eXBlID0gVHJhY2tUeXBlLkFVRElPO1xuXG4gIC8qKlxuICAgKiB0byBiZSBkZXByZWNhdGVkIGluIGZhdm9yIG9mIGxheWVyc1xuICAgKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHVpbnQzMiB3aWR0aCA9IDQ7XG4gICAqL1xuICB3aWR0aCA9IDA7XG5cbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogdWludDMyIGhlaWdodCA9IDU7XG4gICAqL1xuICBoZWlnaHQgPSAwO1xuXG4gIC8qKlxuICAgKiB0cnVlIHRvIGFkZCB0cmFjayBhbmQgaW5pdGlhbGl6ZSB0byBtdXRlZFxuICAgKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGJvb2wgbXV0ZWQgPSA2O1xuICAgKi9cbiAgbXV0ZWQgPSBmYWxzZTtcblxuICAvKipcbiAgICogdHJ1ZSBpZiBEVFggKERpc2NvbnRpbnVvdXMgVHJhbnNtaXNzaW9uKSBpcyBkaXNhYmxlZCBmb3IgYXVkaW9cbiAgICpcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBib29sIGRpc2FibGVfZHR4ID0gNztcbiAgICovXG4gIGRpc2FibGVEdHggPSBmYWxzZTtcblxuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBsaXZla2l0LlRyYWNrU291cmNlIHNvdXJjZSA9IDg7XG4gICAqL1xuICBzb3VyY2UgPSBUcmFja1NvdXJjZS5VTktOT1dOO1xuXG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHJlcGVhdGVkIGxpdmVraXQuVmlkZW9MYXllciBsYXllcnMgPSA5O1xuICAgKi9cbiAgbGF5ZXJzOiBWaWRlb0xheWVyW10gPSBbXTtcblxuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiByZXBlYXRlZCBsaXZla2l0LlNpbXVsY2FzdENvZGVjIHNpbXVsY2FzdF9jb2RlY3MgPSAxMDtcbiAgICovXG4gIHNpbXVsY2FzdENvZGVjczogU2ltdWxjYXN0Q29kZWNbXSA9IFtdO1xuXG4gIC8qKlxuICAgKiBzZXJ2ZXIgSUQgb2YgdHJhY2ssIHB1Ymxpc2ggbmV3IGNvZGVjIHRvIGV4aXN0IHRyYWNrXG4gICAqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogc3RyaW5nIHNpZCA9IDExO1xuICAgKi9cbiAgc2lkID0gXCJcIjtcblxuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBib29sIHN0ZXJlbyA9IDEyO1xuICAgKi9cbiAgc3RlcmVvID0gZmFsc2U7XG5cbiAgLyoqXG4gICAqIHRydWUgaWYgUkVEIChSZWR1bmRhbnQgRW5jb2RpbmcpIGlzIGRpc2FibGVkIGZvciBhdWRpb1xuICAgKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGJvb2wgZGlzYWJsZV9yZWQgPSAxMztcbiAgICovXG4gIGRpc2FibGVSZWQgPSBmYWxzZTtcblxuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBsaXZla2l0LkVuY3J5cHRpb24uVHlwZSBlbmNyeXB0aW9uID0gMTQ7XG4gICAqL1xuICBlbmNyeXB0aW9uID0gRW5jcnlwdGlvbl9UeXBlLk5PTkU7XG5cbiAgLyoqXG4gICAqIHdoaWNoIHN0cmVhbSB0aGUgdHJhY2sgYmVsb25ncyB0bywgdXNlZCB0byBncm91cCB0cmFja3MgdG9nZXRoZXIuXG4gICAqIGlmIG5vdCBzcGVjaWZpZWQsIHNlcnZlciB3aWxsIGluZmVyIGl0IGZyb20gdHJhY2sgc291cmNlIHRvIGJ1bmRsZSBjYW1lcmEvbWljcm9waG9uZSwgc2NyZWVuc2hhcmUvYXVkaW8gdG9nZXRoZXJcbiAgICpcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBzdHJpbmcgc3RyZWFtID0gMTU7XG4gICAqL1xuICBzdHJlYW0gPSBcIlwiO1xuXG4gIGNvbnN0cnVjdG9yKGRhdGE/OiBQYXJ0aWFsTWVzc2FnZTxBZGRUcmFja1JlcXVlc3Q+KSB7XG4gICAgc3VwZXIoKTtcbiAgICBwcm90bzMudXRpbC5pbml0UGFydGlhbChkYXRhLCB0aGlzKTtcbiAgfVxuXG4gIHN0YXRpYyByZWFkb25seSBydW50aW1lOiB0eXBlb2YgcHJvdG8zID0gcHJvdG8zO1xuICBzdGF0aWMgcmVhZG9ubHkgdHlwZU5hbWUgPSBcImxpdmVraXQuQWRkVHJhY2tSZXF1ZXN0XCI7XG4gIHN0YXRpYyByZWFkb25seSBmaWVsZHM6IEZpZWxkTGlzdCA9IHByb3RvMy51dGlsLm5ld0ZpZWxkTGlzdCgoKSA9PiBbXG4gICAgeyBubzogMSwgbmFtZTogXCJjaWRcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqLyB9LFxuICAgIHsgbm86IDIsIG5hbWU6IFwibmFtZVwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovIH0sXG4gICAgeyBubzogMywgbmFtZTogXCJ0eXBlXCIsIGtpbmQ6IFwiZW51bVwiLCBUOiBwcm90bzMuZ2V0RW51bVR5cGUoVHJhY2tUeXBlKSB9LFxuICAgIHsgbm86IDQsIG5hbWU6IFwid2lkdGhcIiwga2luZDogXCJzY2FsYXJcIiwgVDogMTMgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi8gfSxcbiAgICB7IG5vOiA1LCBuYW1lOiBcImhlaWdodFwiLCBraW5kOiBcInNjYWxhclwiLCBUOiAxMyAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqLyB9LFxuICAgIHsgbm86IDYsIG5hbWU6IFwibXV0ZWRcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOCAvKiBTY2FsYXJUeXBlLkJPT0wgKi8gfSxcbiAgICB7IG5vOiA3LCBuYW1lOiBcImRpc2FibGVfZHR4XCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDggLyogU2NhbGFyVHlwZS5CT09MICovIH0sXG4gICAgeyBubzogOCwgbmFtZTogXCJzb3VyY2VcIiwga2luZDogXCJlbnVtXCIsIFQ6IHByb3RvMy5nZXRFbnVtVHlwZShUcmFja1NvdXJjZSkgfSxcbiAgICB7IG5vOiA5LCBuYW1lOiBcImxheWVyc1wiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogVmlkZW9MYXllciwgcmVwZWF0ZWQ6IHRydWUgfSxcbiAgICB7IG5vOiAxMCwgbmFtZTogXCJzaW11bGNhc3RfY29kZWNzXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBTaW11bGNhc3RDb2RlYywgcmVwZWF0ZWQ6IHRydWUgfSxcbiAgICB7IG5vOiAxMSwgbmFtZTogXCJzaWRcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqLyB9LFxuICAgIHsgbm86IDEyLCBuYW1lOiBcInN0ZXJlb1wiLCBraW5kOiBcInNjYWxhclwiLCBUOiA4IC8qIFNjYWxhclR5cGUuQk9PTCAqLyB9LFxuICAgIHsgbm86IDEzLCBuYW1lOiBcImRpc2FibGVfcmVkXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDggLyogU2NhbGFyVHlwZS5CT09MICovIH0sXG4gICAgeyBubzogMTQsIG5hbWU6IFwiZW5jcnlwdGlvblwiLCBraW5kOiBcImVudW1cIiwgVDogcHJvdG8zLmdldEVudW1UeXBlKEVuY3J5cHRpb25fVHlwZSkgfSxcbiAgICB7IG5vOiAxNSwgbmFtZTogXCJzdHJlYW1cIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqLyB9LFxuICBdKTtcblxuICBzdGF0aWMgZnJvbUJpbmFyeShieXRlczogVWludDhBcnJheSwgb3B0aW9ucz86IFBhcnRpYWw8QmluYXJ5UmVhZE9wdGlvbnM+KTogQWRkVHJhY2tSZXF1ZXN0IHtcbiAgICByZXR1cm4gbmV3IEFkZFRyYWNrUmVxdWVzdCgpLmZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpO1xuICB9XG5cbiAgc3RhdGljIGZyb21Kc29uKGpzb25WYWx1ZTogSnNvblZhbHVlLCBvcHRpb25zPzogUGFydGlhbDxKc29uUmVhZE9wdGlvbnM+KTogQWRkVHJhY2tSZXF1ZXN0IHtcbiAgICByZXR1cm4gbmV3IEFkZFRyYWNrUmVxdWVzdCgpLmZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucyk7XG4gIH1cblxuICBzdGF0aWMgZnJvbUpzb25TdHJpbmcoanNvblN0cmluZzogc3RyaW5nLCBvcHRpb25zPzogUGFydGlhbDxKc29uUmVhZE9wdGlvbnM+KTogQWRkVHJhY2tSZXF1ZXN0IHtcbiAgICByZXR1cm4gbmV3IEFkZFRyYWNrUmVxdWVzdCgpLmZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpO1xuICB9XG5cbiAgc3RhdGljIGVxdWFscyhhOiBBZGRUcmFja1JlcXVlc3QgfCBQbGFpbk1lc3NhZ2U8QWRkVHJhY2tSZXF1ZXN0PiB8IHVuZGVmaW5lZCwgYjogQWRkVHJhY2tSZXF1ZXN0IHwgUGxhaW5NZXNzYWdlPEFkZFRyYWNrUmVxdWVzdD4gfCB1bmRlZmluZWQpOiBib29sZWFuIHtcbiAgICByZXR1cm4gcHJvdG8zLnV0aWwuZXF1YWxzKEFkZFRyYWNrUmVxdWVzdCwgYSwgYik7XG4gIH1cbn1cblxuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBsaXZla2l0LlRyaWNrbGVSZXF1ZXN0XG4gKi9cbmV4cG9ydCBjbGFzcyBUcmlja2xlUmVxdWVzdCBleHRlbmRzIE1lc3NhZ2U8VHJpY2tsZVJlcXVlc3Q+IHtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogc3RyaW5nIGNhbmRpZGF0ZUluaXQgPSAxO1xuICAgKi9cbiAgY2FuZGlkYXRlSW5pdCA9IFwiXCI7XG5cbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogbGl2ZWtpdC5TaWduYWxUYXJnZXQgdGFyZ2V0ID0gMjtcbiAgICovXG4gIHRhcmdldCA9IFNpZ25hbFRhcmdldC5QVUJMSVNIRVI7XG5cbiAgY29uc3RydWN0b3IoZGF0YT86IFBhcnRpYWxNZXNzYWdlPFRyaWNrbGVSZXF1ZXN0Pikge1xuICAgIHN1cGVyKCk7XG4gICAgcHJvdG8zLnV0aWwuaW5pdFBhcnRpYWwoZGF0YSwgdGhpcyk7XG4gIH1cblxuICBzdGF0aWMgcmVhZG9ubHkgcnVudGltZTogdHlwZW9mIHByb3RvMyA9IHByb3RvMztcbiAgc3RhdGljIHJlYWRvbmx5IHR5cGVOYW1lID0gXCJsaXZla2l0LlRyaWNrbGVSZXF1ZXN0XCI7XG4gIHN0YXRpYyByZWFkb25seSBmaWVsZHM6IEZpZWxkTGlzdCA9IHByb3RvMy51dGlsLm5ld0ZpZWxkTGlzdCgoKSA9PiBbXG4gICAgeyBubzogMSwgbmFtZTogXCJjYW5kaWRhdGVJbml0XCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi8gfSxcbiAgICB7IG5vOiAyLCBuYW1lOiBcInRhcmdldFwiLCBraW5kOiBcImVudW1cIiwgVDogcHJvdG8zLmdldEVudW1UeXBlKFNpZ25hbFRhcmdldCkgfSxcbiAgXSk7XG5cbiAgc3RhdGljIGZyb21CaW5hcnkoYnl0ZXM6IFVpbnQ4QXJyYXksIG9wdGlvbnM/OiBQYXJ0aWFsPEJpbmFyeVJlYWRPcHRpb25zPik6IFRyaWNrbGVSZXF1ZXN0IHtcbiAgICByZXR1cm4gbmV3IFRyaWNrbGVSZXF1ZXN0KCkuZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucyk7XG4gIH1cblxuICBzdGF0aWMgZnJvbUpzb24oanNvblZhbHVlOiBKc29uVmFsdWUsIG9wdGlvbnM/OiBQYXJ0aWFsPEpzb25SZWFkT3B0aW9ucz4pOiBUcmlja2xlUmVxdWVzdCB7XG4gICAgcmV0dXJuIG5ldyBUcmlja2xlUmVxdWVzdCgpLmZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucyk7XG4gIH1cblxuICBzdGF0aWMgZnJvbUpzb25TdHJpbmcoanNvblN0cmluZzogc3RyaW5nLCBvcHRpb25zPzogUGFydGlhbDxKc29uUmVhZE9wdGlvbnM+KTogVHJpY2tsZVJlcXVlc3Qge1xuICAgIHJldHVybiBuZXcgVHJpY2tsZVJlcXVlc3QoKS5mcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKTtcbiAgfVxuXG4gIHN0YXRpYyBlcXVhbHMoYTogVHJpY2tsZVJlcXVlc3QgfCBQbGFpbk1lc3NhZ2U8VHJpY2tsZVJlcXVlc3Q+IHwgdW5kZWZpbmVkLCBiOiBUcmlja2xlUmVxdWVzdCB8IFBsYWluTWVzc2FnZTxUcmlja2xlUmVxdWVzdD4gfCB1bmRlZmluZWQpOiBib29sZWFuIHtcbiAgICByZXR1cm4gcHJvdG8zLnV0aWwuZXF1YWxzKFRyaWNrbGVSZXF1ZXN0LCBhLCBiKTtcbiAgfVxufVxuXG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBtZXNzYWdlIGxpdmVraXQuTXV0ZVRyYWNrUmVxdWVzdFxuICovXG5leHBvcnQgY2xhc3MgTXV0ZVRyYWNrUmVxdWVzdCBleHRlbmRzIE1lc3NhZ2U8TXV0ZVRyYWNrUmVxdWVzdD4ge1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBzdHJpbmcgc2lkID0gMTtcbiAgICovXG4gIHNpZCA9IFwiXCI7XG5cbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogYm9vbCBtdXRlZCA9IDI7XG4gICAqL1xuICBtdXRlZCA9IGZhbHNlO1xuXG4gIGNvbnN0cnVjdG9yKGRhdGE/OiBQYXJ0aWFsTWVzc2FnZTxNdXRlVHJhY2tSZXF1ZXN0Pikge1xuICAgIHN1cGVyKCk7XG4gICAgcHJvdG8zLnV0aWwuaW5pdFBhcnRpYWwoZGF0YSwgdGhpcyk7XG4gIH1cblxuICBzdGF0aWMgcmVhZG9ubHkgcnVudGltZTogdHlwZW9mIHByb3RvMyA9IHByb3RvMztcbiAgc3RhdGljIHJlYWRvbmx5IHR5cGVOYW1lID0gXCJsaXZla2l0Lk11dGVUcmFja1JlcXVlc3RcIjtcbiAgc3RhdGljIHJlYWRvbmx5IGZpZWxkczogRmllbGRMaXN0ID0gcHJvdG8zLnV0aWwubmV3RmllbGRMaXN0KCgpID0+IFtcbiAgICB7IG5vOiAxLCBuYW1lOiBcInNpZFwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovIH0sXG4gICAgeyBubzogMiwgbmFtZTogXCJtdXRlZFwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA4IC8qIFNjYWxhclR5cGUuQk9PTCAqLyB9LFxuICBdKTtcblxuICBzdGF0aWMgZnJvbUJpbmFyeShieXRlczogVWludDhBcnJheSwgb3B0aW9ucz86IFBhcnRpYWw8QmluYXJ5UmVhZE9wdGlvbnM+KTogTXV0ZVRyYWNrUmVxdWVzdCB7XG4gICAgcmV0dXJuIG5ldyBNdXRlVHJhY2tSZXF1ZXN0KCkuZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucyk7XG4gIH1cblxuICBzdGF0aWMgZnJvbUpzb24oanNvblZhbHVlOiBKc29uVmFsdWUsIG9wdGlvbnM/OiBQYXJ0aWFsPEpzb25SZWFkT3B0aW9ucz4pOiBNdXRlVHJhY2tSZXF1ZXN0IHtcbiAgICByZXR1cm4gbmV3IE11dGVUcmFja1JlcXVlc3QoKS5mcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpO1xuICB9XG5cbiAgc3RhdGljIGZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmc6IHN0cmluZywgb3B0aW9ucz86IFBhcnRpYWw8SnNvblJlYWRPcHRpb25zPik6IE11dGVUcmFja1JlcXVlc3Qge1xuICAgIHJldHVybiBuZXcgTXV0ZVRyYWNrUmVxdWVzdCgpLmZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpO1xuICB9XG5cbiAgc3RhdGljIGVxdWFscyhhOiBNdXRlVHJhY2tSZXF1ZXN0IHwgUGxhaW5NZXNzYWdlPE11dGVUcmFja1JlcXVlc3Q+IHwgdW5kZWZpbmVkLCBiOiBNdXRlVHJhY2tSZXF1ZXN0IHwgUGxhaW5NZXNzYWdlPE11dGVUcmFja1JlcXVlc3Q+IHwgdW5kZWZpbmVkKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHByb3RvMy51dGlsLmVxdWFscyhNdXRlVHJhY2tSZXF1ZXN0LCBhLCBiKTtcbiAgfVxufVxuXG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBtZXNzYWdlIGxpdmVraXQuSm9pblJlc3BvbnNlXG4gKi9cbmV4cG9ydCBjbGFzcyBKb2luUmVzcG9uc2UgZXh0ZW5kcyBNZXNzYWdlPEpvaW5SZXNwb25zZT4ge1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBsaXZla2l0LlJvb20gcm9vbSA9IDE7XG4gICAqL1xuICByb29tPzogUm9vbTtcblxuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBsaXZla2l0LlBhcnRpY2lwYW50SW5mbyBwYXJ0aWNpcGFudCA9IDI7XG4gICAqL1xuICBwYXJ0aWNpcGFudD86IFBhcnRpY2lwYW50SW5mbztcblxuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiByZXBlYXRlZCBsaXZla2l0LlBhcnRpY2lwYW50SW5mbyBvdGhlcl9wYXJ0aWNpcGFudHMgPSAzO1xuICAgKi9cbiAgb3RoZXJQYXJ0aWNpcGFudHM6IFBhcnRpY2lwYW50SW5mb1tdID0gW107XG5cbiAgLyoqXG4gICAqIGRlcHJlY2F0ZWQuIHVzZSBzZXJ2ZXJfaW5mby52ZXJzaW9uIGluc3RlYWQuXG4gICAqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogc3RyaW5nIHNlcnZlcl92ZXJzaW9uID0gNDtcbiAgICovXG4gIHNlcnZlclZlcnNpb24gPSBcIlwiO1xuXG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHJlcGVhdGVkIGxpdmVraXQuSUNFU2VydmVyIGljZV9zZXJ2ZXJzID0gNTtcbiAgICovXG4gIGljZVNlcnZlcnM6IElDRVNlcnZlcltdID0gW107XG5cbiAgLyoqXG4gICAqIHVzZSBzdWJzY3JpYmVyIGFzIHRoZSBwcmltYXJ5IFBlZXJDb25uZWN0aW9uXG4gICAqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogYm9vbCBzdWJzY3JpYmVyX3ByaW1hcnkgPSA2O1xuICAgKi9cbiAgc3Vic2NyaWJlclByaW1hcnkgPSBmYWxzZTtcblxuICAvKipcbiAgICogd2hlbiB0aGUgY3VycmVudCBzZXJ2ZXIgaXNuJ3QgYXZhaWxhYmxlLCByZXR1cm4gYWx0ZXJuYXRlIHVybCB0byByZXRyeSBjb25uZWN0aW9uXG4gICAqIHdoZW4gdGhpcyBpcyBzZXQsIHRoZSBvdGhlciBmaWVsZHMgd2lsbCBiZSBsYXJnZWx5IGVtcHR5XG4gICAqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogc3RyaW5nIGFsdGVybmF0aXZlX3VybCA9IDc7XG4gICAqL1xuICBhbHRlcm5hdGl2ZVVybCA9IFwiXCI7XG5cbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogbGl2ZWtpdC5DbGllbnRDb25maWd1cmF0aW9uIGNsaWVudF9jb25maWd1cmF0aW9uID0gODtcbiAgICovXG4gIGNsaWVudENvbmZpZ3VyYXRpb24/OiBDbGllbnRDb25maWd1cmF0aW9uO1xuXG4gIC8qKlxuICAgKiBkZXByZWNhdGVkLiB1c2Ugc2VydmVyX2luZm8ucmVnaW9uIGluc3RlYWQuXG4gICAqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogc3RyaW5nIHNlcnZlcl9yZWdpb24gPSA5O1xuICAgKi9cbiAgc2VydmVyUmVnaW9uID0gXCJcIjtcblxuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBpbnQzMiBwaW5nX3RpbWVvdXQgPSAxMDtcbiAgICovXG4gIHBpbmdUaW1lb3V0ID0gMDtcblxuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBpbnQzMiBwaW5nX2ludGVydmFsID0gMTE7XG4gICAqL1xuICBwaW5nSW50ZXJ2YWwgPSAwO1xuXG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGxpdmVraXQuU2VydmVySW5mbyBzZXJ2ZXJfaW5mbyA9IDEyO1xuICAgKi9cbiAgc2VydmVySW5mbz86IFNlcnZlckluZm87XG5cbiAgLyoqXG4gICAqIFNlcnZlci1JbmplY3RlZC1GcmFtZSBieXRlIHRyYWlsZXIsIHVzZWQgdG8gaWRlbnRpZnkgdW5lbmNyeXB0ZWQgZnJhbWVzIHdoZW4gZTJlZSBpcyBlbmFibGVkXG4gICAqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogYnl0ZXMgc2lmX3RyYWlsZXIgPSAxMztcbiAgICovXG4gIHNpZlRyYWlsZXIgPSBuZXcgVWludDhBcnJheSgwKTtcblxuICBjb25zdHJ1Y3RvcihkYXRhPzogUGFydGlhbE1lc3NhZ2U8Sm9pblJlc3BvbnNlPikge1xuICAgIHN1cGVyKCk7XG4gICAgcHJvdG8zLnV0aWwuaW5pdFBhcnRpYWwoZGF0YSwgdGhpcyk7XG4gIH1cblxuICBzdGF0aWMgcmVhZG9ubHkgcnVudGltZTogdHlwZW9mIHByb3RvMyA9IHByb3RvMztcbiAgc3RhdGljIHJlYWRvbmx5IHR5cGVOYW1lID0gXCJsaXZla2l0LkpvaW5SZXNwb25zZVwiO1xuICBzdGF0aWMgcmVhZG9ubHkgZmllbGRzOiBGaWVsZExpc3QgPSBwcm90bzMudXRpbC5uZXdGaWVsZExpc3QoKCkgPT4gW1xuICAgIHsgbm86IDEsIG5hbWU6IFwicm9vbVwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogUm9vbSB9LFxuICAgIHsgbm86IDIsIG5hbWU6IFwicGFydGljaXBhbnRcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFBhcnRpY2lwYW50SW5mbyB9LFxuICAgIHsgbm86IDMsIG5hbWU6IFwib3RoZXJfcGFydGljaXBhbnRzXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBQYXJ0aWNpcGFudEluZm8sIHJlcGVhdGVkOiB0cnVlIH0sXG4gICAgeyBubzogNCwgbmFtZTogXCJzZXJ2ZXJfdmVyc2lvblwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovIH0sXG4gICAgeyBubzogNSwgbmFtZTogXCJpY2Vfc2VydmVyc1wiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogSUNFU2VydmVyLCByZXBlYXRlZDogdHJ1ZSB9LFxuICAgIHsgbm86IDYsIG5hbWU6IFwic3Vic2NyaWJlcl9wcmltYXJ5XCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDggLyogU2NhbGFyVHlwZS5CT09MICovIH0sXG4gICAgeyBubzogNywgbmFtZTogXCJhbHRlcm5hdGl2ZV91cmxcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqLyB9LFxuICAgIHsgbm86IDgsIG5hbWU6IFwiY2xpZW50X2NvbmZpZ3VyYXRpb25cIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IENsaWVudENvbmZpZ3VyYXRpb24gfSxcbiAgICB7IG5vOiA5LCBuYW1lOiBcInNlcnZlcl9yZWdpb25cIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqLyB9LFxuICAgIHsgbm86IDEwLCBuYW1lOiBcInBpbmdfdGltZW91dFwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA1IC8qIFNjYWxhclR5cGUuSU5UMzIgKi8gfSxcbiAgICB7IG5vOiAxMSwgbmFtZTogXCJwaW5nX2ludGVydmFsXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDUgLyogU2NhbGFyVHlwZS5JTlQzMiAqLyB9LFxuICAgIHsgbm86IDEyLCBuYW1lOiBcInNlcnZlcl9pbmZvXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBTZXJ2ZXJJbmZvIH0sXG4gICAgeyBubzogMTMsIG5hbWU6IFwic2lmX3RyYWlsZXJcIiwga2luZDogXCJzY2FsYXJcIiwgVDogMTIgLyogU2NhbGFyVHlwZS5CWVRFUyAqLyB9LFxuICBdKTtcblxuICBzdGF0aWMgZnJvbUJpbmFyeShieXRlczogVWludDhBcnJheSwgb3B0aW9ucz86IFBhcnRpYWw8QmluYXJ5UmVhZE9wdGlvbnM+KTogSm9pblJlc3BvbnNlIHtcbiAgICByZXR1cm4gbmV3IEpvaW5SZXNwb25zZSgpLmZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpO1xuICB9XG5cbiAgc3RhdGljIGZyb21Kc29uKGpzb25WYWx1ZTogSnNvblZhbHVlLCBvcHRpb25zPzogUGFydGlhbDxKc29uUmVhZE9wdGlvbnM+KTogSm9pblJlc3BvbnNlIHtcbiAgICByZXR1cm4gbmV3IEpvaW5SZXNwb25zZSgpLmZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucyk7XG4gIH1cblxuICBzdGF0aWMgZnJvbUpzb25TdHJpbmcoanNvblN0cmluZzogc3RyaW5nLCBvcHRpb25zPzogUGFydGlhbDxKc29uUmVhZE9wdGlvbnM+KTogSm9pblJlc3BvbnNlIHtcbiAgICByZXR1cm4gbmV3IEpvaW5SZXNwb25zZSgpLmZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpO1xuICB9XG5cbiAgc3RhdGljIGVxdWFscyhhOiBKb2luUmVzcG9uc2UgfCBQbGFpbk1lc3NhZ2U8Sm9pblJlc3BvbnNlPiB8IHVuZGVmaW5lZCwgYjogSm9pblJlc3BvbnNlIHwgUGxhaW5NZXNzYWdlPEpvaW5SZXNwb25zZT4gfCB1bmRlZmluZWQpOiBib29sZWFuIHtcbiAgICByZXR1cm4gcHJvdG8zLnV0aWwuZXF1YWxzKEpvaW5SZXNwb25zZSwgYSwgYik7XG4gIH1cbn1cblxuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBsaXZla2l0LlJlY29ubmVjdFJlc3BvbnNlXG4gKi9cbmV4cG9ydCBjbGFzcyBSZWNvbm5lY3RSZXNwb25zZSBleHRlbmRzIE1lc3NhZ2U8UmVjb25uZWN0UmVzcG9uc2U+IHtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogcmVwZWF0ZWQgbGl2ZWtpdC5JQ0VTZXJ2ZXIgaWNlX3NlcnZlcnMgPSAxO1xuICAgKi9cbiAgaWNlU2VydmVyczogSUNFU2VydmVyW10gPSBbXTtcblxuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBsaXZla2l0LkNsaWVudENvbmZpZ3VyYXRpb24gY2xpZW50X2NvbmZpZ3VyYXRpb24gPSAyO1xuICAgKi9cbiAgY2xpZW50Q29uZmlndXJhdGlvbj86IENsaWVudENvbmZpZ3VyYXRpb247XG5cbiAgY29uc3RydWN0b3IoZGF0YT86IFBhcnRpYWxNZXNzYWdlPFJlY29ubmVjdFJlc3BvbnNlPikge1xuICAgIHN1cGVyKCk7XG4gICAgcHJvdG8zLnV0aWwuaW5pdFBhcnRpYWwoZGF0YSwgdGhpcyk7XG4gIH1cblxuICBzdGF0aWMgcmVhZG9ubHkgcnVudGltZTogdHlwZW9mIHByb3RvMyA9IHByb3RvMztcbiAgc3RhdGljIHJlYWRvbmx5IHR5cGVOYW1lID0gXCJsaXZla2l0LlJlY29ubmVjdFJlc3BvbnNlXCI7XG4gIHN0YXRpYyByZWFkb25seSBmaWVsZHM6IEZpZWxkTGlzdCA9IHByb3RvMy51dGlsLm5ld0ZpZWxkTGlzdCgoKSA9PiBbXG4gICAgeyBubzogMSwgbmFtZTogXCJpY2Vfc2VydmVyc1wiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogSUNFU2VydmVyLCByZXBlYXRlZDogdHJ1ZSB9LFxuICAgIHsgbm86IDIsIG5hbWU6IFwiY2xpZW50X2NvbmZpZ3VyYXRpb25cIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IENsaWVudENvbmZpZ3VyYXRpb24gfSxcbiAgXSk7XG5cbiAgc3RhdGljIGZyb21CaW5hcnkoYnl0ZXM6IFVpbnQ4QXJyYXksIG9wdGlvbnM/OiBQYXJ0aWFsPEJpbmFyeVJlYWRPcHRpb25zPik6IFJlY29ubmVjdFJlc3BvbnNlIHtcbiAgICByZXR1cm4gbmV3IFJlY29ubmVjdFJlc3BvbnNlKCkuZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucyk7XG4gIH1cblxuICBzdGF0aWMgZnJvbUpzb24oanNvblZhbHVlOiBKc29uVmFsdWUsIG9wdGlvbnM/OiBQYXJ0aWFsPEpzb25SZWFkT3B0aW9ucz4pOiBSZWNvbm5lY3RSZXNwb25zZSB7XG4gICAgcmV0dXJuIG5ldyBSZWNvbm5lY3RSZXNwb25zZSgpLmZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucyk7XG4gIH1cblxuICBzdGF0aWMgZnJvbUpzb25TdHJpbmcoanNvblN0cmluZzogc3RyaW5nLCBvcHRpb25zPzogUGFydGlhbDxKc29uUmVhZE9wdGlvbnM+KTogUmVjb25uZWN0UmVzcG9uc2Uge1xuICAgIHJldHVybiBuZXcgUmVjb25uZWN0UmVzcG9uc2UoKS5mcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKTtcbiAgfVxuXG4gIHN0YXRpYyBlcXVhbHMoYTogUmVjb25uZWN0UmVzcG9uc2UgfCBQbGFpbk1lc3NhZ2U8UmVjb25uZWN0UmVzcG9uc2U+IHwgdW5kZWZpbmVkLCBiOiBSZWNvbm5lY3RSZXNwb25zZSB8IFBsYWluTWVzc2FnZTxSZWNvbm5lY3RSZXNwb25zZT4gfCB1bmRlZmluZWQpOiBib29sZWFuIHtcbiAgICByZXR1cm4gcHJvdG8zLnV0aWwuZXF1YWxzKFJlY29ubmVjdFJlc3BvbnNlLCBhLCBiKTtcbiAgfVxufVxuXG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBtZXNzYWdlIGxpdmVraXQuVHJhY2tQdWJsaXNoZWRSZXNwb25zZVxuICovXG5leHBvcnQgY2xhc3MgVHJhY2tQdWJsaXNoZWRSZXNwb25zZSBleHRlbmRzIE1lc3NhZ2U8VHJhY2tQdWJsaXNoZWRSZXNwb25zZT4ge1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBzdHJpbmcgY2lkID0gMTtcbiAgICovXG4gIGNpZCA9IFwiXCI7XG5cbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogbGl2ZWtpdC5UcmFja0luZm8gdHJhY2sgPSAyO1xuICAgKi9cbiAgdHJhY2s/OiBUcmFja0luZm87XG5cbiAgY29uc3RydWN0b3IoZGF0YT86IFBhcnRpYWxNZXNzYWdlPFRyYWNrUHVibGlzaGVkUmVzcG9uc2U+KSB7XG4gICAgc3VwZXIoKTtcbiAgICBwcm90bzMudXRpbC5pbml0UGFydGlhbChkYXRhLCB0aGlzKTtcbiAgfVxuXG4gIHN0YXRpYyByZWFkb25seSBydW50aW1lOiB0eXBlb2YgcHJvdG8zID0gcHJvdG8zO1xuICBzdGF0aWMgcmVhZG9ubHkgdHlwZU5hbWUgPSBcImxpdmVraXQuVHJhY2tQdWJsaXNoZWRSZXNwb25zZVwiO1xuICBzdGF0aWMgcmVhZG9ubHkgZmllbGRzOiBGaWVsZExpc3QgPSBwcm90bzMudXRpbC5uZXdGaWVsZExpc3QoKCkgPT4gW1xuICAgIHsgbm86IDEsIG5hbWU6IFwiY2lkXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi8gfSxcbiAgICB7IG5vOiAyLCBuYW1lOiBcInRyYWNrXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBUcmFja0luZm8gfSxcbiAgXSk7XG5cbiAgc3RhdGljIGZyb21CaW5hcnkoYnl0ZXM6IFVpbnQ4QXJyYXksIG9wdGlvbnM/OiBQYXJ0aWFsPEJpbmFyeVJlYWRPcHRpb25zPik6IFRyYWNrUHVibGlzaGVkUmVzcG9uc2Uge1xuICAgIHJldHVybiBuZXcgVHJhY2tQdWJsaXNoZWRSZXNwb25zZSgpLmZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpO1xuICB9XG5cbiAgc3RhdGljIGZyb21Kc29uKGpzb25WYWx1ZTogSnNvblZhbHVlLCBvcHRpb25zPzogUGFydGlhbDxKc29uUmVhZE9wdGlvbnM+KTogVHJhY2tQdWJsaXNoZWRSZXNwb25zZSB7XG4gICAgcmV0dXJuIG5ldyBUcmFja1B1Ymxpc2hlZFJlc3BvbnNlKCkuZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tSnNvblN0cmluZyhqc29uU3RyaW5nOiBzdHJpbmcsIG9wdGlvbnM/OiBQYXJ0aWFsPEpzb25SZWFkT3B0aW9ucz4pOiBUcmFja1B1Ymxpc2hlZFJlc3BvbnNlIHtcbiAgICByZXR1cm4gbmV3IFRyYWNrUHVibGlzaGVkUmVzcG9uc2UoKS5mcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKTtcbiAgfVxuXG4gIHN0YXRpYyBlcXVhbHMoYTogVHJhY2tQdWJsaXNoZWRSZXNwb25zZSB8IFBsYWluTWVzc2FnZTxUcmFja1B1Ymxpc2hlZFJlc3BvbnNlPiB8IHVuZGVmaW5lZCwgYjogVHJhY2tQdWJsaXNoZWRSZXNwb25zZSB8IFBsYWluTWVzc2FnZTxUcmFja1B1Ymxpc2hlZFJlc3BvbnNlPiB8IHVuZGVmaW5lZCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBwcm90bzMudXRpbC5lcXVhbHMoVHJhY2tQdWJsaXNoZWRSZXNwb25zZSwgYSwgYik7XG4gIH1cbn1cblxuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBsaXZla2l0LlRyYWNrVW5wdWJsaXNoZWRSZXNwb25zZVxuICovXG5leHBvcnQgY2xhc3MgVHJhY2tVbnB1Ymxpc2hlZFJlc3BvbnNlIGV4dGVuZHMgTWVzc2FnZTxUcmFja1VucHVibGlzaGVkUmVzcG9uc2U+IHtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogc3RyaW5nIHRyYWNrX3NpZCA9IDE7XG4gICAqL1xuICB0cmFja1NpZCA9IFwiXCI7XG5cbiAgY29uc3RydWN0b3IoZGF0YT86IFBhcnRpYWxNZXNzYWdlPFRyYWNrVW5wdWJsaXNoZWRSZXNwb25zZT4pIHtcbiAgICBzdXBlcigpO1xuICAgIHByb3RvMy51dGlsLmluaXRQYXJ0aWFsKGRhdGEsIHRoaXMpO1xuICB9XG5cbiAgc3RhdGljIHJlYWRvbmx5IHJ1bnRpbWU6IHR5cGVvZiBwcm90bzMgPSBwcm90bzM7XG4gIHN0YXRpYyByZWFkb25seSB0eXBlTmFtZSA9IFwibGl2ZWtpdC5UcmFja1VucHVibGlzaGVkUmVzcG9uc2VcIjtcbiAgc3RhdGljIHJlYWRvbmx5IGZpZWxkczogRmllbGRMaXN0ID0gcHJvdG8zLnV0aWwubmV3RmllbGRMaXN0KCgpID0+IFtcbiAgICB7IG5vOiAxLCBuYW1lOiBcInRyYWNrX3NpZFwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovIH0sXG4gIF0pO1xuXG4gIHN0YXRpYyBmcm9tQmluYXJ5KGJ5dGVzOiBVaW50OEFycmF5LCBvcHRpb25zPzogUGFydGlhbDxCaW5hcnlSZWFkT3B0aW9ucz4pOiBUcmFja1VucHVibGlzaGVkUmVzcG9uc2Uge1xuICAgIHJldHVybiBuZXcgVHJhY2tVbnB1Ymxpc2hlZFJlc3BvbnNlKCkuZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucyk7XG4gIH1cblxuICBzdGF0aWMgZnJvbUpzb24oanNvblZhbHVlOiBKc29uVmFsdWUsIG9wdGlvbnM/OiBQYXJ0aWFsPEpzb25SZWFkT3B0aW9ucz4pOiBUcmFja1VucHVibGlzaGVkUmVzcG9uc2Uge1xuICAgIHJldHVybiBuZXcgVHJhY2tVbnB1Ymxpc2hlZFJlc3BvbnNlKCkuZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tSnNvblN0cmluZyhqc29uU3RyaW5nOiBzdHJpbmcsIG9wdGlvbnM/OiBQYXJ0aWFsPEpzb25SZWFkT3B0aW9ucz4pOiBUcmFja1VucHVibGlzaGVkUmVzcG9uc2Uge1xuICAgIHJldHVybiBuZXcgVHJhY2tVbnB1Ymxpc2hlZFJlc3BvbnNlKCkuZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucyk7XG4gIH1cblxuICBzdGF0aWMgZXF1YWxzKGE6IFRyYWNrVW5wdWJsaXNoZWRSZXNwb25zZSB8IFBsYWluTWVzc2FnZTxUcmFja1VucHVibGlzaGVkUmVzcG9uc2U+IHwgdW5kZWZpbmVkLCBiOiBUcmFja1VucHVibGlzaGVkUmVzcG9uc2UgfCBQbGFpbk1lc3NhZ2U8VHJhY2tVbnB1Ymxpc2hlZFJlc3BvbnNlPiB8IHVuZGVmaW5lZCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBwcm90bzMudXRpbC5lcXVhbHMoVHJhY2tVbnB1Ymxpc2hlZFJlc3BvbnNlLCBhLCBiKTtcbiAgfVxufVxuXG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBtZXNzYWdlIGxpdmVraXQuU2Vzc2lvbkRlc2NyaXB0aW9uXG4gKi9cbmV4cG9ydCBjbGFzcyBTZXNzaW9uRGVzY3JpcHRpb24gZXh0ZW5kcyBNZXNzYWdlPFNlc3Npb25EZXNjcmlwdGlvbj4ge1xuICAvKipcbiAgICogXCJhbnN3ZXJcIiB8IFwib2ZmZXJcIiB8IFwicHJhbnN3ZXJcIiB8IFwicm9sbGJhY2tcIlxuICAgKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHN0cmluZyB0eXBlID0gMTtcbiAgICovXG4gIHR5cGUgPSBcIlwiO1xuXG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHN0cmluZyBzZHAgPSAyO1xuICAgKi9cbiAgc2RwID0gXCJcIjtcblxuICBjb25zdHJ1Y3RvcihkYXRhPzogUGFydGlhbE1lc3NhZ2U8U2Vzc2lvbkRlc2NyaXB0aW9uPikge1xuICAgIHN1cGVyKCk7XG4gICAgcHJvdG8zLnV0aWwuaW5pdFBhcnRpYWwoZGF0YSwgdGhpcyk7XG4gIH1cblxuICBzdGF0aWMgcmVhZG9ubHkgcnVudGltZTogdHlwZW9mIHByb3RvMyA9IHByb3RvMztcbiAgc3RhdGljIHJlYWRvbmx5IHR5cGVOYW1lID0gXCJsaXZla2l0LlNlc3Npb25EZXNjcmlwdGlvblwiO1xuICBzdGF0aWMgcmVhZG9ubHkgZmllbGRzOiBGaWVsZExpc3QgPSBwcm90bzMudXRpbC5uZXdGaWVsZExpc3QoKCkgPT4gW1xuICAgIHsgbm86IDEsIG5hbWU6IFwidHlwZVwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovIH0sXG4gICAgeyBubzogMiwgbmFtZTogXCJzZHBcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqLyB9LFxuICBdKTtcblxuICBzdGF0aWMgZnJvbUJpbmFyeShieXRlczogVWludDhBcnJheSwgb3B0aW9ucz86IFBhcnRpYWw8QmluYXJ5UmVhZE9wdGlvbnM+KTogU2Vzc2lvbkRlc2NyaXB0aW9uIHtcbiAgICByZXR1cm4gbmV3IFNlc3Npb25EZXNjcmlwdGlvbigpLmZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpO1xuICB9XG5cbiAgc3RhdGljIGZyb21Kc29uKGpzb25WYWx1ZTogSnNvblZhbHVlLCBvcHRpb25zPzogUGFydGlhbDxKc29uUmVhZE9wdGlvbnM+KTogU2Vzc2lvbkRlc2NyaXB0aW9uIHtcbiAgICByZXR1cm4gbmV3IFNlc3Npb25EZXNjcmlwdGlvbigpLmZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucyk7XG4gIH1cblxuICBzdGF0aWMgZnJvbUpzb25TdHJpbmcoanNvblN0cmluZzogc3RyaW5nLCBvcHRpb25zPzogUGFydGlhbDxKc29uUmVhZE9wdGlvbnM+KTogU2Vzc2lvbkRlc2NyaXB0aW9uIHtcbiAgICByZXR1cm4gbmV3IFNlc3Npb25EZXNjcmlwdGlvbigpLmZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpO1xuICB9XG5cbiAgc3RhdGljIGVxdWFscyhhOiBTZXNzaW9uRGVzY3JpcHRpb24gfCBQbGFpbk1lc3NhZ2U8U2Vzc2lvbkRlc2NyaXB0aW9uPiB8IHVuZGVmaW5lZCwgYjogU2Vzc2lvbkRlc2NyaXB0aW9uIHwgUGxhaW5NZXNzYWdlPFNlc3Npb25EZXNjcmlwdGlvbj4gfCB1bmRlZmluZWQpOiBib29sZWFuIHtcbiAgICByZXR1cm4gcHJvdG8zLnV0aWwuZXF1YWxzKFNlc3Npb25EZXNjcmlwdGlvbiwgYSwgYik7XG4gIH1cbn1cblxuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBsaXZla2l0LlBhcnRpY2lwYW50VXBkYXRlXG4gKi9cbmV4cG9ydCBjbGFzcyBQYXJ0aWNpcGFudFVwZGF0ZSBleHRlbmRzIE1lc3NhZ2U8UGFydGljaXBhbnRVcGRhdGU+IHtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogcmVwZWF0ZWQgbGl2ZWtpdC5QYXJ0aWNpcGFudEluZm8gcGFydGljaXBhbnRzID0gMTtcbiAgICovXG4gIHBhcnRpY2lwYW50czogUGFydGljaXBhbnRJbmZvW10gPSBbXTtcblxuICBjb25zdHJ1Y3RvcihkYXRhPzogUGFydGlhbE1lc3NhZ2U8UGFydGljaXBhbnRVcGRhdGU+KSB7XG4gICAgc3VwZXIoKTtcbiAgICBwcm90bzMudXRpbC5pbml0UGFydGlhbChkYXRhLCB0aGlzKTtcbiAgfVxuXG4gIHN0YXRpYyByZWFkb25seSBydW50aW1lOiB0eXBlb2YgcHJvdG8zID0gcHJvdG8zO1xuICBzdGF0aWMgcmVhZG9ubHkgdHlwZU5hbWUgPSBcImxpdmVraXQuUGFydGljaXBhbnRVcGRhdGVcIjtcbiAgc3RhdGljIHJlYWRvbmx5IGZpZWxkczogRmllbGRMaXN0ID0gcHJvdG8zLnV0aWwubmV3RmllbGRMaXN0KCgpID0+IFtcbiAgICB7IG5vOiAxLCBuYW1lOiBcInBhcnRpY2lwYW50c1wiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogUGFydGljaXBhbnRJbmZvLCByZXBlYXRlZDogdHJ1ZSB9LFxuICBdKTtcblxuICBzdGF0aWMgZnJvbUJpbmFyeShieXRlczogVWludDhBcnJheSwgb3B0aW9ucz86IFBhcnRpYWw8QmluYXJ5UmVhZE9wdGlvbnM+KTogUGFydGljaXBhbnRVcGRhdGUge1xuICAgIHJldHVybiBuZXcgUGFydGljaXBhbnRVcGRhdGUoKS5mcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tSnNvbihqc29uVmFsdWU6IEpzb25WYWx1ZSwgb3B0aW9ucz86IFBhcnRpYWw8SnNvblJlYWRPcHRpb25zPik6IFBhcnRpY2lwYW50VXBkYXRlIHtcbiAgICByZXR1cm4gbmV3IFBhcnRpY2lwYW50VXBkYXRlKCkuZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tSnNvblN0cmluZyhqc29uU3RyaW5nOiBzdHJpbmcsIG9wdGlvbnM/OiBQYXJ0aWFsPEpzb25SZWFkT3B0aW9ucz4pOiBQYXJ0aWNpcGFudFVwZGF0ZSB7XG4gICAgcmV0dXJuIG5ldyBQYXJ0aWNpcGFudFVwZGF0ZSgpLmZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpO1xuICB9XG5cbiAgc3RhdGljIGVxdWFscyhhOiBQYXJ0aWNpcGFudFVwZGF0ZSB8IFBsYWluTWVzc2FnZTxQYXJ0aWNpcGFudFVwZGF0ZT4gfCB1bmRlZmluZWQsIGI6IFBhcnRpY2lwYW50VXBkYXRlIHwgUGxhaW5NZXNzYWdlPFBhcnRpY2lwYW50VXBkYXRlPiB8IHVuZGVmaW5lZCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBwcm90bzMudXRpbC5lcXVhbHMoUGFydGljaXBhbnRVcGRhdGUsIGEsIGIpO1xuICB9XG59XG5cbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgbGl2ZWtpdC5VcGRhdGVTdWJzY3JpcHRpb25cbiAqL1xuZXhwb3J0IGNsYXNzIFVwZGF0ZVN1YnNjcmlwdGlvbiBleHRlbmRzIE1lc3NhZ2U8VXBkYXRlU3Vic2NyaXB0aW9uPiB7XG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHJlcGVhdGVkIHN0cmluZyB0cmFja19zaWRzID0gMTtcbiAgICovXG4gIHRyYWNrU2lkczogc3RyaW5nW10gPSBbXTtcblxuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBib29sIHN1YnNjcmliZSA9IDI7XG4gICAqL1xuICBzdWJzY3JpYmUgPSBmYWxzZTtcblxuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiByZXBlYXRlZCBsaXZla2l0LlBhcnRpY2lwYW50VHJhY2tzIHBhcnRpY2lwYW50X3RyYWNrcyA9IDM7XG4gICAqL1xuICBwYXJ0aWNpcGFudFRyYWNrczogUGFydGljaXBhbnRUcmFja3NbXSA9IFtdO1xuXG4gIGNvbnN0cnVjdG9yKGRhdGE/OiBQYXJ0aWFsTWVzc2FnZTxVcGRhdGVTdWJzY3JpcHRpb24+KSB7XG4gICAgc3VwZXIoKTtcbiAgICBwcm90bzMudXRpbC5pbml0UGFydGlhbChkYXRhLCB0aGlzKTtcbiAgfVxuXG4gIHN0YXRpYyByZWFkb25seSBydW50aW1lOiB0eXBlb2YgcHJvdG8zID0gcHJvdG8zO1xuICBzdGF0aWMgcmVhZG9ubHkgdHlwZU5hbWUgPSBcImxpdmVraXQuVXBkYXRlU3Vic2NyaXB0aW9uXCI7XG4gIHN0YXRpYyByZWFkb25seSBmaWVsZHM6IEZpZWxkTGlzdCA9IHByb3RvMy51dGlsLm5ld0ZpZWxkTGlzdCgoKSA9PiBbXG4gICAgeyBubzogMSwgbmFtZTogXCJ0cmFja19zaWRzXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi8sIHJlcGVhdGVkOiB0cnVlIH0sXG4gICAgeyBubzogMiwgbmFtZTogXCJzdWJzY3JpYmVcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOCAvKiBTY2FsYXJUeXBlLkJPT0wgKi8gfSxcbiAgICB7IG5vOiAzLCBuYW1lOiBcInBhcnRpY2lwYW50X3RyYWNrc1wiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogUGFydGljaXBhbnRUcmFja3MsIHJlcGVhdGVkOiB0cnVlIH0sXG4gIF0pO1xuXG4gIHN0YXRpYyBmcm9tQmluYXJ5KGJ5dGVzOiBVaW50OEFycmF5LCBvcHRpb25zPzogUGFydGlhbDxCaW5hcnlSZWFkT3B0aW9ucz4pOiBVcGRhdGVTdWJzY3JpcHRpb24ge1xuICAgIHJldHVybiBuZXcgVXBkYXRlU3Vic2NyaXB0aW9uKCkuZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucyk7XG4gIH1cblxuICBzdGF0aWMgZnJvbUpzb24oanNvblZhbHVlOiBKc29uVmFsdWUsIG9wdGlvbnM/OiBQYXJ0aWFsPEpzb25SZWFkT3B0aW9ucz4pOiBVcGRhdGVTdWJzY3JpcHRpb24ge1xuICAgIHJldHVybiBuZXcgVXBkYXRlU3Vic2NyaXB0aW9uKCkuZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tSnNvblN0cmluZyhqc29uU3RyaW5nOiBzdHJpbmcsIG9wdGlvbnM/OiBQYXJ0aWFsPEpzb25SZWFkT3B0aW9ucz4pOiBVcGRhdGVTdWJzY3JpcHRpb24ge1xuICAgIHJldHVybiBuZXcgVXBkYXRlU3Vic2NyaXB0aW9uKCkuZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucyk7XG4gIH1cblxuICBzdGF0aWMgZXF1YWxzKGE6IFVwZGF0ZVN1YnNjcmlwdGlvbiB8IFBsYWluTWVzc2FnZTxVcGRhdGVTdWJzY3JpcHRpb24+IHwgdW5kZWZpbmVkLCBiOiBVcGRhdGVTdWJzY3JpcHRpb24gfCBQbGFpbk1lc3NhZ2U8VXBkYXRlU3Vic2NyaXB0aW9uPiB8IHVuZGVmaW5lZCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBwcm90bzMudXRpbC5lcXVhbHMoVXBkYXRlU3Vic2NyaXB0aW9uLCBhLCBiKTtcbiAgfVxufVxuXG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBtZXNzYWdlIGxpdmVraXQuVXBkYXRlVHJhY2tTZXR0aW5nc1xuICovXG5leHBvcnQgY2xhc3MgVXBkYXRlVHJhY2tTZXR0aW5ncyBleHRlbmRzIE1lc3NhZ2U8VXBkYXRlVHJhY2tTZXR0aW5ncz4ge1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiByZXBlYXRlZCBzdHJpbmcgdHJhY2tfc2lkcyA9IDE7XG4gICAqL1xuICB0cmFja1NpZHM6IHN0cmluZ1tdID0gW107XG5cbiAgLyoqXG4gICAqIHdoZW4gdHJ1ZSwgdGhlIHRyYWNrIGlzIHBsYWNlZCBpbiBhIHBhdXNlZCBzdGF0ZSwgd2l0aCBubyBuZXcgZGF0YSByZXR1cm5lZFxuICAgKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGJvb2wgZGlzYWJsZWQgPSAzO1xuICAgKi9cbiAgZGlzYWJsZWQgPSBmYWxzZTtcblxuICAvKipcbiAgICogZGVwcmVjYXRlZCBpbiBmYXZvciBvZiB3aWR0aCAmIGhlaWdodFxuICAgKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGxpdmVraXQuVmlkZW9RdWFsaXR5IHF1YWxpdHkgPSA0O1xuICAgKi9cbiAgcXVhbGl0eSA9IFZpZGVvUXVhbGl0eS5MT1c7XG5cbiAgLyoqXG4gICAqIGZvciB2aWRlbywgd2lkdGggdG8gcmVjZWl2ZVxuICAgKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHVpbnQzMiB3aWR0aCA9IDU7XG4gICAqL1xuICB3aWR0aCA9IDA7XG5cbiAgLyoqXG4gICAqIGZvciB2aWRlbywgaGVpZ2h0IHRvIHJlY2VpdmVcbiAgICpcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiB1aW50MzIgaGVpZ2h0ID0gNjtcbiAgICovXG4gIGhlaWdodCA9IDA7XG5cbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogdWludDMyIGZwcyA9IDc7XG4gICAqL1xuICBmcHMgPSAwO1xuXG4gIC8qKlxuICAgKiBzdWJzY3JpcHRpb24gcHJpb3JpdHkuIDEgYmVpbmcgdGhlIGhpZ2hlc3QgKDAgaXMgdW5zZXQpXG4gICAqIHdoZW4gdW5zZXQsIHNlcnZlciBzaWxsIGFzc2lnbiBwcmlvcml0eSBiYXNlZCBvbiB0aGUgb3JkZXIgb2Ygc3Vic2NyaXB0aW9uXG4gICAqIHNlcnZlciB3aWxsIHVzZSBwcmlvcml0eSBpbiB0aGUgZm9sbG93aW5nIHdheXM6XG4gICAqIDEuIHdoZW4gc3Vic2NyaWJlZCB0cmFja3MgZXhjZWVkIHBlci1wYXJ0aWNpcGFudCBzdWJzY3JpcHRpb24gbGltaXQsIHNlcnZlciB3aWxsXG4gICAqICAgIHBhdXNlIHRoZSBsb3dlc3QgcHJpb3JpdHkgdHJhY2tzXG4gICAqIDIuIHdoZW4gdGhlIG5ldHdvcmsgaXMgY29uZ2VzdGVkLCBzZXJ2ZXIgd2lsbCBhc3NpZ24gYXZhaWxhYmxlIGJhbmR3aWR0aCB0b1xuICAgKiAgICBoaWdoZXIgcHJpb3JpdHkgdHJhY2tzIGZpcnN0LiBsb3dlc3QgcHJpb3JpdHkgdHJhY2tzIGNhbiBiZSBwYXVzZWRcbiAgICpcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiB1aW50MzIgcHJpb3JpdHkgPSA4O1xuICAgKi9cbiAgcHJpb3JpdHkgPSAwO1xuXG4gIGNvbnN0cnVjdG9yKGRhdGE/OiBQYXJ0aWFsTWVzc2FnZTxVcGRhdGVUcmFja1NldHRpbmdzPikge1xuICAgIHN1cGVyKCk7XG4gICAgcHJvdG8zLnV0aWwuaW5pdFBhcnRpYWwoZGF0YSwgdGhpcyk7XG4gIH1cblxuICBzdGF0aWMgcmVhZG9ubHkgcnVudGltZTogdHlwZW9mIHByb3RvMyA9IHByb3RvMztcbiAgc3RhdGljIHJlYWRvbmx5IHR5cGVOYW1lID0gXCJsaXZla2l0LlVwZGF0ZVRyYWNrU2V0dGluZ3NcIjtcbiAgc3RhdGljIHJlYWRvbmx5IGZpZWxkczogRmllbGRMaXN0ID0gcHJvdG8zLnV0aWwubmV3RmllbGRMaXN0KCgpID0+IFtcbiAgICB7IG5vOiAxLCBuYW1lOiBcInRyYWNrX3NpZHNcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqLywgcmVwZWF0ZWQ6IHRydWUgfSxcbiAgICB7IG5vOiAzLCBuYW1lOiBcImRpc2FibGVkXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDggLyogU2NhbGFyVHlwZS5CT09MICovIH0sXG4gICAgeyBubzogNCwgbmFtZTogXCJxdWFsaXR5XCIsIGtpbmQ6IFwiZW51bVwiLCBUOiBwcm90bzMuZ2V0RW51bVR5cGUoVmlkZW9RdWFsaXR5KSB9LFxuICAgIHsgbm86IDUsIG5hbWU6IFwid2lkdGhcIiwga2luZDogXCJzY2FsYXJcIiwgVDogMTMgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi8gfSxcbiAgICB7IG5vOiA2LCBuYW1lOiBcImhlaWdodFwiLCBraW5kOiBcInNjYWxhclwiLCBUOiAxMyAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqLyB9LFxuICAgIHsgbm86IDcsIG5hbWU6IFwiZnBzXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDEzIC8qIFNjYWxhclR5cGUuVUlOVDMyICovIH0sXG4gICAgeyBubzogOCwgbmFtZTogXCJwcmlvcml0eVwiLCBraW5kOiBcInNjYWxhclwiLCBUOiAxMyAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqLyB9LFxuICBdKTtcblxuICBzdGF0aWMgZnJvbUJpbmFyeShieXRlczogVWludDhBcnJheSwgb3B0aW9ucz86IFBhcnRpYWw8QmluYXJ5UmVhZE9wdGlvbnM+KTogVXBkYXRlVHJhY2tTZXR0aW5ncyB7XG4gICAgcmV0dXJuIG5ldyBVcGRhdGVUcmFja1NldHRpbmdzKCkuZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucyk7XG4gIH1cblxuICBzdGF0aWMgZnJvbUpzb24oanNvblZhbHVlOiBKc29uVmFsdWUsIG9wdGlvbnM/OiBQYXJ0aWFsPEpzb25SZWFkT3B0aW9ucz4pOiBVcGRhdGVUcmFja1NldHRpbmdzIHtcbiAgICByZXR1cm4gbmV3IFVwZGF0ZVRyYWNrU2V0dGluZ3MoKS5mcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpO1xuICB9XG5cbiAgc3RhdGljIGZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmc6IHN0cmluZywgb3B0aW9ucz86IFBhcnRpYWw8SnNvblJlYWRPcHRpb25zPik6IFVwZGF0ZVRyYWNrU2V0dGluZ3Mge1xuICAgIHJldHVybiBuZXcgVXBkYXRlVHJhY2tTZXR0aW5ncygpLmZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpO1xuICB9XG5cbiAgc3RhdGljIGVxdWFscyhhOiBVcGRhdGVUcmFja1NldHRpbmdzIHwgUGxhaW5NZXNzYWdlPFVwZGF0ZVRyYWNrU2V0dGluZ3M+IHwgdW5kZWZpbmVkLCBiOiBVcGRhdGVUcmFja1NldHRpbmdzIHwgUGxhaW5NZXNzYWdlPFVwZGF0ZVRyYWNrU2V0dGluZ3M+IHwgdW5kZWZpbmVkKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHByb3RvMy51dGlsLmVxdWFscyhVcGRhdGVUcmFja1NldHRpbmdzLCBhLCBiKTtcbiAgfVxufVxuXG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBtZXNzYWdlIGxpdmVraXQuTGVhdmVSZXF1ZXN0XG4gKi9cbmV4cG9ydCBjbGFzcyBMZWF2ZVJlcXVlc3QgZXh0ZW5kcyBNZXNzYWdlPExlYXZlUmVxdWVzdD4ge1xuICAvKipcbiAgICogc2VudCB3aGVuIHNlcnZlciBpbml0aWF0ZXMgdGhlIGRpc2Nvbm5lY3QgZHVlIHRvIHNlcnZlci1yZXN0YXJ0XG4gICAqIGluZGljYXRlcyBjbGllbnRzIHNob3VsZCBhdHRlbXB0IGZ1bGwtcmVjb25uZWN0IHNlcXVlbmNlXG4gICAqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogYm9vbCBjYW5fcmVjb25uZWN0ID0gMTtcbiAgICovXG4gIGNhblJlY29ubmVjdCA9IGZhbHNlO1xuXG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGxpdmVraXQuRGlzY29ubmVjdFJlYXNvbiByZWFzb24gPSAyO1xuICAgKi9cbiAgcmVhc29uID0gRGlzY29ubmVjdFJlYXNvbi5VTktOT1dOX1JFQVNPTjtcblxuICBjb25zdHJ1Y3RvcihkYXRhPzogUGFydGlhbE1lc3NhZ2U8TGVhdmVSZXF1ZXN0Pikge1xuICAgIHN1cGVyKCk7XG4gICAgcHJvdG8zLnV0aWwuaW5pdFBhcnRpYWwoZGF0YSwgdGhpcyk7XG4gIH1cblxuICBzdGF0aWMgcmVhZG9ubHkgcnVudGltZTogdHlwZW9mIHByb3RvMyA9IHByb3RvMztcbiAgc3RhdGljIHJlYWRvbmx5IHR5cGVOYW1lID0gXCJsaXZla2l0LkxlYXZlUmVxdWVzdFwiO1xuICBzdGF0aWMgcmVhZG9ubHkgZmllbGRzOiBGaWVsZExpc3QgPSBwcm90bzMudXRpbC5uZXdGaWVsZExpc3QoKCkgPT4gW1xuICAgIHsgbm86IDEsIG5hbWU6IFwiY2FuX3JlY29ubmVjdFwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA4IC8qIFNjYWxhclR5cGUuQk9PTCAqLyB9LFxuICAgIHsgbm86IDIsIG5hbWU6IFwicmVhc29uXCIsIGtpbmQ6IFwiZW51bVwiLCBUOiBwcm90bzMuZ2V0RW51bVR5cGUoRGlzY29ubmVjdFJlYXNvbikgfSxcbiAgXSk7XG5cbiAgc3RhdGljIGZyb21CaW5hcnkoYnl0ZXM6IFVpbnQ4QXJyYXksIG9wdGlvbnM/OiBQYXJ0aWFsPEJpbmFyeVJlYWRPcHRpb25zPik6IExlYXZlUmVxdWVzdCB7XG4gICAgcmV0dXJuIG5ldyBMZWF2ZVJlcXVlc3QoKS5mcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tSnNvbihqc29uVmFsdWU6IEpzb25WYWx1ZSwgb3B0aW9ucz86IFBhcnRpYWw8SnNvblJlYWRPcHRpb25zPik6IExlYXZlUmVxdWVzdCB7XG4gICAgcmV0dXJuIG5ldyBMZWF2ZVJlcXVlc3QoKS5mcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpO1xuICB9XG5cbiAgc3RhdGljIGZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmc6IHN0cmluZywgb3B0aW9ucz86IFBhcnRpYWw8SnNvblJlYWRPcHRpb25zPik6IExlYXZlUmVxdWVzdCB7XG4gICAgcmV0dXJuIG5ldyBMZWF2ZVJlcXVlc3QoKS5mcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKTtcbiAgfVxuXG4gIHN0YXRpYyBlcXVhbHMoYTogTGVhdmVSZXF1ZXN0IHwgUGxhaW5NZXNzYWdlPExlYXZlUmVxdWVzdD4gfCB1bmRlZmluZWQsIGI6IExlYXZlUmVxdWVzdCB8IFBsYWluTWVzc2FnZTxMZWF2ZVJlcXVlc3Q+IHwgdW5kZWZpbmVkKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHByb3RvMy51dGlsLmVxdWFscyhMZWF2ZVJlcXVlc3QsIGEsIGIpO1xuICB9XG59XG5cbi8qKlxuICogbWVzc2FnZSB0byBpbmRpY2F0ZSBwdWJsaXNoZWQgdmlkZW8gdHJhY2sgZGltZW5zaW9ucyBhcmUgY2hhbmdpbmdcbiAqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBsaXZla2l0LlVwZGF0ZVZpZGVvTGF5ZXJzXG4gKi9cbmV4cG9ydCBjbGFzcyBVcGRhdGVWaWRlb0xheWVycyBleHRlbmRzIE1lc3NhZ2U8VXBkYXRlVmlkZW9MYXllcnM+IHtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogc3RyaW5nIHRyYWNrX3NpZCA9IDE7XG4gICAqL1xuICB0cmFja1NpZCA9IFwiXCI7XG5cbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogcmVwZWF0ZWQgbGl2ZWtpdC5WaWRlb0xheWVyIGxheWVycyA9IDI7XG4gICAqL1xuICBsYXllcnM6IFZpZGVvTGF5ZXJbXSA9IFtdO1xuXG4gIGNvbnN0cnVjdG9yKGRhdGE/OiBQYXJ0aWFsTWVzc2FnZTxVcGRhdGVWaWRlb0xheWVycz4pIHtcbiAgICBzdXBlcigpO1xuICAgIHByb3RvMy51dGlsLmluaXRQYXJ0aWFsKGRhdGEsIHRoaXMpO1xuICB9XG5cbiAgc3RhdGljIHJlYWRvbmx5IHJ1bnRpbWU6IHR5cGVvZiBwcm90bzMgPSBwcm90bzM7XG4gIHN0YXRpYyByZWFkb25seSB0eXBlTmFtZSA9IFwibGl2ZWtpdC5VcGRhdGVWaWRlb0xheWVyc1wiO1xuICBzdGF0aWMgcmVhZG9ubHkgZmllbGRzOiBGaWVsZExpc3QgPSBwcm90bzMudXRpbC5uZXdGaWVsZExpc3QoKCkgPT4gW1xuICAgIHsgbm86IDEsIG5hbWU6IFwidHJhY2tfc2lkXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi8gfSxcbiAgICB7IG5vOiAyLCBuYW1lOiBcImxheWVyc1wiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogVmlkZW9MYXllciwgcmVwZWF0ZWQ6IHRydWUgfSxcbiAgXSk7XG5cbiAgc3RhdGljIGZyb21CaW5hcnkoYnl0ZXM6IFVpbnQ4QXJyYXksIG9wdGlvbnM/OiBQYXJ0aWFsPEJpbmFyeVJlYWRPcHRpb25zPik6IFVwZGF0ZVZpZGVvTGF5ZXJzIHtcbiAgICByZXR1cm4gbmV3IFVwZGF0ZVZpZGVvTGF5ZXJzKCkuZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucyk7XG4gIH1cblxuICBzdGF0aWMgZnJvbUpzb24oanNvblZhbHVlOiBKc29uVmFsdWUsIG9wdGlvbnM/OiBQYXJ0aWFsPEpzb25SZWFkT3B0aW9ucz4pOiBVcGRhdGVWaWRlb0xheWVycyB7XG4gICAgcmV0dXJuIG5ldyBVcGRhdGVWaWRlb0xheWVycygpLmZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucyk7XG4gIH1cblxuICBzdGF0aWMgZnJvbUpzb25TdHJpbmcoanNvblN0cmluZzogc3RyaW5nLCBvcHRpb25zPzogUGFydGlhbDxKc29uUmVhZE9wdGlvbnM+KTogVXBkYXRlVmlkZW9MYXllcnMge1xuICAgIHJldHVybiBuZXcgVXBkYXRlVmlkZW9MYXllcnMoKS5mcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKTtcbiAgfVxuXG4gIHN0YXRpYyBlcXVhbHMoYTogVXBkYXRlVmlkZW9MYXllcnMgfCBQbGFpbk1lc3NhZ2U8VXBkYXRlVmlkZW9MYXllcnM+IHwgdW5kZWZpbmVkLCBiOiBVcGRhdGVWaWRlb0xheWVycyB8IFBsYWluTWVzc2FnZTxVcGRhdGVWaWRlb0xheWVycz4gfCB1bmRlZmluZWQpOiBib29sZWFuIHtcbiAgICByZXR1cm4gcHJvdG8zLnV0aWwuZXF1YWxzKFVwZGF0ZVZpZGVvTGF5ZXJzLCBhLCBiKTtcbiAgfVxufVxuXG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBtZXNzYWdlIGxpdmVraXQuVXBkYXRlUGFydGljaXBhbnRNZXRhZGF0YVxuICovXG5leHBvcnQgY2xhc3MgVXBkYXRlUGFydGljaXBhbnRNZXRhZGF0YSBleHRlbmRzIE1lc3NhZ2U8VXBkYXRlUGFydGljaXBhbnRNZXRhZGF0YT4ge1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBzdHJpbmcgbWV0YWRhdGEgPSAxO1xuICAgKi9cbiAgbWV0YWRhdGEgPSBcIlwiO1xuXG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHN0cmluZyBuYW1lID0gMjtcbiAgICovXG4gIG5hbWUgPSBcIlwiO1xuXG4gIGNvbnN0cnVjdG9yKGRhdGE/OiBQYXJ0aWFsTWVzc2FnZTxVcGRhdGVQYXJ0aWNpcGFudE1ldGFkYXRhPikge1xuICAgIHN1cGVyKCk7XG4gICAgcHJvdG8zLnV0aWwuaW5pdFBhcnRpYWwoZGF0YSwgdGhpcyk7XG4gIH1cblxuICBzdGF0aWMgcmVhZG9ubHkgcnVudGltZTogdHlwZW9mIHByb3RvMyA9IHByb3RvMztcbiAgc3RhdGljIHJlYWRvbmx5IHR5cGVOYW1lID0gXCJsaXZla2l0LlVwZGF0ZVBhcnRpY2lwYW50TWV0YWRhdGFcIjtcbiAgc3RhdGljIHJlYWRvbmx5IGZpZWxkczogRmllbGRMaXN0ID0gcHJvdG8zLnV0aWwubmV3RmllbGRMaXN0KCgpID0+IFtcbiAgICB7IG5vOiAxLCBuYW1lOiBcIm1ldGFkYXRhXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi8gfSxcbiAgICB7IG5vOiAyLCBuYW1lOiBcIm5hbWVcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqLyB9LFxuICBdKTtcblxuICBzdGF0aWMgZnJvbUJpbmFyeShieXRlczogVWludDhBcnJheSwgb3B0aW9ucz86IFBhcnRpYWw8QmluYXJ5UmVhZE9wdGlvbnM+KTogVXBkYXRlUGFydGljaXBhbnRNZXRhZGF0YSB7XG4gICAgcmV0dXJuIG5ldyBVcGRhdGVQYXJ0aWNpcGFudE1ldGFkYXRhKCkuZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucyk7XG4gIH1cblxuICBzdGF0aWMgZnJvbUpzb24oanNvblZhbHVlOiBKc29uVmFsdWUsIG9wdGlvbnM/OiBQYXJ0aWFsPEpzb25SZWFkT3B0aW9ucz4pOiBVcGRhdGVQYXJ0aWNpcGFudE1ldGFkYXRhIHtcbiAgICByZXR1cm4gbmV3IFVwZGF0ZVBhcnRpY2lwYW50TWV0YWRhdGEoKS5mcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpO1xuICB9XG5cbiAgc3RhdGljIGZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmc6IHN0cmluZywgb3B0aW9ucz86IFBhcnRpYWw8SnNvblJlYWRPcHRpb25zPik6IFVwZGF0ZVBhcnRpY2lwYW50TWV0YWRhdGEge1xuICAgIHJldHVybiBuZXcgVXBkYXRlUGFydGljaXBhbnRNZXRhZGF0YSgpLmZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpO1xuICB9XG5cbiAgc3RhdGljIGVxdWFscyhhOiBVcGRhdGVQYXJ0aWNpcGFudE1ldGFkYXRhIHwgUGxhaW5NZXNzYWdlPFVwZGF0ZVBhcnRpY2lwYW50TWV0YWRhdGE+IHwgdW5kZWZpbmVkLCBiOiBVcGRhdGVQYXJ0aWNpcGFudE1ldGFkYXRhIHwgUGxhaW5NZXNzYWdlPFVwZGF0ZVBhcnRpY2lwYW50TWV0YWRhdGE+IHwgdW5kZWZpbmVkKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHByb3RvMy51dGlsLmVxdWFscyhVcGRhdGVQYXJ0aWNpcGFudE1ldGFkYXRhLCBhLCBiKTtcbiAgfVxufVxuXG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBtZXNzYWdlIGxpdmVraXQuSUNFU2VydmVyXG4gKi9cbmV4cG9ydCBjbGFzcyBJQ0VTZXJ2ZXIgZXh0ZW5kcyBNZXNzYWdlPElDRVNlcnZlcj4ge1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiByZXBlYXRlZCBzdHJpbmcgdXJscyA9IDE7XG4gICAqL1xuICB1cmxzOiBzdHJpbmdbXSA9IFtdO1xuXG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHN0cmluZyB1c2VybmFtZSA9IDI7XG4gICAqL1xuICB1c2VybmFtZSA9IFwiXCI7XG5cbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogc3RyaW5nIGNyZWRlbnRpYWwgPSAzO1xuICAgKi9cbiAgY3JlZGVudGlhbCA9IFwiXCI7XG5cbiAgY29uc3RydWN0b3IoZGF0YT86IFBhcnRpYWxNZXNzYWdlPElDRVNlcnZlcj4pIHtcbiAgICBzdXBlcigpO1xuICAgIHByb3RvMy51dGlsLmluaXRQYXJ0aWFsKGRhdGEsIHRoaXMpO1xuICB9XG5cbiAgc3RhdGljIHJlYWRvbmx5IHJ1bnRpbWU6IHR5cGVvZiBwcm90bzMgPSBwcm90bzM7XG4gIHN0YXRpYyByZWFkb25seSB0eXBlTmFtZSA9IFwibGl2ZWtpdC5JQ0VTZXJ2ZXJcIjtcbiAgc3RhdGljIHJlYWRvbmx5IGZpZWxkczogRmllbGRMaXN0ID0gcHJvdG8zLnV0aWwubmV3RmllbGRMaXN0KCgpID0+IFtcbiAgICB7IG5vOiAxLCBuYW1lOiBcInVybHNcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqLywgcmVwZWF0ZWQ6IHRydWUgfSxcbiAgICB7IG5vOiAyLCBuYW1lOiBcInVzZXJuYW1lXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi8gfSxcbiAgICB7IG5vOiAzLCBuYW1lOiBcImNyZWRlbnRpYWxcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqLyB9LFxuICBdKTtcblxuICBzdGF0aWMgZnJvbUJpbmFyeShieXRlczogVWludDhBcnJheSwgb3B0aW9ucz86IFBhcnRpYWw8QmluYXJ5UmVhZE9wdGlvbnM+KTogSUNFU2VydmVyIHtcbiAgICByZXR1cm4gbmV3IElDRVNlcnZlcigpLmZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpO1xuICB9XG5cbiAgc3RhdGljIGZyb21Kc29uKGpzb25WYWx1ZTogSnNvblZhbHVlLCBvcHRpb25zPzogUGFydGlhbDxKc29uUmVhZE9wdGlvbnM+KTogSUNFU2VydmVyIHtcbiAgICByZXR1cm4gbmV3IElDRVNlcnZlcigpLmZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucyk7XG4gIH1cblxuICBzdGF0aWMgZnJvbUpzb25TdHJpbmcoanNvblN0cmluZzogc3RyaW5nLCBvcHRpb25zPzogUGFydGlhbDxKc29uUmVhZE9wdGlvbnM+KTogSUNFU2VydmVyIHtcbiAgICByZXR1cm4gbmV3IElDRVNlcnZlcigpLmZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpO1xuICB9XG5cbiAgc3RhdGljIGVxdWFscyhhOiBJQ0VTZXJ2ZXIgfCBQbGFpbk1lc3NhZ2U8SUNFU2VydmVyPiB8IHVuZGVmaW5lZCwgYjogSUNFU2VydmVyIHwgUGxhaW5NZXNzYWdlPElDRVNlcnZlcj4gfCB1bmRlZmluZWQpOiBib29sZWFuIHtcbiAgICByZXR1cm4gcHJvdG8zLnV0aWwuZXF1YWxzKElDRVNlcnZlciwgYSwgYik7XG4gIH1cbn1cblxuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBsaXZla2l0LlNwZWFrZXJzQ2hhbmdlZFxuICovXG5leHBvcnQgY2xhc3MgU3BlYWtlcnNDaGFuZ2VkIGV4dGVuZHMgTWVzc2FnZTxTcGVha2Vyc0NoYW5nZWQ+IHtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogcmVwZWF0ZWQgbGl2ZWtpdC5TcGVha2VySW5mbyBzcGVha2VycyA9IDE7XG4gICAqL1xuICBzcGVha2VyczogU3BlYWtlckluZm9bXSA9IFtdO1xuXG4gIGNvbnN0cnVjdG9yKGRhdGE/OiBQYXJ0aWFsTWVzc2FnZTxTcGVha2Vyc0NoYW5nZWQ+KSB7XG4gICAgc3VwZXIoKTtcbiAgICBwcm90bzMudXRpbC5pbml0UGFydGlhbChkYXRhLCB0aGlzKTtcbiAgfVxuXG4gIHN0YXRpYyByZWFkb25seSBydW50aW1lOiB0eXBlb2YgcHJvdG8zID0gcHJvdG8zO1xuICBzdGF0aWMgcmVhZG9ubHkgdHlwZU5hbWUgPSBcImxpdmVraXQuU3BlYWtlcnNDaGFuZ2VkXCI7XG4gIHN0YXRpYyByZWFkb25seSBmaWVsZHM6IEZpZWxkTGlzdCA9IHByb3RvMy51dGlsLm5ld0ZpZWxkTGlzdCgoKSA9PiBbXG4gICAgeyBubzogMSwgbmFtZTogXCJzcGVha2Vyc1wiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogU3BlYWtlckluZm8sIHJlcGVhdGVkOiB0cnVlIH0sXG4gIF0pO1xuXG4gIHN0YXRpYyBmcm9tQmluYXJ5KGJ5dGVzOiBVaW50OEFycmF5LCBvcHRpb25zPzogUGFydGlhbDxCaW5hcnlSZWFkT3B0aW9ucz4pOiBTcGVha2Vyc0NoYW5nZWQge1xuICAgIHJldHVybiBuZXcgU3BlYWtlcnNDaGFuZ2VkKCkuZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucyk7XG4gIH1cblxuICBzdGF0aWMgZnJvbUpzb24oanNvblZhbHVlOiBKc29uVmFsdWUsIG9wdGlvbnM/OiBQYXJ0aWFsPEpzb25SZWFkT3B0aW9ucz4pOiBTcGVha2Vyc0NoYW5nZWQge1xuICAgIHJldHVybiBuZXcgU3BlYWtlcnNDaGFuZ2VkKCkuZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tSnNvblN0cmluZyhqc29uU3RyaW5nOiBzdHJpbmcsIG9wdGlvbnM/OiBQYXJ0aWFsPEpzb25SZWFkT3B0aW9ucz4pOiBTcGVha2Vyc0NoYW5nZWQge1xuICAgIHJldHVybiBuZXcgU3BlYWtlcnNDaGFuZ2VkKCkuZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucyk7XG4gIH1cblxuICBzdGF0aWMgZXF1YWxzKGE6IFNwZWFrZXJzQ2hhbmdlZCB8IFBsYWluTWVzc2FnZTxTcGVha2Vyc0NoYW5nZWQ+IHwgdW5kZWZpbmVkLCBiOiBTcGVha2Vyc0NoYW5nZWQgfCBQbGFpbk1lc3NhZ2U8U3BlYWtlcnNDaGFuZ2VkPiB8IHVuZGVmaW5lZCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBwcm90bzMudXRpbC5lcXVhbHMoU3BlYWtlcnNDaGFuZ2VkLCBhLCBiKTtcbiAgfVxufVxuXG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBtZXNzYWdlIGxpdmVraXQuUm9vbVVwZGF0ZVxuICovXG5leHBvcnQgY2xhc3MgUm9vbVVwZGF0ZSBleHRlbmRzIE1lc3NhZ2U8Um9vbVVwZGF0ZT4ge1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBsaXZla2l0LlJvb20gcm9vbSA9IDE7XG4gICAqL1xuICByb29tPzogUm9vbTtcblxuICBjb25zdHJ1Y3RvcihkYXRhPzogUGFydGlhbE1lc3NhZ2U8Um9vbVVwZGF0ZT4pIHtcbiAgICBzdXBlcigpO1xuICAgIHByb3RvMy51dGlsLmluaXRQYXJ0aWFsKGRhdGEsIHRoaXMpO1xuICB9XG5cbiAgc3RhdGljIHJlYWRvbmx5IHJ1bnRpbWU6IHR5cGVvZiBwcm90bzMgPSBwcm90bzM7XG4gIHN0YXRpYyByZWFkb25seSB0eXBlTmFtZSA9IFwibGl2ZWtpdC5Sb29tVXBkYXRlXCI7XG4gIHN0YXRpYyByZWFkb25seSBmaWVsZHM6IEZpZWxkTGlzdCA9IHByb3RvMy51dGlsLm5ld0ZpZWxkTGlzdCgoKSA9PiBbXG4gICAgeyBubzogMSwgbmFtZTogXCJyb29tXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBSb29tIH0sXG4gIF0pO1xuXG4gIHN0YXRpYyBmcm9tQmluYXJ5KGJ5dGVzOiBVaW50OEFycmF5LCBvcHRpb25zPzogUGFydGlhbDxCaW5hcnlSZWFkT3B0aW9ucz4pOiBSb29tVXBkYXRlIHtcbiAgICByZXR1cm4gbmV3IFJvb21VcGRhdGUoKS5mcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tSnNvbihqc29uVmFsdWU6IEpzb25WYWx1ZSwgb3B0aW9ucz86IFBhcnRpYWw8SnNvblJlYWRPcHRpb25zPik6IFJvb21VcGRhdGUge1xuICAgIHJldHVybiBuZXcgUm9vbVVwZGF0ZSgpLmZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucyk7XG4gIH1cblxuICBzdGF0aWMgZnJvbUpzb25TdHJpbmcoanNvblN0cmluZzogc3RyaW5nLCBvcHRpb25zPzogUGFydGlhbDxKc29uUmVhZE9wdGlvbnM+KTogUm9vbVVwZGF0ZSB7XG4gICAgcmV0dXJuIG5ldyBSb29tVXBkYXRlKCkuZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucyk7XG4gIH1cblxuICBzdGF0aWMgZXF1YWxzKGE6IFJvb21VcGRhdGUgfCBQbGFpbk1lc3NhZ2U8Um9vbVVwZGF0ZT4gfCB1bmRlZmluZWQsIGI6IFJvb21VcGRhdGUgfCBQbGFpbk1lc3NhZ2U8Um9vbVVwZGF0ZT4gfCB1bmRlZmluZWQpOiBib29sZWFuIHtcbiAgICByZXR1cm4gcHJvdG8zLnV0aWwuZXF1YWxzKFJvb21VcGRhdGUsIGEsIGIpO1xuICB9XG59XG5cbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgbGl2ZWtpdC5Db25uZWN0aW9uUXVhbGl0eUluZm9cbiAqL1xuZXhwb3J0IGNsYXNzIENvbm5lY3Rpb25RdWFsaXR5SW5mbyBleHRlbmRzIE1lc3NhZ2U8Q29ubmVjdGlvblF1YWxpdHlJbmZvPiB7XG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHN0cmluZyBwYXJ0aWNpcGFudF9zaWQgPSAxO1xuICAgKi9cbiAgcGFydGljaXBhbnRTaWQgPSBcIlwiO1xuXG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGxpdmVraXQuQ29ubmVjdGlvblF1YWxpdHkgcXVhbGl0eSA9IDI7XG4gICAqL1xuICBxdWFsaXR5ID0gQ29ubmVjdGlvblF1YWxpdHkuUE9PUjtcblxuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBmbG9hdCBzY29yZSA9IDM7XG4gICAqL1xuICBzY29yZSA9IDA7XG5cbiAgY29uc3RydWN0b3IoZGF0YT86IFBhcnRpYWxNZXNzYWdlPENvbm5lY3Rpb25RdWFsaXR5SW5mbz4pIHtcbiAgICBzdXBlcigpO1xuICAgIHByb3RvMy51dGlsLmluaXRQYXJ0aWFsKGRhdGEsIHRoaXMpO1xuICB9XG5cbiAgc3RhdGljIHJlYWRvbmx5IHJ1bnRpbWU6IHR5cGVvZiBwcm90bzMgPSBwcm90bzM7XG4gIHN0YXRpYyByZWFkb25seSB0eXBlTmFtZSA9IFwibGl2ZWtpdC5Db25uZWN0aW9uUXVhbGl0eUluZm9cIjtcbiAgc3RhdGljIHJlYWRvbmx5IGZpZWxkczogRmllbGRMaXN0ID0gcHJvdG8zLnV0aWwubmV3RmllbGRMaXN0KCgpID0+IFtcbiAgICB7IG5vOiAxLCBuYW1lOiBcInBhcnRpY2lwYW50X3NpZFwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovIH0sXG4gICAgeyBubzogMiwgbmFtZTogXCJxdWFsaXR5XCIsIGtpbmQ6IFwiZW51bVwiLCBUOiBwcm90bzMuZ2V0RW51bVR5cGUoQ29ubmVjdGlvblF1YWxpdHkpIH0sXG4gICAgeyBubzogMywgbmFtZTogXCJzY29yZVwiLCBraW5kOiBcInNjYWxhclwiLCBUOiAyIC8qIFNjYWxhclR5cGUuRkxPQVQgKi8gfSxcbiAgXSk7XG5cbiAgc3RhdGljIGZyb21CaW5hcnkoYnl0ZXM6IFVpbnQ4QXJyYXksIG9wdGlvbnM/OiBQYXJ0aWFsPEJpbmFyeVJlYWRPcHRpb25zPik6IENvbm5lY3Rpb25RdWFsaXR5SW5mbyB7XG4gICAgcmV0dXJuIG5ldyBDb25uZWN0aW9uUXVhbGl0eUluZm8oKS5mcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tSnNvbihqc29uVmFsdWU6IEpzb25WYWx1ZSwgb3B0aW9ucz86IFBhcnRpYWw8SnNvblJlYWRPcHRpb25zPik6IENvbm5lY3Rpb25RdWFsaXR5SW5mbyB7XG4gICAgcmV0dXJuIG5ldyBDb25uZWN0aW9uUXVhbGl0eUluZm8oKS5mcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpO1xuICB9XG5cbiAgc3RhdGljIGZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmc6IHN0cmluZywgb3B0aW9ucz86IFBhcnRpYWw8SnNvblJlYWRPcHRpb25zPik6IENvbm5lY3Rpb25RdWFsaXR5SW5mbyB7XG4gICAgcmV0dXJuIG5ldyBDb25uZWN0aW9uUXVhbGl0eUluZm8oKS5mcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKTtcbiAgfVxuXG4gIHN0YXRpYyBlcXVhbHMoYTogQ29ubmVjdGlvblF1YWxpdHlJbmZvIHwgUGxhaW5NZXNzYWdlPENvbm5lY3Rpb25RdWFsaXR5SW5mbz4gfCB1bmRlZmluZWQsIGI6IENvbm5lY3Rpb25RdWFsaXR5SW5mbyB8IFBsYWluTWVzc2FnZTxDb25uZWN0aW9uUXVhbGl0eUluZm8+IHwgdW5kZWZpbmVkKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHByb3RvMy51dGlsLmVxdWFscyhDb25uZWN0aW9uUXVhbGl0eUluZm8sIGEsIGIpO1xuICB9XG59XG5cbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgbGl2ZWtpdC5Db25uZWN0aW9uUXVhbGl0eVVwZGF0ZVxuICovXG5leHBvcnQgY2xhc3MgQ29ubmVjdGlvblF1YWxpdHlVcGRhdGUgZXh0ZW5kcyBNZXNzYWdlPENvbm5lY3Rpb25RdWFsaXR5VXBkYXRlPiB7XG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHJlcGVhdGVkIGxpdmVraXQuQ29ubmVjdGlvblF1YWxpdHlJbmZvIHVwZGF0ZXMgPSAxO1xuICAgKi9cbiAgdXBkYXRlczogQ29ubmVjdGlvblF1YWxpdHlJbmZvW10gPSBbXTtcblxuICBjb25zdHJ1Y3RvcihkYXRhPzogUGFydGlhbE1lc3NhZ2U8Q29ubmVjdGlvblF1YWxpdHlVcGRhdGU+KSB7XG4gICAgc3VwZXIoKTtcbiAgICBwcm90bzMudXRpbC5pbml0UGFydGlhbChkYXRhLCB0aGlzKTtcbiAgfVxuXG4gIHN0YXRpYyByZWFkb25seSBydW50aW1lOiB0eXBlb2YgcHJvdG8zID0gcHJvdG8zO1xuICBzdGF0aWMgcmVhZG9ubHkgdHlwZU5hbWUgPSBcImxpdmVraXQuQ29ubmVjdGlvblF1YWxpdHlVcGRhdGVcIjtcbiAgc3RhdGljIHJlYWRvbmx5IGZpZWxkczogRmllbGRMaXN0ID0gcHJvdG8zLnV0aWwubmV3RmllbGRMaXN0KCgpID0+IFtcbiAgICB7IG5vOiAxLCBuYW1lOiBcInVwZGF0ZXNcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IENvbm5lY3Rpb25RdWFsaXR5SW5mbywgcmVwZWF0ZWQ6IHRydWUgfSxcbiAgXSk7XG5cbiAgc3RhdGljIGZyb21CaW5hcnkoYnl0ZXM6IFVpbnQ4QXJyYXksIG9wdGlvbnM/OiBQYXJ0aWFsPEJpbmFyeVJlYWRPcHRpb25zPik6IENvbm5lY3Rpb25RdWFsaXR5VXBkYXRlIHtcbiAgICByZXR1cm4gbmV3IENvbm5lY3Rpb25RdWFsaXR5VXBkYXRlKCkuZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucyk7XG4gIH1cblxuICBzdGF0aWMgZnJvbUpzb24oanNvblZhbHVlOiBKc29uVmFsdWUsIG9wdGlvbnM/OiBQYXJ0aWFsPEpzb25SZWFkT3B0aW9ucz4pOiBDb25uZWN0aW9uUXVhbGl0eVVwZGF0ZSB7XG4gICAgcmV0dXJuIG5ldyBDb25uZWN0aW9uUXVhbGl0eVVwZGF0ZSgpLmZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucyk7XG4gIH1cblxuICBzdGF0aWMgZnJvbUpzb25TdHJpbmcoanNvblN0cmluZzogc3RyaW5nLCBvcHRpb25zPzogUGFydGlhbDxKc29uUmVhZE9wdGlvbnM+KTogQ29ubmVjdGlvblF1YWxpdHlVcGRhdGUge1xuICAgIHJldHVybiBuZXcgQ29ubmVjdGlvblF1YWxpdHlVcGRhdGUoKS5mcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKTtcbiAgfVxuXG4gIHN0YXRpYyBlcXVhbHMoYTogQ29ubmVjdGlvblF1YWxpdHlVcGRhdGUgfCBQbGFpbk1lc3NhZ2U8Q29ubmVjdGlvblF1YWxpdHlVcGRhdGU+IHwgdW5kZWZpbmVkLCBiOiBDb25uZWN0aW9uUXVhbGl0eVVwZGF0ZSB8IFBsYWluTWVzc2FnZTxDb25uZWN0aW9uUXVhbGl0eVVwZGF0ZT4gfCB1bmRlZmluZWQpOiBib29sZWFuIHtcbiAgICByZXR1cm4gcHJvdG8zLnV0aWwuZXF1YWxzKENvbm5lY3Rpb25RdWFsaXR5VXBkYXRlLCBhLCBiKTtcbiAgfVxufVxuXG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBtZXNzYWdlIGxpdmVraXQuU3RyZWFtU3RhdGVJbmZvXG4gKi9cbmV4cG9ydCBjbGFzcyBTdHJlYW1TdGF0ZUluZm8gZXh0ZW5kcyBNZXNzYWdlPFN0cmVhbVN0YXRlSW5mbz4ge1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBzdHJpbmcgcGFydGljaXBhbnRfc2lkID0gMTtcbiAgICovXG4gIHBhcnRpY2lwYW50U2lkID0gXCJcIjtcblxuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBzdHJpbmcgdHJhY2tfc2lkID0gMjtcbiAgICovXG4gIHRyYWNrU2lkID0gXCJcIjtcblxuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBsaXZla2l0LlN0cmVhbVN0YXRlIHN0YXRlID0gMztcbiAgICovXG4gIHN0YXRlID0gU3RyZWFtU3RhdGUuQUNUSVZFO1xuXG4gIGNvbnN0cnVjdG9yKGRhdGE/OiBQYXJ0aWFsTWVzc2FnZTxTdHJlYW1TdGF0ZUluZm8+KSB7XG4gICAgc3VwZXIoKTtcbiAgICBwcm90bzMudXRpbC5pbml0UGFydGlhbChkYXRhLCB0aGlzKTtcbiAgfVxuXG4gIHN0YXRpYyByZWFkb25seSBydW50aW1lOiB0eXBlb2YgcHJvdG8zID0gcHJvdG8zO1xuICBzdGF0aWMgcmVhZG9ubHkgdHlwZU5hbWUgPSBcImxpdmVraXQuU3RyZWFtU3RhdGVJbmZvXCI7XG4gIHN0YXRpYyByZWFkb25seSBmaWVsZHM6IEZpZWxkTGlzdCA9IHByb3RvMy51dGlsLm5ld0ZpZWxkTGlzdCgoKSA9PiBbXG4gICAgeyBubzogMSwgbmFtZTogXCJwYXJ0aWNpcGFudF9zaWRcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqLyB9LFxuICAgIHsgbm86IDIsIG5hbWU6IFwidHJhY2tfc2lkXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi8gfSxcbiAgICB7IG5vOiAzLCBuYW1lOiBcInN0YXRlXCIsIGtpbmQ6IFwiZW51bVwiLCBUOiBwcm90bzMuZ2V0RW51bVR5cGUoU3RyZWFtU3RhdGUpIH0sXG4gIF0pO1xuXG4gIHN0YXRpYyBmcm9tQmluYXJ5KGJ5dGVzOiBVaW50OEFycmF5LCBvcHRpb25zPzogUGFydGlhbDxCaW5hcnlSZWFkT3B0aW9ucz4pOiBTdHJlYW1TdGF0ZUluZm8ge1xuICAgIHJldHVybiBuZXcgU3RyZWFtU3RhdGVJbmZvKCkuZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucyk7XG4gIH1cblxuICBzdGF0aWMgZnJvbUpzb24oanNvblZhbHVlOiBKc29uVmFsdWUsIG9wdGlvbnM/OiBQYXJ0aWFsPEpzb25SZWFkT3B0aW9ucz4pOiBTdHJlYW1TdGF0ZUluZm8ge1xuICAgIHJldHVybiBuZXcgU3RyZWFtU3RhdGVJbmZvKCkuZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tSnNvblN0cmluZyhqc29uU3RyaW5nOiBzdHJpbmcsIG9wdGlvbnM/OiBQYXJ0aWFsPEpzb25SZWFkT3B0aW9ucz4pOiBTdHJlYW1TdGF0ZUluZm8ge1xuICAgIHJldHVybiBuZXcgU3RyZWFtU3RhdGVJbmZvKCkuZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucyk7XG4gIH1cblxuICBzdGF0aWMgZXF1YWxzKGE6IFN0cmVhbVN0YXRlSW5mbyB8IFBsYWluTWVzc2FnZTxTdHJlYW1TdGF0ZUluZm8+IHwgdW5kZWZpbmVkLCBiOiBTdHJlYW1TdGF0ZUluZm8gfCBQbGFpbk1lc3NhZ2U8U3RyZWFtU3RhdGVJbmZvPiB8IHVuZGVmaW5lZCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBwcm90bzMudXRpbC5lcXVhbHMoU3RyZWFtU3RhdGVJbmZvLCBhLCBiKTtcbiAgfVxufVxuXG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBtZXNzYWdlIGxpdmVraXQuU3RyZWFtU3RhdGVVcGRhdGVcbiAqL1xuZXhwb3J0IGNsYXNzIFN0cmVhbVN0YXRlVXBkYXRlIGV4dGVuZHMgTWVzc2FnZTxTdHJlYW1TdGF0ZVVwZGF0ZT4ge1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiByZXBlYXRlZCBsaXZla2l0LlN0cmVhbVN0YXRlSW5mbyBzdHJlYW1fc3RhdGVzID0gMTtcbiAgICovXG4gIHN0cmVhbVN0YXRlczogU3RyZWFtU3RhdGVJbmZvW10gPSBbXTtcblxuICBjb25zdHJ1Y3RvcihkYXRhPzogUGFydGlhbE1lc3NhZ2U8U3RyZWFtU3RhdGVVcGRhdGU+KSB7XG4gICAgc3VwZXIoKTtcbiAgICBwcm90bzMudXRpbC5pbml0UGFydGlhbChkYXRhLCB0aGlzKTtcbiAgfVxuXG4gIHN0YXRpYyByZWFkb25seSBydW50aW1lOiB0eXBlb2YgcHJvdG8zID0gcHJvdG8zO1xuICBzdGF0aWMgcmVhZG9ubHkgdHlwZU5hbWUgPSBcImxpdmVraXQuU3RyZWFtU3RhdGVVcGRhdGVcIjtcbiAgc3RhdGljIHJlYWRvbmx5IGZpZWxkczogRmllbGRMaXN0ID0gcHJvdG8zLnV0aWwubmV3RmllbGRMaXN0KCgpID0+IFtcbiAgICB7IG5vOiAxLCBuYW1lOiBcInN0cmVhbV9zdGF0ZXNcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFN0cmVhbVN0YXRlSW5mbywgcmVwZWF0ZWQ6IHRydWUgfSxcbiAgXSk7XG5cbiAgc3RhdGljIGZyb21CaW5hcnkoYnl0ZXM6IFVpbnQ4QXJyYXksIG9wdGlvbnM/OiBQYXJ0aWFsPEJpbmFyeVJlYWRPcHRpb25zPik6IFN0cmVhbVN0YXRlVXBkYXRlIHtcbiAgICByZXR1cm4gbmV3IFN0cmVhbVN0YXRlVXBkYXRlKCkuZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucyk7XG4gIH1cblxuICBzdGF0aWMgZnJvbUpzb24oanNvblZhbHVlOiBKc29uVmFsdWUsIG9wdGlvbnM/OiBQYXJ0aWFsPEpzb25SZWFkT3B0aW9ucz4pOiBTdHJlYW1TdGF0ZVVwZGF0ZSB7XG4gICAgcmV0dXJuIG5ldyBTdHJlYW1TdGF0ZVVwZGF0ZSgpLmZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucyk7XG4gIH1cblxuICBzdGF0aWMgZnJvbUpzb25TdHJpbmcoanNvblN0cmluZzogc3RyaW5nLCBvcHRpb25zPzogUGFydGlhbDxKc29uUmVhZE9wdGlvbnM+KTogU3RyZWFtU3RhdGVVcGRhdGUge1xuICAgIHJldHVybiBuZXcgU3RyZWFtU3RhdGVVcGRhdGUoKS5mcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKTtcbiAgfVxuXG4gIHN0YXRpYyBlcXVhbHMoYTogU3RyZWFtU3RhdGVVcGRhdGUgfCBQbGFpbk1lc3NhZ2U8U3RyZWFtU3RhdGVVcGRhdGU+IHwgdW5kZWZpbmVkLCBiOiBTdHJlYW1TdGF0ZVVwZGF0ZSB8IFBsYWluTWVzc2FnZTxTdHJlYW1TdGF0ZVVwZGF0ZT4gfCB1bmRlZmluZWQpOiBib29sZWFuIHtcbiAgICByZXR1cm4gcHJvdG8zLnV0aWwuZXF1YWxzKFN0cmVhbVN0YXRlVXBkYXRlLCBhLCBiKTtcbiAgfVxufVxuXG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBtZXNzYWdlIGxpdmVraXQuU3Vic2NyaWJlZFF1YWxpdHlcbiAqL1xuZXhwb3J0IGNsYXNzIFN1YnNjcmliZWRRdWFsaXR5IGV4dGVuZHMgTWVzc2FnZTxTdWJzY3JpYmVkUXVhbGl0eT4ge1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBsaXZla2l0LlZpZGVvUXVhbGl0eSBxdWFsaXR5ID0gMTtcbiAgICovXG4gIHF1YWxpdHkgPSBWaWRlb1F1YWxpdHkuTE9XO1xuXG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGJvb2wgZW5hYmxlZCA9IDI7XG4gICAqL1xuICBlbmFibGVkID0gZmFsc2U7XG5cbiAgY29uc3RydWN0b3IoZGF0YT86IFBhcnRpYWxNZXNzYWdlPFN1YnNjcmliZWRRdWFsaXR5Pikge1xuICAgIHN1cGVyKCk7XG4gICAgcHJvdG8zLnV0aWwuaW5pdFBhcnRpYWwoZGF0YSwgdGhpcyk7XG4gIH1cblxuICBzdGF0aWMgcmVhZG9ubHkgcnVudGltZTogdHlwZW9mIHByb3RvMyA9IHByb3RvMztcbiAgc3RhdGljIHJlYWRvbmx5IHR5cGVOYW1lID0gXCJsaXZla2l0LlN1YnNjcmliZWRRdWFsaXR5XCI7XG4gIHN0YXRpYyByZWFkb25seSBmaWVsZHM6IEZpZWxkTGlzdCA9IHByb3RvMy51dGlsLm5ld0ZpZWxkTGlzdCgoKSA9PiBbXG4gICAgeyBubzogMSwgbmFtZTogXCJxdWFsaXR5XCIsIGtpbmQ6IFwiZW51bVwiLCBUOiBwcm90bzMuZ2V0RW51bVR5cGUoVmlkZW9RdWFsaXR5KSB9LFxuICAgIHsgbm86IDIsIG5hbWU6IFwiZW5hYmxlZFwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA4IC8qIFNjYWxhclR5cGUuQk9PTCAqLyB9LFxuICBdKTtcblxuICBzdGF0aWMgZnJvbUJpbmFyeShieXRlczogVWludDhBcnJheSwgb3B0aW9ucz86IFBhcnRpYWw8QmluYXJ5UmVhZE9wdGlvbnM+KTogU3Vic2NyaWJlZFF1YWxpdHkge1xuICAgIHJldHVybiBuZXcgU3Vic2NyaWJlZFF1YWxpdHkoKS5mcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tSnNvbihqc29uVmFsdWU6IEpzb25WYWx1ZSwgb3B0aW9ucz86IFBhcnRpYWw8SnNvblJlYWRPcHRpb25zPik6IFN1YnNjcmliZWRRdWFsaXR5IHtcbiAgICByZXR1cm4gbmV3IFN1YnNjcmliZWRRdWFsaXR5KCkuZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tSnNvblN0cmluZyhqc29uU3RyaW5nOiBzdHJpbmcsIG9wdGlvbnM/OiBQYXJ0aWFsPEpzb25SZWFkT3B0aW9ucz4pOiBTdWJzY3JpYmVkUXVhbGl0eSB7XG4gICAgcmV0dXJuIG5ldyBTdWJzY3JpYmVkUXVhbGl0eSgpLmZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpO1xuICB9XG5cbiAgc3RhdGljIGVxdWFscyhhOiBTdWJzY3JpYmVkUXVhbGl0eSB8IFBsYWluTWVzc2FnZTxTdWJzY3JpYmVkUXVhbGl0eT4gfCB1bmRlZmluZWQsIGI6IFN1YnNjcmliZWRRdWFsaXR5IHwgUGxhaW5NZXNzYWdlPFN1YnNjcmliZWRRdWFsaXR5PiB8IHVuZGVmaW5lZCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBwcm90bzMudXRpbC5lcXVhbHMoU3Vic2NyaWJlZFF1YWxpdHksIGEsIGIpO1xuICB9XG59XG5cbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgbGl2ZWtpdC5TdWJzY3JpYmVkQ29kZWNcbiAqL1xuZXhwb3J0IGNsYXNzIFN1YnNjcmliZWRDb2RlYyBleHRlbmRzIE1lc3NhZ2U8U3Vic2NyaWJlZENvZGVjPiB7XG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHN0cmluZyBjb2RlYyA9IDE7XG4gICAqL1xuICBjb2RlYyA9IFwiXCI7XG5cbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogcmVwZWF0ZWQgbGl2ZWtpdC5TdWJzY3JpYmVkUXVhbGl0eSBxdWFsaXRpZXMgPSAyO1xuICAgKi9cbiAgcXVhbGl0aWVzOiBTdWJzY3JpYmVkUXVhbGl0eVtdID0gW107XG5cbiAgY29uc3RydWN0b3IoZGF0YT86IFBhcnRpYWxNZXNzYWdlPFN1YnNjcmliZWRDb2RlYz4pIHtcbiAgICBzdXBlcigpO1xuICAgIHByb3RvMy51dGlsLmluaXRQYXJ0aWFsKGRhdGEsIHRoaXMpO1xuICB9XG5cbiAgc3RhdGljIHJlYWRvbmx5IHJ1bnRpbWU6IHR5cGVvZiBwcm90bzMgPSBwcm90bzM7XG4gIHN0YXRpYyByZWFkb25seSB0eXBlTmFtZSA9IFwibGl2ZWtpdC5TdWJzY3JpYmVkQ29kZWNcIjtcbiAgc3RhdGljIHJlYWRvbmx5IGZpZWxkczogRmllbGRMaXN0ID0gcHJvdG8zLnV0aWwubmV3RmllbGRMaXN0KCgpID0+IFtcbiAgICB7IG5vOiAxLCBuYW1lOiBcImNvZGVjXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi8gfSxcbiAgICB7IG5vOiAyLCBuYW1lOiBcInF1YWxpdGllc1wiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogU3Vic2NyaWJlZFF1YWxpdHksIHJlcGVhdGVkOiB0cnVlIH0sXG4gIF0pO1xuXG4gIHN0YXRpYyBmcm9tQmluYXJ5KGJ5dGVzOiBVaW50OEFycmF5LCBvcHRpb25zPzogUGFydGlhbDxCaW5hcnlSZWFkT3B0aW9ucz4pOiBTdWJzY3JpYmVkQ29kZWMge1xuICAgIHJldHVybiBuZXcgU3Vic2NyaWJlZENvZGVjKCkuZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucyk7XG4gIH1cblxuICBzdGF0aWMgZnJvbUpzb24oanNvblZhbHVlOiBKc29uVmFsdWUsIG9wdGlvbnM/OiBQYXJ0aWFsPEpzb25SZWFkT3B0aW9ucz4pOiBTdWJzY3JpYmVkQ29kZWMge1xuICAgIHJldHVybiBuZXcgU3Vic2NyaWJlZENvZGVjKCkuZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tSnNvblN0cmluZyhqc29uU3RyaW5nOiBzdHJpbmcsIG9wdGlvbnM/OiBQYXJ0aWFsPEpzb25SZWFkT3B0aW9ucz4pOiBTdWJzY3JpYmVkQ29kZWMge1xuICAgIHJldHVybiBuZXcgU3Vic2NyaWJlZENvZGVjKCkuZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucyk7XG4gIH1cblxuICBzdGF0aWMgZXF1YWxzKGE6IFN1YnNjcmliZWRDb2RlYyB8IFBsYWluTWVzc2FnZTxTdWJzY3JpYmVkQ29kZWM+IHwgdW5kZWZpbmVkLCBiOiBTdWJzY3JpYmVkQ29kZWMgfCBQbGFpbk1lc3NhZ2U8U3Vic2NyaWJlZENvZGVjPiB8IHVuZGVmaW5lZCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBwcm90bzMudXRpbC5lcXVhbHMoU3Vic2NyaWJlZENvZGVjLCBhLCBiKTtcbiAgfVxufVxuXG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBtZXNzYWdlIGxpdmVraXQuU3Vic2NyaWJlZFF1YWxpdHlVcGRhdGVcbiAqL1xuZXhwb3J0IGNsYXNzIFN1YnNjcmliZWRRdWFsaXR5VXBkYXRlIGV4dGVuZHMgTWVzc2FnZTxTdWJzY3JpYmVkUXVhbGl0eVVwZGF0ZT4ge1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBzdHJpbmcgdHJhY2tfc2lkID0gMTtcbiAgICovXG4gIHRyYWNrU2lkID0gXCJcIjtcblxuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiByZXBlYXRlZCBsaXZla2l0LlN1YnNjcmliZWRRdWFsaXR5IHN1YnNjcmliZWRfcXVhbGl0aWVzID0gMjtcbiAgICovXG4gIHN1YnNjcmliZWRRdWFsaXRpZXM6IFN1YnNjcmliZWRRdWFsaXR5W10gPSBbXTtcblxuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiByZXBlYXRlZCBsaXZla2l0LlN1YnNjcmliZWRDb2RlYyBzdWJzY3JpYmVkX2NvZGVjcyA9IDM7XG4gICAqL1xuICBzdWJzY3JpYmVkQ29kZWNzOiBTdWJzY3JpYmVkQ29kZWNbXSA9IFtdO1xuXG4gIGNvbnN0cnVjdG9yKGRhdGE/OiBQYXJ0aWFsTWVzc2FnZTxTdWJzY3JpYmVkUXVhbGl0eVVwZGF0ZT4pIHtcbiAgICBzdXBlcigpO1xuICAgIHByb3RvMy51dGlsLmluaXRQYXJ0aWFsKGRhdGEsIHRoaXMpO1xuICB9XG5cbiAgc3RhdGljIHJlYWRvbmx5IHJ1bnRpbWU6IHR5cGVvZiBwcm90bzMgPSBwcm90bzM7XG4gIHN0YXRpYyByZWFkb25seSB0eXBlTmFtZSA9IFwibGl2ZWtpdC5TdWJzY3JpYmVkUXVhbGl0eVVwZGF0ZVwiO1xuICBzdGF0aWMgcmVhZG9ubHkgZmllbGRzOiBGaWVsZExpc3QgPSBwcm90bzMudXRpbC5uZXdGaWVsZExpc3QoKCkgPT4gW1xuICAgIHsgbm86IDEsIG5hbWU6IFwidHJhY2tfc2lkXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi8gfSxcbiAgICB7IG5vOiAyLCBuYW1lOiBcInN1YnNjcmliZWRfcXVhbGl0aWVzXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBTdWJzY3JpYmVkUXVhbGl0eSwgcmVwZWF0ZWQ6IHRydWUgfSxcbiAgICB7IG5vOiAzLCBuYW1lOiBcInN1YnNjcmliZWRfY29kZWNzXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBTdWJzY3JpYmVkQ29kZWMsIHJlcGVhdGVkOiB0cnVlIH0sXG4gIF0pO1xuXG4gIHN0YXRpYyBmcm9tQmluYXJ5KGJ5dGVzOiBVaW50OEFycmF5LCBvcHRpb25zPzogUGFydGlhbDxCaW5hcnlSZWFkT3B0aW9ucz4pOiBTdWJzY3JpYmVkUXVhbGl0eVVwZGF0ZSB7XG4gICAgcmV0dXJuIG5ldyBTdWJzY3JpYmVkUXVhbGl0eVVwZGF0ZSgpLmZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpO1xuICB9XG5cbiAgc3RhdGljIGZyb21Kc29uKGpzb25WYWx1ZTogSnNvblZhbHVlLCBvcHRpb25zPzogUGFydGlhbDxKc29uUmVhZE9wdGlvbnM+KTogU3Vic2NyaWJlZFF1YWxpdHlVcGRhdGUge1xuICAgIHJldHVybiBuZXcgU3Vic2NyaWJlZFF1YWxpdHlVcGRhdGUoKS5mcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpO1xuICB9XG5cbiAgc3RhdGljIGZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmc6IHN0cmluZywgb3B0aW9ucz86IFBhcnRpYWw8SnNvblJlYWRPcHRpb25zPik6IFN1YnNjcmliZWRRdWFsaXR5VXBkYXRlIHtcbiAgICByZXR1cm4gbmV3IFN1YnNjcmliZWRRdWFsaXR5VXBkYXRlKCkuZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucyk7XG4gIH1cblxuICBzdGF0aWMgZXF1YWxzKGE6IFN1YnNjcmliZWRRdWFsaXR5VXBkYXRlIHwgUGxhaW5NZXNzYWdlPFN1YnNjcmliZWRRdWFsaXR5VXBkYXRlPiB8IHVuZGVmaW5lZCwgYjogU3Vic2NyaWJlZFF1YWxpdHlVcGRhdGUgfCBQbGFpbk1lc3NhZ2U8U3Vic2NyaWJlZFF1YWxpdHlVcGRhdGU+IHwgdW5kZWZpbmVkKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHByb3RvMy51dGlsLmVxdWFscyhTdWJzY3JpYmVkUXVhbGl0eVVwZGF0ZSwgYSwgYik7XG4gIH1cbn1cblxuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBsaXZla2l0LlRyYWNrUGVybWlzc2lvblxuICovXG5leHBvcnQgY2xhc3MgVHJhY2tQZXJtaXNzaW9uIGV4dGVuZHMgTWVzc2FnZTxUcmFja1Blcm1pc3Npb24+IHtcbiAgLyoqXG4gICAqIHBlcm1pc3Npb24gY291bGQgYmUgZ3JhbnRlZCBlaXRoZXIgYnkgcGFydGljaXBhbnQgc2lkIG9yIGlkZW50aXR5XG4gICAqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogc3RyaW5nIHBhcnRpY2lwYW50X3NpZCA9IDE7XG4gICAqL1xuICBwYXJ0aWNpcGFudFNpZCA9IFwiXCI7XG5cbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogYm9vbCBhbGxfdHJhY2tzID0gMjtcbiAgICovXG4gIGFsbFRyYWNrcyA9IGZhbHNlO1xuXG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHJlcGVhdGVkIHN0cmluZyB0cmFja19zaWRzID0gMztcbiAgICovXG4gIHRyYWNrU2lkczogc3RyaW5nW10gPSBbXTtcblxuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBzdHJpbmcgcGFydGljaXBhbnRfaWRlbnRpdHkgPSA0O1xuICAgKi9cbiAgcGFydGljaXBhbnRJZGVudGl0eSA9IFwiXCI7XG5cbiAgY29uc3RydWN0b3IoZGF0YT86IFBhcnRpYWxNZXNzYWdlPFRyYWNrUGVybWlzc2lvbj4pIHtcbiAgICBzdXBlcigpO1xuICAgIHByb3RvMy51dGlsLmluaXRQYXJ0aWFsKGRhdGEsIHRoaXMpO1xuICB9XG5cbiAgc3RhdGljIHJlYWRvbmx5IHJ1bnRpbWU6IHR5cGVvZiBwcm90bzMgPSBwcm90bzM7XG4gIHN0YXRpYyByZWFkb25seSB0eXBlTmFtZSA9IFwibGl2ZWtpdC5UcmFja1Blcm1pc3Npb25cIjtcbiAgc3RhdGljIHJlYWRvbmx5IGZpZWxkczogRmllbGRMaXN0ID0gcHJvdG8zLnV0aWwubmV3RmllbGRMaXN0KCgpID0+IFtcbiAgICB7IG5vOiAxLCBuYW1lOiBcInBhcnRpY2lwYW50X3NpZFwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovIH0sXG4gICAgeyBubzogMiwgbmFtZTogXCJhbGxfdHJhY2tzXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDggLyogU2NhbGFyVHlwZS5CT09MICovIH0sXG4gICAgeyBubzogMywgbmFtZTogXCJ0cmFja19zaWRzXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi8sIHJlcGVhdGVkOiB0cnVlIH0sXG4gICAgeyBubzogNCwgbmFtZTogXCJwYXJ0aWNpcGFudF9pZGVudGl0eVwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovIH0sXG4gIF0pO1xuXG4gIHN0YXRpYyBmcm9tQmluYXJ5KGJ5dGVzOiBVaW50OEFycmF5LCBvcHRpb25zPzogUGFydGlhbDxCaW5hcnlSZWFkT3B0aW9ucz4pOiBUcmFja1Blcm1pc3Npb24ge1xuICAgIHJldHVybiBuZXcgVHJhY2tQZXJtaXNzaW9uKCkuZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucyk7XG4gIH1cblxuICBzdGF0aWMgZnJvbUpzb24oanNvblZhbHVlOiBKc29uVmFsdWUsIG9wdGlvbnM/OiBQYXJ0aWFsPEpzb25SZWFkT3B0aW9ucz4pOiBUcmFja1Blcm1pc3Npb24ge1xuICAgIHJldHVybiBuZXcgVHJhY2tQZXJtaXNzaW9uKCkuZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tSnNvblN0cmluZyhqc29uU3RyaW5nOiBzdHJpbmcsIG9wdGlvbnM/OiBQYXJ0aWFsPEpzb25SZWFkT3B0aW9ucz4pOiBUcmFja1Blcm1pc3Npb24ge1xuICAgIHJldHVybiBuZXcgVHJhY2tQZXJtaXNzaW9uKCkuZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucyk7XG4gIH1cblxuICBzdGF0aWMgZXF1YWxzKGE6IFRyYWNrUGVybWlzc2lvbiB8IFBsYWluTWVzc2FnZTxUcmFja1Blcm1pc3Npb24+IHwgdW5kZWZpbmVkLCBiOiBUcmFja1Blcm1pc3Npb24gfCBQbGFpbk1lc3NhZ2U8VHJhY2tQZXJtaXNzaW9uPiB8IHVuZGVmaW5lZCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBwcm90bzMudXRpbC5lcXVhbHMoVHJhY2tQZXJtaXNzaW9uLCBhLCBiKTtcbiAgfVxufVxuXG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBtZXNzYWdlIGxpdmVraXQuU3Vic2NyaXB0aW9uUGVybWlzc2lvblxuICovXG5leHBvcnQgY2xhc3MgU3Vic2NyaXB0aW9uUGVybWlzc2lvbiBleHRlbmRzIE1lc3NhZ2U8U3Vic2NyaXB0aW9uUGVybWlzc2lvbj4ge1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBib29sIGFsbF9wYXJ0aWNpcGFudHMgPSAxO1xuICAgKi9cbiAgYWxsUGFydGljaXBhbnRzID0gZmFsc2U7XG5cbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogcmVwZWF0ZWQgbGl2ZWtpdC5UcmFja1Blcm1pc3Npb24gdHJhY2tfcGVybWlzc2lvbnMgPSAyO1xuICAgKi9cbiAgdHJhY2tQZXJtaXNzaW9uczogVHJhY2tQZXJtaXNzaW9uW10gPSBbXTtcblxuICBjb25zdHJ1Y3RvcihkYXRhPzogUGFydGlhbE1lc3NhZ2U8U3Vic2NyaXB0aW9uUGVybWlzc2lvbj4pIHtcbiAgICBzdXBlcigpO1xuICAgIHByb3RvMy51dGlsLmluaXRQYXJ0aWFsKGRhdGEsIHRoaXMpO1xuICB9XG5cbiAgc3RhdGljIHJlYWRvbmx5IHJ1bnRpbWU6IHR5cGVvZiBwcm90bzMgPSBwcm90bzM7XG4gIHN0YXRpYyByZWFkb25seSB0eXBlTmFtZSA9IFwibGl2ZWtpdC5TdWJzY3JpcHRpb25QZXJtaXNzaW9uXCI7XG4gIHN0YXRpYyByZWFkb25seSBmaWVsZHM6IEZpZWxkTGlzdCA9IHByb3RvMy51dGlsLm5ld0ZpZWxkTGlzdCgoKSA9PiBbXG4gICAgeyBubzogMSwgbmFtZTogXCJhbGxfcGFydGljaXBhbnRzXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDggLyogU2NhbGFyVHlwZS5CT09MICovIH0sXG4gICAgeyBubzogMiwgbmFtZTogXCJ0cmFja19wZXJtaXNzaW9uc1wiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogVHJhY2tQZXJtaXNzaW9uLCByZXBlYXRlZDogdHJ1ZSB9LFxuICBdKTtcblxuICBzdGF0aWMgZnJvbUJpbmFyeShieXRlczogVWludDhBcnJheSwgb3B0aW9ucz86IFBhcnRpYWw8QmluYXJ5UmVhZE9wdGlvbnM+KTogU3Vic2NyaXB0aW9uUGVybWlzc2lvbiB7XG4gICAgcmV0dXJuIG5ldyBTdWJzY3JpcHRpb25QZXJtaXNzaW9uKCkuZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucyk7XG4gIH1cblxuICBzdGF0aWMgZnJvbUpzb24oanNvblZhbHVlOiBKc29uVmFsdWUsIG9wdGlvbnM/OiBQYXJ0aWFsPEpzb25SZWFkT3B0aW9ucz4pOiBTdWJzY3JpcHRpb25QZXJtaXNzaW9uIHtcbiAgICByZXR1cm4gbmV3IFN1YnNjcmlwdGlvblBlcm1pc3Npb24oKS5mcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpO1xuICB9XG5cbiAgc3RhdGljIGZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmc6IHN0cmluZywgb3B0aW9ucz86IFBhcnRpYWw8SnNvblJlYWRPcHRpb25zPik6IFN1YnNjcmlwdGlvblBlcm1pc3Npb24ge1xuICAgIHJldHVybiBuZXcgU3Vic2NyaXB0aW9uUGVybWlzc2lvbigpLmZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpO1xuICB9XG5cbiAgc3RhdGljIGVxdWFscyhhOiBTdWJzY3JpcHRpb25QZXJtaXNzaW9uIHwgUGxhaW5NZXNzYWdlPFN1YnNjcmlwdGlvblBlcm1pc3Npb24+IHwgdW5kZWZpbmVkLCBiOiBTdWJzY3JpcHRpb25QZXJtaXNzaW9uIHwgUGxhaW5NZXNzYWdlPFN1YnNjcmlwdGlvblBlcm1pc3Npb24+IHwgdW5kZWZpbmVkKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHByb3RvMy51dGlsLmVxdWFscyhTdWJzY3JpcHRpb25QZXJtaXNzaW9uLCBhLCBiKTtcbiAgfVxufVxuXG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBtZXNzYWdlIGxpdmVraXQuU3Vic2NyaXB0aW9uUGVybWlzc2lvblVwZGF0ZVxuICovXG5leHBvcnQgY2xhc3MgU3Vic2NyaXB0aW9uUGVybWlzc2lvblVwZGF0ZSBleHRlbmRzIE1lc3NhZ2U8U3Vic2NyaXB0aW9uUGVybWlzc2lvblVwZGF0ZT4ge1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBzdHJpbmcgcGFydGljaXBhbnRfc2lkID0gMTtcbiAgICovXG4gIHBhcnRpY2lwYW50U2lkID0gXCJcIjtcblxuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBzdHJpbmcgdHJhY2tfc2lkID0gMjtcbiAgICovXG4gIHRyYWNrU2lkID0gXCJcIjtcblxuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBib29sIGFsbG93ZWQgPSAzO1xuICAgKi9cbiAgYWxsb3dlZCA9IGZhbHNlO1xuXG4gIGNvbnN0cnVjdG9yKGRhdGE/OiBQYXJ0aWFsTWVzc2FnZTxTdWJzY3JpcHRpb25QZXJtaXNzaW9uVXBkYXRlPikge1xuICAgIHN1cGVyKCk7XG4gICAgcHJvdG8zLnV0aWwuaW5pdFBhcnRpYWwoZGF0YSwgdGhpcyk7XG4gIH1cblxuICBzdGF0aWMgcmVhZG9ubHkgcnVudGltZTogdHlwZW9mIHByb3RvMyA9IHByb3RvMztcbiAgc3RhdGljIHJlYWRvbmx5IHR5cGVOYW1lID0gXCJsaXZla2l0LlN1YnNjcmlwdGlvblBlcm1pc3Npb25VcGRhdGVcIjtcbiAgc3RhdGljIHJlYWRvbmx5IGZpZWxkczogRmllbGRMaXN0ID0gcHJvdG8zLnV0aWwubmV3RmllbGRMaXN0KCgpID0+IFtcbiAgICB7IG5vOiAxLCBuYW1lOiBcInBhcnRpY2lwYW50X3NpZFwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovIH0sXG4gICAgeyBubzogMiwgbmFtZTogXCJ0cmFja19zaWRcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqLyB9LFxuICAgIHsgbm86IDMsIG5hbWU6IFwiYWxsb3dlZFwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA4IC8qIFNjYWxhclR5cGUuQk9PTCAqLyB9LFxuICBdKTtcblxuICBzdGF0aWMgZnJvbUJpbmFyeShieXRlczogVWludDhBcnJheSwgb3B0aW9ucz86IFBhcnRpYWw8QmluYXJ5UmVhZE9wdGlvbnM+KTogU3Vic2NyaXB0aW9uUGVybWlzc2lvblVwZGF0ZSB7XG4gICAgcmV0dXJuIG5ldyBTdWJzY3JpcHRpb25QZXJtaXNzaW9uVXBkYXRlKCkuZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucyk7XG4gIH1cblxuICBzdGF0aWMgZnJvbUpzb24oanNvblZhbHVlOiBKc29uVmFsdWUsIG9wdGlvbnM/OiBQYXJ0aWFsPEpzb25SZWFkT3B0aW9ucz4pOiBTdWJzY3JpcHRpb25QZXJtaXNzaW9uVXBkYXRlIHtcbiAgICByZXR1cm4gbmV3IFN1YnNjcmlwdGlvblBlcm1pc3Npb25VcGRhdGUoKS5mcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpO1xuICB9XG5cbiAgc3RhdGljIGZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmc6IHN0cmluZywgb3B0aW9ucz86IFBhcnRpYWw8SnNvblJlYWRPcHRpb25zPik6IFN1YnNjcmlwdGlvblBlcm1pc3Npb25VcGRhdGUge1xuICAgIHJldHVybiBuZXcgU3Vic2NyaXB0aW9uUGVybWlzc2lvblVwZGF0ZSgpLmZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpO1xuICB9XG5cbiAgc3RhdGljIGVxdWFscyhhOiBTdWJzY3JpcHRpb25QZXJtaXNzaW9uVXBkYXRlIHwgUGxhaW5NZXNzYWdlPFN1YnNjcmlwdGlvblBlcm1pc3Npb25VcGRhdGU+IHwgdW5kZWZpbmVkLCBiOiBTdWJzY3JpcHRpb25QZXJtaXNzaW9uVXBkYXRlIHwgUGxhaW5NZXNzYWdlPFN1YnNjcmlwdGlvblBlcm1pc3Npb25VcGRhdGU+IHwgdW5kZWZpbmVkKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHByb3RvMy51dGlsLmVxdWFscyhTdWJzY3JpcHRpb25QZXJtaXNzaW9uVXBkYXRlLCBhLCBiKTtcbiAgfVxufVxuXG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBtZXNzYWdlIGxpdmVraXQuU3luY1N0YXRlXG4gKi9cbmV4cG9ydCBjbGFzcyBTeW5jU3RhdGUgZXh0ZW5kcyBNZXNzYWdlPFN5bmNTdGF0ZT4ge1xuICAvKipcbiAgICogbGFzdCBzdWJzY3JpYmUgYW5zd2VyIGJlZm9yZSByZWNvbm5lY3RpbmdcbiAgICpcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBsaXZla2l0LlNlc3Npb25EZXNjcmlwdGlvbiBhbnN3ZXIgPSAxO1xuICAgKi9cbiAgYW5zd2VyPzogU2Vzc2lvbkRlc2NyaXB0aW9uO1xuXG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGxpdmVraXQuVXBkYXRlU3Vic2NyaXB0aW9uIHN1YnNjcmlwdGlvbiA9IDI7XG4gICAqL1xuICBzdWJzY3JpcHRpb24/OiBVcGRhdGVTdWJzY3JpcHRpb247XG5cbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogcmVwZWF0ZWQgbGl2ZWtpdC5UcmFja1B1Ymxpc2hlZFJlc3BvbnNlIHB1Ymxpc2hfdHJhY2tzID0gMztcbiAgICovXG4gIHB1Ymxpc2hUcmFja3M6IFRyYWNrUHVibGlzaGVkUmVzcG9uc2VbXSA9IFtdO1xuXG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHJlcGVhdGVkIGxpdmVraXQuRGF0YUNoYW5uZWxJbmZvIGRhdGFfY2hhbm5lbHMgPSA0O1xuICAgKi9cbiAgZGF0YUNoYW5uZWxzOiBEYXRhQ2hhbm5lbEluZm9bXSA9IFtdO1xuXG4gIC8qKlxuICAgKiBsYXN0IHJlY2VpdmVkIHNlcnZlciBzaWRlIG9mZmVyIGJlZm9yZSByZWNvbm5lY3RpbmdcbiAgICpcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBsaXZla2l0LlNlc3Npb25EZXNjcmlwdGlvbiBvZmZlciA9IDU7XG4gICAqL1xuICBvZmZlcj86IFNlc3Npb25EZXNjcmlwdGlvbjtcblxuICBjb25zdHJ1Y3RvcihkYXRhPzogUGFydGlhbE1lc3NhZ2U8U3luY1N0YXRlPikge1xuICAgIHN1cGVyKCk7XG4gICAgcHJvdG8zLnV0aWwuaW5pdFBhcnRpYWwoZGF0YSwgdGhpcyk7XG4gIH1cblxuICBzdGF0aWMgcmVhZG9ubHkgcnVudGltZTogdHlwZW9mIHByb3RvMyA9IHByb3RvMztcbiAgc3RhdGljIHJlYWRvbmx5IHR5cGVOYW1lID0gXCJsaXZla2l0LlN5bmNTdGF0ZVwiO1xuICBzdGF0aWMgcmVhZG9ubHkgZmllbGRzOiBGaWVsZExpc3QgPSBwcm90bzMudXRpbC5uZXdGaWVsZExpc3QoKCkgPT4gW1xuICAgIHsgbm86IDEsIG5hbWU6IFwiYW5zd2VyXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBTZXNzaW9uRGVzY3JpcHRpb24gfSxcbiAgICB7IG5vOiAyLCBuYW1lOiBcInN1YnNjcmlwdGlvblwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogVXBkYXRlU3Vic2NyaXB0aW9uIH0sXG4gICAgeyBubzogMywgbmFtZTogXCJwdWJsaXNoX3RyYWNrc1wiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogVHJhY2tQdWJsaXNoZWRSZXNwb25zZSwgcmVwZWF0ZWQ6IHRydWUgfSxcbiAgICB7IG5vOiA0LCBuYW1lOiBcImRhdGFfY2hhbm5lbHNcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IERhdGFDaGFubmVsSW5mbywgcmVwZWF0ZWQ6IHRydWUgfSxcbiAgICB7IG5vOiA1LCBuYW1lOiBcIm9mZmVyXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBTZXNzaW9uRGVzY3JpcHRpb24gfSxcbiAgXSk7XG5cbiAgc3RhdGljIGZyb21CaW5hcnkoYnl0ZXM6IFVpbnQ4QXJyYXksIG9wdGlvbnM/OiBQYXJ0aWFsPEJpbmFyeVJlYWRPcHRpb25zPik6IFN5bmNTdGF0ZSB7XG4gICAgcmV0dXJuIG5ldyBTeW5jU3RhdGUoKS5mcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tSnNvbihqc29uVmFsdWU6IEpzb25WYWx1ZSwgb3B0aW9ucz86IFBhcnRpYWw8SnNvblJlYWRPcHRpb25zPik6IFN5bmNTdGF0ZSB7XG4gICAgcmV0dXJuIG5ldyBTeW5jU3RhdGUoKS5mcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpO1xuICB9XG5cbiAgc3RhdGljIGZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmc6IHN0cmluZywgb3B0aW9ucz86IFBhcnRpYWw8SnNvblJlYWRPcHRpb25zPik6IFN5bmNTdGF0ZSB7XG4gICAgcmV0dXJuIG5ldyBTeW5jU3RhdGUoKS5mcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKTtcbiAgfVxuXG4gIHN0YXRpYyBlcXVhbHMoYTogU3luY1N0YXRlIHwgUGxhaW5NZXNzYWdlPFN5bmNTdGF0ZT4gfCB1bmRlZmluZWQsIGI6IFN5bmNTdGF0ZSB8IFBsYWluTWVzc2FnZTxTeW5jU3RhdGU+IHwgdW5kZWZpbmVkKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHByb3RvMy51dGlsLmVxdWFscyhTeW5jU3RhdGUsIGEsIGIpO1xuICB9XG59XG5cbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgbGl2ZWtpdC5EYXRhQ2hhbm5lbEluZm9cbiAqL1xuZXhwb3J0IGNsYXNzIERhdGFDaGFubmVsSW5mbyBleHRlbmRzIE1lc3NhZ2U8RGF0YUNoYW5uZWxJbmZvPiB7XG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHN0cmluZyBsYWJlbCA9IDE7XG4gICAqL1xuICBsYWJlbCA9IFwiXCI7XG5cbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogdWludDMyIGlkID0gMjtcbiAgICovXG4gIGlkID0gMDtcblxuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBsaXZla2l0LlNpZ25hbFRhcmdldCB0YXJnZXQgPSAzO1xuICAgKi9cbiAgdGFyZ2V0ID0gU2lnbmFsVGFyZ2V0LlBVQkxJU0hFUjtcblxuICBjb25zdHJ1Y3RvcihkYXRhPzogUGFydGlhbE1lc3NhZ2U8RGF0YUNoYW5uZWxJbmZvPikge1xuICAgIHN1cGVyKCk7XG4gICAgcHJvdG8zLnV0aWwuaW5pdFBhcnRpYWwoZGF0YSwgdGhpcyk7XG4gIH1cblxuICBzdGF0aWMgcmVhZG9ubHkgcnVudGltZTogdHlwZW9mIHByb3RvMyA9IHByb3RvMztcbiAgc3RhdGljIHJlYWRvbmx5IHR5cGVOYW1lID0gXCJsaXZla2l0LkRhdGFDaGFubmVsSW5mb1wiO1xuICBzdGF0aWMgcmVhZG9ubHkgZmllbGRzOiBGaWVsZExpc3QgPSBwcm90bzMudXRpbC5uZXdGaWVsZExpc3QoKCkgPT4gW1xuICAgIHsgbm86IDEsIG5hbWU6IFwibGFiZWxcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqLyB9LFxuICAgIHsgbm86IDIsIG5hbWU6IFwiaWRcIiwga2luZDogXCJzY2FsYXJcIiwgVDogMTMgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi8gfSxcbiAgICB7IG5vOiAzLCBuYW1lOiBcInRhcmdldFwiLCBraW5kOiBcImVudW1cIiwgVDogcHJvdG8zLmdldEVudW1UeXBlKFNpZ25hbFRhcmdldCkgfSxcbiAgXSk7XG5cbiAgc3RhdGljIGZyb21CaW5hcnkoYnl0ZXM6IFVpbnQ4QXJyYXksIG9wdGlvbnM/OiBQYXJ0aWFsPEJpbmFyeVJlYWRPcHRpb25zPik6IERhdGFDaGFubmVsSW5mbyB7XG4gICAgcmV0dXJuIG5ldyBEYXRhQ2hhbm5lbEluZm8oKS5mcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tSnNvbihqc29uVmFsdWU6IEpzb25WYWx1ZSwgb3B0aW9ucz86IFBhcnRpYWw8SnNvblJlYWRPcHRpb25zPik6IERhdGFDaGFubmVsSW5mbyB7XG4gICAgcmV0dXJuIG5ldyBEYXRhQ2hhbm5lbEluZm8oKS5mcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpO1xuICB9XG5cbiAgc3RhdGljIGZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmc6IHN0cmluZywgb3B0aW9ucz86IFBhcnRpYWw8SnNvblJlYWRPcHRpb25zPik6IERhdGFDaGFubmVsSW5mbyB7XG4gICAgcmV0dXJuIG5ldyBEYXRhQ2hhbm5lbEluZm8oKS5mcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKTtcbiAgfVxuXG4gIHN0YXRpYyBlcXVhbHMoYTogRGF0YUNoYW5uZWxJbmZvIHwgUGxhaW5NZXNzYWdlPERhdGFDaGFubmVsSW5mbz4gfCB1bmRlZmluZWQsIGI6IERhdGFDaGFubmVsSW5mbyB8IFBsYWluTWVzc2FnZTxEYXRhQ2hhbm5lbEluZm8+IHwgdW5kZWZpbmVkKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHByb3RvMy51dGlsLmVxdWFscyhEYXRhQ2hhbm5lbEluZm8sIGEsIGIpO1xuICB9XG59XG5cbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgbGl2ZWtpdC5TaW11bGF0ZVNjZW5hcmlvXG4gKi9cbmV4cG9ydCBjbGFzcyBTaW11bGF0ZVNjZW5hcmlvIGV4dGVuZHMgTWVzc2FnZTxTaW11bGF0ZVNjZW5hcmlvPiB7XG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gb25lb2YgbGl2ZWtpdC5TaW11bGF0ZVNjZW5hcmlvLnNjZW5hcmlvXG4gICAqL1xuICBzY2VuYXJpbzoge1xuICAgIC8qKlxuICAgICAqIHNpbXVsYXRlIE4gc2Vjb25kcyBvZiBzcGVha2VyIGFjdGl2aXR5XG4gICAgICpcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGludDMyIHNwZWFrZXJfdXBkYXRlID0gMTtcbiAgICAgKi9cbiAgICB2YWx1ZTogbnVtYmVyO1xuICAgIGNhc2U6IFwic3BlYWtlclVwZGF0ZVwiO1xuICB9IHwge1xuICAgIC8qKlxuICAgICAqIHNpbXVsYXRlIGxvY2FsIG5vZGUgZmFpbHVyZVxuICAgICAqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBib29sIG5vZGVfZmFpbHVyZSA9IDI7XG4gICAgICovXG4gICAgdmFsdWU6IGJvb2xlYW47XG4gICAgY2FzZTogXCJub2RlRmFpbHVyZVwiO1xuICB9IHwge1xuICAgIC8qKlxuICAgICAqIHNpbXVsYXRlIG1pZ3JhdGlvblxuICAgICAqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBib29sIG1pZ3JhdGlvbiA9IDM7XG4gICAgICovXG4gICAgdmFsdWU6IGJvb2xlYW47XG4gICAgY2FzZTogXCJtaWdyYXRpb25cIjtcbiAgfSB8IHtcbiAgICAvKipcbiAgICAgKiBzZXJ2ZXIgdG8gc2VuZCBsZWF2ZVxuICAgICAqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBib29sIHNlcnZlcl9sZWF2ZSA9IDQ7XG4gICAgICovXG4gICAgdmFsdWU6IGJvb2xlYW47XG4gICAgY2FzZTogXCJzZXJ2ZXJMZWF2ZVwiO1xuICB9IHwge1xuICAgIC8qKlxuICAgICAqIHN3aXRjaCBjYW5kaWRhdGUgcHJvdG9jb2wgdG8gdGNwXG4gICAgICpcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGxpdmVraXQuQ2FuZGlkYXRlUHJvdG9jb2wgc3dpdGNoX2NhbmRpZGF0ZV9wcm90b2NvbCA9IDU7XG4gICAgICovXG4gICAgdmFsdWU6IENhbmRpZGF0ZVByb3RvY29sO1xuICAgIGNhc2U6IFwic3dpdGNoQ2FuZGlkYXRlUHJvdG9jb2xcIjtcbiAgfSB8IHtcbiAgICAvKipcbiAgICAgKiBtYXhpbXVtIGJhbmR3aWR0aCBmb3Igc3Vic2NyaWJlcnMsIGluIGJwc1xuICAgICAqIHdoZW4gemVybywgY2xlYXJzIGFydGlmaWNpYWwgYmFuZHdpZHRoIGxpbWl0XG4gICAgICpcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGludDY0IHN1YnNjcmliZXJfYmFuZHdpZHRoID0gNjtcbiAgICAgKi9cbiAgICB2YWx1ZTogYmlnaW50O1xuICAgIGNhc2U6IFwic3Vic2NyaWJlckJhbmR3aWR0aFwiO1xuICB9IHwge1xuICAgIC8qKlxuICAgICAqIGRpc2Nvbm5lY3Qgc2lnbmFsIG9uIHJlc3VtZVxuICAgICAqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBib29sIGRpc2Nvbm5lY3Rfc2lnbmFsX29uX3Jlc3VtZSA9IDc7XG4gICAgICovXG4gICAgdmFsdWU6IGJvb2xlYW47XG4gICAgY2FzZTogXCJkaXNjb25uZWN0U2lnbmFsT25SZXN1bWVcIjtcbiAgfSB8IHtcbiAgICAvKipcbiAgICAgKiBkaXNjb25uZWN0IHNpZ25hbCBvbiByZXN1bWUgYmVmb3JlIHNlbmRpbmcgYW55IG1lc3NhZ2VzIGZyb20gc2VydmVyXG4gICAgICpcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGJvb2wgZGlzY29ubmVjdF9zaWduYWxfb25fcmVzdW1lX25vX21lc3NhZ2VzID0gODtcbiAgICAgKi9cbiAgICB2YWx1ZTogYm9vbGVhbjtcbiAgICBjYXNlOiBcImRpc2Nvbm5lY3RTaWduYWxPblJlc3VtZU5vTWVzc2FnZXNcIjtcbiAgfSB8IHsgY2FzZTogdW5kZWZpbmVkOyB2YWx1ZT86IHVuZGVmaW5lZCB9ID0geyBjYXNlOiB1bmRlZmluZWQgfTtcblxuICBjb25zdHJ1Y3RvcihkYXRhPzogUGFydGlhbE1lc3NhZ2U8U2ltdWxhdGVTY2VuYXJpbz4pIHtcbiAgICBzdXBlcigpO1xuICAgIHByb3RvMy51dGlsLmluaXRQYXJ0aWFsKGRhdGEsIHRoaXMpO1xuICB9XG5cbiAgc3RhdGljIHJlYWRvbmx5IHJ1bnRpbWU6IHR5cGVvZiBwcm90bzMgPSBwcm90bzM7XG4gIHN0YXRpYyByZWFkb25seSB0eXBlTmFtZSA9IFwibGl2ZWtpdC5TaW11bGF0ZVNjZW5hcmlvXCI7XG4gIHN0YXRpYyByZWFkb25seSBmaWVsZHM6IEZpZWxkTGlzdCA9IHByb3RvMy51dGlsLm5ld0ZpZWxkTGlzdCgoKSA9PiBbXG4gICAgeyBubzogMSwgbmFtZTogXCJzcGVha2VyX3VwZGF0ZVwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA1IC8qIFNjYWxhclR5cGUuSU5UMzIgKi8sIG9uZW9mOiBcInNjZW5hcmlvXCIgfSxcbiAgICB7IG5vOiAyLCBuYW1lOiBcIm5vZGVfZmFpbHVyZVwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA4IC8qIFNjYWxhclR5cGUuQk9PTCAqLywgb25lb2Y6IFwic2NlbmFyaW9cIiB9LFxuICAgIHsgbm86IDMsIG5hbWU6IFwibWlncmF0aW9uXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDggLyogU2NhbGFyVHlwZS5CT09MICovLCBvbmVvZjogXCJzY2VuYXJpb1wiIH0sXG4gICAgeyBubzogNCwgbmFtZTogXCJzZXJ2ZXJfbGVhdmVcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOCAvKiBTY2FsYXJUeXBlLkJPT0wgKi8sIG9uZW9mOiBcInNjZW5hcmlvXCIgfSxcbiAgICB7IG5vOiA1LCBuYW1lOiBcInN3aXRjaF9jYW5kaWRhdGVfcHJvdG9jb2xcIiwga2luZDogXCJlbnVtXCIsIFQ6IHByb3RvMy5nZXRFbnVtVHlwZShDYW5kaWRhdGVQcm90b2NvbCksIG9uZW9mOiBcInNjZW5hcmlvXCIgfSxcbiAgICB7IG5vOiA2LCBuYW1lOiBcInN1YnNjcmliZXJfYmFuZHdpZHRoXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDMgLyogU2NhbGFyVHlwZS5JTlQ2NCAqLywgb25lb2Y6IFwic2NlbmFyaW9cIiB9LFxuICAgIHsgbm86IDcsIG5hbWU6IFwiZGlzY29ubmVjdF9zaWduYWxfb25fcmVzdW1lXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDggLyogU2NhbGFyVHlwZS5CT09MICovLCBvbmVvZjogXCJzY2VuYXJpb1wiIH0sXG4gICAgeyBubzogOCwgbmFtZTogXCJkaXNjb25uZWN0X3NpZ25hbF9vbl9yZXN1bWVfbm9fbWVzc2FnZXNcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOCAvKiBTY2FsYXJUeXBlLkJPT0wgKi8sIG9uZW9mOiBcInNjZW5hcmlvXCIgfSxcbiAgXSk7XG5cbiAgc3RhdGljIGZyb21CaW5hcnkoYnl0ZXM6IFVpbnQ4QXJyYXksIG9wdGlvbnM/OiBQYXJ0aWFsPEJpbmFyeVJlYWRPcHRpb25zPik6IFNpbXVsYXRlU2NlbmFyaW8ge1xuICAgIHJldHVybiBuZXcgU2ltdWxhdGVTY2VuYXJpbygpLmZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpO1xuICB9XG5cbiAgc3RhdGljIGZyb21Kc29uKGpzb25WYWx1ZTogSnNvblZhbHVlLCBvcHRpb25zPzogUGFydGlhbDxKc29uUmVhZE9wdGlvbnM+KTogU2ltdWxhdGVTY2VuYXJpbyB7XG4gICAgcmV0dXJuIG5ldyBTaW11bGF0ZVNjZW5hcmlvKCkuZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tSnNvblN0cmluZyhqc29uU3RyaW5nOiBzdHJpbmcsIG9wdGlvbnM/OiBQYXJ0aWFsPEpzb25SZWFkT3B0aW9ucz4pOiBTaW11bGF0ZVNjZW5hcmlvIHtcbiAgICByZXR1cm4gbmV3IFNpbXVsYXRlU2NlbmFyaW8oKS5mcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKTtcbiAgfVxuXG4gIHN0YXRpYyBlcXVhbHMoYTogU2ltdWxhdGVTY2VuYXJpbyB8IFBsYWluTWVzc2FnZTxTaW11bGF0ZVNjZW5hcmlvPiB8IHVuZGVmaW5lZCwgYjogU2ltdWxhdGVTY2VuYXJpbyB8IFBsYWluTWVzc2FnZTxTaW11bGF0ZVNjZW5hcmlvPiB8IHVuZGVmaW5lZCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBwcm90bzMudXRpbC5lcXVhbHMoU2ltdWxhdGVTY2VuYXJpbywgYSwgYik7XG4gIH1cbn1cblxuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBsaXZla2l0LlBpbmdcbiAqL1xuZXhwb3J0IGNsYXNzIFBpbmcgZXh0ZW5kcyBNZXNzYWdlPFBpbmc+IHtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogaW50NjQgdGltZXN0YW1wID0gMTtcbiAgICovXG4gIHRpbWVzdGFtcCA9IHByb3RvSW50NjQuemVybztcblxuICAvKipcbiAgICogcnR0IGluIG1pbGxpc2Vjb25kcyBjYWxjdWxhdGVkIGJ5IGNsaWVudFxuICAgKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGludDY0IHJ0dCA9IDI7XG4gICAqL1xuICBydHQgPSBwcm90b0ludDY0Lnplcm87XG5cbiAgY29uc3RydWN0b3IoZGF0YT86IFBhcnRpYWxNZXNzYWdlPFBpbmc+KSB7XG4gICAgc3VwZXIoKTtcbiAgICBwcm90bzMudXRpbC5pbml0UGFydGlhbChkYXRhLCB0aGlzKTtcbiAgfVxuXG4gIHN0YXRpYyByZWFkb25seSBydW50aW1lOiB0eXBlb2YgcHJvdG8zID0gcHJvdG8zO1xuICBzdGF0aWMgcmVhZG9ubHkgdHlwZU5hbWUgPSBcImxpdmVraXQuUGluZ1wiO1xuICBzdGF0aWMgcmVhZG9ubHkgZmllbGRzOiBGaWVsZExpc3QgPSBwcm90bzMudXRpbC5uZXdGaWVsZExpc3QoKCkgPT4gW1xuICAgIHsgbm86IDEsIG5hbWU6IFwidGltZXN0YW1wXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDMgLyogU2NhbGFyVHlwZS5JTlQ2NCAqLyB9LFxuICAgIHsgbm86IDIsIG5hbWU6IFwicnR0XCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDMgLyogU2NhbGFyVHlwZS5JTlQ2NCAqLyB9LFxuICBdKTtcblxuICBzdGF0aWMgZnJvbUJpbmFyeShieXRlczogVWludDhBcnJheSwgb3B0aW9ucz86IFBhcnRpYWw8QmluYXJ5UmVhZE9wdGlvbnM+KTogUGluZyB7XG4gICAgcmV0dXJuIG5ldyBQaW5nKCkuZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucyk7XG4gIH1cblxuICBzdGF0aWMgZnJvbUpzb24oanNvblZhbHVlOiBKc29uVmFsdWUsIG9wdGlvbnM/OiBQYXJ0aWFsPEpzb25SZWFkT3B0aW9ucz4pOiBQaW5nIHtcbiAgICByZXR1cm4gbmV3IFBpbmcoKS5mcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpO1xuICB9XG5cbiAgc3RhdGljIGZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmc6IHN0cmluZywgb3B0aW9ucz86IFBhcnRpYWw8SnNvblJlYWRPcHRpb25zPik6IFBpbmcge1xuICAgIHJldHVybiBuZXcgUGluZygpLmZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpO1xuICB9XG5cbiAgc3RhdGljIGVxdWFscyhhOiBQaW5nIHwgUGxhaW5NZXNzYWdlPFBpbmc+IHwgdW5kZWZpbmVkLCBiOiBQaW5nIHwgUGxhaW5NZXNzYWdlPFBpbmc+IHwgdW5kZWZpbmVkKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHByb3RvMy51dGlsLmVxdWFscyhQaW5nLCBhLCBiKTtcbiAgfVxufVxuXG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBtZXNzYWdlIGxpdmVraXQuUG9uZ1xuICovXG5leHBvcnQgY2xhc3MgUG9uZyBleHRlbmRzIE1lc3NhZ2U8UG9uZz4ge1xuICAvKipcbiAgICogdGltZXN0YW1wIGZpZWxkIG9mIGxhc3QgcmVjZWl2ZWQgcGluZyByZXF1ZXN0XG4gICAqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogaW50NjQgbGFzdF9waW5nX3RpbWVzdGFtcCA9IDE7XG4gICAqL1xuICBsYXN0UGluZ1RpbWVzdGFtcCA9IHByb3RvSW50NjQuemVybztcblxuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBpbnQ2NCB0aW1lc3RhbXAgPSAyO1xuICAgKi9cbiAgdGltZXN0YW1wID0gcHJvdG9JbnQ2NC56ZXJvO1xuXG4gIGNvbnN0cnVjdG9yKGRhdGE/OiBQYXJ0aWFsTWVzc2FnZTxQb25nPikge1xuICAgIHN1cGVyKCk7XG4gICAgcHJvdG8zLnV0aWwuaW5pdFBhcnRpYWwoZGF0YSwgdGhpcyk7XG4gIH1cblxuICBzdGF0aWMgcmVhZG9ubHkgcnVudGltZTogdHlwZW9mIHByb3RvMyA9IHByb3RvMztcbiAgc3RhdGljIHJlYWRvbmx5IHR5cGVOYW1lID0gXCJsaXZla2l0LlBvbmdcIjtcbiAgc3RhdGljIHJlYWRvbmx5IGZpZWxkczogRmllbGRMaXN0ID0gcHJvdG8zLnV0aWwubmV3RmllbGRMaXN0KCgpID0+IFtcbiAgICB7IG5vOiAxLCBuYW1lOiBcImxhc3RfcGluZ190aW1lc3RhbXBcIiwga2luZDogXCJzY2FsYXJcIiwgVDogMyAvKiBTY2FsYXJUeXBlLklOVDY0ICovIH0sXG4gICAgeyBubzogMiwgbmFtZTogXCJ0aW1lc3RhbXBcIiwga2luZDogXCJzY2FsYXJcIiwgVDogMyAvKiBTY2FsYXJUeXBlLklOVDY0ICovIH0sXG4gIF0pO1xuXG4gIHN0YXRpYyBmcm9tQmluYXJ5KGJ5dGVzOiBVaW50OEFycmF5LCBvcHRpb25zPzogUGFydGlhbDxCaW5hcnlSZWFkT3B0aW9ucz4pOiBQb25nIHtcbiAgICByZXR1cm4gbmV3IFBvbmcoKS5mcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tSnNvbihqc29uVmFsdWU6IEpzb25WYWx1ZSwgb3B0aW9ucz86IFBhcnRpYWw8SnNvblJlYWRPcHRpb25zPik6IFBvbmcge1xuICAgIHJldHVybiBuZXcgUG9uZygpLmZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucyk7XG4gIH1cblxuICBzdGF0aWMgZnJvbUpzb25TdHJpbmcoanNvblN0cmluZzogc3RyaW5nLCBvcHRpb25zPzogUGFydGlhbDxKc29uUmVhZE9wdGlvbnM+KTogUG9uZyB7XG4gICAgcmV0dXJuIG5ldyBQb25nKCkuZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucyk7XG4gIH1cblxuICBzdGF0aWMgZXF1YWxzKGE6IFBvbmcgfCBQbGFpbk1lc3NhZ2U8UG9uZz4gfCB1bmRlZmluZWQsIGI6IFBvbmcgfCBQbGFpbk1lc3NhZ2U8UG9uZz4gfCB1bmRlZmluZWQpOiBib29sZWFuIHtcbiAgICByZXR1cm4gcHJvdG8zLnV0aWwuZXF1YWxzKFBvbmcsIGEsIGIpO1xuICB9XG59XG5cbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgbGl2ZWtpdC5SZWdpb25TZXR0aW5nc1xuICovXG5leHBvcnQgY2xhc3MgUmVnaW9uU2V0dGluZ3MgZXh0ZW5kcyBNZXNzYWdlPFJlZ2lvblNldHRpbmdzPiB7XG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHJlcGVhdGVkIGxpdmVraXQuUmVnaW9uSW5mbyByZWdpb25zID0gMTtcbiAgICovXG4gIHJlZ2lvbnM6IFJlZ2lvbkluZm9bXSA9IFtdO1xuXG4gIGNvbnN0cnVjdG9yKGRhdGE/OiBQYXJ0aWFsTWVzc2FnZTxSZWdpb25TZXR0aW5ncz4pIHtcbiAgICBzdXBlcigpO1xuICAgIHByb3RvMy51dGlsLmluaXRQYXJ0aWFsKGRhdGEsIHRoaXMpO1xuICB9XG5cbiAgc3RhdGljIHJlYWRvbmx5IHJ1bnRpbWU6IHR5cGVvZiBwcm90bzMgPSBwcm90bzM7XG4gIHN0YXRpYyByZWFkb25seSB0eXBlTmFtZSA9IFwibGl2ZWtpdC5SZWdpb25TZXR0aW5nc1wiO1xuICBzdGF0aWMgcmVhZG9ubHkgZmllbGRzOiBGaWVsZExpc3QgPSBwcm90bzMudXRpbC5uZXdGaWVsZExpc3QoKCkgPT4gW1xuICAgIHsgbm86IDEsIG5hbWU6IFwicmVnaW9uc1wiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogUmVnaW9uSW5mbywgcmVwZWF0ZWQ6IHRydWUgfSxcbiAgXSk7XG5cbiAgc3RhdGljIGZyb21CaW5hcnkoYnl0ZXM6IFVpbnQ4QXJyYXksIG9wdGlvbnM/OiBQYXJ0aWFsPEJpbmFyeVJlYWRPcHRpb25zPik6IFJlZ2lvblNldHRpbmdzIHtcbiAgICByZXR1cm4gbmV3IFJlZ2lvblNldHRpbmdzKCkuZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucyk7XG4gIH1cblxuICBzdGF0aWMgZnJvbUpzb24oanNvblZhbHVlOiBKc29uVmFsdWUsIG9wdGlvbnM/OiBQYXJ0aWFsPEpzb25SZWFkT3B0aW9ucz4pOiBSZWdpb25TZXR0aW5ncyB7XG4gICAgcmV0dXJuIG5ldyBSZWdpb25TZXR0aW5ncygpLmZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucyk7XG4gIH1cblxuICBzdGF0aWMgZnJvbUpzb25TdHJpbmcoanNvblN0cmluZzogc3RyaW5nLCBvcHRpb25zPzogUGFydGlhbDxKc29uUmVhZE9wdGlvbnM+KTogUmVnaW9uU2V0dGluZ3Mge1xuICAgIHJldHVybiBuZXcgUmVnaW9uU2V0dGluZ3MoKS5mcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKTtcbiAgfVxuXG4gIHN0YXRpYyBlcXVhbHMoYTogUmVnaW9uU2V0dGluZ3MgfCBQbGFpbk1lc3NhZ2U8UmVnaW9uU2V0dGluZ3M+IHwgdW5kZWZpbmVkLCBiOiBSZWdpb25TZXR0aW5ncyB8IFBsYWluTWVzc2FnZTxSZWdpb25TZXR0aW5ncz4gfCB1bmRlZmluZWQpOiBib29sZWFuIHtcbiAgICByZXR1cm4gcHJvdG8zLnV0aWwuZXF1YWxzKFJlZ2lvblNldHRpbmdzLCBhLCBiKTtcbiAgfVxufVxuXG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBtZXNzYWdlIGxpdmVraXQuUmVnaW9uSW5mb1xuICovXG5leHBvcnQgY2xhc3MgUmVnaW9uSW5mbyBleHRlbmRzIE1lc3NhZ2U8UmVnaW9uSW5mbz4ge1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBzdHJpbmcgcmVnaW9uID0gMTtcbiAgICovXG4gIHJlZ2lvbiA9IFwiXCI7XG5cbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogc3RyaW5nIHVybCA9IDI7XG4gICAqL1xuICB1cmwgPSBcIlwiO1xuXG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGludDY0IGRpc3RhbmNlID0gMztcbiAgICovXG4gIGRpc3RhbmNlID0gcHJvdG9JbnQ2NC56ZXJvO1xuXG4gIGNvbnN0cnVjdG9yKGRhdGE/OiBQYXJ0aWFsTWVzc2FnZTxSZWdpb25JbmZvPikge1xuICAgIHN1cGVyKCk7XG4gICAgcHJvdG8zLnV0aWwuaW5pdFBhcnRpYWwoZGF0YSwgdGhpcyk7XG4gIH1cblxuICBzdGF0aWMgcmVhZG9ubHkgcnVudGltZTogdHlwZW9mIHByb3RvMyA9IHByb3RvMztcbiAgc3RhdGljIHJlYWRvbmx5IHR5cGVOYW1lID0gXCJsaXZla2l0LlJlZ2lvbkluZm9cIjtcbiAgc3RhdGljIHJlYWRvbmx5IGZpZWxkczogRmllbGRMaXN0ID0gcHJvdG8zLnV0aWwubmV3RmllbGRMaXN0KCgpID0+IFtcbiAgICB7IG5vOiAxLCBuYW1lOiBcInJlZ2lvblwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovIH0sXG4gICAgeyBubzogMiwgbmFtZTogXCJ1cmxcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqLyB9LFxuICAgIHsgbm86IDMsIG5hbWU6IFwiZGlzdGFuY2VcIiwga2luZDogXCJzY2FsYXJcIiwgVDogMyAvKiBTY2FsYXJUeXBlLklOVDY0ICovIH0sXG4gIF0pO1xuXG4gIHN0YXRpYyBmcm9tQmluYXJ5KGJ5dGVzOiBVaW50OEFycmF5LCBvcHRpb25zPzogUGFydGlhbDxCaW5hcnlSZWFkT3B0aW9ucz4pOiBSZWdpb25JbmZvIHtcbiAgICByZXR1cm4gbmV3IFJlZ2lvbkluZm8oKS5mcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tSnNvbihqc29uVmFsdWU6IEpzb25WYWx1ZSwgb3B0aW9ucz86IFBhcnRpYWw8SnNvblJlYWRPcHRpb25zPik6IFJlZ2lvbkluZm8ge1xuICAgIHJldHVybiBuZXcgUmVnaW9uSW5mbygpLmZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucyk7XG4gIH1cblxuICBzdGF0aWMgZnJvbUpzb25TdHJpbmcoanNvblN0cmluZzogc3RyaW5nLCBvcHRpb25zPzogUGFydGlhbDxKc29uUmVhZE9wdGlvbnM+KTogUmVnaW9uSW5mbyB7XG4gICAgcmV0dXJuIG5ldyBSZWdpb25JbmZvKCkuZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucyk7XG4gIH1cblxuICBzdGF0aWMgZXF1YWxzKGE6IFJlZ2lvbkluZm8gfCBQbGFpbk1lc3NhZ2U8UmVnaW9uSW5mbz4gfCB1bmRlZmluZWQsIGI6IFJlZ2lvbkluZm8gfCBQbGFpbk1lc3NhZ2U8UmVnaW9uSW5mbz4gfCB1bmRlZmluZWQpOiBib29sZWFuIHtcbiAgICByZXR1cm4gcHJvdG8zLnV0aWwuZXF1YWxzKFJlZ2lvbkluZm8sIGEsIGIpO1xuICB9XG59XG5cbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgbGl2ZWtpdC5TdWJzY3JpcHRpb25SZXNwb25zZVxuICovXG5leHBvcnQgY2xhc3MgU3Vic2NyaXB0aW9uUmVzcG9uc2UgZXh0ZW5kcyBNZXNzYWdlPFN1YnNjcmlwdGlvblJlc3BvbnNlPiB7XG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHN0cmluZyB0cmFja19zaWQgPSAxO1xuICAgKi9cbiAgdHJhY2tTaWQgPSBcIlwiO1xuXG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGxpdmVraXQuU3Vic2NyaXB0aW9uRXJyb3IgZXJyID0gMjtcbiAgICovXG4gIGVyciA9IFN1YnNjcmlwdGlvbkVycm9yLlNFX1VOS05PV047XG5cbiAgY29uc3RydWN0b3IoZGF0YT86IFBhcnRpYWxNZXNzYWdlPFN1YnNjcmlwdGlvblJlc3BvbnNlPikge1xuICAgIHN1cGVyKCk7XG4gICAgcHJvdG8zLnV0aWwuaW5pdFBhcnRpYWwoZGF0YSwgdGhpcyk7XG4gIH1cblxuICBzdGF0aWMgcmVhZG9ubHkgcnVudGltZTogdHlwZW9mIHByb3RvMyA9IHByb3RvMztcbiAgc3RhdGljIHJlYWRvbmx5IHR5cGVOYW1lID0gXCJsaXZla2l0LlN1YnNjcmlwdGlvblJlc3BvbnNlXCI7XG4gIHN0YXRpYyByZWFkb25seSBmaWVsZHM6IEZpZWxkTGlzdCA9IHByb3RvMy51dGlsLm5ld0ZpZWxkTGlzdCgoKSA9PiBbXG4gICAgeyBubzogMSwgbmFtZTogXCJ0cmFja19zaWRcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqLyB9LFxuICAgIHsgbm86IDIsIG5hbWU6IFwiZXJyXCIsIGtpbmQ6IFwiZW51bVwiLCBUOiBwcm90bzMuZ2V0RW51bVR5cGUoU3Vic2NyaXB0aW9uRXJyb3IpIH0sXG4gIF0pO1xuXG4gIHN0YXRpYyBmcm9tQmluYXJ5KGJ5dGVzOiBVaW50OEFycmF5LCBvcHRpb25zPzogUGFydGlhbDxCaW5hcnlSZWFkT3B0aW9ucz4pOiBTdWJzY3JpcHRpb25SZXNwb25zZSB7XG4gICAgcmV0dXJuIG5ldyBTdWJzY3JpcHRpb25SZXNwb25zZSgpLmZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpO1xuICB9XG5cbiAgc3RhdGljIGZyb21Kc29uKGpzb25WYWx1ZTogSnNvblZhbHVlLCBvcHRpb25zPzogUGFydGlhbDxKc29uUmVhZE9wdGlvbnM+KTogU3Vic2NyaXB0aW9uUmVzcG9uc2Uge1xuICAgIHJldHVybiBuZXcgU3Vic2NyaXB0aW9uUmVzcG9uc2UoKS5mcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpO1xuICB9XG5cbiAgc3RhdGljIGZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmc6IHN0cmluZywgb3B0aW9ucz86IFBhcnRpYWw8SnNvblJlYWRPcHRpb25zPik6IFN1YnNjcmlwdGlvblJlc3BvbnNlIHtcbiAgICByZXR1cm4gbmV3IFN1YnNjcmlwdGlvblJlc3BvbnNlKCkuZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucyk7XG4gIH1cblxuICBzdGF0aWMgZXF1YWxzKGE6IFN1YnNjcmlwdGlvblJlc3BvbnNlIHwgUGxhaW5NZXNzYWdlPFN1YnNjcmlwdGlvblJlc3BvbnNlPiB8IHVuZGVmaW5lZCwgYjogU3Vic2NyaXB0aW9uUmVzcG9uc2UgfCBQbGFpbk1lc3NhZ2U8U3Vic2NyaXB0aW9uUmVzcG9uc2U+IHwgdW5kZWZpbmVkKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHByb3RvMy51dGlsLmVxdWFscyhTdWJzY3JpcHRpb25SZXNwb25zZSwgYSwgYik7XG4gIH1cbn1cblxuIiwiZXhwb3J0IGZ1bmN0aW9uIGNsb25lRGVlcDxUPih2YWx1ZTogVCkge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygc3RydWN0dXJlZENsb25lID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHN0cnVjdHVyZWRDbG9uZSh2YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkodmFsdWUpKSBhcyBUO1xuICB9XG59XG4iLCJpbXBvcnQgeyBFdmVudEVtaXR0ZXIgfSBmcm9tICdldmVudHMnO1xuaW1wb3J0IHR5cGUgVHlwZWRFdmVudEVtaXR0ZXIgZnJvbSAndHlwZWQtZW1pdHRlcic7XG5pbXBvcnQgdHlwZSB7IFNpZ25hbENsaWVudCB9IGZyb20gJy4uLy4uL2FwaS9TaWduYWxDbGllbnQnO1xuaW1wb3J0IGxvZywgeyBMb2dnZXJOYW1lcywgU3RydWN0dXJlZExvZ2dlciwgZ2V0TG9nZ2VyIH0gZnJvbSAnLi4vLi4vbG9nZ2VyJztcbmltcG9ydCB7IFRyYWNrU291cmNlLCBUcmFja1R5cGUgfSBmcm9tICcuLi8uLi9wcm90by9saXZla2l0X21vZGVsc19wYic7XG5pbXBvcnQgeyBTdHJlYW1TdGF0ZSBhcyBQcm90b1N0cmVhbVN0YXRlIH0gZnJvbSAnLi4vLi4vcHJvdG8vbGl2ZWtpdF9ydGNfcGInO1xuaW1wb3J0IHsgVHJhY2tFdmVudCB9IGZyb20gJy4uL2V2ZW50cyc7XG5pbXBvcnQgdHlwZSB7IExvZ2dlck9wdGlvbnMgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyBpc0ZpcmVGb3gsIGlzU2FmYXJpLCBpc1dlYiB9IGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCB7IGdldExvZ0NvbnRleHRGcm9tVHJhY2sgfSBmcm9tICcuL3V0aWxzJztcblxuY29uc3QgQkFDS0dST1VORF9SRUFDVElPTl9ERUxBWSA9IDUwMDA7XG5cbi8vIGtlZXAgb2xkIGF1ZGlvIGVsZW1lbnRzIHdoZW4gZGV0YWNoZWQsIHdlIHdvdWxkIHJlLXVzZSB0aGVtIHNpbmNlIG9uIGlPU1xuLy8gU2FmYXJpIHRyYWNrcyB3aGljaCBhdWRpbyBlbGVtZW50cyBoYXZlIGJlZW4gXCJibGVzc2VkXCIgYnkgdGhlIHVzZXIuXG5jb25zdCByZWN5Y2xlZEVsZW1lbnRzOiBBcnJheTxIVE1MQXVkaW9FbGVtZW50PiA9IFtdO1xuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgVHJhY2sgZXh0ZW5kcyAoRXZlbnRFbWl0dGVyIGFzIG5ldyAoKSA9PiBUeXBlZEV2ZW50RW1pdHRlcjxUcmFja0V2ZW50Q2FsbGJhY2tzPikge1xuICBraW5kOiBUcmFjay5LaW5kO1xuXG4gIGF0dGFjaGVkRWxlbWVudHM6IEhUTUxNZWRpYUVsZW1lbnRbXSA9IFtdO1xuXG4gIGlzTXV0ZWQ6IGJvb2xlYW4gPSBmYWxzZTtcblxuICBzb3VyY2U6IFRyYWNrLlNvdXJjZTtcblxuICAvKipcbiAgICogc2lkIGlzIHNldCBhZnRlciB0cmFjayBpcyBwdWJsaXNoZWQgdG8gc2VydmVyLCBvciBpZiBpdCdzIGEgcmVtb3RlIHRyYWNrXG4gICAqL1xuICBzaWQ/OiBUcmFjay5TSUQ7XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgbWVkaWFTdHJlYW0/OiBNZWRpYVN0cmVhbTtcblxuICAvKipcbiAgICogaW5kaWNhdGVzIGN1cnJlbnQgc3RhdGUgb2Ygc3RyZWFtLCBpdCdsbCBpbmRpY2F0ZSBgcGF1c2VkYCBpZiB0aGUgdHJhY2tcbiAgICogaGFzIGJlZW4gcGF1c2VkIGJ5IGNvbmdlc3Rpb24gY29udHJvbGxlclxuICAgKi9cbiAgc3RyZWFtU3RhdGU6IFRyYWNrLlN0cmVhbVN0YXRlID0gVHJhY2suU3RyZWFtU3RhdGUuQWN0aXZlO1xuXG4gIHByb3RlY3RlZCBfbWVkaWFTdHJlYW1UcmFjazogTWVkaWFTdHJlYW1UcmFjaztcblxuICBwcm90ZWN0ZWQgX21lZGlhU3RyZWFtSUQ6IHN0cmluZztcblxuICBwcm90ZWN0ZWQgaXNJbkJhY2tncm91bmQ6IGJvb2xlYW4gPSBmYWxzZTtcblxuICBwcml2YXRlIGJhY2tncm91bmRUaW1lb3V0OiBSZXR1cm5UeXBlPHR5cGVvZiBzZXRUaW1lb3V0PiB8IHVuZGVmaW5lZDtcblxuICBwcml2YXRlIGxvZ2dlckNvbnRleHRDYjogTG9nZ2VyT3B0aW9uc1snbG9nZ2VyQ29udGV4dENiJ107XG5cbiAgcHJvdGVjdGVkIF9jdXJyZW50Qml0cmF0ZTogbnVtYmVyID0gMDtcblxuICBwcm90ZWN0ZWQgbW9uaXRvckludGVydmFsPzogUmV0dXJuVHlwZTx0eXBlb2Ygc2V0SW50ZXJ2YWw+O1xuXG4gIHByb3RlY3RlZCBsb2c6IFN0cnVjdHVyZWRMb2dnZXIgPSBsb2c7XG5cbiAgcHJvdGVjdGVkIGNvbnN0cnVjdG9yKFxuICAgIG1lZGlhVHJhY2s6IE1lZGlhU3RyZWFtVHJhY2ssXG4gICAga2luZDogVHJhY2suS2luZCxcbiAgICBsb2dnZXJPcHRpb25zOiBMb2dnZXJPcHRpb25zID0ge30sXG4gICkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5sb2cgPSBnZXRMb2dnZXIobG9nZ2VyT3B0aW9ucy5sb2dnZXJOYW1lID8/IExvZ2dlck5hbWVzLlRyYWNrKTtcbiAgICB0aGlzLmxvZ2dlckNvbnRleHRDYiA9IGxvZ2dlck9wdGlvbnMubG9nZ2VyQ29udGV4dENiO1xuXG4gICAgdGhpcy5zZXRNYXhMaXN0ZW5lcnMoMTAwKTtcbiAgICB0aGlzLmtpbmQgPSBraW5kO1xuICAgIHRoaXMuX21lZGlhU3RyZWFtVHJhY2sgPSBtZWRpYVRyYWNrO1xuICAgIHRoaXMuX21lZGlhU3RyZWFtSUQgPSBtZWRpYVRyYWNrLmlkO1xuICAgIHRoaXMuc291cmNlID0gVHJhY2suU291cmNlLlVua25vd247XG4gIH1cblxuICBwcm90ZWN0ZWQgZ2V0IGxvZ0NvbnRleHQoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnRoaXMubG9nZ2VyQ29udGV4dENiPy4oKSxcbiAgICAgIC4uLmdldExvZ0NvbnRleHRGcm9tVHJhY2sodGhpcyksXG4gICAgfTtcbiAgfVxuXG4gIC8qKiBjdXJyZW50IHJlY2VpdmUgYml0cyBwZXIgc2Vjb25kICovXG4gIGdldCBjdXJyZW50Qml0cmF0ZSgpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLl9jdXJyZW50Qml0cmF0ZTtcbiAgfVxuXG4gIGdldCBtZWRpYVN0cmVhbVRyYWNrKCkge1xuICAgIHJldHVybiB0aGlzLl9tZWRpYVN0cmVhbVRyYWNrO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKiB1c2VkIGZvciBrZWVwIG1lZGlhU3RyZWFtJ3MgZmlyc3QgaWQsIHNpbmNlIGl0J3MgaWQgbWlnaHQgY2hhbmdlXG4gICAqIGlmIHdlIGRpc2FibGUvZW5hYmxlIGEgdHJhY2tcbiAgICovXG4gIGdldCBtZWRpYVN0cmVhbUlEKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuX21lZGlhU3RyZWFtSUQ7XG4gIH1cblxuICAvKipcbiAgICogY3JlYXRlcyBhIG5ldyBIVE1MQXVkaW9FbGVtZW50IG9yIEhUTUxWaWRlb0VsZW1lbnQsIGF0dGFjaGVzIHRvIGl0LCBhbmQgcmV0dXJucyBpdFxuICAgKi9cbiAgYXR0YWNoKCk6IEhUTUxNZWRpYUVsZW1lbnQ7XG5cbiAgLyoqXG4gICAqIGF0dGFjaGVzIHRyYWNrIHRvIGFuIGV4aXN0aW5nIEhUTUxBdWRpb0VsZW1lbnQgb3IgSFRNTFZpZGVvRWxlbWVudFxuICAgKi9cbiAgYXR0YWNoKGVsZW1lbnQ6IEhUTUxNZWRpYUVsZW1lbnQpOiBIVE1MTWVkaWFFbGVtZW50O1xuICBhdHRhY2goZWxlbWVudD86IEhUTUxNZWRpYUVsZW1lbnQpOiBIVE1MTWVkaWFFbGVtZW50IHtcbiAgICBsZXQgZWxlbWVudFR5cGUgPSAnYXVkaW8nO1xuICAgIGlmICh0aGlzLmtpbmQgPT09IFRyYWNrLktpbmQuVmlkZW8pIHtcbiAgICAgIGVsZW1lbnRUeXBlID0gJ3ZpZGVvJztcbiAgICB9XG4gICAgaWYgKHRoaXMuYXR0YWNoZWRFbGVtZW50cy5sZW5ndGggPT09IDAgJiYgVHJhY2suS2luZC5WaWRlbykge1xuICAgICAgdGhpcy5hZGRBcHBWaXNpYmlsaXR5TGlzdGVuZXIoKTtcbiAgICB9XG4gICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICBpZiAoZWxlbWVudFR5cGUgPT09ICdhdWRpbycpIHtcbiAgICAgICAgcmVjeWNsZWRFbGVtZW50cy5mb3JFYWNoKChlKSA9PiB7XG4gICAgICAgICAgaWYgKGUucGFyZW50RWxlbWVudCA9PT0gbnVsbCAmJiAhZWxlbWVudCkge1xuICAgICAgICAgICAgZWxlbWVudCA9IGU7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgICAgICAvLyByZW1vdmUgaXQgZnJvbSBwb29sXG4gICAgICAgICAgcmVjeWNsZWRFbGVtZW50cy5zcGxpY2UocmVjeWNsZWRFbGVtZW50cy5pbmRleE9mKGVsZW1lbnQpLCAxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICAgIGVsZW1lbnQgPSA8SFRNTE1lZGlhRWxlbWVudD5kb2N1bWVudC5jcmVhdGVFbGVtZW50KGVsZW1lbnRUeXBlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuYXR0YWNoZWRFbGVtZW50cy5pbmNsdWRlcyhlbGVtZW50KSkge1xuICAgICAgdGhpcy5hdHRhY2hlZEVsZW1lbnRzLnB1c2goZWxlbWVudCk7XG4gICAgfVxuXG4gICAgLy8gZXZlbiBpZiB3ZSBiZWxpZXZlIGl0J3MgYWxyZWFkeSBhdHRhY2hlZCB0byB0aGUgZWxlbWVudCwgaXQncyBwb3NzaWJsZVxuICAgIC8vIHRoZSBlbGVtZW50J3Mgc3JjT2JqZWN0IHdhcyBzZXQgdG8gc29tZXRoaW5nIGVsc2Ugb3V0IG9mIGJhbmQuXG4gICAgLy8gd2UnbGwgd2FudCB0byByZS1hdHRhY2ggaXQgaW4gdGhhdCBjYXNlXG4gICAgYXR0YWNoVG9FbGVtZW50KHRoaXMubWVkaWFTdHJlYW1UcmFjaywgZWxlbWVudCk7XG5cbiAgICAvLyBoYW5kbGUgYXV0byBwbGF5YmFjayBmYWlsdXJlc1xuICAgIGNvbnN0IGFsbE1lZGlhU3RyZWFtVHJhY2tzID0gKGVsZW1lbnQuc3JjT2JqZWN0IGFzIE1lZGlhU3RyZWFtKS5nZXRUcmFja3MoKTtcbiAgICBjb25zdCBoYXNBdWRpbyA9IGFsbE1lZGlhU3RyZWFtVHJhY2tzLnNvbWUoKHRyKSA9PiB0ci5raW5kID09PSAnYXVkaW8nKTtcblxuICAgIC8vIG1hbnVhbGx5IHBsYXkgbWVkaWEgdG8gZGV0ZWN0IGF1dG8gcGxheWJhY2sgc3RhdHVzXG4gICAgZWxlbWVudFxuICAgICAgLnBsYXkoKVxuICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICB0aGlzLmVtaXQoaGFzQXVkaW8gPyBUcmFja0V2ZW50LkF1ZGlvUGxheWJhY2tTdGFydGVkIDogVHJhY2tFdmVudC5WaWRlb1BsYXliYWNrU3RhcnRlZCk7XG4gICAgICB9KVxuICAgICAgLmNhdGNoKChlKSA9PiB7XG4gICAgICAgIGlmIChlLm5hbWUgPT09ICdOb3RBbGxvd2VkRXJyb3InKSB7XG4gICAgICAgICAgdGhpcy5lbWl0KGhhc0F1ZGlvID8gVHJhY2tFdmVudC5BdWRpb1BsYXliYWNrRmFpbGVkIDogVHJhY2tFdmVudC5WaWRlb1BsYXliYWNrRmFpbGVkLCBlKTtcbiAgICAgICAgfSBlbHNlIGlmIChlLm5hbWUgPT09ICdBYm9ydEVycm9yJykge1xuICAgICAgICAgIC8vIGNvbW1vbmx5IHRyaWdnZXJlZCBieSBhbm90aGVyIGBwbGF5YCByZXF1ZXN0LCBvbmx5IGxvZyBmb3IgZGVidWdnaW5nIHB1cnBvc2VzXG4gICAgICAgICAgbG9nLmRlYnVnKFxuICAgICAgICAgICAgYCR7aGFzQXVkaW8gPyAnYXVkaW8nIDogJ3ZpZGVvJ30gcGxheWJhY2sgYWJvcnRlZCwgbGlrZWx5IGR1ZSB0byBuZXcgcGxheSByZXF1ZXN0YCxcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxvZy53YXJuKGBjb3VsZCBub3QgcGxheWJhY2sgJHtoYXNBdWRpbyA/ICdhdWRpbycgOiAndmlkZW8nfWAsIGUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIGF1ZGlvIHBsYXliYWNrIGlzbid0IGFsbG93ZWQgbWFrZSBzdXJlIHdlIHN0aWxsIHBsYXkgYmFjayB0aGUgdmlkZW9cbiAgICAgICAgaWYgKFxuICAgICAgICAgIGhhc0F1ZGlvICYmXG4gICAgICAgICAgZWxlbWVudCAmJlxuICAgICAgICAgIGFsbE1lZGlhU3RyZWFtVHJhY2tzLnNvbWUoKHRyKSA9PiB0ci5raW5kID09PSAndmlkZW8nKSAmJlxuICAgICAgICAgIGUubmFtZSA9PT0gJ05vdEFsbG93ZWRFcnJvcidcbiAgICAgICAgKSB7XG4gICAgICAgICAgZWxlbWVudC5tdXRlZCA9IHRydWU7XG4gICAgICAgICAgZWxlbWVudC5wbGF5KCkuY2F0Y2goKCkgPT4ge1xuICAgICAgICAgICAgLy8gY2F0Y2ggZm9yIFNhZmFyaSwgZXhjZWVkZWQgb3B0aW9ucyBhdCB0aGlzIHBvaW50IHRvIGF1dG9tYXRpY2FsbHkgcGxheSB0aGUgbWVkaWEgZWxlbWVudFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgIHRoaXMuZW1pdChUcmFja0V2ZW50LkVsZW1lbnRBdHRhY2hlZCwgZWxlbWVudCk7XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cblxuICAvKipcbiAgICogRGV0YWNoZXMgZnJvbSBhbGwgYXR0YWNoZWQgZWxlbWVudHNcbiAgICovXG4gIGRldGFjaCgpOiBIVE1MTWVkaWFFbGVtZW50W107XG5cbiAgLyoqXG4gICAqIERldGFjaCBmcm9tIGEgc2luZ2xlIGVsZW1lbnRcbiAgICogQHBhcmFtIGVsZW1lbnRcbiAgICovXG4gIGRldGFjaChlbGVtZW50OiBIVE1MTWVkaWFFbGVtZW50KTogSFRNTE1lZGlhRWxlbWVudDtcbiAgZGV0YWNoKGVsZW1lbnQ/OiBIVE1MTWVkaWFFbGVtZW50KTogSFRNTE1lZGlhRWxlbWVudCB8IEhUTUxNZWRpYUVsZW1lbnRbXSB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIGRldGFjaCBmcm9tIGEgc2luZ2xlIGVsZW1lbnRcbiAgICAgIGlmIChlbGVtZW50KSB7XG4gICAgICAgIGRldGFjaFRyYWNrKHRoaXMubWVkaWFTdHJlYW1UcmFjaywgZWxlbWVudCk7XG4gICAgICAgIGNvbnN0IGlkeCA9IHRoaXMuYXR0YWNoZWRFbGVtZW50cy5pbmRleE9mKGVsZW1lbnQpO1xuICAgICAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgICAgICB0aGlzLmF0dGFjaGVkRWxlbWVudHMuc3BsaWNlKGlkeCwgMSk7XG4gICAgICAgICAgdGhpcy5yZWN5Y2xlRWxlbWVudChlbGVtZW50KTtcbiAgICAgICAgICB0aGlzLmVtaXQoVHJhY2tFdmVudC5FbGVtZW50RGV0YWNoZWQsIGVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbGVtZW50O1xuICAgICAgfVxuXG4gICAgICBjb25zdCBkZXRhY2hlZDogSFRNTE1lZGlhRWxlbWVudFtdID0gW107XG4gICAgICB0aGlzLmF0dGFjaGVkRWxlbWVudHMuZm9yRWFjaCgoZWxtKSA9PiB7XG4gICAgICAgIGRldGFjaFRyYWNrKHRoaXMubWVkaWFTdHJlYW1UcmFjaywgZWxtKTtcbiAgICAgICAgZGV0YWNoZWQucHVzaChlbG0pO1xuICAgICAgICB0aGlzLnJlY3ljbGVFbGVtZW50KGVsbSk7XG4gICAgICAgIHRoaXMuZW1pdChUcmFja0V2ZW50LkVsZW1lbnREZXRhY2hlZCwgZWxtKTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyByZW1vdmUgYWxsIHRyYWNrc1xuICAgICAgdGhpcy5hdHRhY2hlZEVsZW1lbnRzID0gW107XG4gICAgICByZXR1cm4gZGV0YWNoZWQ7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmICh0aGlzLmF0dGFjaGVkRWxlbWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlQXBwVmlzaWJpbGl0eUxpc3RlbmVyKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgc3RvcCgpIHtcbiAgICB0aGlzLnN0b3BNb25pdG9yKCk7XG4gICAgdGhpcy5fbWVkaWFTdHJlYW1UcmFjay5zdG9wKCk7XG4gIH1cblxuICBwcm90ZWN0ZWQgZW5hYmxlKCkge1xuICAgIHRoaXMuX21lZGlhU3RyZWFtVHJhY2suZW5hYmxlZCA9IHRydWU7XG4gIH1cblxuICBwcm90ZWN0ZWQgZGlzYWJsZSgpIHtcbiAgICB0aGlzLl9tZWRpYVN0cmVhbVRyYWNrLmVuYWJsZWQgPSBmYWxzZTtcbiAgfVxuXG4gIC8qIEBpbnRlcm5hbCAqL1xuICBhYnN0cmFjdCBzdGFydE1vbml0b3Ioc2lnbmFsQ2xpZW50PzogU2lnbmFsQ2xpZW50KTogdm9pZDtcblxuICAvKiBAaW50ZXJuYWwgKi9cbiAgc3RvcE1vbml0b3IoKSB7XG4gICAgaWYgKHRoaXMubW9uaXRvckludGVydmFsKSB7XG4gICAgICBjbGVhckludGVydmFsKHRoaXMubW9uaXRvckludGVydmFsKTtcbiAgICB9XG4gIH1cblxuICAvKiogQGludGVybmFsICovXG4gIHVwZGF0ZUxvZ2dlck9wdGlvbnMobG9nZ2VyT3B0aW9uczogTG9nZ2VyT3B0aW9ucykge1xuICAgIGlmIChsb2dnZXJPcHRpb25zLmxvZ2dlck5hbWUpIHtcbiAgICAgIHRoaXMubG9nID0gZ2V0TG9nZ2VyKGxvZ2dlck9wdGlvbnMubG9nZ2VyTmFtZSk7XG4gICAgfVxuICAgIGlmIChsb2dnZXJPcHRpb25zLmxvZ2dlckNvbnRleHRDYikge1xuICAgICAgdGhpcy5sb2dnZXJDb250ZXh0Q2IgPSBsb2dnZXJPcHRpb25zLmxvZ2dlckNvbnRleHRDYjtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHJlY3ljbGVFbGVtZW50KGVsZW1lbnQ6IEhUTUxNZWRpYUVsZW1lbnQpIHtcbiAgICBpZiAoZWxlbWVudCBpbnN0YW5jZW9mIEhUTUxBdWRpb0VsZW1lbnQpIHtcbiAgICAgIC8vIHdlIG9ubHkgbmVlZCB0byByZS11c2UgYSBzaW5nbGUgZWxlbWVudFxuICAgICAgbGV0IHNob3VsZENhY2hlID0gdHJ1ZTtcbiAgICAgIGVsZW1lbnQucGF1c2UoKTtcbiAgICAgIHJlY3ljbGVkRWxlbWVudHMuZm9yRWFjaCgoZSkgPT4ge1xuICAgICAgICBpZiAoIWUucGFyZW50RWxlbWVudCkge1xuICAgICAgICAgIHNob3VsZENhY2hlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaWYgKHNob3VsZENhY2hlKSB7XG4gICAgICAgIHJlY3ljbGVkRWxlbWVudHMucHVzaChlbGVtZW50KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcm90ZWN0ZWQgYXBwVmlzaWJpbGl0eUNoYW5nZWRMaXN0ZW5lciA9ICgpID0+IHtcbiAgICBpZiAodGhpcy5iYWNrZ3JvdW5kVGltZW91dCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuYmFja2dyb3VuZFRpbWVvdXQpO1xuICAgIH1cbiAgICAvLyBkZWxheSBhcHAgdmlzaWJpbGl0eSB1cGRhdGUgaWYgaXQgZ29lcyB0byBoaWRkZW5cbiAgICAvLyB1cGRhdGUgaW1tZWRpYXRlbHkgaWYgaXQgY29tZXMgYmFjayB0byBmb2N1c1xuICAgIGlmIChkb2N1bWVudC52aXNpYmlsaXR5U3RhdGUgPT09ICdoaWRkZW4nKSB7XG4gICAgICB0aGlzLmJhY2tncm91bmRUaW1lb3V0ID0gc2V0VGltZW91dChcbiAgICAgICAgKCkgPT4gdGhpcy5oYW5kbGVBcHBWaXNpYmlsaXR5Q2hhbmdlZCgpLFxuICAgICAgICBCQUNLR1JPVU5EX1JFQUNUSU9OX0RFTEFZLFxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5oYW5kbGVBcHBWaXNpYmlsaXR5Q2hhbmdlZCgpO1xuICAgIH1cbiAgfTtcblxuICBwcm90ZWN0ZWQgYXN5bmMgaGFuZGxlQXBwVmlzaWJpbGl0eUNoYW5nZWQoKSB7XG4gICAgdGhpcy5pc0luQmFja2dyb3VuZCA9IGRvY3VtZW50LnZpc2liaWxpdHlTdGF0ZSA9PT0gJ2hpZGRlbic7XG4gIH1cblxuICBwcm90ZWN0ZWQgYWRkQXBwVmlzaWJpbGl0eUxpc3RlbmVyKCkge1xuICAgIGlmIChpc1dlYigpKSB7XG4gICAgICB0aGlzLmlzSW5CYWNrZ3JvdW5kID0gZG9jdW1lbnQudmlzaWJpbGl0eVN0YXRlID09PSAnaGlkZGVuJztcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3Zpc2liaWxpdHljaGFuZ2UnLCB0aGlzLmFwcFZpc2liaWxpdHlDaGFuZ2VkTGlzdGVuZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmlzSW5CYWNrZ3JvdW5kID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcHJvdGVjdGVkIHJlbW92ZUFwcFZpc2liaWxpdHlMaXN0ZW5lcigpIHtcbiAgICBpZiAoaXNXZWIoKSkge1xuICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndmlzaWJpbGl0eWNoYW5nZScsIHRoaXMuYXBwVmlzaWJpbGl0eUNoYW5nZWRMaXN0ZW5lcik7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhdHRhY2hUb0VsZW1lbnQodHJhY2s6IE1lZGlhU3RyZWFtVHJhY2ssIGVsZW1lbnQ6IEhUTUxNZWRpYUVsZW1lbnQpIHtcbiAgbGV0IG1lZGlhU3RyZWFtOiBNZWRpYVN0cmVhbTtcbiAgaWYgKGVsZW1lbnQuc3JjT2JqZWN0IGluc3RhbmNlb2YgTWVkaWFTdHJlYW0pIHtcbiAgICBtZWRpYVN0cmVhbSA9IGVsZW1lbnQuc3JjT2JqZWN0O1xuICB9IGVsc2Uge1xuICAgIG1lZGlhU3RyZWFtID0gbmV3IE1lZGlhU3RyZWFtKCk7XG4gIH1cblxuICAvLyBjaGVjayBpZiB0cmFjayBtYXRjaGVzIGV4aXN0aW5nIHRyYWNrXG4gIGxldCBleGlzdGluZ1RyYWNrczogTWVkaWFTdHJlYW1UcmFja1tdO1xuICBpZiAodHJhY2sua2luZCA9PT0gJ2F1ZGlvJykge1xuICAgIGV4aXN0aW5nVHJhY2tzID0gbWVkaWFTdHJlYW0uZ2V0QXVkaW9UcmFja3MoKTtcbiAgfSBlbHNlIHtcbiAgICBleGlzdGluZ1RyYWNrcyA9IG1lZGlhU3RyZWFtLmdldFZpZGVvVHJhY2tzKCk7XG4gIH1cbiAgaWYgKCFleGlzdGluZ1RyYWNrcy5pbmNsdWRlcyh0cmFjaykpIHtcbiAgICBleGlzdGluZ1RyYWNrcy5mb3JFYWNoKChldCkgPT4ge1xuICAgICAgbWVkaWFTdHJlYW0ucmVtb3ZlVHJhY2soZXQpO1xuICAgIH0pO1xuICAgIG1lZGlhU3RyZWFtLmFkZFRyYWNrKHRyYWNrKTtcbiAgfVxuXG4gIGlmICghaXNTYWZhcmkoKSB8fCAhKGVsZW1lbnQgaW5zdGFuY2VvZiBIVE1MVmlkZW9FbGVtZW50KSkge1xuICAgIC8vIHdoZW4gaW4gbG93IHBvd2VyIG1vZGUgKGFwcGxpZXMgdG8gYm90aCBtYWNPUyBhbmQgaU9TKSwgU2FmYXJpIHdpbGwgc2hvdyBhIHBsYXkvcGF1c2Ugb3ZlcmxheVxuICAgIC8vIHdoZW4gYSB2aWRlbyBzdGFydHMgdGhhdCBoYXMgdGhlIGBhdXRvcGxheWAgYXR0cmlidXRlIGlzIHNldC5cbiAgICAvLyB3ZSB3b3JrIGFyb3VuZCB0aGlzIGJ5IF9ub3RfIHNldHRpbmcgdGhlIGF1dG9wbGF5IGF0dHJpYnV0ZSBvbiBzYWZhcmkgYW5kIGluc3RlYWQgY2FsbCBgc2V0VGltZW91dCgoKSA9PiBlbC5wbGF5KCksMClgIGZ1cnRoZXIgZG93blxuICAgIGVsZW1lbnQuYXV0b3BsYXkgPSB0cnVlO1xuICB9XG4gIC8vIEluIGNhc2UgdGhlcmUgYXJlIG5vIGF1ZGlvIHRyYWNrcyBwcmVzZW50IG9uIHRoZSBtZWRpYXN0cmVhbSwgd2Ugc2V0IHRoZSBlbGVtZW50IGFzIG11dGVkIHRvIGVuc3VyZSBhdXRvcGxheSB3b3Jrc1xuICBlbGVtZW50Lm11dGVkID0gbWVkaWFTdHJlYW0uZ2V0QXVkaW9UcmFja3MoKS5sZW5ndGggPT09IDA7XG4gIGlmIChlbGVtZW50IGluc3RhbmNlb2YgSFRNTFZpZGVvRWxlbWVudCkge1xuICAgIGVsZW1lbnQucGxheXNJbmxpbmUgPSB0cnVlO1xuICB9XG5cbiAgLy8gYXZvaWQgZmxpY2tlclxuICBpZiAoZWxlbWVudC5zcmNPYmplY3QgIT09IG1lZGlhU3RyZWFtKSB7XG4gICAgZWxlbWVudC5zcmNPYmplY3QgPSBtZWRpYVN0cmVhbTtcbiAgICBpZiAoKGlzU2FmYXJpKCkgfHwgaXNGaXJlRm94KCkpICYmIGVsZW1lbnQgaW5zdGFuY2VvZiBIVE1MVmlkZW9FbGVtZW50KSB7XG4gICAgICAvLyBGaXJlZm94IGFsc28gaGFzIGEgdGltaW5nIGlzc3VlIHdoZXJlIHZpZGVvIGRvZXNuJ3QgYWN0dWFsbHkgZ2V0IGF0dGFjaGVkIHVubGVzc1xuICAgICAgLy8gcGVyZm9ybWVkIG91dC1vZi1iYW5kXG4gICAgICAvLyBTYWZhcmkgMTUgaGFzIGEgYnVnIHdoZXJlIGluIGNlcnRhaW4gbGF5b3V0cywgdmlkZW8gZWxlbWVudCByZW5kZXJzXG4gICAgICAvLyBibGFjayB1bnRpbCB0aGUgcGFnZSBpcyByZXNpemVkIG9yIG90aGVyIGNoYW5nZXMgdGFrZSBwbGFjZS5cbiAgICAgIC8vIFJlc2V0dGluZyB0aGUgc3JjIHRyaWdnZXJzIGl0IHRvIHJlbmRlci5cbiAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLmFwcGxlLmNvbS9mb3J1bXMvdGhyZWFkLzY5MDUyM1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGVsZW1lbnQuc3JjT2JqZWN0ID0gbWVkaWFTdHJlYW07XG4gICAgICAgIC8vIFNhZmFyaSAxNSBzb21ldGltZXMgZmFpbHMgdG8gc3RhcnQgYSB2aWRlb1xuICAgICAgICAvLyB3aGVuIHRoZSB3aW5kb3cgaXMgYmFja2dyb3VuZGVkIGJlZm9yZSB0aGUgZmlyc3QgZnJhbWUgaXMgZHJhd25cbiAgICAgICAgLy8gbWFudWFsbHkgY2FsbGluZyBwbGF5IGhlcmUgc2VlbXMgdG8gZml4IHRoYXRcbiAgICAgICAgZWxlbWVudC5wbGF5KCkuY2F0Y2goKCkgPT4ge1xuICAgICAgICAgIC8qKiBkbyBub3RoaW5nICovXG4gICAgICAgIH0pO1xuICAgICAgfSwgMCk7XG4gICAgfVxuICB9XG59XG5cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBmdW5jdGlvbiBkZXRhY2hUcmFjayh0cmFjazogTWVkaWFTdHJlYW1UcmFjaywgZWxlbWVudDogSFRNTE1lZGlhRWxlbWVudCkge1xuICBpZiAoZWxlbWVudC5zcmNPYmplY3QgaW5zdGFuY2VvZiBNZWRpYVN0cmVhbSkge1xuICAgIGNvbnN0IG1lZGlhU3RyZWFtID0gZWxlbWVudC5zcmNPYmplY3Q7XG4gICAgbWVkaWFTdHJlYW0ucmVtb3ZlVHJhY2sodHJhY2spO1xuICAgIGlmIChtZWRpYVN0cmVhbS5nZXRUcmFja3MoKS5sZW5ndGggPiAwKSB7XG4gICAgICBlbGVtZW50LnNyY09iamVjdCA9IG1lZGlhU3RyZWFtO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbGVtZW50LnNyY09iamVjdCA9IG51bGw7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBuYW1lc3BhY2UgVHJhY2sge1xuICBleHBvcnQgZW51bSBLaW5kIHtcbiAgICBBdWRpbyA9ICdhdWRpbycsXG4gICAgVmlkZW8gPSAndmlkZW8nLFxuICAgIFVua25vd24gPSAndW5rbm93bicsXG4gIH1cbiAgZXhwb3J0IHR5cGUgU0lEID0gc3RyaW5nO1xuICBleHBvcnQgZW51bSBTb3VyY2Uge1xuICAgIENhbWVyYSA9ICdjYW1lcmEnLFxuICAgIE1pY3JvcGhvbmUgPSAnbWljcm9waG9uZScsXG4gICAgU2NyZWVuU2hhcmUgPSAnc2NyZWVuX3NoYXJlJyxcbiAgICBTY3JlZW5TaGFyZUF1ZGlvID0gJ3NjcmVlbl9zaGFyZV9hdWRpbycsXG4gICAgVW5rbm93biA9ICd1bmtub3duJyxcbiAgfVxuXG4gIGV4cG9ydCBlbnVtIFN0cmVhbVN0YXRlIHtcbiAgICBBY3RpdmUgPSAnYWN0aXZlJyxcbiAgICBQYXVzZWQgPSAncGF1c2VkJyxcbiAgICBVbmtub3duID0gJ3Vua25vd24nLFxuICB9XG5cbiAgZXhwb3J0IGludGVyZmFjZSBEaW1lbnNpb25zIHtcbiAgICB3aWR0aDogbnVtYmVyO1xuICAgIGhlaWdodDogbnVtYmVyO1xuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBleHBvcnQgZnVuY3Rpb24ga2luZFRvUHJvdG8oazogS2luZCk6IFRyYWNrVHlwZSB7XG4gICAgc3dpdGNoIChrKSB7XG4gICAgICBjYXNlIEtpbmQuQXVkaW86XG4gICAgICAgIHJldHVybiBUcmFja1R5cGUuQVVESU87XG4gICAgICBjYXNlIEtpbmQuVmlkZW86XG4gICAgICAgIHJldHVybiBUcmFja1R5cGUuVklERU87XG4gICAgICBkZWZhdWx0OlxuICAgICAgICAvLyBGSVhNRSB0aGlzIHdhcyBVTlJFQ09HTklaRUQgYmVmb3JlXG4gICAgICAgIHJldHVybiBUcmFja1R5cGUuREFUQTtcbiAgICB9XG4gIH1cblxuICAvKiogQGludGVybmFsICovXG4gIGV4cG9ydCBmdW5jdGlvbiBraW5kRnJvbVByb3RvKHQ6IFRyYWNrVHlwZSk6IEtpbmQgfCB1bmRlZmluZWQge1xuICAgIHN3aXRjaCAodCkge1xuICAgICAgY2FzZSBUcmFja1R5cGUuQVVESU86XG4gICAgICAgIHJldHVybiBLaW5kLkF1ZGlvO1xuICAgICAgY2FzZSBUcmFja1R5cGUuVklERU86XG4gICAgICAgIHJldHVybiBLaW5kLlZpZGVvO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIEtpbmQuVW5rbm93bjtcbiAgICB9XG4gIH1cblxuICAvKiogQGludGVybmFsICovXG4gIGV4cG9ydCBmdW5jdGlvbiBzb3VyY2VUb1Byb3RvKHM6IFNvdXJjZSk6IFRyYWNrU291cmNlIHtcbiAgICBzd2l0Y2ggKHMpIHtcbiAgICAgIGNhc2UgU291cmNlLkNhbWVyYTpcbiAgICAgICAgcmV0dXJuIFRyYWNrU291cmNlLkNBTUVSQTtcbiAgICAgIGNhc2UgU291cmNlLk1pY3JvcGhvbmU6XG4gICAgICAgIHJldHVybiBUcmFja1NvdXJjZS5NSUNST1BIT05FO1xuICAgICAgY2FzZSBTb3VyY2UuU2NyZWVuU2hhcmU6XG4gICAgICAgIHJldHVybiBUcmFja1NvdXJjZS5TQ1JFRU5fU0hBUkU7XG4gICAgICBjYXNlIFNvdXJjZS5TY3JlZW5TaGFyZUF1ZGlvOlxuICAgICAgICByZXR1cm4gVHJhY2tTb3VyY2UuU0NSRUVOX1NIQVJFX0FVRElPO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIFRyYWNrU291cmNlLlVOS05PV047XG4gICAgfVxuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBleHBvcnQgZnVuY3Rpb24gc291cmNlRnJvbVByb3RvKHM6IFRyYWNrU291cmNlKTogU291cmNlIHtcbiAgICBzd2l0Y2ggKHMpIHtcbiAgICAgIGNhc2UgVHJhY2tTb3VyY2UuQ0FNRVJBOlxuICAgICAgICByZXR1cm4gU291cmNlLkNhbWVyYTtcbiAgICAgIGNhc2UgVHJhY2tTb3VyY2UuTUlDUk9QSE9ORTpcbiAgICAgICAgcmV0dXJuIFNvdXJjZS5NaWNyb3Bob25lO1xuICAgICAgY2FzZSBUcmFja1NvdXJjZS5TQ1JFRU5fU0hBUkU6XG4gICAgICAgIHJldHVybiBTb3VyY2UuU2NyZWVuU2hhcmU7XG4gICAgICBjYXNlIFRyYWNrU291cmNlLlNDUkVFTl9TSEFSRV9BVURJTzpcbiAgICAgICAgcmV0dXJuIFNvdXJjZS5TY3JlZW5TaGFyZUF1ZGlvO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIFNvdXJjZS5Vbmtub3duO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgZXhwb3J0IGZ1bmN0aW9uIHN0cmVhbVN0YXRlRnJvbVByb3RvKHM6IFByb3RvU3RyZWFtU3RhdGUpOiBTdHJlYW1TdGF0ZSB7XG4gICAgc3dpdGNoIChzKSB7XG4gICAgICBjYXNlIFByb3RvU3RyZWFtU3RhdGUuQUNUSVZFOlxuICAgICAgICByZXR1cm4gU3RyZWFtU3RhdGUuQWN0aXZlO1xuICAgICAgY2FzZSBQcm90b1N0cmVhbVN0YXRlLlBBVVNFRDpcbiAgICAgICAgcmV0dXJuIFN0cmVhbVN0YXRlLlBhdXNlZDtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBTdHJlYW1TdGF0ZS5Vbmtub3duO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgdHlwZSBUcmFja0V2ZW50Q2FsbGJhY2tzID0ge1xuICBtZXNzYWdlOiAoKSA9PiB2b2lkO1xuICBtdXRlZDogKHRyYWNrPzogYW55KSA9PiB2b2lkO1xuICB1bm11dGVkOiAodHJhY2s/OiBhbnkpID0+IHZvaWQ7XG4gIHJlc3RhcnRlZDogKHRyYWNrPzogYW55KSA9PiB2b2lkO1xuICBlbmRlZDogKHRyYWNrPzogYW55KSA9PiB2b2lkO1xuICB1cGRhdGVTZXR0aW5nczogKCkgPT4gdm9pZDtcbiAgdXBkYXRlU3Vic2NyaXB0aW9uOiAoKSA9PiB2b2lkO1xuICBhdWRpb1BsYXliYWNrU3RhcnRlZDogKCkgPT4gdm9pZDtcbiAgYXVkaW9QbGF5YmFja0ZhaWxlZDogKGVycm9yPzogRXJyb3IpID0+IHZvaWQ7XG4gIGF1ZGlvU2lsZW5jZURldGVjdGVkOiAoKSA9PiB2b2lkO1xuICB2aXNpYmlsaXR5Q2hhbmdlZDogKHZpc2libGU6IGJvb2xlYW4sIHRyYWNrPzogYW55KSA9PiB2b2lkO1xuICB2aWRlb0RpbWVuc2lvbnNDaGFuZ2VkOiAoZGltZW5zaW9uczogVHJhY2suRGltZW5zaW9ucywgdHJhY2s/OiBhbnkpID0+IHZvaWQ7XG4gIHZpZGVvUGxheWJhY2tTdGFydGVkOiAoKSA9PiB2b2lkO1xuICB2aWRlb1BsYXliYWNrRmFpbGVkOiAoZXJyb3I/OiBFcnJvcikgPT4gdm9pZDtcbiAgZWxlbWVudEF0dGFjaGVkOiAoZWxlbWVudDogSFRNTE1lZGlhRWxlbWVudCkgPT4gdm9pZDtcbiAgZWxlbWVudERldGFjaGVkOiAoZWxlbWVudDogSFRNTE1lZGlhRWxlbWVudCkgPT4gdm9pZDtcbiAgdXBzdHJlYW1QYXVzZWQ6ICh0cmFjazogYW55KSA9PiB2b2lkO1xuICB1cHN0cmVhbVJlc3VtZWQ6ICh0cmFjazogYW55KSA9PiB2b2lkO1xufTtcbiIsImltcG9ydCB7IFRyYWNrUHVibGlzaGVkUmVzcG9uc2UgfSBmcm9tICcuLi8uLi9wcm90by9saXZla2l0X3J0Y19wYic7XG5pbXBvcnQgeyBjbG9uZURlZXAgfSBmcm9tICcuLi8uLi91dGlscy9jbG9uZURlZXAnO1xuaW1wb3J0IHsgaXNTYWZhcmksIHNsZWVwIH0gZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0IHsgVHJhY2sgfSBmcm9tICcuL1RyYWNrJztcbmltcG9ydCB0eXBlIHsgVHJhY2tQdWJsaWNhdGlvbiB9IGZyb20gJy4vVHJhY2tQdWJsaWNhdGlvbic7XG5pbXBvcnQge1xuICB0eXBlIEF1ZGlvQ2FwdHVyZU9wdGlvbnMsXG4gIHR5cGUgQ3JlYXRlTG9jYWxUcmFja3NPcHRpb25zLFxuICB0eXBlIFNjcmVlblNoYXJlQ2FwdHVyZU9wdGlvbnMsXG4gIHR5cGUgVmlkZW9DYXB0dXJlT3B0aW9ucyxcbiAgVmlkZW9Db2RlYyxcbiAgdmlkZW9Db2RlY3MsXG59IGZyb20gJy4vb3B0aW9ucyc7XG5pbXBvcnQgdHlwZSB7IEF1ZGlvVHJhY2sgfSBmcm9tICcuL3R5cGVzJztcblxuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlRGVmYXVsdE9wdGlvbnMoXG4gIG9wdGlvbnM/OiBDcmVhdGVMb2NhbFRyYWNrc09wdGlvbnMsXG4gIGF1ZGlvRGVmYXVsdHM/OiBBdWRpb0NhcHR1cmVPcHRpb25zLFxuICB2aWRlb0RlZmF1bHRzPzogVmlkZW9DYXB0dXJlT3B0aW9ucyxcbik6IENyZWF0ZUxvY2FsVHJhY2tzT3B0aW9ucyB7XG4gIGNvbnN0IG9wdHM6IENyZWF0ZUxvY2FsVHJhY2tzT3B0aW9ucyA9IGNsb25lRGVlcChvcHRpb25zKSA/PyB7fTtcbiAgaWYgKG9wdHMuYXVkaW8gPT09IHRydWUpIG9wdHMuYXVkaW8gPSB7fTtcbiAgaWYgKG9wdHMudmlkZW8gPT09IHRydWUpIG9wdHMudmlkZW8gPSB7fTtcblxuICAvLyB1c2UgZGVmYXVsdHNcbiAgaWYgKG9wdHMuYXVkaW8pIHtcbiAgICBtZXJnZU9iamVjdFdpdGhvdXRPdmVyd3JpdGluZyhcbiAgICAgIG9wdHMuYXVkaW8gYXMgUmVjb3JkPHN0cmluZywgdW5rbm93bj4sXG4gICAgICBhdWRpb0RlZmF1bHRzIGFzIFJlY29yZDxzdHJpbmcsIHVua25vd24+LFxuICAgICk7XG4gIH1cbiAgaWYgKG9wdHMudmlkZW8pIHtcbiAgICBtZXJnZU9iamVjdFdpdGhvdXRPdmVyd3JpdGluZyhcbiAgICAgIG9wdHMudmlkZW8gYXMgUmVjb3JkPHN0cmluZywgdW5rbm93bj4sXG4gICAgICB2aWRlb0RlZmF1bHRzIGFzIFJlY29yZDxzdHJpbmcsIHVua25vd24+LFxuICAgICk7XG4gIH1cbiAgcmV0dXJuIG9wdHM7XG59XG5cbmZ1bmN0aW9uIG1lcmdlT2JqZWN0V2l0aG91dE92ZXJ3cml0aW5nKFxuICBtYWluT2JqZWN0OiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPixcbiAgb2JqZWN0VG9NZXJnZTogUmVjb3JkPHN0cmluZywgdW5rbm93bj4sXG4pOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPiB7XG4gIE9iamVjdC5rZXlzKG9iamVjdFRvTWVyZ2UpLmZvckVhY2goKGtleSkgPT4ge1xuICAgIGlmIChtYWluT2JqZWN0W2tleV0gPT09IHVuZGVmaW5lZCkgbWFpbk9iamVjdFtrZXldID0gb2JqZWN0VG9NZXJnZVtrZXldO1xuICB9KTtcbiAgcmV0dXJuIG1haW5PYmplY3Q7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb25zdHJhaW50c0Zvck9wdGlvbnMob3B0aW9uczogQ3JlYXRlTG9jYWxUcmFja3NPcHRpb25zKTogTWVkaWFTdHJlYW1Db25zdHJhaW50cyB7XG4gIGNvbnN0IGNvbnN0cmFpbnRzOiBNZWRpYVN0cmVhbUNvbnN0cmFpbnRzID0ge307XG5cbiAgaWYgKG9wdGlvbnMudmlkZW8pIHtcbiAgICAvLyBkZWZhdWx0IHZpZGVvIG9wdGlvbnNcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMudmlkZW8gPT09ICdvYmplY3QnKSB7XG4gICAgICBjb25zdCB2aWRlb09wdGlvbnM6IE1lZGlhVHJhY2tDb25zdHJhaW50cyA9IHt9O1xuICAgICAgY29uc3QgdGFyZ2V0ID0gdmlkZW9PcHRpb25zIGFzIFJlY29yZDxzdHJpbmcsIHVua25vd24+O1xuICAgICAgY29uc3Qgc291cmNlID0gb3B0aW9ucy52aWRlbyBhcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPjtcbiAgICAgIE9iamVjdC5rZXlzKHNvdXJjZSkuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgIHN3aXRjaCAoa2V5KSB7XG4gICAgICAgICAgY2FzZSAncmVzb2x1dGlvbic6XG4gICAgICAgICAgICAvLyBmbGF0dGVuIFZpZGVvUmVzb2x1dGlvbiBmaWVsZHNcbiAgICAgICAgICAgIG1lcmdlT2JqZWN0V2l0aG91dE92ZXJ3cml0aW5nKHRhcmdldCwgc291cmNlLnJlc29sdXRpb24gYXMgUmVjb3JkPHN0cmluZywgdW5rbm93bj4pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgY29uc3RyYWludHMudmlkZW8gPSB2aWRlb09wdGlvbnM7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0cmFpbnRzLnZpZGVvID0gb3B0aW9ucy52aWRlbztcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgY29uc3RyYWludHMudmlkZW8gPSBmYWxzZTtcbiAgfVxuXG4gIGlmIChvcHRpb25zLmF1ZGlvKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmF1ZGlvID09PSAnb2JqZWN0Jykge1xuICAgICAgY29uc3RyYWludHMuYXVkaW8gPSBvcHRpb25zLmF1ZGlvO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdHJhaW50cy5hdWRpbyA9IHRydWU7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGNvbnN0cmFpbnRzLmF1ZGlvID0gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGNvbnN0cmFpbnRzO1xufVxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGRldGVjdHMgc2lsZW5jZSBvbiBhIGdpdmVuIFtbVHJhY2tdXSBpbnN0YW5jZS5cbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgdHJhY2sgc2VlbXMgdG8gYmUgZW50aXJlbHkgc2lsZW50LlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZGV0ZWN0U2lsZW5jZSh0cmFjazogQXVkaW9UcmFjaywgdGltZU9mZnNldCA9IDIwMCk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICBjb25zdCBjdHggPSBnZXROZXdBdWRpb0NvbnRleHQoKTtcbiAgaWYgKGN0eCkge1xuICAgIGNvbnN0IGFuYWx5c2VyID0gY3R4LmNyZWF0ZUFuYWx5c2VyKCk7XG4gICAgYW5hbHlzZXIuZmZ0U2l6ZSA9IDIwNDg7XG5cbiAgICBjb25zdCBidWZmZXJMZW5ndGggPSBhbmFseXNlci5mcmVxdWVuY3lCaW5Db3VudDtcbiAgICBjb25zdCBkYXRhQXJyYXkgPSBuZXcgVWludDhBcnJheShidWZmZXJMZW5ndGgpO1xuICAgIGNvbnN0IHNvdXJjZSA9IGN0eC5jcmVhdGVNZWRpYVN0cmVhbVNvdXJjZShuZXcgTWVkaWFTdHJlYW0oW3RyYWNrLm1lZGlhU3RyZWFtVHJhY2tdKSk7XG5cbiAgICBzb3VyY2UuY29ubmVjdChhbmFseXNlcik7XG4gICAgYXdhaXQgc2xlZXAodGltZU9mZnNldCk7XG4gICAgYW5hbHlzZXIuZ2V0Qnl0ZVRpbWVEb21haW5EYXRhKGRhdGFBcnJheSk7XG4gICAgY29uc3Qgc29tZU5vaXNlID0gZGF0YUFycmF5LnNvbWUoKHNhbXBsZSkgPT4gc2FtcGxlICE9PSAxMjggJiYgc2FtcGxlICE9PSAwKTtcbiAgICBjdHguY2xvc2UoKTtcbiAgICByZXR1cm4gIXNvbWVOb2lzZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXROZXdBdWRpb0NvbnRleHQoKTogQXVkaW9Db250ZXh0IHwgdm9pZCB7XG4gIGNvbnN0IEF1ZGlvQ29udGV4dCA9XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmICh3aW5kb3cuQXVkaW9Db250ZXh0IHx8IHdpbmRvdy53ZWJraXRBdWRpb0NvbnRleHQpO1xuICBpZiAoQXVkaW9Db250ZXh0KSB7XG4gICAgcmV0dXJuIG5ldyBBdWRpb0NvbnRleHQoeyBsYXRlbmN5SGludDogJ2ludGVyYWN0aXZlJyB9KTtcbiAgfVxufVxuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgZnVuY3Rpb24ga2luZFRvU291cmNlKGtpbmQ6IE1lZGlhRGV2aWNlS2luZCkge1xuICBpZiAoa2luZCA9PT0gJ2F1ZGlvaW5wdXQnKSB7XG4gICAgcmV0dXJuIFRyYWNrLlNvdXJjZS5NaWNyb3Bob25lO1xuICB9IGVsc2UgaWYgKGtpbmQgPT09ICd2aWRlb2lucHV0Jykge1xuICAgIHJldHVybiBUcmFjay5Tb3VyY2UuQ2FtZXJhO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBUcmFjay5Tb3VyY2UuVW5rbm93bjtcbiAgfVxufVxuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgZnVuY3Rpb24gc291cmNlVG9LaW5kKHNvdXJjZTogVHJhY2suU291cmNlKTogTWVkaWFEZXZpY2VLaW5kIHwgdW5kZWZpbmVkIHtcbiAgaWYgKHNvdXJjZSA9PT0gVHJhY2suU291cmNlLk1pY3JvcGhvbmUpIHtcbiAgICByZXR1cm4gJ2F1ZGlvaW5wdXQnO1xuICB9IGVsc2UgaWYgKHNvdXJjZSA9PT0gVHJhY2suU291cmNlLkNhbWVyYSkge1xuICAgIHJldHVybiAndmlkZW9pbnB1dCc7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxufVxuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgZnVuY3Rpb24gc2NyZWVuQ2FwdHVyZVRvRGlzcGxheU1lZGlhU3RyZWFtT3B0aW9ucyhcbiAgb3B0aW9uczogU2NyZWVuU2hhcmVDYXB0dXJlT3B0aW9ucyxcbik6IERpc3BsYXlNZWRpYVN0cmVhbU9wdGlvbnMge1xuICBsZXQgdmlkZW9Db25zdHJhaW50czogTWVkaWFUcmFja0NvbnN0cmFpbnRzIHwgYm9vbGVhbiA9IG9wdGlvbnMudmlkZW8gPz8gdHJ1ZTtcbiAgLy8gdHJlYXQgMCBhcyB1bmNhcHBlZFxuICBpZiAob3B0aW9ucy5yZXNvbHV0aW9uICYmIG9wdGlvbnMucmVzb2x1dGlvbi53aWR0aCA+IDAgJiYgb3B0aW9ucy5yZXNvbHV0aW9uLmhlaWdodCA+IDApIHtcbiAgICB2aWRlb0NvbnN0cmFpbnRzID0gdHlwZW9mIHZpZGVvQ29uc3RyYWludHMgPT09ICdib29sZWFuJyA/IHt9IDogdmlkZW9Db25zdHJhaW50cztcbiAgICBpZiAoaXNTYWZhcmkoKSkge1xuICAgICAgdmlkZW9Db25zdHJhaW50cyA9IHtcbiAgICAgICAgLi4udmlkZW9Db25zdHJhaW50cyxcbiAgICAgICAgd2lkdGg6IHsgbWF4OiBvcHRpb25zLnJlc29sdXRpb24ud2lkdGggfSxcbiAgICAgICAgaGVpZ2h0OiB7IG1heDogb3B0aW9ucy5yZXNvbHV0aW9uLmhlaWdodCB9LFxuICAgICAgICBmcmFtZVJhdGU6IG9wdGlvbnMucmVzb2x1dGlvbi5mcmFtZVJhdGUsXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICB2aWRlb0NvbnN0cmFpbnRzID0ge1xuICAgICAgICAuLi52aWRlb0NvbnN0cmFpbnRzLFxuICAgICAgICB3aWR0aDogeyBpZGVhbDogb3B0aW9ucy5yZXNvbHV0aW9uLndpZHRoIH0sXG4gICAgICAgIGhlaWdodDogeyBpZGVhbDogb3B0aW9ucy5yZXNvbHV0aW9uLmhlaWdodCB9LFxuICAgICAgICBmcmFtZVJhdGU6IG9wdGlvbnMucmVzb2x1dGlvbi5mcmFtZVJhdGUsXG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgYXVkaW86IG9wdGlvbnMuYXVkaW8gPz8gZmFsc2UsXG4gICAgdmlkZW86IHZpZGVvQ29uc3RyYWludHMsXG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvciBzdXBwb3J0IGZvciBleHBlcmltZW50YWwgZGlzcGxheSBtZWRpYSBmZWF0dXJlc1xuICAgIGNvbnRyb2xsZXI6IG9wdGlvbnMuY29udHJvbGxlcixcbiAgICBzZWxmQnJvd3NlclN1cmZhY2U6IG9wdGlvbnMuc2VsZkJyb3dzZXJTdXJmYWNlLFxuICAgIHN1cmZhY2VTd2l0Y2hpbmc6IG9wdGlvbnMuc3VyZmFjZVN3aXRjaGluZyxcbiAgICBzeXN0ZW1BdWRpbzogb3B0aW9ucy5zeXN0ZW1BdWRpbyxcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1pbWVUeXBlVG9WaWRlb0NvZGVjU3RyaW5nKG1pbWVUeXBlOiBzdHJpbmcpIHtcbiAgY29uc3QgY29kZWMgPSBtaW1lVHlwZS5zcGxpdCgnLycpWzFdLnRvTG93ZXJDYXNlKCkgYXMgVmlkZW9Db2RlYztcbiAgaWYgKCF2aWRlb0NvZGVjcy5pbmNsdWRlcyhjb2RlYykpIHtcbiAgICB0aHJvdyBFcnJvcihgVmlkZW8gY29kZWMgbm90IHN1cHBvcnRlZDogJHtjb2RlY31gKTtcbiAgfVxuICByZXR1cm4gY29kZWM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRUcmFja1B1YmxpY2F0aW9uSW5mbzxUIGV4dGVuZHMgVHJhY2tQdWJsaWNhdGlvbj4oXG4gIHRyYWNrczogVFtdLFxuKTogVHJhY2tQdWJsaXNoZWRSZXNwb25zZVtdIHtcbiAgY29uc3QgaW5mb3M6IFRyYWNrUHVibGlzaGVkUmVzcG9uc2VbXSA9IFtdO1xuICB0cmFja3MuZm9yRWFjaCgodHJhY2s6IFRyYWNrUHVibGljYXRpb24pID0+IHtcbiAgICBpZiAodHJhY2sudHJhY2sgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaW5mb3MucHVzaChcbiAgICAgICAgbmV3IFRyYWNrUHVibGlzaGVkUmVzcG9uc2Uoe1xuICAgICAgICAgIGNpZDogdHJhY2sudHJhY2subWVkaWFTdHJlYW1JRCxcbiAgICAgICAgICB0cmFjazogdHJhY2sudHJhY2tJbmZvLFxuICAgICAgICB9KSxcbiAgICAgICk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGluZm9zO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0TG9nQ29udGV4dEZyb21UcmFjayh0cmFjazogVHJhY2sgfCBUcmFja1B1YmxpY2F0aW9uKTogUmVjb3JkPHN0cmluZywgdW5rbm93bj4ge1xuICBpZiAodHJhY2sgaW5zdGFuY2VvZiBUcmFjaykge1xuICAgIHJldHVybiB7XG4gICAgICB0cmFja1NpZDogdHJhY2suc2lkLFxuICAgICAgdHJhY2tTb3VyY2U6IHRyYWNrLnNvdXJjZSxcbiAgICAgIHRyYWNrTXV0ZWQ6IHRyYWNrLmlzTXV0ZWQsXG4gICAgICB0cmFja0VuYWJsZWQ6IHRyYWNrLm1lZGlhU3RyZWFtVHJhY2suZW5hYmxlZCxcbiAgICAgIHRyYWNrS2luZDogdHJhY2sua2luZCxcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB7XG4gICAgICB0cmFja1NpZDogdHJhY2sudHJhY2tTaWQsXG4gICAgICB0cmFja05hbWU6IHRyYWNrLnRyYWNrTmFtZSxcbiAgICAgIHRyYWNrOiB0cmFjay50cmFjayA/IGdldExvZ0NvbnRleHRGcm9tVHJhY2sodHJhY2sudHJhY2spIDogdW5kZWZpbmVkLFxuICAgICAgdHJhY2tFbmFibGVkOiB0cmFjay5pc0VuYWJsZWQsXG4gICAgICB0cmFja0VuY3J5cHRlZDogdHJhY2suaXNFbmNyeXB0ZWQsXG4gICAgICB0cmFja01pbWVUeXBlOiB0cmFjay5taW1lVHlwZSxcbiAgICB9O1xuICB9XG59XG4iLCJpbXBvcnQgeyBDbGllbnRJbmZvLCBDbGllbnRJbmZvX1NESyB9IGZyb20gJy4uL3Byb3RvL2xpdmVraXRfbW9kZWxzX3BiJztcbmltcG9ydCB0eXBlIHsgRGV0ZWN0YWJsZUJyb3dzZXIgfSBmcm9tICcuLi91dGlscy9icm93c2VyUGFyc2VyJztcbmltcG9ydCB7IGdldEJyb3dzZXIgfSBmcm9tICcuLi91dGlscy9icm93c2VyUGFyc2VyJztcbmltcG9ydCB7IHByb3RvY29sVmVyc2lvbiwgdmVyc2lvbiB9IGZyb20gJy4uL3ZlcnNpb24nO1xuaW1wb3J0IENyaXRpY2FsVGltZXJzIGZyb20gJy4vdGltZXJzJztcbmltcG9ydCB0eXBlIExvY2FsQXVkaW9UcmFjayBmcm9tICcuL3RyYWNrL0xvY2FsQXVkaW9UcmFjayc7XG5pbXBvcnQgdHlwZSBSZW1vdGVBdWRpb1RyYWNrIGZyb20gJy4vdHJhY2svUmVtb3RlQXVkaW9UcmFjayc7XG5pbXBvcnQgeyBWaWRlb0NvZGVjLCB2aWRlb0NvZGVjcyB9IGZyb20gJy4vdHJhY2svb3B0aW9ucyc7XG5pbXBvcnQgeyBnZXROZXdBdWRpb0NvbnRleHQgfSBmcm9tICcuL3RyYWNrL3V0aWxzJztcbmltcG9ydCB0eXBlIHsgTGl2ZUtpdFJlYWN0TmF0aXZlSW5mbyB9IGZyb20gJy4vdHlwZXMnO1xuXG5jb25zdCBzZXBhcmF0b3IgPSAnfCc7XG5leHBvcnQgY29uc3QgZGRFeHRlbnNpb25VUkkgPVxuICAnaHR0cHM6Ly9hb21lZGlhY29kZWMuZ2l0aHViLmlvL2F2MS1ydHAtc3BlYy8jZGVwZW5kZW5jeS1kZXNjcmlwdG9yLXJ0cC1oZWFkZXItZXh0ZW5zaW9uJztcblxuZXhwb3J0IGZ1bmN0aW9uIHVucGFja1N0cmVhbUlkKHBhY2tlZDogc3RyaW5nKTogc3RyaW5nW10ge1xuICBjb25zdCBwYXJ0cyA9IHBhY2tlZC5zcGxpdChzZXBhcmF0b3IpO1xuICBpZiAocGFydHMubGVuZ3RoID4gMSkge1xuICAgIHJldHVybiBbcGFydHNbMF0sIHBhY2tlZC5zdWJzdHIocGFydHNbMF0ubGVuZ3RoICsgMSldO1xuICB9XG4gIHJldHVybiBbcGFja2VkLCAnJ107XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzbGVlcChkdXJhdGlvbjogbnVtYmVyKTogUHJvbWlzZTx2b2lkPiB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gQ3JpdGljYWxUaW1lcnMuc2V0VGltZW91dChyZXNvbHZlLCBkdXJhdGlvbikpO1xufVxuXG4vKiogQGludGVybmFsICovXG5leHBvcnQgZnVuY3Rpb24gc3VwcG9ydHNUcmFuc2NlaXZlcigpIHtcbiAgcmV0dXJuICdhZGRUcmFuc2NlaXZlcicgaW4gUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlO1xufVxuXG4vKiogQGludGVybmFsICovXG5leHBvcnQgZnVuY3Rpb24gc3VwcG9ydHNBZGRUcmFjaygpIHtcbiAgcmV0dXJuICdhZGRUcmFjaycgaW4gUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc3VwcG9ydHNBZGFwdGl2ZVN0cmVhbSgpIHtcbiAgcmV0dXJuIHR5cGVvZiBSZXNpemVPYnNlcnZlciAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBJbnRlcnNlY3Rpb25PYnNlcnZlciAhPT0gdW5kZWZpbmVkO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc3VwcG9ydHNEeW5hY2FzdCgpIHtcbiAgcmV0dXJuIHN1cHBvcnRzVHJhbnNjZWl2ZXIoKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHN1cHBvcnRzQVYxKCk6IGJvb2xlYW4ge1xuICBpZiAoISgnZ2V0Q2FwYWJpbGl0aWVzJyBpbiBSVENSdHBTZW5kZXIpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChpc1NhZmFyaSgpKSB7XG4gICAgLy8gU2FmYXJpIDE3IG9uIGlQaG9uZTE0IHJlcG9ydHMgQVYxIGNhcGFiaWxpdHksIGJ1dCBkb2VzIG5vdCBhY3R1YWxseSBzdXBwb3J0IGl0XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IGNhcGFiaWxpdGllcyA9IFJUQ1J0cFNlbmRlci5nZXRDYXBhYmlsaXRpZXMoJ3ZpZGVvJyk7XG4gIGxldCBoYXNBVjEgPSBmYWxzZTtcbiAgaWYgKGNhcGFiaWxpdGllcykge1xuICAgIGZvciAoY29uc3QgY29kZWMgb2YgY2FwYWJpbGl0aWVzLmNvZGVjcykge1xuICAgICAgaWYgKGNvZGVjLm1pbWVUeXBlID09PSAndmlkZW8vQVYxJykge1xuICAgICAgICBoYXNBVjEgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGhhc0FWMTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHN1cHBvcnRzVlA5KCk6IGJvb2xlYW4ge1xuICBpZiAoISgnZ2V0Q2FwYWJpbGl0aWVzJyBpbiBSVENSdHBTZW5kZXIpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChpc0ZpcmVGb3goKSkge1xuICAgIC8vIHRlY2huaWNhbGx5IHNwZWFraW5nIEZpcmVGb3ggc3VwcG9ydHMgVlA5LCBidXQgU1ZDIHB1Ymxpc2hpbmcgaXMgYnJva2VuXG4gICAgLy8gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTYzMzg3NlxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoaXNTYWZhcmkoKSkge1xuICAgIGNvbnN0IGJyb3dzZXIgPSBnZXRCcm93c2VyKCk7XG4gICAgaWYgKGJyb3dzZXI/LnZlcnNpb24gJiYgY29tcGFyZVZlcnNpb25zKGJyb3dzZXIudmVyc2lvbiwgJzE2JykgPCAwKSB7XG4gICAgICAvLyBTYWZhcmkgMTYgYW5kIGJlbG93IGRvZXMgbm90IHN1cHBvcnQgVlA5XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIGNvbnN0IGNhcGFiaWxpdGllcyA9IFJUQ1J0cFNlbmRlci5nZXRDYXBhYmlsaXRpZXMoJ3ZpZGVvJyk7XG4gIGxldCBoYXNWUDkgPSBmYWxzZTtcbiAgaWYgKGNhcGFiaWxpdGllcykge1xuICAgIGZvciAoY29uc3QgY29kZWMgb2YgY2FwYWJpbGl0aWVzLmNvZGVjcykge1xuICAgICAgaWYgKGNvZGVjLm1pbWVUeXBlID09PSAndmlkZW8vVlA5Jykge1xuICAgICAgICBoYXNWUDkgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGhhc1ZQOTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzU1ZDQ29kZWMoY29kZWM/OiBzdHJpbmcpOiBib29sZWFuIHtcbiAgcmV0dXJuIGNvZGVjID09PSAnYXYxJyB8fCBjb2RlYyA9PT0gJ3ZwOSc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzdXBwb3J0c1NldFNpbmtJZChlbG0/OiBIVE1MTWVkaWFFbGVtZW50KTogYm9vbGVhbiB7XG4gIGlmICghZG9jdW1lbnQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKCFlbG0pIHtcbiAgICBlbG0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhdWRpbycpO1xuICB9XG4gIHJldHVybiAnc2V0U2lua0lkJyBpbiBlbG07XG59XG5cbmNvbnN0IHNldENvZGVjUHJlZmVyZW5jZXNWZXJzaW9uczogUmVjb3JkPERldGVjdGFibGVCcm93c2VyLCBzdHJpbmc+ID0ge1xuICBDaHJvbWU6ICcxMDAnLFxuICBTYWZhcmk6ICcxNScsXG4gIEZpcmVmb3g6ICcxMDAnLFxufTtcblxuZXhwb3J0IGZ1bmN0aW9uIHN1cHBvcnRzU2V0Q29kZWNQcmVmZXJlbmNlcyh0cmFuc2NlaXZlcjogUlRDUnRwVHJhbnNjZWl2ZXIpOiBib29sZWFuIHtcbiAgaWYgKCFpc1dlYigpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICghKCdzZXRDb2RlY1ByZWZlcmVuY2VzJyBpbiB0cmFuc2NlaXZlcikpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgYnJvd3NlciA9IGdldEJyb3dzZXIoKTtcbiAgaWYgKCFicm93c2VyPy5uYW1lIHx8ICFicm93c2VyLnZlcnNpb24pIHtcbiAgICAvLyB2ZXJzaW9uIGlzIHJlcXVpcmVkXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IHYgPSBzZXRDb2RlY1ByZWZlcmVuY2VzVmVyc2lvbnNbYnJvd3Nlci5uYW1lXTtcbiAgaWYgKHYpIHtcbiAgICByZXR1cm4gY29tcGFyZVZlcnNpb25zKGJyb3dzZXIudmVyc2lvbiwgdikgPj0gMDtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0Jyb3dzZXJTdXBwb3J0ZWQoKSB7XG4gIHJldHVybiBzdXBwb3J0c1RyYW5zY2VpdmVyKCkgfHwgc3VwcG9ydHNBZGRUcmFjaygpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNGaXJlRm94KCk6IGJvb2xlYW4ge1xuICByZXR1cm4gZ2V0QnJvd3NlcigpPy5uYW1lID09PSAnRmlyZWZveCc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0Nocm9taXVtQmFzZWQoKTogYm9vbGVhbiB7XG4gIHJldHVybiBnZXRCcm93c2VyKCk/Lm5hbWUgPT09ICdDaHJvbWUnO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNTYWZhcmkoKTogYm9vbGVhbiB7XG4gIHJldHVybiBnZXRCcm93c2VyKCk/Lm5hbWUgPT09ICdTYWZhcmknO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNTYWZhcmkxNygpOiBib29sZWFuIHtcbiAgY29uc3QgYiA9IGdldEJyb3dzZXIoKTtcbiAgcmV0dXJuIGI/Lm5hbWUgPT09ICdTYWZhcmknICYmIGIudmVyc2lvbi5zdGFydHNXaXRoKCcxNy4nKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzTW9iaWxlKCk6IGJvb2xlYW4ge1xuICBpZiAoIWlzV2ViKCkpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIC9UYWJsZXR8aVBhZHxNb2JpbGV8QW5kcm9pZHxCbGFja0JlcnJ5Ly50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNXZWIoKTogYm9vbGVhbiB7XG4gIHJldHVybiB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNSZWFjdE5hdGl2ZSgpOiBib29sZWFuIHtcbiAgLy8gbmF2aWdhdG9yLnByb2R1Y3QgaXMgZGVwcmVjYXRlZCBvbiBicm93c2VycywgYnV0IHdpbGwgYmUgc2V0IGFwcHJvcHJpYXRlbHkgZm9yIHJlYWN0LW5hdGl2ZS5cbiAgcmV0dXJuIG5hdmlnYXRvci5wcm9kdWN0ID09ICdSZWFjdE5hdGl2ZSc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0Nsb3VkKHNlcnZlclVybDogVVJMKSB7XG4gIHJldHVybiAoXG4gICAgc2VydmVyVXJsLmhvc3RuYW1lLmVuZHNXaXRoKCcubGl2ZWtpdC5jbG91ZCcpIHx8IHNlcnZlclVybC5ob3N0bmFtZS5lbmRzV2l0aCgnLmxpdmVraXQucnVuJylcbiAgKTtcbn1cblxuZnVuY3Rpb24gZ2V0TEtSZWFjdE5hdGl2ZUluZm8oKTogTGl2ZUtpdFJlYWN0TmF0aXZlSW5mbyB8IHVuZGVmaW5lZCB7XG4gIC8vIGdsb2JhbCBkZWZpbmVkIG9ubHkgZm9yIFJlYWN0TmF0aXZlLlxuICAvLyBAdHMtaWdub3JlXG4gIGlmIChnbG9iYWwgJiYgZ2xvYmFsLkxpdmVLaXRSZWFjdE5hdGl2ZUdsb2JhbCkge1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICByZXR1cm4gZ2xvYmFsLkxpdmVLaXRSZWFjdE5hdGl2ZUdsb2JhbCBhcyBMaXZlS2l0UmVhY3ROYXRpdmVJbmZvO1xuICB9XG5cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFJlYWN0TmF0aXZlT3MoKTogc3RyaW5nIHwgdW5kZWZpbmVkIHtcbiAgaWYgKCFpc1JlYWN0TmF0aXZlKCkpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgbGV0IGluZm8gPSBnZXRMS1JlYWN0TmF0aXZlSW5mbygpO1xuICBpZiAoaW5mbykge1xuICAgIHJldHVybiBpbmZvLnBsYXRmb3JtO1xuICB9XG5cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldERldmljZVBpeGVsUmF0aW8oKTogbnVtYmVyIHtcbiAgaWYgKGlzV2ViKCkpIHtcbiAgICByZXR1cm4gd2luZG93LmRldmljZVBpeGVsUmF0aW87XG4gIH1cblxuICBpZiAoaXNSZWFjdE5hdGl2ZSgpKSB7XG4gICAgbGV0IGluZm8gPSBnZXRMS1JlYWN0TmF0aXZlSW5mbygpO1xuICAgIGlmIChpbmZvKSB7XG4gICAgICByZXR1cm4gaW5mby5kZXZpY2VQaXhlbFJhdGlvO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiAxO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY29tcGFyZVZlcnNpb25zKHYxOiBzdHJpbmcsIHYyOiBzdHJpbmcpOiBudW1iZXIge1xuICBjb25zdCBwYXJ0czEgPSB2MS5zcGxpdCgnLicpO1xuICBjb25zdCBwYXJ0czIgPSB2Mi5zcGxpdCgnLicpO1xuICBjb25zdCBrID0gTWF0aC5taW4ocGFydHMxLmxlbmd0aCwgcGFydHMyLmxlbmd0aCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgazsgKytpKSB7XG4gICAgY29uc3QgcDEgPSBwYXJzZUludChwYXJ0czFbaV0sIDEwKTtcbiAgICBjb25zdCBwMiA9IHBhcnNlSW50KHBhcnRzMltpXSwgMTApO1xuICAgIGlmIChwMSA+IHAyKSByZXR1cm4gMTtcbiAgICBpZiAocDEgPCBwMikgcmV0dXJuIC0xO1xuICAgIGlmIChpID09PSBrIC0gMSAmJiBwMSA9PT0gcDIpIHJldHVybiAwO1xuICB9XG4gIGlmICh2MSA9PT0gJycgJiYgdjIgIT09ICcnKSB7XG4gICAgcmV0dXJuIC0xO1xuICB9IGVsc2UgaWYgKHYyID09PSAnJykge1xuICAgIHJldHVybiAxO1xuICB9XG4gIHJldHVybiBwYXJ0czEubGVuZ3RoID09IHBhcnRzMi5sZW5ndGggPyAwIDogcGFydHMxLmxlbmd0aCA8IHBhcnRzMi5sZW5ndGggPyAtMSA6IDE7XG59XG5cbmZ1bmN0aW9uIHJvRGlzcGF0Y2hDYWxsYmFjayhlbnRyaWVzOiBSZXNpemVPYnNlcnZlckVudHJ5W10pIHtcbiAgZm9yIChjb25zdCBlbnRyeSBvZiBlbnRyaWVzKSB7XG4gICAgKGVudHJ5LnRhcmdldCBhcyBPYnNlcnZhYmxlTWVkaWFFbGVtZW50KS5oYW5kbGVSZXNpemUoZW50cnkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlvRGlzcGF0Y2hDYWxsYmFjayhlbnRyaWVzOiBJbnRlcnNlY3Rpb25PYnNlcnZlckVudHJ5W10pIHtcbiAgZm9yIChjb25zdCBlbnRyeSBvZiBlbnRyaWVzKSB7XG4gICAgKGVudHJ5LnRhcmdldCBhcyBPYnNlcnZhYmxlTWVkaWFFbGVtZW50KS5oYW5kbGVWaXNpYmlsaXR5Q2hhbmdlZChlbnRyeSk7XG4gIH1cbn1cblxubGV0IHJlc2l6ZU9ic2VydmVyOiBSZXNpemVPYnNlcnZlciB8IG51bGwgPSBudWxsO1xuZXhwb3J0IGNvbnN0IGdldFJlc2l6ZU9ic2VydmVyID0gKCkgPT4ge1xuICBpZiAoIXJlc2l6ZU9ic2VydmVyKSByZXNpemVPYnNlcnZlciA9IG5ldyBSZXNpemVPYnNlcnZlcihyb0Rpc3BhdGNoQ2FsbGJhY2spO1xuICByZXR1cm4gcmVzaXplT2JzZXJ2ZXI7XG59O1xuXG5sZXQgaW50ZXJzZWN0aW9uT2JzZXJ2ZXI6IEludGVyc2VjdGlvbk9ic2VydmVyIHwgbnVsbCA9IG51bGw7XG5leHBvcnQgY29uc3QgZ2V0SW50ZXJzZWN0aW9uT2JzZXJ2ZXIgPSAoKSA9PiB7XG4gIGlmICghaW50ZXJzZWN0aW9uT2JzZXJ2ZXIpIHtcbiAgICBpbnRlcnNlY3Rpb25PYnNlcnZlciA9IG5ldyBJbnRlcnNlY3Rpb25PYnNlcnZlcihpb0Rpc3BhdGNoQ2FsbGJhY2ssIHtcbiAgICAgIHJvb3Q6IG51bGwsXG4gICAgICByb290TWFyZ2luOiAnMHB4JyxcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gaW50ZXJzZWN0aW9uT2JzZXJ2ZXI7XG59O1xuXG5leHBvcnQgaW50ZXJmYWNlIE9ic2VydmFibGVNZWRpYUVsZW1lbnQgZXh0ZW5kcyBIVE1MTWVkaWFFbGVtZW50IHtcbiAgaGFuZGxlUmVzaXplOiAoZW50cnk6IFJlc2l6ZU9ic2VydmVyRW50cnkpID0+IHZvaWQ7XG4gIGhhbmRsZVZpc2liaWxpdHlDaGFuZ2VkOiAoZW50cnk6IEludGVyc2VjdGlvbk9ic2VydmVyRW50cnkpID0+IHZvaWQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRDbGllbnRJbmZvKCk6IENsaWVudEluZm8ge1xuICBjb25zdCBpbmZvID0gbmV3IENsaWVudEluZm8oe1xuICAgIHNkazogQ2xpZW50SW5mb19TREsuSlMsXG4gICAgcHJvdG9jb2w6IHByb3RvY29sVmVyc2lvbixcbiAgICB2ZXJzaW9uLFxuICB9KTtcblxuICBpZiAoaXNSZWFjdE5hdGl2ZSgpKSB7XG4gICAgaW5mby5vcyA9IGdldFJlYWN0TmF0aXZlT3MoKSA/PyAnJztcbiAgfVxuICByZXR1cm4gaW5mbztcbn1cblxubGV0IGVtcHR5VmlkZW9TdHJlYW1UcmFjazogTWVkaWFTdHJlYW1UcmFjayB8IHVuZGVmaW5lZDtcblxuZXhwb3J0IGZ1bmN0aW9uIGdldEVtcHR5VmlkZW9TdHJlYW1UcmFjaygpIHtcbiAgaWYgKCFlbXB0eVZpZGVvU3RyZWFtVHJhY2spIHtcbiAgICBlbXB0eVZpZGVvU3RyZWFtVHJhY2sgPSBjcmVhdGVEdW1teVZpZGVvU3RyZWFtVHJhY2soKTtcbiAgfVxuICByZXR1cm4gZW1wdHlWaWRlb1N0cmVhbVRyYWNrLmNsb25lKCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVEdW1teVZpZGVvU3RyZWFtVHJhY2soXG4gIHdpZHRoOiBudW1iZXIgPSAxNixcbiAgaGVpZ2h0OiBudW1iZXIgPSAxNixcbiAgZW5hYmxlZDogYm9vbGVhbiA9IGZhbHNlLFxuICBwYWludENvbnRlbnQ6IGJvb2xlYW4gPSBmYWxzZSxcbikge1xuICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgLy8gdGhlIGNhbnZhcyBzaXplIGlzIHNldCB0byAxNiBieSBkZWZhdWx0LCBiZWNhdXNlIGVsZWN0cm9uIGFwcHMgc2VlbSB0byBmYWlsIHdpdGggc21hbGxlciB2YWx1ZXNcbiAgY2FudmFzLndpZHRoID0gd2lkdGg7XG4gIGNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG4gIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICBjdHg/LmZpbGxSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gIGlmIChwYWludENvbnRlbnQgJiYgY3R4KSB7XG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGN0eC5hcmMod2lkdGggLyAyLCBoZWlnaHQgLyAyLCA1MCwgMCwgTWF0aC5QSSAqIDIsIHRydWUpO1xuICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICBjdHguZmlsbFN0eWxlID0gJ2dyZXknO1xuICAgIGN0eC5maWxsKCk7XG4gIH1cbiAgLy8gQHRzLWlnbm9yZVxuICBjb25zdCBkdW1teVN0cmVhbSA9IGNhbnZhcy5jYXB0dXJlU3RyZWFtKCk7XG4gIGNvbnN0IFtkdW1teVRyYWNrXSA9IGR1bW15U3RyZWFtLmdldFRyYWNrcygpO1xuICBpZiAoIWR1bW15VHJhY2spIHtcbiAgICB0aHJvdyBFcnJvcignQ291bGQgbm90IGdldCBlbXB0eSBtZWRpYSBzdHJlYW0gdmlkZW8gdHJhY2snKTtcbiAgfVxuICBkdW1teVRyYWNrLmVuYWJsZWQgPSBlbmFibGVkO1xuXG4gIHJldHVybiBkdW1teVRyYWNrO1xufVxuXG5sZXQgZW1wdHlBdWRpb1N0cmVhbVRyYWNrOiBNZWRpYVN0cmVhbVRyYWNrIHwgdW5kZWZpbmVkO1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RW1wdHlBdWRpb1N0cmVhbVRyYWNrKCkge1xuICBpZiAoIWVtcHR5QXVkaW9TdHJlYW1UcmFjaykge1xuICAgIC8vIGltcGxlbWVudGF0aW9uIGFkYXB0ZWQgZnJvbSBodHRwczovL2Jsb2cubW96aWxsYS5vcmcvd2VicnRjL3dhcm0tdXAtd2l0aC1yZXBsYWNldHJhY2svXG4gICAgY29uc3QgY3R4ID0gbmV3IEF1ZGlvQ29udGV4dCgpO1xuICAgIGNvbnN0IG9zY2lsbGF0b3IgPSBjdHguY3JlYXRlT3NjaWxsYXRvcigpO1xuICAgIGNvbnN0IGdhaW4gPSBjdHguY3JlYXRlR2FpbigpO1xuICAgIGdhaW4uZ2Fpbi5zZXRWYWx1ZUF0VGltZSgwLCAwKTtcbiAgICBjb25zdCBkc3QgPSBjdHguY3JlYXRlTWVkaWFTdHJlYW1EZXN0aW5hdGlvbigpO1xuICAgIG9zY2lsbGF0b3IuY29ubmVjdChnYWluKTtcbiAgICBnYWluLmNvbm5lY3QoZHN0KTtcbiAgICBvc2NpbGxhdG9yLnN0YXJ0KCk7XG4gICAgW2VtcHR5QXVkaW9TdHJlYW1UcmFja10gPSBkc3Quc3RyZWFtLmdldEF1ZGlvVHJhY2tzKCk7XG4gICAgaWYgKCFlbXB0eUF1ZGlvU3RyZWFtVHJhY2spIHtcbiAgICAgIHRocm93IEVycm9yKCdDb3VsZCBub3QgZ2V0IGVtcHR5IG1lZGlhIHN0cmVhbSBhdWRpbyB0cmFjaycpO1xuICAgIH1cbiAgICBlbXB0eUF1ZGlvU3RyZWFtVHJhY2suZW5hYmxlZCA9IGZhbHNlO1xuICB9XG4gIHJldHVybiBlbXB0eUF1ZGlvU3RyZWFtVHJhY2suY2xvbmUoKTtcbn1cblxuZXhwb3J0IGNsYXNzIEZ1dHVyZTxUPiB7XG4gIHByb21pc2U6IFByb21pc2U8VD47XG5cbiAgcmVzb2x2ZT86IChhcmc6IFQpID0+IHZvaWQ7XG5cbiAgcmVqZWN0PzogKGU6IGFueSkgPT4gdm9pZDtcblxuICBvbkZpbmFsbHk/OiAoKSA9PiB2b2lkO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIGZ1dHVyZUJhc2U/OiAocmVzb2x2ZTogKGFyZzogVCkgPT4gdm9pZCwgcmVqZWN0OiAoZTogYW55KSA9PiB2b2lkKSA9PiB2b2lkLFxuICAgIG9uRmluYWxseT86ICgpID0+IHZvaWQsXG4gICkge1xuICAgIHRoaXMub25GaW5hbGx5ID0gb25GaW5hbGx5O1xuICAgIHRoaXMucHJvbWlzZSA9IG5ldyBQcm9taXNlPFQ+KGFzeW5jIChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMucmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICB0aGlzLnJlamVjdCA9IHJlamVjdDtcbiAgICAgIGlmIChmdXR1cmVCYXNlKSB7XG4gICAgICAgIGF3YWl0IGZ1dHVyZUJhc2UocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgIH1cbiAgICB9KS5maW5hbGx5KCgpID0+IHRoaXMub25GaW5hbGx5Py4oKSk7XG4gIH1cbn1cblxuZXhwb3J0IHR5cGUgQXVkaW9BbmFseXNlck9wdGlvbnMgPSB7XG4gIC8qKlxuICAgKiBJZiBzZXQgdG8gdHJ1ZSwgdGhlIGFuYWx5c2VyIHdpbGwgdXNlIGEgY2xvbmVkIHZlcnNpb24gb2YgdGhlIHVuZGVybHlpbmcgbWVkaWFzdHJlYW10cmFjaywgd2hpY2ggd29uJ3QgYmUgaW1wYWN0ZWQgYnkgbXV0aW5nIHRoZSB0cmFjay5cbiAgICogVXNlZnVsIGZvciBsb2NhbCB0cmFja3Mgd2hlbiBpbXBsZW1lbnRpbmcgdGhpbmdzIGxpa2UgXCJzZWVtcyBsaWtlIHlvdSdyZSBtdXRlZCwgYnV0IHRyeWluZyB0byBzcGVha1wiLlxuICAgKiBEZWZhdWx0cyB0byBmYWxzZVxuICAgKi9cbiAgY2xvbmVUcmFjaz86IGJvb2xlYW47XG4gIC8qKlxuICAgKiBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0FuYWx5c2VyTm9kZS9mZnRTaXplXG4gICAqL1xuICBmZnRTaXplPzogbnVtYmVyO1xuICAvKipcbiAgICogc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9BbmFseXNlck5vZGUvc21vb3RoaW5nVGltZUNvbnN0YW50XG4gICAqL1xuICBzbW9vdGhpbmdUaW1lQ29uc3RhbnQ/OiBudW1iZXI7XG4gIC8qKlxuICAgKiBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0FuYWx5c2VyTm9kZS9taW5EZWNpYmVsc1xuICAgKi9cbiAgbWluRGVjaWJlbHM/OiBudW1iZXI7XG4gIC8qKlxuICAgKiBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0FuYWx5c2VyTm9kZS9tYXhEZWNpYmVsc1xuICAgKi9cbiAgbWF4RGVjaWJlbHM/OiBudW1iZXI7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYW5kIHJldHVybnMgYW4gYW5hbHlzZXIgd2ViIGF1ZGlvIG5vZGUgdGhhdCBpcyBhdHRhY2hlZCB0byB0aGUgcHJvdmlkZWQgdHJhY2suXG4gKiBBZGRpdGlvbmFsbHkgcmV0dXJucyBhIGNvbnZlbmllbmNlIG1ldGhvZCBgY2FsY3VsYXRlVm9sdW1lYCB0byBwZXJmb3JtIGluc3RhbnQgdm9sdW1lIHJlYWRpbmdzIG9uIHRoYXQgdHJhY2suXG4gKiBDYWxsIHRoZSByZXR1cm5lZCBgY2xlYW51cGAgZnVuY3Rpb24gdG8gY2xvc2UgdGhlIGF1ZGlvQ29udGV4dCB0aGF0IGhhcyBiZWVuIGNyZWF0ZWQgZm9yIHRoZSBpbnN0YW5jZSBvZiB0aGlzIGhlbHBlclxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQXVkaW9BbmFseXNlcihcbiAgdHJhY2s6IExvY2FsQXVkaW9UcmFjayB8IFJlbW90ZUF1ZGlvVHJhY2ssXG4gIG9wdGlvbnM/OiBBdWRpb0FuYWx5c2VyT3B0aW9ucyxcbikge1xuICBjb25zdCBvcHRzID0ge1xuICAgIGNsb25lVHJhY2s6IGZhbHNlLFxuICAgIGZmdFNpemU6IDIwNDgsXG4gICAgc21vb3RoaW5nVGltZUNvbnN0YW50OiAwLjgsXG4gICAgbWluRGVjaWJlbHM6IC0xMDAsXG4gICAgbWF4RGVjaWJlbHM6IC04MCxcbiAgICAuLi5vcHRpb25zLFxuICB9O1xuICBjb25zdCBhdWRpb0NvbnRleHQgPSBnZXROZXdBdWRpb0NvbnRleHQoKTtcblxuICBpZiAoIWF1ZGlvQ29udGV4dCkge1xuICAgIHRocm93IG5ldyBFcnJvcignQXVkaW8gQ29udGV4dCBub3Qgc3VwcG9ydGVkIG9uIHRoaXMgYnJvd3NlcicpO1xuICB9XG4gIGNvbnN0IHN0cmVhbVRyYWNrID0gb3B0cy5jbG9uZVRyYWNrID8gdHJhY2subWVkaWFTdHJlYW1UcmFjay5jbG9uZSgpIDogdHJhY2subWVkaWFTdHJlYW1UcmFjaztcbiAgY29uc3QgbWVkaWFTdHJlYW1Tb3VyY2UgPSBhdWRpb0NvbnRleHQuY3JlYXRlTWVkaWFTdHJlYW1Tb3VyY2UobmV3IE1lZGlhU3RyZWFtKFtzdHJlYW1UcmFja10pKTtcbiAgY29uc3QgYW5hbHlzZXIgPSBhdWRpb0NvbnRleHQuY3JlYXRlQW5hbHlzZXIoKTtcbiAgYW5hbHlzZXIubWluRGVjaWJlbHMgPSBvcHRzLm1pbkRlY2liZWxzO1xuICBhbmFseXNlci5tYXhEZWNpYmVscyA9IG9wdHMubWF4RGVjaWJlbHM7XG4gIGFuYWx5c2VyLmZmdFNpemUgPSBvcHRzLmZmdFNpemU7XG4gIGFuYWx5c2VyLnNtb290aGluZ1RpbWVDb25zdGFudCA9IG9wdHMuc21vb3RoaW5nVGltZUNvbnN0YW50O1xuXG4gIG1lZGlhU3RyZWFtU291cmNlLmNvbm5lY3QoYW5hbHlzZXIpO1xuICBjb25zdCBkYXRhQXJyYXkgPSBuZXcgVWludDhBcnJheShhbmFseXNlci5mcmVxdWVuY3lCaW5Db3VudCk7XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZXMgdGhlIGN1cnJlbnQgdm9sdW1lIG9mIHRoZSB0cmFjayBpbiB0aGUgcmFuZ2UgZnJvbSAwIHRvIDFcbiAgICovXG4gIGNvbnN0IGNhbGN1bGF0ZVZvbHVtZSA9ICgpID0+IHtcbiAgICBhbmFseXNlci5nZXRCeXRlRnJlcXVlbmN5RGF0YShkYXRhQXJyYXkpO1xuICAgIGxldCBzdW0gPSAwO1xuICAgIGZvciAoY29uc3QgYW1wbGl0dWRlIG9mIGRhdGFBcnJheSkge1xuICAgICAgc3VtICs9IE1hdGgucG93KGFtcGxpdHVkZSAvIDI1NSwgMik7XG4gICAgfVxuICAgIGNvbnN0IHZvbHVtZSA9IE1hdGguc3FydChzdW0gLyBkYXRhQXJyYXkubGVuZ3RoKTtcbiAgICByZXR1cm4gdm9sdW1lO1xuICB9O1xuXG4gIGNvbnN0IGNsZWFudXAgPSBhc3luYyAoKSA9PiB7XG4gICAgYXdhaXQgYXVkaW9Db250ZXh0LmNsb3NlKCk7XG4gICAgaWYgKG9wdHMuY2xvbmVUcmFjaykge1xuICAgICAgc3RyZWFtVHJhY2suc3RvcCgpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4geyBjYWxjdWxhdGVWb2x1bWUsIGFuYWx5c2VyLCBjbGVhbnVwIH07XG59XG5cbmV4cG9ydCBjbGFzcyBNdXRleCB7XG4gIHByaXZhdGUgX2xvY2tpbmc6IFByb21pc2U8dm9pZD47XG5cbiAgcHJpdmF0ZSBfbG9ja3M6IG51bWJlcjtcblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLl9sb2NraW5nID0gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgdGhpcy5fbG9ja3MgPSAwO1xuICB9XG5cbiAgaXNMb2NrZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2xvY2tzID4gMDtcbiAgfVxuXG4gIGxvY2soKSB7XG4gICAgdGhpcy5fbG9ja3MgKz0gMTtcblxuICAgIGxldCB1bmxvY2tOZXh0OiAoKSA9PiB2b2lkO1xuXG4gICAgY29uc3Qgd2lsbExvY2sgPSBuZXcgUHJvbWlzZTx2b2lkPihcbiAgICAgIChyZXNvbHZlKSA9PlxuICAgICAgICAodW5sb2NrTmV4dCA9ICgpID0+IHtcbiAgICAgICAgICB0aGlzLl9sb2NrcyAtPSAxO1xuICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfSksXG4gICAgKTtcblxuICAgIGNvbnN0IHdpbGxVbmxvY2sgPSB0aGlzLl9sb2NraW5nLnRoZW4oKCkgPT4gdW5sb2NrTmV4dCk7XG5cbiAgICB0aGlzLl9sb2NraW5nID0gdGhpcy5fbG9ja2luZy50aGVuKCgpID0+IHdpbGxMb2NrKTtcblxuICAgIHJldHVybiB3aWxsVW5sb2NrO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1ZpZGVvQ29kZWMobWF5YmVDb2RlYzogc3RyaW5nKTogbWF5YmVDb2RlYyBpcyBWaWRlb0NvZGVjIHtcbiAgcmV0dXJuIHZpZGVvQ29kZWNzLmluY2x1ZGVzKG1heWJlQ29kZWMgYXMgVmlkZW9Db2RlYyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1bndyYXBDb25zdHJhaW50KGNvbnN0cmFpbnQ6IENvbnN0cmFpbkRPTVN0cmluZyk6IHN0cmluZyB7XG4gIGlmICh0eXBlb2YgY29uc3RyYWludCA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gY29uc3RyYWludDtcbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KGNvbnN0cmFpbnQpKSB7XG4gICAgcmV0dXJuIGNvbnN0cmFpbnRbMF07XG4gIH1cbiAgaWYgKGNvbnN0cmFpbnQuZXhhY3QpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShjb25zdHJhaW50LmV4YWN0KSkge1xuICAgICAgcmV0dXJuIGNvbnN0cmFpbnQuZXhhY3RbMF07XG4gICAgfVxuICAgIHJldHVybiBjb25zdHJhaW50LmV4YWN0O1xuICB9XG4gIGlmIChjb25zdHJhaW50LmlkZWFsKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY29uc3RyYWludC5pZGVhbCkpIHtcbiAgICAgIHJldHVybiBjb25zdHJhaW50LmlkZWFsWzBdO1xuICAgIH1cbiAgICByZXR1cm4gY29uc3RyYWludC5pZGVhbDtcbiAgfVxuICB0aHJvdyBFcnJvcignY291bGQgbm90IHVud3JhcCBjb25zdHJhaW50Jyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0b1dlYnNvY2tldFVybCh1cmw6IHN0cmluZyk6IHN0cmluZyB7XG4gIGlmICh1cmwuc3RhcnRzV2l0aCgnaHR0cCcpKSB7XG4gICAgcmV0dXJuIHVybC5yZXBsYWNlKC9eKGh0dHApLywgJ3dzJyk7XG4gIH1cbiAgcmV0dXJuIHVybDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRvSHR0cFVybCh1cmw6IHN0cmluZyk6IHN0cmluZyB7XG4gIGlmICh1cmwuc3RhcnRzV2l0aCgnd3MnKSkge1xuICAgIHJldHVybiB1cmwucmVwbGFjZSgvXih3cykvLCAnaHR0cCcpO1xuICB9XG4gIHJldHVybiB1cmw7XG59XG4iLCJpbXBvcnQgbG9nIGZyb20gJy4uL2xvZ2dlcic7XG5pbXBvcnQgeyBpc1NhZmFyaSB9IGZyb20gJy4vdXRpbHMnO1xuXG5jb25zdCBkZWZhdWx0SWQgPSAnZGVmYXVsdCc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERldmljZU1hbmFnZXIge1xuICBwcml2YXRlIHN0YXRpYyBpbnN0YW5jZT86IERldmljZU1hbmFnZXI7XG5cbiAgc3RhdGljIG1lZGlhRGV2aWNlS2luZHM6IE1lZGlhRGV2aWNlS2luZFtdID0gWydhdWRpb2lucHV0JywgJ2F1ZGlvb3V0cHV0JywgJ3ZpZGVvaW5wdXQnXTtcblxuICBzdGF0aWMgZ2V0SW5zdGFuY2UoKTogRGV2aWNlTWFuYWdlciB7XG4gICAgaWYgKHRoaXMuaW5zdGFuY2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5pbnN0YW5jZSA9IG5ldyBEZXZpY2VNYW5hZ2VyKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmluc3RhbmNlO1xuICB9XG5cbiAgc3RhdGljIHVzZXJNZWRpYVByb21pc2VNYXA6IE1hcDxNZWRpYURldmljZUtpbmQsIFByb21pc2U8TWVkaWFTdHJlYW0+PiA9IG5ldyBNYXAoKTtcblxuICBhc3luYyBnZXREZXZpY2VzKFxuICAgIGtpbmQ/OiBNZWRpYURldmljZUtpbmQsXG4gICAgcmVxdWVzdFBlcm1pc3Npb25zOiBib29sZWFuID0gdHJ1ZSxcbiAgKTogUHJvbWlzZTxNZWRpYURldmljZUluZm9bXT4ge1xuICAgIGlmIChEZXZpY2VNYW5hZ2VyLnVzZXJNZWRpYVByb21pc2VNYXA/LnNpemUgPiAwKSB7XG4gICAgICBsb2cuZGVidWcoJ2F3YWl0aW5nIGdldFVzZXJNZWRpYSBwcm9taXNlJyk7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoa2luZCkge1xuICAgICAgICAgIGF3YWl0IERldmljZU1hbmFnZXIudXNlck1lZGlhUHJvbWlzZU1hcC5nZXQoa2luZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoRGV2aWNlTWFuYWdlci51c2VyTWVkaWFQcm9taXNlTWFwLnZhbHVlcygpKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZTogYW55KSB7XG4gICAgICAgIGxvZy53YXJuKCdlcnJvciB3YWl0aW5nIGZvciBtZWRpYSBwZXJtaXNzb25zJyk7XG4gICAgICB9XG4gICAgfVxuICAgIGxldCBkZXZpY2VzID0gYXdhaXQgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5lbnVtZXJhdGVEZXZpY2VzKCk7XG5cbiAgICBpZiAoXG4gICAgICByZXF1ZXN0UGVybWlzc2lvbnMgJiZcbiAgICAgIC8vIGZvciBzYWZhcmkgd2UgbmVlZCB0byBza2lwIHRoaXMgY2hlY2ssIGFzIG90aGVyd2lzZSBpdCB3aWxsIHJlLWFjcXVpcmUgdXNlciBtZWRpYSBhbmQgZmFpbCBvbiBpT1MgaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTE3OTM2M1xuICAgICAgIShpc1NhZmFyaSgpICYmIHRoaXMuaGFzRGV2aWNlSW5Vc2Uoa2luZCkpXG4gICAgKSB7XG4gICAgICBjb25zdCBpc0R1bW15RGV2aWNlT3JFbXB0eSA9XG4gICAgICAgIGRldmljZXMubGVuZ3RoID09PSAwIHx8XG4gICAgICAgIGRldmljZXMuc29tZSgoZGV2aWNlKSA9PiB7XG4gICAgICAgICAgY29uc3Qgbm9MYWJlbCA9IGRldmljZS5sYWJlbCA9PT0gJyc7XG4gICAgICAgICAgY29uc3QgaXNSZWxldmFudCA9IGtpbmQgPyBkZXZpY2Uua2luZCA9PT0ga2luZCA6IHRydWU7XG4gICAgICAgICAgcmV0dXJuIG5vTGFiZWwgJiYgaXNSZWxldmFudDtcbiAgICAgICAgfSk7XG5cbiAgICAgIGlmIChpc0R1bW15RGV2aWNlT3JFbXB0eSkge1xuICAgICAgICBjb25zdCBwZXJtaXNzaW9uc1RvQWNxdWlyZSA9IHtcbiAgICAgICAgICB2aWRlbzoga2luZCAhPT0gJ2F1ZGlvaW5wdXQnICYmIGtpbmQgIT09ICdhdWRpb291dHB1dCcsXG4gICAgICAgICAgYXVkaW86IGtpbmQgIT09ICd2aWRlb2lucHV0JyxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgc3RyZWFtID0gYXdhaXQgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEocGVybWlzc2lvbnNUb0FjcXVpcmUpO1xuICAgICAgICBkZXZpY2VzID0gYXdhaXQgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5lbnVtZXJhdGVEZXZpY2VzKCk7XG4gICAgICAgIHN0cmVhbS5nZXRUcmFja3MoKS5mb3JFYWNoKCh0cmFjaykgPT4ge1xuICAgICAgICAgIHRyYWNrLnN0b3AoKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChraW5kKSB7XG4gICAgICBkZXZpY2VzID0gZGV2aWNlcy5maWx0ZXIoKGRldmljZSkgPT4gZGV2aWNlLmtpbmQgPT09IGtpbmQpO1xuICAgIH1cblxuICAgIHJldHVybiBkZXZpY2VzO1xuICB9XG5cbiAgYXN5bmMgbm9ybWFsaXplRGV2aWNlSWQoXG4gICAga2luZDogTWVkaWFEZXZpY2VLaW5kLFxuICAgIGRldmljZUlkPzogc3RyaW5nLFxuICAgIGdyb3VwSWQ/OiBzdHJpbmcsXG4gICk6IFByb21pc2U8c3RyaW5nIHwgdW5kZWZpbmVkPiB7XG4gICAgaWYgKGRldmljZUlkICE9PSBkZWZhdWx0SWQpIHtcbiAgICAgIHJldHVybiBkZXZpY2VJZDtcbiAgICB9XG5cbiAgICAvLyByZXNvbHZlIGFjdHVhbCBkZXZpY2UgaWQgaWYgaXQncyAnZGVmYXVsdCc6IENocm9tZSByZXR1cm5zIGl0IHdoZW4gbm9cbiAgICAvLyBkZXZpY2UgaGFzIGJlZW4gY2hvc2VuXG4gICAgY29uc3QgZGV2aWNlcyA9IGF3YWl0IHRoaXMuZ2V0RGV2aWNlcyhraW5kKTtcblxuICAgIGNvbnN0IGRldmljZSA9IGRldmljZXMuZmluZCgoZCkgPT4gZC5ncm91cElkID09PSBncm91cElkICYmIGQuZGV2aWNlSWQgIT09IGRlZmF1bHRJZCk7XG5cbiAgICByZXR1cm4gZGV2aWNlPy5kZXZpY2VJZDtcbiAgfVxuXG4gIHByaXZhdGUgaGFzRGV2aWNlSW5Vc2Uoa2luZD86IE1lZGlhRGV2aWNlS2luZCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBraW5kXG4gICAgICA/IERldmljZU1hbmFnZXIudXNlck1lZGlhUHJvbWlzZU1hcC5oYXMoa2luZClcbiAgICAgIDogRGV2aWNlTWFuYWdlci51c2VyTWVkaWFQcm9taXNlTWFwLnNpemUgPiAwO1xuICB9XG59XG4iLCJpbXBvcnQgeyBkZWJvdW5jZSB9IGZyb20gJ3RzLWRlYm91bmNlJztcbmltcG9ydCB7IGdldEJyb3dzZXIgfSBmcm9tICcuLi8uLi91dGlscy9icm93c2VyUGFyc2VyJztcbmltcG9ydCBEZXZpY2VNYW5hZ2VyIGZyb20gJy4uL0RldmljZU1hbmFnZXInO1xuaW1wb3J0IHsgRGV2aWNlVW5zdXBwb3J0ZWRFcnJvciwgVHJhY2tJbnZhbGlkRXJyb3IgfSBmcm9tICcuLi9lcnJvcnMnO1xuaW1wb3J0IHsgVHJhY2tFdmVudCB9IGZyb20gJy4uL2V2ZW50cyc7XG5pbXBvcnQgdHlwZSB7IExvZ2dlck9wdGlvbnMgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyBNdXRleCwgY29tcGFyZVZlcnNpb25zLCBpc01vYmlsZSwgc2xlZXAgfSBmcm9tICcuLi91dGlscyc7XG5pbXBvcnQgeyBUcmFjaywgYXR0YWNoVG9FbGVtZW50LCBkZXRhY2hUcmFjayB9IGZyb20gJy4vVHJhY2snO1xuaW1wb3J0IHR5cGUgeyBWaWRlb0NvZGVjIH0gZnJvbSAnLi9vcHRpb25zJztcbmltcG9ydCB0eXBlIHsgVHJhY2tQcm9jZXNzb3IgfSBmcm9tICcuL3Byb2Nlc3Nvci90eXBlcyc7XG5cbmNvbnN0IGRlZmF1bHREaW1lbnNpb25zVGltZW91dCA9IDEwMDA7XG5cbmV4cG9ydCBkZWZhdWx0IGFic3RyYWN0IGNsYXNzIExvY2FsVHJhY2sgZXh0ZW5kcyBUcmFjayB7XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgc2VuZGVyPzogUlRDUnRwU2VuZGVyO1xuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgY29kZWM/OiBWaWRlb0NvZGVjO1xuXG4gIGdldCBjb25zdHJhaW50cygpIHtcbiAgICByZXR1cm4gdGhpcy5fY29uc3RyYWludHM7XG4gIH1cblxuICBwcm90ZWN0ZWQgX2NvbnN0cmFpbnRzOiBNZWRpYVRyYWNrQ29uc3RyYWludHM7XG5cbiAgcHJvdGVjdGVkIHJlYWNxdWlyZVRyYWNrOiBib29sZWFuO1xuXG4gIHByb3RlY3RlZCBwcm92aWRlZEJ5VXNlcjogYm9vbGVhbjtcblxuICBwcm90ZWN0ZWQgbXV0ZUxvY2s6IE11dGV4O1xuXG4gIHByb3RlY3RlZCBwYXVzZVVwc3RyZWFtTG9jazogTXV0ZXg7XG5cbiAgcHJvdGVjdGVkIHByb2Nlc3NvckVsZW1lbnQ/OiBIVE1MTWVkaWFFbGVtZW50O1xuXG4gIHByb3RlY3RlZCBwcm9jZXNzb3I/OiBUcmFja1Byb2Nlc3Nvcjx0aGlzWydraW5kJ10+O1xuXG4gIHByb3RlY3RlZCBwcm9jZXNzb3JMb2NrOiBNdXRleDtcblxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIG1lZGlhVHJhY2tcbiAgICogQHBhcmFtIGtpbmRcbiAgICogQHBhcmFtIGNvbnN0cmFpbnRzIE1lZGlhVHJhY2tDb25zdHJhaW50cyB0aGF0IGFyZSBiZWluZyB1c2VkIHdoZW4gcmVzdGFydGluZyBvciByZWFjcXVpcmluZyB0cmFja3NcbiAgICogQHBhcmFtIHVzZXJQcm92aWRlZFRyYWNrIFNpZ25hbHMgdG8gdGhlIFNESyB3aGV0aGVyIG9yIG5vdCB0aGUgbWVkaWFUcmFjayBzaG91bGQgYmUgbWFuYWdlZCAoaS5lLiByZWxlYXNlZCBhbmQgcmVhY3F1aXJlZCkgaW50ZXJuYWxseSBieSB0aGUgU0RLXG4gICAqL1xuICBwcm90ZWN0ZWQgY29uc3RydWN0b3IoXG4gICAgbWVkaWFUcmFjazogTWVkaWFTdHJlYW1UcmFjayxcbiAgICBraW5kOiBUcmFjay5LaW5kLFxuICAgIGNvbnN0cmFpbnRzPzogTWVkaWFUcmFja0NvbnN0cmFpbnRzLFxuICAgIHVzZXJQcm92aWRlZFRyYWNrID0gZmFsc2UsXG4gICAgbG9nZ2VyT3B0aW9ucz86IExvZ2dlck9wdGlvbnMsXG4gICkge1xuICAgIHN1cGVyKG1lZGlhVHJhY2ssIGtpbmQsIGxvZ2dlck9wdGlvbnMpO1xuICAgIHRoaXMucmVhY3F1aXJlVHJhY2sgPSBmYWxzZTtcbiAgICB0aGlzLnByb3ZpZGVkQnlVc2VyID0gdXNlclByb3ZpZGVkVHJhY2s7XG4gICAgdGhpcy5tdXRlTG9jayA9IG5ldyBNdXRleCgpO1xuICAgIHRoaXMucGF1c2VVcHN0cmVhbUxvY2sgPSBuZXcgTXV0ZXgoKTtcbiAgICB0aGlzLnByb2Nlc3NvckxvY2sgPSBuZXcgTXV0ZXgoKTtcbiAgICB0aGlzLnNldE1lZGlhU3RyZWFtVHJhY2sobWVkaWFUcmFjaywgdHJ1ZSk7XG5cbiAgICAvLyBhZGRlZCB0byBzYXRpc2Z5IFRTIGNvbXBpbGVyLCBjb25zdHJhaW50cyBhcmUgc3luY2VkIHdpdGggTWVkaWFTdHJlYW1UcmFja1xuICAgIHRoaXMuX2NvbnN0cmFpbnRzID0gbWVkaWFUcmFjay5nZXRDb25zdHJhaW50cygpO1xuICAgIGlmIChjb25zdHJhaW50cykge1xuICAgICAgdGhpcy5fY29uc3RyYWludHMgPSBjb25zdHJhaW50cztcbiAgICB9XG4gIH1cblxuICBnZXQgaWQoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5fbWVkaWFTdHJlYW1UcmFjay5pZDtcbiAgfVxuXG4gIGdldCBkaW1lbnNpb25zKCk6IFRyYWNrLkRpbWVuc2lvbnMgfCB1bmRlZmluZWQge1xuICAgIGlmICh0aGlzLmtpbmQgIT09IFRyYWNrLktpbmQuVmlkZW8pIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSB0aGlzLl9tZWRpYVN0cmVhbVRyYWNrLmdldFNldHRpbmdzKCk7XG4gICAgaWYgKHdpZHRoICYmIGhlaWdodCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgd2lkdGgsXG4gICAgICAgIGhlaWdodCxcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICBwcml2YXRlIF9pc1Vwc3RyZWFtUGF1c2VkOiBib29sZWFuID0gZmFsc2U7XG5cbiAgZ2V0IGlzVXBzdHJlYW1QYXVzZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lzVXBzdHJlYW1QYXVzZWQ7XG4gIH1cblxuICBnZXQgaXNVc2VyUHJvdmlkZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvdmlkZWRCeVVzZXI7XG4gIH1cblxuICBnZXQgbWVkaWFTdHJlYW1UcmFjaygpIHtcbiAgICByZXR1cm4gdGhpcy5wcm9jZXNzb3I/LnByb2Nlc3NlZFRyYWNrID8/IHRoaXMuX21lZGlhU3RyZWFtVHJhY2s7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIHNldE1lZGlhU3RyZWFtVHJhY2sobmV3VHJhY2s6IE1lZGlhU3RyZWFtVHJhY2ssIGZvcmNlPzogYm9vbGVhbikge1xuICAgIGlmIChuZXdUcmFjayA9PT0gdGhpcy5fbWVkaWFTdHJlYW1UcmFjayAmJiAhZm9yY2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuX21lZGlhU3RyZWFtVHJhY2spIHtcbiAgICAgIC8vIGRldGFjaFxuICAgICAgdGhpcy5hdHRhY2hlZEVsZW1lbnRzLmZvckVhY2goKGVsKSA9PiB7XG4gICAgICAgIGRldGFjaFRyYWNrKHRoaXMuX21lZGlhU3RyZWFtVHJhY2ssIGVsKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5kZWJvdW5jZWRUcmFja011dGVIYW5kbGVyLmNhbmNlbCgnbmV3LXRyYWNrJyk7XG4gICAgICB0aGlzLl9tZWRpYVN0cmVhbVRyYWNrLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2VuZGVkJywgdGhpcy5oYW5kbGVFbmRlZCk7XG4gICAgICB0aGlzLl9tZWRpYVN0cmVhbVRyYWNrLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ211dGUnLCB0aGlzLmhhbmRsZVRyYWNrTXV0ZUV2ZW50KTtcbiAgICAgIHRoaXMuX21lZGlhU3RyZWFtVHJhY2sucmVtb3ZlRXZlbnRMaXN0ZW5lcigndW5tdXRlJywgdGhpcy5oYW5kbGVUcmFja1VubXV0ZUV2ZW50KTtcbiAgICB9XG5cbiAgICB0aGlzLm1lZGlhU3RyZWFtID0gbmV3IE1lZGlhU3RyZWFtKFtuZXdUcmFja10pO1xuICAgIGlmIChuZXdUcmFjaykge1xuICAgICAgbmV3VHJhY2suYWRkRXZlbnRMaXN0ZW5lcignZW5kZWQnLCB0aGlzLmhhbmRsZUVuZGVkKTtcbiAgICAgIC8vIHdoZW4gdW5kZXJseWluZyB0cmFjayBlbWl0cyBtdXRlLCBpdCBpbmRpY2F0ZXMgdGhhdCB0aGUgZGV2aWNlIGlzIHVuYWJsZVxuICAgICAgLy8gdG8gcHJvZHVjZSBtZWRpYS4gSW4gdGhpcyBjYXNlIHdlJ2xsIG5lZWQgdG8gc2lnbmFsIHdpdGggcmVtb3RlIHRoYXRcbiAgICAgIC8vIHRoZSB0cmFjayBpcyBcIm11dGVkXCJcbiAgICAgIC8vIG5vdGUgdGhpcyBpcyBkaWZmZXJlbnQgZnJvbSBMb2NhbFRyYWNrLm11dGUgYmVjYXVzZSB3ZSBkbyBub3Qgd2FudCB0b1xuICAgICAgLy8gdG91Y2ggTWVkaWFTdHJlYW1UcmFjay5lbmFibGVkXG4gICAgICBuZXdUcmFjay5hZGRFdmVudExpc3RlbmVyKCdtdXRlJywgdGhpcy5oYW5kbGVUcmFja011dGVFdmVudCk7XG4gICAgICBuZXdUcmFjay5hZGRFdmVudExpc3RlbmVyKCd1bm11dGUnLCB0aGlzLmhhbmRsZVRyYWNrVW5tdXRlRXZlbnQpO1xuICAgICAgdGhpcy5fY29uc3RyYWludHMgPSBuZXdUcmFjay5nZXRDb25zdHJhaW50cygpO1xuICAgIH1cbiAgICBsZXQgcHJvY2Vzc2VkVHJhY2s6IE1lZGlhU3RyZWFtVHJhY2sgfCB1bmRlZmluZWQ7XG4gICAgaWYgKHRoaXMucHJvY2Vzc29yICYmIG5ld1RyYWNrICYmIHRoaXMucHJvY2Vzc29yRWxlbWVudCkge1xuICAgICAgdGhpcy5sb2cuZGVidWcoJ3Jlc3RhcnRpbmcgcHJvY2Vzc29yJywgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgIGlmICh0aGlzLmtpbmQgPT09ICd1bmtub3duJykge1xuICAgICAgICB0aHJvdyBUeXBlRXJyb3IoJ2Nhbm5vdCBzZXQgcHJvY2Vzc29yIG9uIHRyYWNrIG9mIHVua25vd24ga2luZCcpO1xuICAgICAgfVxuXG4gICAgICBhdHRhY2hUb0VsZW1lbnQobmV3VHJhY2ssIHRoaXMucHJvY2Vzc29yRWxlbWVudCk7XG4gICAgICAvLyBlbnN1cmUgdGhlIHByb2Nlc3NvckVsZW1lbnQgaXRzZWxmIHN0YXlzIG11dGVkXG4gICAgICB0aGlzLnByb2Nlc3NvckVsZW1lbnQubXV0ZWQgPSB0cnVlO1xuICAgICAgYXdhaXQgdGhpcy5wcm9jZXNzb3IucmVzdGFydCh7XG4gICAgICAgIHRyYWNrOiBuZXdUcmFjayxcbiAgICAgICAga2luZDogdGhpcy5raW5kLFxuICAgICAgICBlbGVtZW50OiB0aGlzLnByb2Nlc3NvckVsZW1lbnQsXG4gICAgICB9KTtcbiAgICAgIHByb2Nlc3NlZFRyYWNrID0gdGhpcy5wcm9jZXNzb3IucHJvY2Vzc2VkVHJhY2s7XG4gICAgfVxuICAgIGlmICh0aGlzLnNlbmRlcikge1xuICAgICAgYXdhaXQgdGhpcy5zZW5kZXIucmVwbGFjZVRyYWNrKHByb2Nlc3NlZFRyYWNrID8/IG5ld1RyYWNrKTtcbiAgICB9XG4gICAgLy8gaWYgYG5ld1RyYWNrYCBpcyBkaWZmZXJlbnQgZnJvbSB0aGUgZXhpc3RpbmcgdHJhY2ssIHN0b3AgdGhlXG4gICAgLy8gb2xkZXIgdHJhY2sganVzdCBiZWZvcmUgcmVwbGFjaW5nIGl0XG4gICAgaWYgKCF0aGlzLnByb3ZpZGVkQnlVc2VyICYmIHRoaXMuX21lZGlhU3RyZWFtVHJhY2sgIT09IG5ld1RyYWNrKSB7XG4gICAgICB0aGlzLl9tZWRpYVN0cmVhbVRyYWNrLnN0b3AoKTtcbiAgICB9XG4gICAgdGhpcy5fbWVkaWFTdHJlYW1UcmFjayA9IG5ld1RyYWNrO1xuICAgIGlmIChuZXdUcmFjaykge1xuICAgICAgLy8gc3luYyBtdXRlZCBzdGF0ZSB3aXRoIHRoZSBlbmFibGVkIHN0YXRlIG9mIHRoZSBuZXdseSBwcm92aWRlZCB0cmFja1xuICAgICAgdGhpcy5fbWVkaWFTdHJlYW1UcmFjay5lbmFibGVkID0gIXRoaXMuaXNNdXRlZDtcbiAgICAgIC8vIHdoZW4gYSB2YWxpZCB0cmFjayBpcyByZXBsYWNlLCB3ZSdkIHdhbnQgdG8gc3RhcnQgcHJvZHVjaW5nXG4gICAgICBhd2FpdCB0aGlzLnJlc3VtZVVwc3RyZWFtKCk7XG4gICAgICB0aGlzLmF0dGFjaGVkRWxlbWVudHMuZm9yRWFjaCgoZWwpID0+IHtcbiAgICAgICAgYXR0YWNoVG9FbGVtZW50KHByb2Nlc3NlZFRyYWNrID8/IG5ld1RyYWNrLCBlbCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBhc3luYyB3YWl0Rm9yRGltZW5zaW9ucyh0aW1lb3V0ID0gZGVmYXVsdERpbWVuc2lvbnNUaW1lb3V0KTogUHJvbWlzZTxUcmFjay5EaW1lbnNpb25zPiB7XG4gICAgaWYgKHRoaXMua2luZCA9PT0gVHJhY2suS2luZC5BdWRpbykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdjYW5ub3QgZ2V0IGRpbWVuc2lvbnMgZm9yIGF1ZGlvIHRyYWNrcycpO1xuICAgIH1cblxuICAgIGlmIChnZXRCcm93c2VyKCk/Lm9zID09PSAnaU9TJykge1xuICAgICAgLy8gYnJvd3NlcnMgcmVwb3J0IHdyb25nIGluaXRpYWwgcmVzb2x1dGlvbiBvbiBpT1MuXG4gICAgICAvLyB3aGVuIHNsaWdodGx5IGRlbGF5aW5nIHRoZSBjYWxsIHRvIC5nZXRTZXR0aW5ncygpLCB0aGUgY29ycmVjdCByZXNvbHV0aW9uIGlzIGJlaW5nIHJlcG9ydGVkXG4gICAgICBhd2FpdCBzbGVlcCgxMCk7XG4gICAgfVxuXG4gICAgY29uc3Qgc3RhcnRlZCA9IERhdGUubm93KCk7XG4gICAgd2hpbGUgKERhdGUubm93KCkgLSBzdGFydGVkIDwgdGltZW91dCkge1xuICAgICAgY29uc3QgZGltcyA9IHRoaXMuZGltZW5zaW9ucztcbiAgICAgIGlmIChkaW1zKSB7XG4gICAgICAgIHJldHVybiBkaW1zO1xuICAgICAgfVxuICAgICAgYXdhaXQgc2xlZXAoNTApO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgVHJhY2tJbnZhbGlkRXJyb3IoJ3VuYWJsZSB0byBnZXQgdHJhY2sgZGltZW5zaW9ucyBhZnRlciB0aW1lb3V0Jyk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybnMgRGV2aWNlSUQgb2YgdGhlIGRldmljZSB0aGF0IGlzIGN1cnJlbnRseSBiZWluZyB1c2VkIGZvciB0aGlzIHRyYWNrXG4gICAqL1xuICBhc3luYyBnZXREZXZpY2VJZCgpOiBQcm9taXNlPHN0cmluZyB8IHVuZGVmaW5lZD4ge1xuICAgIC8vIHNjcmVlbiBzaGFyZSBkb2Vzbid0IGhhdmUgYSB1c2FibGUgZGV2aWNlIGlkXG4gICAgaWYgKHRoaXMuc291cmNlID09PSBUcmFjay5Tb3VyY2UuU2NyZWVuU2hhcmUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgeyBkZXZpY2VJZCwgZ3JvdXBJZCB9ID0gdGhpcy5fbWVkaWFTdHJlYW1UcmFjay5nZXRTZXR0aW5ncygpO1xuICAgIGNvbnN0IGtpbmQgPSB0aGlzLmtpbmQgPT09IFRyYWNrLktpbmQuQXVkaW8gPyAnYXVkaW9pbnB1dCcgOiAndmlkZW9pbnB1dCc7XG5cbiAgICByZXR1cm4gRGV2aWNlTWFuYWdlci5nZXRJbnN0YW5jZSgpLm5vcm1hbGl6ZURldmljZUlkKGtpbmQsIGRldmljZUlkLCBncm91cElkKTtcbiAgfVxuXG4gIGFzeW5jIG11dGUoKTogUHJvbWlzZTxMb2NhbFRyYWNrPiB7XG4gICAgdGhpcy5zZXRUcmFja011dGVkKHRydWUpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgYXN5bmMgdW5tdXRlKCk6IFByb21pc2U8TG9jYWxUcmFjaz4ge1xuICAgIHRoaXMuc2V0VHJhY2tNdXRlZChmYWxzZSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBhc3luYyByZXBsYWNlVHJhY2sodHJhY2s6IE1lZGlhU3RyZWFtVHJhY2ssIHVzZXJQcm92aWRlZFRyYWNrID0gdHJ1ZSk6IFByb21pc2U8TG9jYWxUcmFjaz4ge1xuICAgIGlmICghdGhpcy5zZW5kZXIpIHtcbiAgICAgIHRocm93IG5ldyBUcmFja0ludmFsaWRFcnJvcigndW5hYmxlIHRvIHJlcGxhY2UgYW4gdW5wdWJsaXNoZWQgdHJhY2snKTtcbiAgICB9XG5cbiAgICB0aGlzLmxvZy5kZWJ1ZygncmVwbGFjZSBNZWRpYVN0cmVhbVRyYWNrJywgdGhpcy5sb2dDb250ZXh0KTtcbiAgICBhd2FpdCB0aGlzLnNldE1lZGlhU3RyZWFtVHJhY2sodHJhY2spO1xuICAgIC8vIHRoaXMgbXVzdCBiZSBzeW5jZWQgKmFmdGVyKiBzZXR0aW5nIG1lZGlhU3RyZWFtVHJhY2sgYWJvdmUsIHNpbmNlIGl0IHJlbGllc1xuICAgIC8vIG9uIHRoZSBwcmV2aW91cyBzdGF0ZSBpbiBvcmRlciB0byBjbGVhbnVwXG4gICAgdGhpcy5wcm92aWRlZEJ5VXNlciA9IHVzZXJQcm92aWRlZFRyYWNrO1xuXG4gICAgaWYgKHRoaXMucHJvY2Vzc29yKSB7XG4gICAgICBhd2FpdCB0aGlzLnN0b3BQcm9jZXNzb3IoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBwcm90ZWN0ZWQgYXN5bmMgcmVzdGFydChjb25zdHJhaW50cz86IE1lZGlhVHJhY2tDb25zdHJhaW50cyk6IFByb21pc2U8TG9jYWxUcmFjaz4ge1xuICAgIGlmICghY29uc3RyYWludHMpIHtcbiAgICAgIGNvbnN0cmFpbnRzID0gdGhpcy5fY29uc3RyYWludHM7XG4gICAgfVxuICAgIHRoaXMubG9nLmRlYnVnKCdyZXN0YXJ0aW5nIHRyYWNrIHdpdGggY29uc3RyYWludHMnLCB7IC4uLnRoaXMubG9nQ29udGV4dCwgY29uc3RyYWludHMgfSk7XG5cbiAgICBjb25zdCBzdHJlYW1Db25zdHJhaW50czogTWVkaWFTdHJlYW1Db25zdHJhaW50cyA9IHtcbiAgICAgIGF1ZGlvOiBmYWxzZSxcbiAgICAgIHZpZGVvOiBmYWxzZSxcbiAgICB9O1xuXG4gICAgaWYgKHRoaXMua2luZCA9PT0gVHJhY2suS2luZC5WaWRlbykge1xuICAgICAgc3RyZWFtQ29uc3RyYWludHMudmlkZW8gPSBjb25zdHJhaW50cztcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyZWFtQ29uc3RyYWludHMuYXVkaW8gPSBjb25zdHJhaW50cztcbiAgICB9XG5cbiAgICAvLyB0aGVzZSBzdGVwcyBhcmUgZHVwbGljYXRlZCBmcm9tIHNldE1lZGlhU3RyZWFtVHJhY2sgYmVjYXVzZSB3ZSBtdXN0IHN0b3BcbiAgICAvLyB0aGUgcHJldmlvdXMgdHJhY2tzIGJlZm9yZSBuZXcgdHJhY2tzIGNhbiBiZSBhY3F1aXJlZFxuICAgIHRoaXMuYXR0YWNoZWRFbGVtZW50cy5mb3JFYWNoKChlbCkgPT4ge1xuICAgICAgZGV0YWNoVHJhY2sodGhpcy5tZWRpYVN0cmVhbVRyYWNrLCBlbCk7XG4gICAgfSk7XG4gICAgdGhpcy5fbWVkaWFTdHJlYW1UcmFjay5yZW1vdmVFdmVudExpc3RlbmVyKCdlbmRlZCcsIHRoaXMuaGFuZGxlRW5kZWQpO1xuICAgIC8vIG9uIFNhZmFyaSwgdGhlIG9sZCBhdWRpbyB0cmFjayBtdXN0IGJlIHN0b3BwZWQgYmVmb3JlIGF0dGVtcHRpbmcgdG8gYWNxdWlyZVxuICAgIC8vIHRoZSBuZXcgdHJhY2ssIG90aGVyd2lzZSB0aGUgbmV3IHRyYWNrIHdpbGwgc3RvcCB3aXRoXG4gICAgLy8gJ0EgTWVkaWFTdHJlYW1UcmFjayBlbmRlZCBkdWUgdG8gYSBjYXB0dXJlIGZhaWx1cmVgXG4gICAgdGhpcy5fbWVkaWFTdHJlYW1UcmFjay5zdG9wKCk7XG5cbiAgICAvLyBjcmVhdGUgbmV3IHRyYWNrIGFuZCBhdHRhY2hcbiAgICBjb25zdCBtZWRpYVN0cmVhbSA9IGF3YWl0IG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKHN0cmVhbUNvbnN0cmFpbnRzKTtcbiAgICBjb25zdCBuZXdUcmFjayA9IG1lZGlhU3RyZWFtLmdldFRyYWNrcygpWzBdO1xuICAgIG5ld1RyYWNrLmFkZEV2ZW50TGlzdGVuZXIoJ2VuZGVkJywgdGhpcy5oYW5kbGVFbmRlZCk7XG4gICAgdGhpcy5sb2cuZGVidWcoJ3JlLWFjcXVpcmVkIE1lZGlhU3RyZWFtVHJhY2snLCB0aGlzLmxvZ0NvbnRleHQpO1xuXG4gICAgYXdhaXQgdGhpcy5zZXRNZWRpYVN0cmVhbVRyYWNrKG5ld1RyYWNrKTtcbiAgICB0aGlzLl9jb25zdHJhaW50cyA9IGNvbnN0cmFpbnRzO1xuXG4gICAgdGhpcy5lbWl0KFRyYWNrRXZlbnQuUmVzdGFydGVkLCB0aGlzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHByb3RlY3RlZCBzZXRUcmFja011dGVkKG11dGVkOiBib29sZWFuKSB7XG4gICAgdGhpcy5sb2cuZGVidWcoYHNldHRpbmcgJHt0aGlzLmtpbmR9IHRyYWNrICR7bXV0ZWQgPyAnbXV0ZWQnIDogJ3VubXV0ZWQnfWAsIHRoaXMubG9nQ29udGV4dCk7XG5cbiAgICBpZiAodGhpcy5pc011dGVkID09PSBtdXRlZCAmJiB0aGlzLl9tZWRpYVN0cmVhbVRyYWNrLmVuYWJsZWQgIT09IG11dGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5pc011dGVkID0gbXV0ZWQ7XG4gICAgdGhpcy5fbWVkaWFTdHJlYW1UcmFjay5lbmFibGVkID0gIW11dGVkO1xuICAgIHRoaXMuZW1pdChtdXRlZCA/IFRyYWNrRXZlbnQuTXV0ZWQgOiBUcmFja0V2ZW50LlVubXV0ZWQsIHRoaXMpO1xuICB9XG5cbiAgcHJvdGVjdGVkIGdldCBuZWVkc1JlQWNxdWlzaXRpb24oKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIChcbiAgICAgIHRoaXMuX21lZGlhU3RyZWFtVHJhY2sucmVhZHlTdGF0ZSAhPT0gJ2xpdmUnIHx8XG4gICAgICB0aGlzLl9tZWRpYVN0cmVhbVRyYWNrLm11dGVkIHx8XG4gICAgICAhdGhpcy5fbWVkaWFTdHJlYW1UcmFjay5lbmFibGVkIHx8XG4gICAgICB0aGlzLnJlYWNxdWlyZVRyYWNrXG4gICAgKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBhc3luYyBoYW5kbGVBcHBWaXNpYmlsaXR5Q2hhbmdlZCgpIHtcbiAgICBhd2FpdCBzdXBlci5oYW5kbGVBcHBWaXNpYmlsaXR5Q2hhbmdlZCgpO1xuICAgIGlmICghaXNNb2JpbGUoKSkgcmV0dXJuO1xuICAgIHRoaXMubG9nLmRlYnVnKGB2aXNpYmlsaXR5IGNoYW5nZWQsIGlzIGluIEJhY2tncm91bmQ6ICR7dGhpcy5pc0luQmFja2dyb3VuZH1gLCB0aGlzLmxvZ0NvbnRleHQpO1xuXG4gICAgaWYgKCF0aGlzLmlzSW5CYWNrZ3JvdW5kICYmIHRoaXMubmVlZHNSZUFjcXVpc2l0aW9uICYmICF0aGlzLmlzVXNlclByb3ZpZGVkICYmICF0aGlzLmlzTXV0ZWQpIHtcbiAgICAgIHRoaXMubG9nLmRlYnVnKGB0cmFjayBuZWVkcyB0byBiZSByZWFjcXVpcmVkLCByZXN0YXJ0aW5nICR7dGhpcy5zb3VyY2V9YCwgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgIGF3YWl0IHRoaXMucmVzdGFydCgpO1xuICAgICAgdGhpcy5yZWFjcXVpcmVUcmFjayA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgaGFuZGxlVHJhY2tNdXRlRXZlbnQgPSAoKSA9PlxuICAgIHRoaXMuZGVib3VuY2VkVHJhY2tNdXRlSGFuZGxlcigpLmNhdGNoKCgpID0+XG4gICAgICB0aGlzLmxvZy5kZWJ1ZygndHJhY2sgbXV0ZSBib3VuY2UgZ290IGNhbmNlbGxlZCBieSBhbiB1bm11dGUgZXZlbnQnLCB0aGlzLmxvZ0NvbnRleHQpLFxuICAgICk7XG5cbiAgcHJpdmF0ZSBkZWJvdW5jZWRUcmFja011dGVIYW5kbGVyID0gZGVib3VuY2UoYXN5bmMgKCkgPT4ge1xuICAgIGF3YWl0IHRoaXMucGF1c2VVcHN0cmVhbSgpO1xuICB9LCA1MDAwKTtcblxuICBwcml2YXRlIGhhbmRsZVRyYWNrVW5tdXRlRXZlbnQgPSBhc3luYyAoKSA9PiB7XG4gICAgdGhpcy5kZWJvdW5jZWRUcmFja011dGVIYW5kbGVyLmNhbmNlbCgndW5tdXRlJyk7XG4gICAgYXdhaXQgdGhpcy5yZXN1bWVVcHN0cmVhbSgpO1xuICB9O1xuXG4gIHByaXZhdGUgaGFuZGxlRW5kZWQgPSAoKSA9PiB7XG4gICAgaWYgKHRoaXMuaXNJbkJhY2tncm91bmQpIHtcbiAgICAgIHRoaXMucmVhY3F1aXJlVHJhY2sgPSB0cnVlO1xuICAgIH1cbiAgICB0aGlzLl9tZWRpYVN0cmVhbVRyYWNrLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ211dGUnLCB0aGlzLmhhbmRsZVRyYWNrTXV0ZUV2ZW50KTtcbiAgICB0aGlzLl9tZWRpYVN0cmVhbVRyYWNrLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3VubXV0ZScsIHRoaXMuaGFuZGxlVHJhY2tVbm11dGVFdmVudCk7XG4gICAgdGhpcy5lbWl0KFRyYWNrRXZlbnQuRW5kZWQsIHRoaXMpO1xuICB9O1xuXG4gIHN0b3AoKSB7XG4gICAgc3VwZXIuc3RvcCgpO1xuXG4gICAgdGhpcy5fbWVkaWFTdHJlYW1UcmFjay5yZW1vdmVFdmVudExpc3RlbmVyKCdlbmRlZCcsIHRoaXMuaGFuZGxlRW5kZWQpO1xuICAgIHRoaXMuX21lZGlhU3RyZWFtVHJhY2sucmVtb3ZlRXZlbnRMaXN0ZW5lcignbXV0ZScsIHRoaXMuaGFuZGxlVHJhY2tNdXRlRXZlbnQpO1xuICAgIHRoaXMuX21lZGlhU3RyZWFtVHJhY2sucmVtb3ZlRXZlbnRMaXN0ZW5lcigndW5tdXRlJywgdGhpcy5oYW5kbGVUcmFja1VubXV0ZUV2ZW50KTtcbiAgICB0aGlzLnByb2Nlc3Nvcj8uZGVzdHJveSgpO1xuICAgIHRoaXMucHJvY2Vzc29yID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIHBhdXNlcyBwdWJsaXNoaW5nIHRvIHRoZSBzZXJ2ZXIgd2l0aG91dCBkaXNhYmxpbmcgdGhlIGxvY2FsIE1lZGlhU3RyZWFtVHJhY2tcbiAgICogdGhpcyBpcyB1c2VkIHRvIGRpc3BsYXkgYSB1c2VyJ3Mgb3duIHZpZGVvIGxvY2FsbHkgd2hpbGUgcGF1c2luZyBwdWJsaXNoaW5nIHRvXG4gICAqIHRoZSBzZXJ2ZXIuXG4gICAqIHRoaXMgQVBJIGlzIHVuc3VwcG9ydGVkIG9uIFNhZmFyaSA8IDEyIGR1ZSB0byBhIGJ1Z1xuICAgKiovXG4gIGFzeW5jIHBhdXNlVXBzdHJlYW0oKSB7XG4gICAgY29uc3QgdW5sb2NrID0gYXdhaXQgdGhpcy5wYXVzZVVwc3RyZWFtTG9jay5sb2NrKCk7XG4gICAgdHJ5IHtcbiAgICAgIGlmICh0aGlzLl9pc1Vwc3RyZWFtUGF1c2VkID09PSB0cnVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5zZW5kZXIpIHtcbiAgICAgICAgdGhpcy5sb2cud2FybigndW5hYmxlIHRvIHBhdXNlIHVwc3RyZWFtIGZvciBhbiB1bnB1Ymxpc2hlZCB0cmFjaycsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5faXNVcHN0cmVhbVBhdXNlZCA9IHRydWU7XG4gICAgICB0aGlzLmVtaXQoVHJhY2tFdmVudC5VcHN0cmVhbVBhdXNlZCwgdGhpcyk7XG4gICAgICBjb25zdCBicm93c2VyID0gZ2V0QnJvd3NlcigpO1xuICAgICAgaWYgKGJyb3dzZXI/Lm5hbWUgPT09ICdTYWZhcmknICYmIGNvbXBhcmVWZXJzaW9ucyhicm93c2VyLnZlcnNpb24sICcxMi4wJykgPCAwKSB7XG4gICAgICAgIC8vIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xODQ5MTFcbiAgICAgICAgdGhyb3cgbmV3IERldmljZVVuc3VwcG9ydGVkRXJyb3IoJ3BhdXNlVXBzdHJlYW0gaXMgbm90IHN1cHBvcnRlZCBvbiBTYWZhcmkgPCAxMi4nKTtcbiAgICAgIH1cbiAgICAgIGF3YWl0IHRoaXMuc2VuZGVyLnJlcGxhY2VUcmFjayhudWxsKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdW5sb2NrKCk7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgcmVzdW1lVXBzdHJlYW0oKSB7XG4gICAgY29uc3QgdW5sb2NrID0gYXdhaXQgdGhpcy5wYXVzZVVwc3RyZWFtTG9jay5sb2NrKCk7XG4gICAgdHJ5IHtcbiAgICAgIGlmICh0aGlzLl9pc1Vwc3RyZWFtUGF1c2VkID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuc2VuZGVyKSB7XG4gICAgICAgIHRoaXMubG9nLndhcm4oJ3VuYWJsZSB0byByZXN1bWUgdXBzdHJlYW0gZm9yIGFuIHVucHVibGlzaGVkIHRyYWNrJywgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5faXNVcHN0cmVhbVBhdXNlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5lbWl0KFRyYWNrRXZlbnQuVXBzdHJlYW1SZXN1bWVkLCB0aGlzKTtcblxuICAgICAgLy8gdGhpcyBvcGVyYXRpb24gaXMgbm9vcCBpZiBtZWRpYXN0cmVhbXRyYWNrIGlzIGFscmVhZHkgYmVpbmcgc2VudFxuICAgICAgYXdhaXQgdGhpcy5zZW5kZXIucmVwbGFjZVRyYWNrKHRoaXMuX21lZGlhU3RyZWFtVHJhY2spO1xuICAgIH0gZmluYWxseSB7XG4gICAgICB1bmxvY2soKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgUlRDU3RhdHNSZXBvcnQgZm9yIHRoZSBMb2NhbFRyYWNrJ3MgdW5kZXJseWluZyBSVENSdHBTZW5kZXJcbiAgICogU2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9SVENTdGF0c1JlcG9ydFxuICAgKlxuICAgKiBAcmV0dXJucyBQcm9taXNlPFJUQ1N0YXRzUmVwb3J0PiB8IHVuZGVmaW5lZFxuICAgKi9cbiAgYXN5bmMgZ2V0UlRDU3RhdHNSZXBvcnQoKTogUHJvbWlzZTxSVENTdGF0c1JlcG9ydCB8IHVuZGVmaW5lZD4ge1xuICAgIGlmICghdGhpcy5zZW5kZXI/LmdldFN0YXRzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHN0YXRzUmVwb3J0ID0gYXdhaXQgdGhpcy5zZW5kZXIuZ2V0U3RhdHMoKTtcbiAgICByZXR1cm4gc3RhdHNSZXBvcnQ7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyBhIHByb2Nlc3NvciBvbiB0aGlzIHRyYWNrLlxuICAgKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2xpdmVraXQvdHJhY2stcHJvY2Vzc29ycy1qcyBmb3IgZXhhbXBsZSB1c2FnZVxuICAgKlxuICAgKiBAZXhwZXJpbWVudGFsXG4gICAqXG4gICAqIEBwYXJhbSBwcm9jZXNzb3JcbiAgICogQHBhcmFtIHNob3dQcm9jZXNzZWRTdHJlYW1Mb2NhbGx5XG4gICAqIEByZXR1cm5zXG4gICAqL1xuICBhc3luYyBzZXRQcm9jZXNzb3IocHJvY2Vzc29yOiBUcmFja1Byb2Nlc3Nvcjx0aGlzWydraW5kJ10+LCBzaG93UHJvY2Vzc2VkU3RyZWFtTG9jYWxseSA9IHRydWUpIHtcbiAgICBjb25zdCB1bmxvY2sgPSBhd2FpdCB0aGlzLnByb2Nlc3NvckxvY2subG9jaygpO1xuICAgIHRyeSB7XG4gICAgICB0aGlzLmxvZy5kZWJ1Zygnc2V0dGluZyB1cCBwcm9jZXNzb3InLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgaWYgKHRoaXMucHJvY2Vzc29yKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuc3RvcFByb2Nlc3NvcigpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMua2luZCA9PT0gJ3Vua25vd24nKSB7XG4gICAgICAgIHRocm93IFR5cGVFcnJvcignY2Fubm90IHNldCBwcm9jZXNzb3Igb24gdHJhY2sgb2YgdW5rbm93biBraW5kJyk7XG4gICAgICB9XG4gICAgICB0aGlzLnByb2Nlc3NvckVsZW1lbnQgPSB0aGlzLnByb2Nlc3NvckVsZW1lbnQgPz8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0aGlzLmtpbmQpO1xuXG4gICAgICBhdHRhY2hUb0VsZW1lbnQodGhpcy5fbWVkaWFTdHJlYW1UcmFjaywgdGhpcy5wcm9jZXNzb3JFbGVtZW50KTtcbiAgICAgIHRoaXMucHJvY2Vzc29yRWxlbWVudC5tdXRlZCA9IHRydWU7XG5cbiAgICAgIHRoaXMucHJvY2Vzc29yRWxlbWVudFxuICAgICAgICAucGxheSgpXG4gICAgICAgIC5jYXRjaCgoZXJyb3IpID0+XG4gICAgICAgICAgdGhpcy5sb2cuZXJyb3IoJ2ZhaWxlZCB0byBwbGF5IHByb2Nlc3NvciBlbGVtZW50JywgeyAuLi50aGlzLmxvZ0NvbnRleHQsIGVycm9yIH0pLFxuICAgICAgICApO1xuXG4gICAgICBjb25zdCBwcm9jZXNzb3JPcHRpb25zID0ge1xuICAgICAgICBraW5kOiB0aGlzLmtpbmQsXG4gICAgICAgIHRyYWNrOiB0aGlzLl9tZWRpYVN0cmVhbVRyYWNrLFxuICAgICAgICBlbGVtZW50OiB0aGlzLnByb2Nlc3NvckVsZW1lbnQsXG4gICAgICB9O1xuXG4gICAgICBhd2FpdCBwcm9jZXNzb3IuaW5pdChwcm9jZXNzb3JPcHRpb25zKTtcbiAgICAgIHRoaXMucHJvY2Vzc29yID0gcHJvY2Vzc29yO1xuICAgICAgaWYgKHRoaXMucHJvY2Vzc29yLnByb2Nlc3NlZFRyYWNrKSB7XG4gICAgICAgIGZvciAoY29uc3QgZWwgb2YgdGhpcy5hdHRhY2hlZEVsZW1lbnRzKSB7XG4gICAgICAgICAgaWYgKGVsICE9PSB0aGlzLnByb2Nlc3NvckVsZW1lbnQgJiYgc2hvd1Byb2Nlc3NlZFN0cmVhbUxvY2FsbHkpIHtcbiAgICAgICAgICAgIGRldGFjaFRyYWNrKHRoaXMuX21lZGlhU3RyZWFtVHJhY2ssIGVsKTtcbiAgICAgICAgICAgIGF0dGFjaFRvRWxlbWVudCh0aGlzLnByb2Nlc3Nvci5wcm9jZXNzZWRUcmFjaywgZWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBhd2FpdCB0aGlzLnNlbmRlcj8ucmVwbGFjZVRyYWNrKHRoaXMucHJvY2Vzc29yLnByb2Nlc3NlZFRyYWNrKTtcbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgdW5sb2NrKCk7XG4gICAgfVxuICB9XG5cbiAgZ2V0UHJvY2Vzc29yKCkge1xuICAgIHJldHVybiB0aGlzLnByb2Nlc3NvcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdG9wcyB0aGUgdHJhY2sgcHJvY2Vzc29yXG4gICAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vbGl2ZWtpdC90cmFjay1wcm9jZXNzb3JzLWpzIGZvciBleGFtcGxlIHVzYWdlXG4gICAqXG4gICAqIEBleHBlcmltZW50YWxcbiAgICogQHJldHVybnNcbiAgICovXG4gIGFzeW5jIHN0b3BQcm9jZXNzb3IoKSB7XG4gICAgaWYgKCF0aGlzLnByb2Nlc3NvcikgcmV0dXJuO1xuXG4gICAgdGhpcy5sb2cuZGVidWcoJ3N0b3BwaW5nIHByb2Nlc3NvcicsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgdGhpcy5wcm9jZXNzb3IucHJvY2Vzc2VkVHJhY2s/LnN0b3AoKTtcbiAgICBhd2FpdCB0aGlzLnByb2Nlc3Nvci5kZXN0cm95KCk7XG4gICAgdGhpcy5wcm9jZXNzb3IgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5wcm9jZXNzb3JFbGVtZW50Py5yZW1vdmUoKTtcbiAgICB0aGlzLnByb2Nlc3NvckVsZW1lbnQgPSB1bmRlZmluZWQ7XG5cbiAgICBhd2FpdCB0aGlzLnJlc3RhcnQoKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBhYnN0cmFjdCBtb25pdG9yU2VuZGVyKCk6IHZvaWQ7XG59XG4iLCJpbXBvcnQgeyBFdmVudEVtaXR0ZXIgfSBmcm9tICdldmVudHMnO1xuaW1wb3J0IHR5cGUgVHlwZWRFdmVudEVtaXR0ZXIgZnJvbSAndHlwZWQtZW1pdHRlcic7XG5pbXBvcnQgbG9nIGZyb20gJy4uL2xvZ2dlcic7XG5pbXBvcnQgeyBFbmNyeXB0aW9uX1R5cGUsIFRyYWNrSW5mbyB9IGZyb20gJy4uL3Byb3RvL2xpdmVraXRfbW9kZWxzX3BiJztcbmltcG9ydCB0eXBlIFJUQ0VuZ2luZSBmcm9tICcuLi9yb29tL1JUQ0VuZ2luZSc7XG5pbXBvcnQgdHlwZSBSb29tIGZyb20gJy4uL3Jvb20vUm9vbSc7XG5pbXBvcnQgeyBDb25uZWN0aW9uU3RhdGUgfSBmcm9tICcuLi9yb29tL1Jvb20nO1xuaW1wb3J0IHsgRGV2aWNlVW5zdXBwb3J0ZWRFcnJvciB9IGZyb20gJy4uL3Jvb20vZXJyb3JzJztcbmltcG9ydCB7IEVuZ2luZUV2ZW50LCBQYXJ0aWNpcGFudEV2ZW50LCBSb29tRXZlbnQgfSBmcm9tICcuLi9yb29tL2V2ZW50cyc7XG5pbXBvcnQgTG9jYWxUcmFjayBmcm9tICcuLi9yb29tL3RyYWNrL0xvY2FsVHJhY2snO1xuaW1wb3J0IHR5cGUgUmVtb3RlVHJhY2sgZnJvbSAnLi4vcm9vbS90cmFjay9SZW1vdGVUcmFjayc7XG5pbXBvcnQgdHlwZSB7IFRyYWNrIH0gZnJvbSAnLi4vcm9vbS90cmFjay9UcmFjayc7XG5pbXBvcnQgdHlwZSB7IFZpZGVvQ29kZWMgfSBmcm9tICcuLi9yb29tL3RyYWNrL29wdGlvbnMnO1xuaW1wb3J0IHsgbWltZVR5cGVUb1ZpZGVvQ29kZWNTdHJpbmcgfSBmcm9tICcuLi9yb29tL3RyYWNrL3V0aWxzJztcbmltcG9ydCB0eXBlIHsgQmFzZUtleVByb3ZpZGVyIH0gZnJvbSAnLi9LZXlQcm92aWRlcic7XG5pbXBvcnQgeyBFMkVFX0ZMQUcgfSBmcm9tICcuL2NvbnN0YW50cyc7XG5pbXBvcnQgeyB0eXBlIEUyRUVNYW5hZ2VyQ2FsbGJhY2tzLCBFbmNyeXB0aW9uRXZlbnQsIEtleVByb3ZpZGVyRXZlbnQgfSBmcm9tICcuL2V2ZW50cyc7XG5pbXBvcnQgdHlwZSB7XG4gIEUyRUVPcHRpb25zLFxuICBFMkVFV29ya2VyTWVzc2FnZSxcbiAgRW5hYmxlTWVzc2FnZSxcbiAgRW5jb2RlTWVzc2FnZSxcbiAgSW5pdE1lc3NhZ2UsXG4gIEtleUluZm8sXG4gIFJUUFZpZGVvTWFwTWVzc2FnZSxcbiAgUmF0Y2hldFJlcXVlc3RNZXNzYWdlLFxuICBSZW1vdmVUcmFuc2Zvcm1NZXNzYWdlLFxuICBTZXRLZXlNZXNzYWdlLFxuICBTaWZUcmFpbGVyTWVzc2FnZSxcbiAgVXBkYXRlQ29kZWNNZXNzYWdlLFxufSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCB7IGlzRTJFRVN1cHBvcnRlZCwgaXNTY3JpcHRUcmFuc2Zvcm1TdXBwb3J0ZWQgfSBmcm9tICcuL3V0aWxzJztcblxuLyoqXG4gKiBAZXhwZXJpbWVudGFsXG4gKi9cbmV4cG9ydCBjbGFzcyBFMkVFTWFuYWdlciBleHRlbmRzIChFdmVudEVtaXR0ZXIgYXMgbmV3ICgpID0+IFR5cGVkRXZlbnRFbWl0dGVyPEUyRUVNYW5hZ2VyQ2FsbGJhY2tzPikge1xuICBwcm90ZWN0ZWQgd29ya2VyOiBXb3JrZXI7XG5cbiAgcHJvdGVjdGVkIHJvb20/OiBSb29tO1xuXG4gIHByaXZhdGUgZW5jcnlwdGlvbkVuYWJsZWQ6IGJvb2xlYW47XG5cbiAgcHJpdmF0ZSBrZXlQcm92aWRlcjogQmFzZUtleVByb3ZpZGVyO1xuXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnM6IEUyRUVPcHRpb25zKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmtleVByb3ZpZGVyID0gb3B0aW9ucy5rZXlQcm92aWRlcjtcbiAgICB0aGlzLndvcmtlciA9IG9wdGlvbnMud29ya2VyO1xuICAgIHRoaXMuZW5jcnlwdGlvbkVuYWJsZWQgPSBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHNldHVwKHJvb206IFJvb20pIHtcbiAgICBpZiAoIWlzRTJFRVN1cHBvcnRlZCgpKSB7XG4gICAgICB0aHJvdyBuZXcgRGV2aWNlVW5zdXBwb3J0ZWRFcnJvcihcbiAgICAgICAgJ3RyaWVkIHRvIHNldHVwIGVuZC10by1lbmQgZW5jcnlwdGlvbiBvbiBhbiB1bnN1cHBvcnRlZCBicm93c2VyJyxcbiAgICAgICk7XG4gICAgfVxuICAgIGxvZy5pbmZvKCdzZXR0aW5nIHVwIGUyZWUnKTtcbiAgICBpZiAocm9vbSAhPT0gdGhpcy5yb29tKSB7XG4gICAgICB0aGlzLnJvb20gPSByb29tO1xuICAgICAgdGhpcy5zZXR1cEV2ZW50TGlzdGVuZXJzKHJvb20sIHRoaXMua2V5UHJvdmlkZXIpO1xuICAgICAgLy8gdGhpcy53b3JrZXIgPSBuZXcgV29ya2VyKCcnKTtcbiAgICAgIGNvbnN0IG1zZzogSW5pdE1lc3NhZ2UgPSB7XG4gICAgICAgIGtpbmQ6ICdpbml0JyxcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIGtleVByb3ZpZGVyT3B0aW9uczogdGhpcy5rZXlQcm92aWRlci5nZXRPcHRpb25zKCksXG4gICAgICAgIH0sXG4gICAgICB9O1xuICAgICAgaWYgKHRoaXMud29ya2VyKSB7XG4gICAgICAgIGxvZy5pbmZvKGBpbml0aWFsaXppbmcgd29ya2VyYCwgeyB3b3JrZXI6IHRoaXMud29ya2VyIH0pO1xuICAgICAgICB0aGlzLndvcmtlci5vbm1lc3NhZ2UgPSB0aGlzLm9uV29ya2VyTWVzc2FnZTtcbiAgICAgICAgdGhpcy53b3JrZXIub25lcnJvciA9IHRoaXMub25Xb3JrZXJFcnJvcjtcbiAgICAgICAgdGhpcy53b3JrZXIucG9zdE1lc3NhZ2UobXNnKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBzZXRQYXJ0aWNpcGFudENyeXB0b3JFbmFibGVkKGVuYWJsZWQ6IGJvb2xlYW4sIHBhcnRpY2lwYW50SWRlbnRpdHk6IHN0cmluZykge1xuICAgIGxvZy5kZWJ1Zyhgc2V0IGUyZWUgdG8gJHtlbmFibGVkfSBmb3IgcGFydGljaXBhbnQgJHtwYXJ0aWNpcGFudElkZW50aXR5fWApO1xuICAgIHRoaXMucG9zdEVuYWJsZShlbmFibGVkLCBwYXJ0aWNpcGFudElkZW50aXR5KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHNldFNpZlRyYWlsZXIodHJhaWxlcjogVWludDhBcnJheSkge1xuICAgIGlmICghdHJhaWxlciB8fCB0cmFpbGVyLmxlbmd0aCA9PT0gMCkge1xuICAgICAgbG9nLndhcm4oXCJpZ25vcmluZyBzZXJ2ZXIgc2VudCB0cmFpbGVyIGFzIGl0J3MgZW1wdHlcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucG9zdFNpZlRyYWlsZXIodHJhaWxlcik7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBvbldvcmtlck1lc3NhZ2UgPSAoZXY6IE1lc3NhZ2VFdmVudDxFMkVFV29ya2VyTWVzc2FnZT4pID0+IHtcbiAgICBjb25zdCB7IGtpbmQsIGRhdGEgfSA9IGV2LmRhdGE7XG4gICAgc3dpdGNoIChraW5kKSB7XG4gICAgICBjYXNlICdlcnJvcic6XG4gICAgICAgIGxvZy5lcnJvcihkYXRhLmVycm9yLm1lc3NhZ2UpO1xuICAgICAgICB0aGlzLmVtaXQoRW5jcnlwdGlvbkV2ZW50LkVuY3J5cHRpb25FcnJvciwgZGF0YS5lcnJvcik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnaW5pdEFjayc6XG4gICAgICAgIGlmIChkYXRhLmVuYWJsZWQpIHtcbiAgICAgICAgICB0aGlzLmtleVByb3ZpZGVyLmdldEtleXMoKS5mb3JFYWNoKChrZXlJbmZvKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnBvc3RLZXkoa2V5SW5mbyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ2VuYWJsZSc6XG4gICAgICAgIGlmIChcbiAgICAgICAgICB0aGlzLmVuY3J5cHRpb25FbmFibGVkICE9PSBkYXRhLmVuYWJsZWQgJiZcbiAgICAgICAgICBkYXRhLnBhcnRpY2lwYW50SWRlbnRpdHkgPT09IHRoaXMucm9vbT8ubG9jYWxQYXJ0aWNpcGFudC5pZGVudGl0eVxuICAgICAgICApIHtcbiAgICAgICAgICB0aGlzLmVtaXQoXG4gICAgICAgICAgICBFbmNyeXB0aW9uRXZlbnQuUGFydGljaXBhbnRFbmNyeXB0aW9uU3RhdHVzQ2hhbmdlZCxcbiAgICAgICAgICAgIGRhdGEuZW5hYmxlZCxcbiAgICAgICAgICAgIHRoaXMucm9vbSEubG9jYWxQYXJ0aWNpcGFudCxcbiAgICAgICAgICApO1xuICAgICAgICAgIHRoaXMuZW5jcnlwdGlvbkVuYWJsZWQgPSBkYXRhLmVuYWJsZWQ7XG4gICAgICAgIH0gZWxzZSBpZiAoZGF0YS5wYXJ0aWNpcGFudElkZW50aXR5KSB7XG4gICAgICAgICAgY29uc3QgcGFydGljaXBhbnQgPSB0aGlzLnJvb20/LmdldFBhcnRpY2lwYW50QnlJZGVudGl0eShkYXRhLnBhcnRpY2lwYW50SWRlbnRpdHkpO1xuICAgICAgICAgIGlmICghcGFydGljaXBhbnQpIHtcbiAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcbiAgICAgICAgICAgICAgYGNvdWxkbid0IHNldCBlbmNyeXB0aW9uIHN0YXR1cywgcGFydGljaXBhbnQgbm90IGZvdW5kJHtkYXRhLnBhcnRpY2lwYW50SWRlbnRpdHl9YCxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuZW1pdChFbmNyeXB0aW9uRXZlbnQuUGFydGljaXBhbnRFbmNyeXB0aW9uU3RhdHVzQ2hhbmdlZCwgZGF0YS5lbmFibGVkLCBwYXJ0aWNpcGFudCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZW5jcnlwdGlvbkVuYWJsZWQpIHtcbiAgICAgICAgICB0aGlzLmtleVByb3ZpZGVyLmdldEtleXMoKS5mb3JFYWNoKChrZXlJbmZvKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnBvc3RLZXkoa2V5SW5mbyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdyYXRjaGV0S2V5JzpcbiAgICAgICAgdGhpcy5rZXlQcm92aWRlci5lbWl0KEtleVByb3ZpZGVyRXZlbnQuS2V5UmF0Y2hldGVkLCBkYXRhLm1hdGVyaWFsLCBkYXRhLmtleUluZGV4KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBicmVhaztcbiAgICB9XG4gIH07XG5cbiAgcHJpdmF0ZSBvbldvcmtlckVycm9yID0gKGV2OiBFcnJvckV2ZW50KSA9PiB7XG4gICAgbG9nLmVycm9yKCdlMmVlIHdvcmtlciBlbmNvdW50ZXJlZCBhbiBlcnJvcjonLCB7IGVycm9yOiBldi5lcnJvciB9KTtcbiAgICB0aGlzLmVtaXQoRW5jcnlwdGlvbkV2ZW50LkVuY3J5cHRpb25FcnJvciwgZXYuZXJyb3IpO1xuICB9O1xuXG4gIHB1YmxpYyBzZXR1cEVuZ2luZShlbmdpbmU6IFJUQ0VuZ2luZSkge1xuICAgIGVuZ2luZS5vbihFbmdpbmVFdmVudC5SVFBWaWRlb01hcFVwZGF0ZSwgKHJ0cE1hcCkgPT4ge1xuICAgICAgdGhpcy5wb3N0UlRQTWFwKHJ0cE1hcCk7XG4gICAgfSk7XG4gIH1cblxuICBwcml2YXRlIHNldHVwRXZlbnRMaXN0ZW5lcnMocm9vbTogUm9vbSwga2V5UHJvdmlkZXI6IEJhc2VLZXlQcm92aWRlcikge1xuICAgIHJvb20ub24oUm9vbUV2ZW50LlRyYWNrUHVibGlzaGVkLCAocHViLCBwYXJ0aWNpcGFudCkgPT5cbiAgICAgIHRoaXMuc2V0UGFydGljaXBhbnRDcnlwdG9yRW5hYmxlZChcbiAgICAgICAgcHViLnRyYWNrSW5mbyEuZW5jcnlwdGlvbiAhPT0gRW5jcnlwdGlvbl9UeXBlLk5PTkUsXG4gICAgICAgIHBhcnRpY2lwYW50LmlkZW50aXR5LFxuICAgICAgKSxcbiAgICApO1xuICAgIHJvb21cbiAgICAgIC5vbihSb29tRXZlbnQuQ29ubmVjdGlvblN0YXRlQ2hhbmdlZCwgKHN0YXRlKSA9PiB7XG4gICAgICAgIGlmIChzdGF0ZSA9PT0gQ29ubmVjdGlvblN0YXRlLkNvbm5lY3RlZCkge1xuICAgICAgICAgIHJvb20ucGFydGljaXBhbnRzLmZvckVhY2goKHBhcnRpY2lwYW50KSA9PiB7XG4gICAgICAgICAgICBwYXJ0aWNpcGFudC50cmFja3MuZm9yRWFjaCgocHViKSA9PiB7XG4gICAgICAgICAgICAgIHRoaXMuc2V0UGFydGljaXBhbnRDcnlwdG9yRW5hYmxlZChcbiAgICAgICAgICAgICAgICBwdWIudHJhY2tJbmZvIS5lbmNyeXB0aW9uICE9PSBFbmNyeXB0aW9uX1R5cGUuTk9ORSxcbiAgICAgICAgICAgICAgICBwYXJ0aWNpcGFudC5pZGVudGl0eSxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KVxuICAgICAgLm9uKFJvb21FdmVudC5UcmFja1Vuc3Vic2NyaWJlZCwgKHRyYWNrLCBfLCBwYXJ0aWNpcGFudCkgPT4ge1xuICAgICAgICBjb25zdCBtc2c6IFJlbW92ZVRyYW5zZm9ybU1lc3NhZ2UgPSB7XG4gICAgICAgICAga2luZDogJ3JlbW92ZVRyYW5zZm9ybScsXG4gICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgcGFydGljaXBhbnRJZGVudGl0eTogcGFydGljaXBhbnQuaWRlbnRpdHksXG4gICAgICAgICAgICB0cmFja0lkOiB0cmFjay5tZWRpYVN0cmVhbUlELFxuICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMud29ya2VyPy5wb3N0TWVzc2FnZShtc2cpO1xuICAgICAgfSlcbiAgICAgIC5vbihSb29tRXZlbnQuVHJhY2tTdWJzY3JpYmVkLCAodHJhY2ssIHB1YiwgcGFydGljaXBhbnQpID0+IHtcbiAgICAgICAgdGhpcy5zZXR1cEUyRUVSZWNlaXZlcih0cmFjaywgcGFydGljaXBhbnQuaWRlbnRpdHksIHB1Yi50cmFja0luZm8pO1xuICAgICAgfSlcbiAgICAgIC5vbihSb29tRXZlbnQuU2lnbmFsQ29ubmVjdGVkLCAoKSA9PiB7XG4gICAgICAgIGlmICghdGhpcy5yb29tKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgZXhwZWN0ZWQgcm9vbSB0byBiZSBwcmVzZW50IG9uIHNpZ25hbCBjb25uZWN0YCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXRQYXJ0aWNpcGFudENyeXB0b3JFbmFibGVkKFxuICAgICAgICAgIHRoaXMucm9vbS5sb2NhbFBhcnRpY2lwYW50LmlzRTJFRUVuYWJsZWQsXG4gICAgICAgICAgdGhpcy5yb29tLmxvY2FsUGFydGljaXBhbnQuaWRlbnRpdHksXG4gICAgICAgICk7XG4gICAgICAgIGtleVByb3ZpZGVyLmdldEtleXMoKS5mb3JFYWNoKChrZXlJbmZvKSA9PiB7XG4gICAgICAgICAgdGhpcy5wb3N0S2V5KGtleUluZm8pO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIHJvb20ubG9jYWxQYXJ0aWNpcGFudC5vbihQYXJ0aWNpcGFudEV2ZW50LkxvY2FsVHJhY2tQdWJsaXNoZWQsIGFzeW5jIChwdWJsaWNhdGlvbikgPT4ge1xuICAgICAgdGhpcy5zZXR1cEUyRUVTZW5kZXIocHVibGljYXRpb24udHJhY2shLCBwdWJsaWNhdGlvbi50cmFjayEuc2VuZGVyISk7XG4gICAgfSk7XG5cbiAgICBrZXlQcm92aWRlclxuICAgICAgLm9uKEtleVByb3ZpZGVyRXZlbnQuU2V0S2V5LCAoa2V5SW5mbykgPT4gdGhpcy5wb3N0S2V5KGtleUluZm8pKVxuICAgICAgLm9uKEtleVByb3ZpZGVyRXZlbnQuUmF0Y2hldFJlcXVlc3QsIChwYXJ0aWNpcGFudElkLCBrZXlJbmRleCkgPT5cbiAgICAgICAgdGhpcy5wb3N0UmF0Y2hldFJlcXVlc3QocGFydGljaXBhbnRJZCwga2V5SW5kZXgpLFxuICAgICAgKTtcbiAgfVxuXG4gIHByaXZhdGUgcG9zdFJhdGNoZXRSZXF1ZXN0KHBhcnRpY2lwYW50SWRlbnRpdHk/OiBzdHJpbmcsIGtleUluZGV4PzogbnVtYmVyKSB7XG4gICAgaWYgKCF0aGlzLndvcmtlcikge1xuICAgICAgdGhyb3cgRXJyb3IoJ2NvdWxkIG5vdCByYXRjaGV0IGtleSwgd29ya2VyIGlzIG1pc3NpbmcnKTtcbiAgICB9XG4gICAgY29uc3QgbXNnOiBSYXRjaGV0UmVxdWVzdE1lc3NhZ2UgPSB7XG4gICAgICBraW5kOiAncmF0Y2hldFJlcXVlc3QnLFxuICAgICAgZGF0YToge1xuICAgICAgICBwYXJ0aWNpcGFudElkZW50aXR5OiBwYXJ0aWNpcGFudElkZW50aXR5LFxuICAgICAgICBrZXlJbmRleCxcbiAgICAgIH0sXG4gICAgfTtcbiAgICB0aGlzLndvcmtlci5wb3N0TWVzc2FnZShtc2cpO1xuICB9XG5cbiAgcHJpdmF0ZSBwb3N0S2V5KHsga2V5LCBwYXJ0aWNpcGFudElkZW50aXR5LCBrZXlJbmRleCB9OiBLZXlJbmZvKSB7XG4gICAgaWYgKCF0aGlzLndvcmtlcikge1xuICAgICAgdGhyb3cgRXJyb3IoJ2NvdWxkIG5vdCBzZXQga2V5LCB3b3JrZXIgaXMgbWlzc2luZycpO1xuICAgIH1cbiAgICBjb25zdCBtc2c6IFNldEtleU1lc3NhZ2UgPSB7XG4gICAgICBraW5kOiAnc2V0S2V5JyxcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgcGFydGljaXBhbnRJZGVudGl0eTogcGFydGljaXBhbnRJZGVudGl0eSxcbiAgICAgICAgaXNQdWJsaXNoZXI6IHBhcnRpY2lwYW50SWRlbnRpdHkgPT09IHRoaXMucm9vbT8ubG9jYWxQYXJ0aWNpcGFudC5pZGVudGl0eSxcbiAgICAgICAga2V5LFxuICAgICAgICBrZXlJbmRleCxcbiAgICAgIH0sXG4gICAgfTtcbiAgICB0aGlzLndvcmtlci5wb3N0TWVzc2FnZShtc2cpO1xuICB9XG5cbiAgcHJpdmF0ZSBwb3N0RW5hYmxlKGVuYWJsZWQ6IGJvb2xlYW4sIHBhcnRpY2lwYW50SWRlbnRpdHk6IHN0cmluZykge1xuICAgIGlmICh0aGlzLndvcmtlcikge1xuICAgICAgY29uc3QgZW5hYmxlTXNnOiBFbmFibGVNZXNzYWdlID0ge1xuICAgICAgICBraW5kOiAnZW5hYmxlJyxcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIGVuYWJsZWQsXG4gICAgICAgICAgcGFydGljaXBhbnRJZGVudGl0eSxcbiAgICAgICAgfSxcbiAgICAgIH07XG4gICAgICB0aGlzLndvcmtlci5wb3N0TWVzc2FnZShlbmFibGVNc2cpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoJ2ZhaWxlZCB0byBlbmFibGUgZTJlZSwgd29ya2VyIGlzIG5vdCByZWFkeScpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgcG9zdFJUUE1hcChtYXA6IE1hcDxudW1iZXIsIFZpZGVvQ29kZWM+KSB7XG4gICAgaWYgKCF0aGlzLndvcmtlcikge1xuICAgICAgdGhyb3cgVHlwZUVycm9yKCdjb3VsZCBub3QgcG9zdCBydHAgbWFwLCB3b3JrZXIgaXMgbWlzc2luZycpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMucm9vbT8ubG9jYWxQYXJ0aWNpcGFudC5pZGVudGl0eSkge1xuICAgICAgdGhyb3cgVHlwZUVycm9yKCdjb3VsZCBub3QgcG9zdCBydHAgbWFwLCBsb2NhbCBwYXJ0aWNpcGFudCBpZGVudGl0eSBpcyBtaXNzaW5nJyk7XG4gICAgfVxuICAgIGNvbnN0IG1zZzogUlRQVmlkZW9NYXBNZXNzYWdlID0ge1xuICAgICAga2luZDogJ3NldFJUUE1hcCcsXG4gICAgICBkYXRhOiB7XG4gICAgICAgIG1hcCxcbiAgICAgICAgcGFydGljaXBhbnRJZGVudGl0eTogdGhpcy5yb29tLmxvY2FsUGFydGljaXBhbnQuaWRlbnRpdHksXG4gICAgICB9LFxuICAgIH07XG4gICAgdGhpcy53b3JrZXIucG9zdE1lc3NhZ2UobXNnKTtcbiAgfVxuXG4gIHByaXZhdGUgcG9zdFNpZlRyYWlsZXIodHJhaWxlcjogVWludDhBcnJheSkge1xuICAgIGlmICghdGhpcy53b3JrZXIpIHtcbiAgICAgIHRocm93IEVycm9yKCdjb3VsZCBub3QgcG9zdCBTSUYgdHJhaWxlciwgd29ya2VyIGlzIG1pc3NpbmcnKTtcbiAgICB9XG4gICAgY29uc3QgbXNnOiBTaWZUcmFpbGVyTWVzc2FnZSA9IHtcbiAgICAgIGtpbmQ6ICdzZXRTaWZUcmFpbGVyJyxcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgdHJhaWxlcixcbiAgICAgIH0sXG4gICAgfTtcbiAgICB0aGlzLndvcmtlci5wb3N0TWVzc2FnZShtc2cpO1xuICB9XG5cbiAgcHJpdmF0ZSBzZXR1cEUyRUVSZWNlaXZlcih0cmFjazogUmVtb3RlVHJhY2ssIHJlbW90ZUlkOiBzdHJpbmcsIHRyYWNrSW5mbz86IFRyYWNrSW5mbykge1xuICAgIGlmICghdHJhY2sucmVjZWl2ZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCF0cmFja0luZm8/Lm1pbWVUeXBlIHx8IHRyYWNrSW5mby5taW1lVHlwZSA9PT0gJycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ01pbWVUeXBlIG1pc3NpbmcgZnJvbSB0cmFja0luZm8sIGNhbm5vdCBzZXQgdXAgRTJFRSBjcnlwdG9yJyk7XG4gICAgfVxuICAgIHRoaXMuaGFuZGxlUmVjZWl2ZXIoXG4gICAgICB0cmFjay5yZWNlaXZlcixcbiAgICAgIHRyYWNrLm1lZGlhU3RyZWFtSUQsXG4gICAgICByZW1vdGVJZCxcbiAgICAgIHRyYWNrLmtpbmQgPT09ICd2aWRlbycgPyBtaW1lVHlwZVRvVmlkZW9Db2RlY1N0cmluZyh0cmFja0luZm8ubWltZVR5cGUpIDogdW5kZWZpbmVkLFxuICAgICk7XG4gIH1cblxuICBwcml2YXRlIHNldHVwRTJFRVNlbmRlcih0cmFjazogVHJhY2ssIHNlbmRlcjogUlRDUnRwU2VuZGVyKSB7XG4gICAgaWYgKCEodHJhY2sgaW5zdGFuY2VvZiBMb2NhbFRyYWNrKSB8fCAhc2VuZGVyKSB7XG4gICAgICBpZiAoIXNlbmRlcikgbG9nLndhcm4oJ2Vhcmx5IHJldHVybiBiZWNhdXNlIHNlbmRlciBpcyBub3QgcmVhZHknKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5oYW5kbGVTZW5kZXIoc2VuZGVyLCB0cmFjay5tZWRpYVN0cmVhbUlELCB1bmRlZmluZWQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZXMgdGhlIGdpdmVuIHtAY29kZSBSVENSdHBSZWNlaXZlcn0gYnkgY3JlYXRpbmcgYSB7QGNvZGUgVHJhbnNmb3JtU3RyZWFtfSB3aGljaCB3aWxsIGluamVjdFxuICAgKiBhIGZyYW1lIGRlY29kZXIuXG4gICAqXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIGhhbmRsZVJlY2VpdmVyKFxuICAgIHJlY2VpdmVyOiBSVENSdHBSZWNlaXZlcixcbiAgICB0cmFja0lkOiBzdHJpbmcsXG4gICAgcGFydGljaXBhbnRJZGVudGl0eTogc3RyaW5nLFxuICAgIGNvZGVjPzogVmlkZW9Db2RlYyxcbiAgKSB7XG4gICAgaWYgKCF0aGlzLndvcmtlcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChpc1NjcmlwdFRyYW5zZm9ybVN1cHBvcnRlZCgpKSB7XG4gICAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICBraW5kOiAnZGVjb2RlJyxcbiAgICAgICAgcGFydGljaXBhbnRJZGVudGl0eSxcbiAgICAgICAgdHJhY2tJZCxcbiAgICAgICAgY29kZWMsXG4gICAgICB9O1xuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgcmVjZWl2ZXIudHJhbnNmb3JtID0gbmV3IFJUQ1J0cFNjcmlwdFRyYW5zZm9ybSh0aGlzLndvcmtlciwgb3B0aW9ucyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChFMkVFX0ZMQUcgaW4gcmVjZWl2ZXIgJiYgY29kZWMpIHtcbiAgICAgICAgLy8gb25seSB1cGRhdGUgY29kZWNcbiAgICAgICAgY29uc3QgbXNnOiBVcGRhdGVDb2RlY01lc3NhZ2UgPSB7XG4gICAgICAgICAga2luZDogJ3VwZGF0ZUNvZGVjJyxcbiAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICB0cmFja0lkLFxuICAgICAgICAgICAgY29kZWMsXG4gICAgICAgICAgICBwYXJ0aWNpcGFudElkZW50aXR5OiBwYXJ0aWNpcGFudElkZW50aXR5LFxuICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMud29ya2VyLnBvc3RNZXNzYWdlKG1zZyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIGxldCB3cml0YWJsZTogV3JpdGFibGVTdHJlYW0gPSByZWNlaXZlci53cml0YWJsZVN0cmVhbTtcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIGxldCByZWFkYWJsZTogUmVhZGFibGVTdHJlYW0gPSByZWNlaXZlci5yZWFkYWJsZVN0cmVhbTtcbiAgICAgIGlmICghd3JpdGFibGUgfHwgIXJlYWRhYmxlKSB7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgY29uc3QgcmVjZWl2ZXJTdHJlYW1zID0gcmVjZWl2ZXIuY3JlYXRlRW5jb2RlZFN0cmVhbXMoKTtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICByZWNlaXZlci53cml0YWJsZVN0cmVhbSA9IHJlY2VpdmVyU3RyZWFtcy53cml0YWJsZTtcbiAgICAgICAgd3JpdGFibGUgPSByZWNlaXZlclN0cmVhbXMud3JpdGFibGU7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgcmVjZWl2ZXIucmVhZGFibGVTdHJlYW0gPSByZWNlaXZlclN0cmVhbXMucmVhZGFibGU7XG4gICAgICAgIHJlYWRhYmxlID0gcmVjZWl2ZXJTdHJlYW1zLnJlYWRhYmxlO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBtc2c6IEVuY29kZU1lc3NhZ2UgPSB7XG4gICAgICAgIGtpbmQ6ICdkZWNvZGUnLFxuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgcmVhZGFibGVTdHJlYW06IHJlYWRhYmxlLFxuICAgICAgICAgIHdyaXRhYmxlU3RyZWFtOiB3cml0YWJsZSxcbiAgICAgICAgICB0cmFja0lkOiB0cmFja0lkLFxuICAgICAgICAgIGNvZGVjLFxuICAgICAgICAgIHBhcnRpY2lwYW50SWRlbnRpdHk6IHBhcnRpY2lwYW50SWRlbnRpdHksXG4gICAgICAgIH0sXG4gICAgICB9O1xuICAgICAgdGhpcy53b3JrZXIucG9zdE1lc3NhZ2UobXNnLCBbcmVhZGFibGUsIHdyaXRhYmxlXSk7XG4gICAgfVxuXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHJlY2VpdmVyW0UyRUVfRkxBR10gPSB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZXMgdGhlIGdpdmVuIHtAY29kZSBSVENSdHBTZW5kZXJ9IGJ5IGNyZWF0aW5nIGEge0Bjb2RlIFRyYW5zZm9ybVN0cmVhbX0gd2hpY2ggd2lsbCBpbmplY3RcbiAgICogYSBmcmFtZSBlbmNvZGVyLlxuICAgKlxuICAgKi9cbiAgcHJpdmF0ZSBoYW5kbGVTZW5kZXIoc2VuZGVyOiBSVENSdHBTZW5kZXIsIHRyYWNrSWQ6IHN0cmluZywgY29kZWM/OiBWaWRlb0NvZGVjKSB7XG4gICAgaWYgKEUyRUVfRkxBRyBpbiBzZW5kZXIgfHwgIXRoaXMud29ya2VyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLnJvb20/LmxvY2FsUGFydGljaXBhbnQuaWRlbnRpdHkgfHwgdGhpcy5yb29tLmxvY2FsUGFydGljaXBhbnQuaWRlbnRpdHkgPT09ICcnKSB7XG4gICAgICB0aHJvdyBUeXBlRXJyb3IoJ2xvY2FsIGlkZW50aXR5IG5lZWRzIHRvIGJlIGtub3duIGluIG9yZGVyIHRvIHNldCB1cCBlbmNyeXB0ZWQgc2VuZGVyJyk7XG4gICAgfVxuXG4gICAgaWYgKGlzU2NyaXB0VHJhbnNmb3JtU3VwcG9ydGVkKCkpIHtcbiAgICAgIGxvZy5pbmZvKCdpbml0aWFsaXplIHNjcmlwdCB0cmFuc2Zvcm0nKTtcbiAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgIGtpbmQ6ICdlbmNvZGUnLFxuICAgICAgICBwYXJ0aWNpcGFudElkZW50aXR5OiB0aGlzLnJvb20ubG9jYWxQYXJ0aWNpcGFudC5pZGVudGl0eSxcbiAgICAgICAgdHJhY2tJZCxcbiAgICAgICAgY29kZWMsXG4gICAgICB9O1xuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgc2VuZGVyLnRyYW5zZm9ybSA9IG5ldyBSVENSdHBTY3JpcHRUcmFuc2Zvcm0odGhpcy53b3JrZXIsIG9wdGlvbnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsb2cuaW5mbygnaW5pdGlhbGl6ZSBlbmNvZGVkIHN0cmVhbXMnKTtcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIGNvbnN0IHNlbmRlclN0cmVhbXMgPSBzZW5kZXIuY3JlYXRlRW5jb2RlZFN0cmVhbXMoKTtcbiAgICAgIGNvbnN0IG1zZzogRW5jb2RlTWVzc2FnZSA9IHtcbiAgICAgICAga2luZDogJ2VuY29kZScsXG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICByZWFkYWJsZVN0cmVhbTogc2VuZGVyU3RyZWFtcy5yZWFkYWJsZSxcbiAgICAgICAgICB3cml0YWJsZVN0cmVhbTogc2VuZGVyU3RyZWFtcy53cml0YWJsZSxcbiAgICAgICAgICBjb2RlYyxcbiAgICAgICAgICB0cmFja0lkLFxuICAgICAgICAgIHBhcnRpY2lwYW50SWRlbnRpdHk6IHRoaXMucm9vbS5sb2NhbFBhcnRpY2lwYW50LmlkZW50aXR5LFxuICAgICAgICB9LFxuICAgICAgfTtcbiAgICAgIHRoaXMud29ya2VyLnBvc3RNZXNzYWdlKG1zZywgW3NlbmRlclN0cmVhbXMucmVhZGFibGUsIHNlbmRlclN0cmVhbXMud3JpdGFibGVdKTtcbiAgICB9XG5cbiAgICAvLyBAdHMtaWdub3JlXG4gICAgc2VuZGVyW0UyRUVfRkxBR10gPSB0cnVlO1xuICB9XG59XG4iLCJpbXBvcnQgeyBNdXRleCB9IGZyb20gJy4uL3Jvb20vdXRpbHMnO1xuXG50eXBlIFF1ZXVlVGFzazxUPiA9ICgpID0+IFByb21pc2VMaWtlPFQ+O1xuXG5lbnVtIFF1ZXVlVGFza1N0YXR1cyB7XG4gICdXQUlUSU5HJyxcbiAgJ1JVTk5JTkcnLFxuICAnQ09NUExFVEVEJyxcbn1cblxudHlwZSBRdWV1ZVRhc2tJbmZvID0ge1xuICBpZDogbnVtYmVyO1xuICBlbnF1ZXVlZEF0OiBudW1iZXI7XG4gIGV4ZWN1dGVkQXQ/OiBudW1iZXI7XG4gIHN0YXR1czogUXVldWVUYXNrU3RhdHVzO1xufTtcblxuZXhwb3J0IGNsYXNzIEFzeW5jUXVldWUge1xuICBwcml2YXRlIHBlbmRpbmdUYXNrczogTWFwPG51bWJlciwgUXVldWVUYXNrSW5mbz47XG5cbiAgcHJpdmF0ZSB0YXNrTXV0ZXg6IE11dGV4O1xuXG4gIHByaXZhdGUgbmV4dFRhc2tJbmRleDogbnVtYmVyO1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMucGVuZGluZ1Rhc2tzID0gbmV3IE1hcCgpO1xuICAgIHRoaXMudGFza011dGV4ID0gbmV3IE11dGV4KCk7XG4gICAgdGhpcy5uZXh0VGFza0luZGV4ID0gMDtcbiAgfVxuXG4gIGFzeW5jIHJ1bjxUPih0YXNrOiBRdWV1ZVRhc2s8VD4pIHtcbiAgICBjb25zdCB0YXNrSW5mbzogUXVldWVUYXNrSW5mbyA9IHtcbiAgICAgIGlkOiB0aGlzLm5leHRUYXNrSW5kZXgrKyxcbiAgICAgIGVucXVldWVkQXQ6IERhdGUubm93KCksXG4gICAgICBzdGF0dXM6IFF1ZXVlVGFza1N0YXR1cy5XQUlUSU5HLFxuICAgIH07XG4gICAgdGhpcy5wZW5kaW5nVGFza3Muc2V0KHRhc2tJbmZvLmlkLCB0YXNrSW5mbyk7XG4gICAgY29uc3QgdW5sb2NrID0gYXdhaXQgdGhpcy50YXNrTXV0ZXgubG9jaygpO1xuICAgIHRyeSB7XG4gICAgICB0YXNrSW5mby5leGVjdXRlZEF0ID0gRGF0ZS5ub3coKTtcbiAgICAgIHRhc2tJbmZvLnN0YXR1cyA9IFF1ZXVlVGFza1N0YXR1cy5SVU5OSU5HO1xuICAgICAgcmV0dXJuIGF3YWl0IHRhc2soKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdGFza0luZm8uc3RhdHVzID0gUXVldWVUYXNrU3RhdHVzLkNPTVBMRVRFRDtcbiAgICAgIHRoaXMucGVuZGluZ1Rhc2tzLmRlbGV0ZSh0YXNrSW5mby5pZCk7XG4gICAgICB1bmxvY2soKTtcbiAgICB9XG4gIH1cblxuICBhc3luYyBmbHVzaCgpIHtcbiAgICByZXR1cm4gdGhpcy5ydW4oYXN5bmMgKCkgPT4ge30pO1xuICB9XG5cbiAgc25hcHNob3QoKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5wZW5kaW5nVGFza3MudmFsdWVzKCkpO1xuICB9XG59XG4iLCJpbXBvcnQgeyBwcm90b0ludDY0IH0gZnJvbSAnQGJ1ZmJ1aWxkL3Byb3RvYnVmJztcbmltcG9ydCBsb2csIHsgTG9nZ2VyTmFtZXMsIGdldExvZ2dlciB9IGZyb20gJy4uL2xvZ2dlcic7XG5pbXBvcnQge1xuICBDbGllbnRJbmZvLFxuICBEaXNjb25uZWN0UmVhc29uLFxuICBQYXJ0aWNpcGFudEluZm8sXG4gIFJlY29ubmVjdFJlYXNvbixcbiAgUm9vbSxcbiAgU3BlYWtlckluZm8sXG4gIFZpZGVvTGF5ZXIsXG59IGZyb20gJy4uL3Byb3RvL2xpdmVraXRfbW9kZWxzX3BiJztcbmltcG9ydCB7XG4gIEFkZFRyYWNrUmVxdWVzdCxcbiAgQ29ubmVjdGlvblF1YWxpdHlVcGRhdGUsXG4gIEpvaW5SZXNwb25zZSxcbiAgTGVhdmVSZXF1ZXN0LFxuICBNdXRlVHJhY2tSZXF1ZXN0LFxuICBQaW5nLFxuICBSZWNvbm5lY3RSZXNwb25zZSxcbiAgU2Vzc2lvbkRlc2NyaXB0aW9uLFxuICBTaWduYWxSZXF1ZXN0LFxuICBTaWduYWxSZXNwb25zZSxcbiAgU2lnbmFsVGFyZ2V0LFxuICBTaW11bGF0ZVNjZW5hcmlvLFxuICBTdHJlYW1TdGF0ZVVwZGF0ZSxcbiAgU3Vic2NyaWJlZFF1YWxpdHlVcGRhdGUsXG4gIFN1YnNjcmlwdGlvblBlcm1pc3Npb24sXG4gIFN1YnNjcmlwdGlvblBlcm1pc3Npb25VcGRhdGUsXG4gIFN1YnNjcmlwdGlvblJlc3BvbnNlLFxuICBTeW5jU3RhdGUsXG4gIFRyYWNrUGVybWlzc2lvbixcbiAgVHJhY2tQdWJsaXNoZWRSZXNwb25zZSxcbiAgVHJhY2tVbnB1Ymxpc2hlZFJlc3BvbnNlLFxuICBUcmlja2xlUmVxdWVzdCxcbiAgVXBkYXRlUGFydGljaXBhbnRNZXRhZGF0YSxcbiAgVXBkYXRlU3Vic2NyaXB0aW9uLFxuICBVcGRhdGVUcmFja1NldHRpbmdzLFxuICBVcGRhdGVWaWRlb0xheWVycyxcbn0gZnJvbSAnLi4vcHJvdG8vbGl2ZWtpdF9ydGNfcGInO1xuaW1wb3J0IHsgQ29ubmVjdGlvbkVycm9yLCBDb25uZWN0aW9uRXJyb3JSZWFzb24gfSBmcm9tICcuLi9yb29tL2Vycm9ycyc7XG5pbXBvcnQgQ3JpdGljYWxUaW1lcnMgZnJvbSAnLi4vcm9vbS90aW1lcnMnO1xuaW1wb3J0IHR5cGUgeyBMb2dnZXJPcHRpb25zIH0gZnJvbSAnLi4vcm9vbS90eXBlcyc7XG5pbXBvcnQgeyBNdXRleCwgZ2V0Q2xpZW50SW5mbywgaXNSZWFjdE5hdGl2ZSwgc2xlZXAsIHRvV2Vic29ja2V0VXJsIH0gZnJvbSAnLi4vcm9vbS91dGlscyc7XG5pbXBvcnQgeyBBc3luY1F1ZXVlIH0gZnJvbSAnLi4vdXRpbHMvQXN5bmNRdWV1ZSc7XG5cbi8vIGludGVybmFsIG9wdGlvbnNcbmludGVyZmFjZSBDb25uZWN0T3B0cyBleHRlbmRzIFNpZ25hbE9wdGlvbnMge1xuICAvKiogaW50ZXJuYWwgKi9cbiAgcmVjb25uZWN0PzogYm9vbGVhbjtcbiAgLyoqIGludGVybmFsICovXG4gIHJlY29ubmVjdFJlYXNvbj86IG51bWJlcjtcbiAgLyoqIGludGVybmFsICovXG4gIHNpZD86IHN0cmluZztcbn1cblxuLy8gcHVibGljIG9wdGlvbnNcbmV4cG9ydCBpbnRlcmZhY2UgU2lnbmFsT3B0aW9ucyB7XG4gIGF1dG9TdWJzY3JpYmU6IGJvb2xlYW47XG4gIC8qKiBAZGVwcmVjYXRlZCAqL1xuICBwdWJsaXNoT25seT86IHN0cmluZztcbiAgYWRhcHRpdmVTdHJlYW0/OiBib29sZWFuO1xuICBtYXhSZXRyaWVzOiBudW1iZXI7XG4gIGUyZWVFbmFibGVkOiBib29sZWFuO1xuICB3ZWJzb2NrZXRUaW1lb3V0OiBudW1iZXI7XG59XG5cbnR5cGUgU2lnbmFsTWVzc2FnZSA9IFNpZ25hbFJlcXVlc3RbJ21lc3NhZ2UnXTtcblxudHlwZSBTaWduYWxLaW5kID0gTm9uTnVsbGFibGU8U2lnbmFsTWVzc2FnZT5bJ2Nhc2UnXTtcblxuY29uc3QgcGFzc1Rocm91Z2hRdWV1ZVNpZ25hbHM6IEFycmF5PFNpZ25hbEtpbmQ+ID0gW1xuICAnc3luY1N0YXRlJyxcbiAgJ3RyaWNrbGUnLFxuICAnb2ZmZXInLFxuICAnYW5zd2VyJyxcbiAgJ3NpbXVsYXRlJyxcbiAgJ2xlYXZlJyxcbl07XG5cbmZ1bmN0aW9uIGNhblBhc3NUaHJvdWdoUXVldWUocmVxOiBTaWduYWxNZXNzYWdlKTogYm9vbGVhbiB7XG4gIGNvbnN0IGNhblBhc3MgPSBwYXNzVGhyb3VnaFF1ZXVlU2lnbmFscy5pbmRleE9mKHJlcSEuY2FzZSkgPj0gMDtcbiAgbG9nLnRyYWNlKCdyZXF1ZXN0IGFsbG93ZWQgdG8gYnlwYXNzIHF1ZXVlOicsIHsgY2FuUGFzcywgcmVxIH0pO1xuICByZXR1cm4gY2FuUGFzcztcbn1cblxuZXhwb3J0IGVudW0gU2lnbmFsQ29ubmVjdGlvblN0YXRlIHtcbiAgQ09OTkVDVElORyxcbiAgQ09OTkVDVEVELFxuICBSRUNPTk5FQ1RJTkcsXG4gIERJU0NPTk5FQ1RJTkcsXG4gIERJU0NPTk5FQ1RFRCxcbn1cblxuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGNsYXNzIFNpZ25hbENsaWVudCB7XG4gIHJlcXVlc3RRdWV1ZTogQXN5bmNRdWV1ZTtcblxuICBxdWV1ZWRSZXF1ZXN0czogQXJyYXk8KCkgPT4gUHJvbWlzZTx2b2lkPj47XG5cbiAgdXNlSlNPTjogYm9vbGVhbjtcblxuICAvKiogc2lnbmFsIHJ0dCBpbiBtaWxsaXNlY29uZHMgKi9cbiAgcnR0OiBudW1iZXIgPSAwO1xuXG4gIC8qKiBzaW11bGF0ZSBzaWduYWxpbmcgbGF0ZW5jeSBieSBkZWxheWluZyBtZXNzYWdlcyAqL1xuICBzaWduYWxMYXRlbmN5PzogbnVtYmVyO1xuXG4gIG9uQ2xvc2U/OiAocmVhc29uOiBzdHJpbmcpID0+IHZvaWQ7XG5cbiAgb25BbnN3ZXI/OiAoc2Q6IFJUQ1Nlc3Npb25EZXNjcmlwdGlvbkluaXQpID0+IHZvaWQ7XG5cbiAgb25PZmZlcj86IChzZDogUlRDU2Vzc2lvbkRlc2NyaXB0aW9uSW5pdCkgPT4gdm9pZDtcblxuICAvLyB3aGVuIGEgbmV3IElDRSBjYW5kaWRhdGUgaXMgbWFkZSBhdmFpbGFibGVcbiAgb25Ucmlja2xlPzogKHNkOiBSVENJY2VDYW5kaWRhdGVJbml0LCB0YXJnZXQ6IFNpZ25hbFRhcmdldCkgPT4gdm9pZDtcblxuICBvblBhcnRpY2lwYW50VXBkYXRlPzogKHVwZGF0ZXM6IFBhcnRpY2lwYW50SW5mb1tdKSA9PiB2b2lkO1xuXG4gIG9uTG9jYWxUcmFja1B1Ymxpc2hlZD86IChyZXM6IFRyYWNrUHVibGlzaGVkUmVzcG9uc2UpID0+IHZvaWQ7XG5cbiAgb25OZWdvdGlhdGVSZXF1ZXN0ZWQ/OiAoKSA9PiB2b2lkO1xuXG4gIG9uU3BlYWtlcnNDaGFuZ2VkPzogKHJlczogU3BlYWtlckluZm9bXSkgPT4gdm9pZDtcblxuICBvblJlbW90ZU11dGVDaGFuZ2VkPzogKHRyYWNrU2lkOiBzdHJpbmcsIG11dGVkOiBib29sZWFuKSA9PiB2b2lkO1xuXG4gIG9uUm9vbVVwZGF0ZT86IChyb29tOiBSb29tKSA9PiB2b2lkO1xuXG4gIG9uQ29ubmVjdGlvblF1YWxpdHk/OiAodXBkYXRlOiBDb25uZWN0aW9uUXVhbGl0eVVwZGF0ZSkgPT4gdm9pZDtcblxuICBvblN0cmVhbVN0YXRlVXBkYXRlPzogKHVwZGF0ZTogU3RyZWFtU3RhdGVVcGRhdGUpID0+IHZvaWQ7XG5cbiAgb25TdWJzY3JpYmVkUXVhbGl0eVVwZGF0ZT86ICh1cGRhdGU6IFN1YnNjcmliZWRRdWFsaXR5VXBkYXRlKSA9PiB2b2lkO1xuXG4gIG9uU3Vic2NyaXB0aW9uUGVybWlzc2lvblVwZGF0ZT86ICh1cGRhdGU6IFN1YnNjcmlwdGlvblBlcm1pc3Npb25VcGRhdGUpID0+IHZvaWQ7XG5cbiAgb25TdWJzY3JpcHRpb25FcnJvcj86ICh1cGRhdGU6IFN1YnNjcmlwdGlvblJlc3BvbnNlKSA9PiB2b2lkO1xuXG4gIG9uTG9jYWxUcmFja1VucHVibGlzaGVkPzogKHJlczogVHJhY2tVbnB1Ymxpc2hlZFJlc3BvbnNlKSA9PiB2b2lkO1xuXG4gIG9uVG9rZW5SZWZyZXNoPzogKHRva2VuOiBzdHJpbmcpID0+IHZvaWQ7XG5cbiAgb25MZWF2ZT86IChsZWF2ZTogTGVhdmVSZXF1ZXN0KSA9PiB2b2lkO1xuXG4gIGNvbm5lY3RPcHRpb25zPzogQ29ubmVjdE9wdHM7XG5cbiAgd3M/OiBXZWJTb2NrZXQ7XG5cbiAgZ2V0IGN1cnJlbnRTdGF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZTtcbiAgfVxuXG4gIGdldCBpc0Rpc2Nvbm5lY3RlZCgpIHtcbiAgICByZXR1cm4gKFxuICAgICAgdGhpcy5zdGF0ZSA9PT0gU2lnbmFsQ29ubmVjdGlvblN0YXRlLkRJU0NPTk5FQ1RJTkcgfHxcbiAgICAgIHRoaXMuc3RhdGUgPT09IFNpZ25hbENvbm5lY3Rpb25TdGF0ZS5ESVNDT05ORUNURURcbiAgICApO1xuICB9XG5cbiAgcHJpdmF0ZSBnZXQgaXNFc3RhYmxpc2hpbmdDb25uZWN0aW9uKCkge1xuICAgIHJldHVybiAoXG4gICAgICB0aGlzLnN0YXRlID09PSBTaWduYWxDb25uZWN0aW9uU3RhdGUuQ09OTkVDVElORyB8fFxuICAgICAgdGhpcy5zdGF0ZSA9PT0gU2lnbmFsQ29ubmVjdGlvblN0YXRlLlJFQ09OTkVDVElOR1xuICAgICk7XG4gIH1cblxuICBwcml2YXRlIG9wdGlvbnM/OiBTaWduYWxPcHRpb25zO1xuXG4gIHByaXZhdGUgcGluZ1RpbWVvdXQ6IFJldHVyblR5cGU8dHlwZW9mIHNldFRpbWVvdXQ+IHwgdW5kZWZpbmVkO1xuXG4gIHByaXZhdGUgcGluZ1RpbWVvdXREdXJhdGlvbjogbnVtYmVyIHwgdW5kZWZpbmVkO1xuXG4gIHByaXZhdGUgcGluZ0ludGVydmFsRHVyYXRpb246IG51bWJlciB8IHVuZGVmaW5lZDtcblxuICBwcml2YXRlIHBpbmdJbnRlcnZhbDogUmV0dXJuVHlwZTx0eXBlb2Ygc2V0SW50ZXJ2YWw+IHwgdW5kZWZpbmVkO1xuXG4gIHByaXZhdGUgY2xvc2luZ0xvY2s6IE11dGV4O1xuXG4gIHByaXZhdGUgc3RhdGU6IFNpZ25hbENvbm5lY3Rpb25TdGF0ZSA9IFNpZ25hbENvbm5lY3Rpb25TdGF0ZS5ESVNDT05ORUNURUQ7XG5cbiAgcHJpdmF0ZSBjb25uZWN0aW9uTG9jazogTXV0ZXg7XG5cbiAgcHJpdmF0ZSBsb2cgPSBsb2c7XG5cbiAgcHJpdmF0ZSBsb2dnZXJDb250ZXh0Q2I/OiBMb2dnZXJPcHRpb25zWydsb2dnZXJDb250ZXh0Q2InXTtcblxuICBjb25zdHJ1Y3Rvcih1c2VKU09OOiBib29sZWFuID0gZmFsc2UsIGxvZ2dlck9wdGlvbnM6IExvZ2dlck9wdGlvbnMgPSB7fSkge1xuICAgIHRoaXMubG9nID0gZ2V0TG9nZ2VyKGxvZ2dlck9wdGlvbnMubG9nZ2VyTmFtZSA/PyBMb2dnZXJOYW1lcy5TaWduYWwpO1xuICAgIHRoaXMubG9nZ2VyQ29udGV4dENiID0gbG9nZ2VyT3B0aW9ucy5sb2dnZXJDb250ZXh0Q2I7XG4gICAgdGhpcy51c2VKU09OID0gdXNlSlNPTjtcbiAgICB0aGlzLnJlcXVlc3RRdWV1ZSA9IG5ldyBBc3luY1F1ZXVlKCk7XG4gICAgdGhpcy5xdWV1ZWRSZXF1ZXN0cyA9IFtdO1xuICAgIHRoaXMuY2xvc2luZ0xvY2sgPSBuZXcgTXV0ZXgoKTtcbiAgICB0aGlzLmNvbm5lY3Rpb25Mb2NrID0gbmV3IE11dGV4KCk7XG4gICAgdGhpcy5zdGF0ZSA9IFNpZ25hbENvbm5lY3Rpb25TdGF0ZS5ESVNDT05ORUNURUQ7XG4gIH1cblxuICBwcml2YXRlIGdldCBsb2dDb250ZXh0KCkge1xuICAgIHJldHVybiB0aGlzLmxvZ2dlckNvbnRleHRDYj8uKCkgPz8ge307XG4gIH1cblxuICBhc3luYyBqb2luKFxuICAgIHVybDogc3RyaW5nLFxuICAgIHRva2VuOiBzdHJpbmcsXG4gICAgb3B0czogU2lnbmFsT3B0aW9ucyxcbiAgICBhYm9ydFNpZ25hbD86IEFib3J0U2lnbmFsLFxuICApOiBQcm9taXNlPEpvaW5SZXNwb25zZT4ge1xuICAgIC8vIGR1cmluZyBhIGZ1bGwgcmVjb25uZWN0LCB3ZSdkIHdhbnQgdG8gc3RhcnQgdGhlIHNlcXVlbmNlIGV2ZW4gaWYgY3VycmVudGx5XG4gICAgLy8gY29ubmVjdGVkXG4gICAgdGhpcy5zdGF0ZSA9IFNpZ25hbENvbm5lY3Rpb25TdGF0ZS5DT05ORUNUSU5HO1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdHM7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5jb25uZWN0KHVybCwgdG9rZW4sIG9wdHMsIGFib3J0U2lnbmFsKTtcbiAgICByZXR1cm4gcmVzIGFzIEpvaW5SZXNwb25zZTtcbiAgfVxuXG4gIGFzeW5jIHJlY29ubmVjdChcbiAgICB1cmw6IHN0cmluZyxcbiAgICB0b2tlbjogc3RyaW5nLFxuICAgIHNpZD86IHN0cmluZyxcbiAgICByZWFzb24/OiBSZWNvbm5lY3RSZWFzb24sXG4gICk6IFByb21pc2U8UmVjb25uZWN0UmVzcG9uc2UgfCB2b2lkPiB7XG4gICAgaWYgKCF0aGlzLm9wdGlvbnMpIHtcbiAgICAgIHRoaXMubG9nLndhcm4oXG4gICAgICAgICdhdHRlbXB0ZWQgdG8gcmVjb25uZWN0IHdpdGhvdXQgc2lnbmFsIG9wdGlvbnMgYmVpbmcgc2V0LCBpZ25vcmluZycsXG4gICAgICAgIHRoaXMubG9nQ29udGV4dCxcbiAgICAgICk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuc3RhdGUgPSBTaWduYWxDb25uZWN0aW9uU3RhdGUuUkVDT05ORUNUSU5HO1xuICAgIC8vIGNsZWFyIHBpbmcgaW50ZXJ2YWwgYW5kIHJlc3RhcnQgaXQgb25jZSByZWNvbm5lY3RlZFxuICAgIHRoaXMuY2xlYXJQaW5nSW50ZXJ2YWwoKTtcblxuICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuY29ubmVjdCh1cmwsIHRva2VuLCB7XG4gICAgICAuLi50aGlzLm9wdGlvbnMsXG4gICAgICByZWNvbm5lY3Q6IHRydWUsXG4gICAgICBzaWQsXG4gICAgICByZWNvbm5lY3RSZWFzb246IHJlYXNvbixcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzO1xuICB9XG5cbiAgcHJpdmF0ZSBjb25uZWN0KFxuICAgIHVybDogc3RyaW5nLFxuICAgIHRva2VuOiBzdHJpbmcsXG4gICAgb3B0czogQ29ubmVjdE9wdHMsXG4gICAgYWJvcnRTaWduYWw/OiBBYm9ydFNpZ25hbCxcbiAgKTogUHJvbWlzZTxKb2luUmVzcG9uc2UgfCBSZWNvbm5lY3RSZXNwb25zZSB8IHZvaWQ+IHtcbiAgICB0aGlzLmNvbm5lY3RPcHRpb25zID0gb3B0cztcbiAgICB1cmwgPSB0b1dlYnNvY2tldFVybCh1cmwpO1xuICAgIC8vIHN0cmlwIHRyYWlsaW5nIHNsYXNoXG4gICAgdXJsID0gdXJsLnJlcGxhY2UoL1xcLyQvLCAnJyk7XG4gICAgdXJsICs9ICcvcnRjJztcblxuICAgIGNvbnN0IGNsaWVudEluZm8gPSBnZXRDbGllbnRJbmZvKCk7XG4gICAgY29uc3QgcGFyYW1zID0gY3JlYXRlQ29ubmVjdGlvblBhcmFtcyh0b2tlbiwgY2xpZW50SW5mbywgb3B0cyk7XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2U8Sm9pblJlc3BvbnNlIHwgUmVjb25uZWN0UmVzcG9uc2UgfCB2b2lkPihhc3luYyAocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjb25zdCB1bmxvY2sgPSBhd2FpdCB0aGlzLmNvbm5lY3Rpb25Mb2NrLmxvY2soKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGFib3J0SGFuZGxlciA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHdzVGltZW91dCk7XG4gICAgICAgICAgcmVqZWN0KG5ldyBDb25uZWN0aW9uRXJyb3IoJ3Jvb20gY29ubmVjdGlvbiBoYXMgYmVlbiBjYW5jZWxsZWQgKHNpZ25hbCknKSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3Qgd3NUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICAgIHJlamVjdChuZXcgQ29ubmVjdGlvbkVycm9yKCdyb29tIGNvbm5lY3Rpb24gaGFzIHRpbWVkIG91dCAoc2lnbmFsKScpKTtcbiAgICAgICAgfSwgb3B0cy53ZWJzb2NrZXRUaW1lb3V0KTtcblxuICAgICAgICBpZiAoYWJvcnRTaWduYWw/LmFib3J0ZWQpIHtcbiAgICAgICAgICBhYm9ydEhhbmRsZXIoKTtcbiAgICAgICAgfVxuICAgICAgICBhYm9ydFNpZ25hbD8uYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBhYm9ydEhhbmRsZXIpO1xuICAgICAgICB0aGlzLmxvZy5kZWJ1ZyhgY29ubmVjdGluZyB0byAke3VybCArIHBhcmFtc31gLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgICBpZiAodGhpcy53cykge1xuICAgICAgICAgIGF3YWl0IHRoaXMuY2xvc2UoZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMud3MgPSBuZXcgV2ViU29ja2V0KHVybCArIHBhcmFtcyk7XG4gICAgICAgIHRoaXMud3MuYmluYXJ5VHlwZSA9ICdhcnJheWJ1ZmZlcic7XG5cbiAgICAgICAgdGhpcy53cy5vbm9wZW4gPSAoKSA9PiB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHdzVGltZW91dCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy53cy5vbmVycm9yID0gYXN5bmMgKGV2OiBFdmVudCkgPT4ge1xuICAgICAgICAgIGlmICh0aGlzLnN0YXRlICE9PSBTaWduYWxDb25uZWN0aW9uU3RhdGUuQ09OTkVDVEVEKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQod3NUaW1lb3V0KTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBhd2FpdCBmZXRjaChgaHR0cCR7dXJsLnN1YnN0cmluZygyKX0vdmFsaWRhdGUke3BhcmFtc31gKTtcbiAgICAgICAgICAgICAgaWYgKHJlc3Auc3RhdHVzLnRvRml4ZWQoMCkuc3RhcnRzV2l0aCgnNCcpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbXNnID0gYXdhaXQgcmVzcC50ZXh0KCk7XG4gICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBDb25uZWN0aW9uRXJyb3IobXNnLCBDb25uZWN0aW9uRXJyb3JSZWFzb24uTm90QWxsb3dlZCwgcmVzcC5zdGF0dXMpKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZWplY3QoXG4gICAgICAgICAgICAgICAgICBuZXcgQ29ubmVjdGlvbkVycm9yKFxuICAgICAgICAgICAgICAgICAgICAnSW50ZXJuYWwgZXJyb3InLFxuICAgICAgICAgICAgICAgICAgICBDb25uZWN0aW9uRXJyb3JSZWFzb24uSW50ZXJuYWxFcnJvcixcbiAgICAgICAgICAgICAgICAgICAgcmVzcC5zdGF0dXMsXG4gICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgcmVqZWN0KFxuICAgICAgICAgICAgICAgIG5ldyBDb25uZWN0aW9uRXJyb3IoXG4gICAgICAgICAgICAgICAgICAnc2VydmVyIHdhcyBub3QgcmVhY2hhYmxlJyxcbiAgICAgICAgICAgICAgICAgIENvbm5lY3Rpb25FcnJvclJlYXNvbi5TZXJ2ZXJVbnJlYWNoYWJsZSxcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBvdGhlciBlcnJvcnMsIGhhbmRsZVxuICAgICAgICAgIHRoaXMuaGFuZGxlV1NFcnJvcihldik7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy53cy5vbm1lc3NhZ2UgPSBhc3luYyAoZXY6IE1lc3NhZ2VFdmVudCkgPT4ge1xuICAgICAgICAgIC8vIG5vdCBjb25zaWRlcmVkIGNvbm5lY3RlZCB1bnRpbCBKb2luUmVzcG9uc2UgaXMgcmVjZWl2ZWRcbiAgICAgICAgICBsZXQgcmVzcDogU2lnbmFsUmVzcG9uc2U7XG4gICAgICAgICAgaWYgKHR5cGVvZiBldi5kYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgY29uc3QganNvbiA9IEpTT04ucGFyc2UoZXYuZGF0YSk7XG4gICAgICAgICAgICByZXNwID0gU2lnbmFsUmVzcG9uc2UuZnJvbUpzb24oanNvbik7XG4gICAgICAgICAgfSBlbHNlIGlmIChldi5kYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgICAgIHJlc3AgPSBTaWduYWxSZXNwb25zZS5mcm9tQmluYXJ5KG5ldyBVaW50OEFycmF5KGV2LmRhdGEpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5sb2cuZXJyb3IoXG4gICAgICAgICAgICAgIGBjb3VsZCBub3QgZGVjb2RlIHdlYnNvY2tldCBtZXNzYWdlOiAke3R5cGVvZiBldi5kYXRhfWAsXG4gICAgICAgICAgICAgIHRoaXMubG9nQ29udGV4dCxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHRoaXMuc3RhdGUgIT09IFNpZ25hbENvbm5lY3Rpb25TdGF0ZS5DT05ORUNURUQpIHtcbiAgICAgICAgICAgIGxldCBzaG91bGRQcm9jZXNzTWVzc2FnZSA9IGZhbHNlO1xuICAgICAgICAgICAgLy8gaGFuZGxlIGpvaW4gbWVzc2FnZSBvbmx5XG4gICAgICAgICAgICBpZiAocmVzcC5tZXNzYWdlPy5jYXNlID09PSAnam9pbicpIHtcbiAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFNpZ25hbENvbm5lY3Rpb25TdGF0ZS5DT05ORUNURUQ7XG4gICAgICAgICAgICAgIGFib3J0U2lnbmFsPy5yZW1vdmVFdmVudExpc3RlbmVyKCdhYm9ydCcsIGFib3J0SGFuZGxlcik7XG4gICAgICAgICAgICAgIHRoaXMucGluZ1RpbWVvdXREdXJhdGlvbiA9IHJlc3AubWVzc2FnZS52YWx1ZS5waW5nVGltZW91dDtcbiAgICAgICAgICAgICAgdGhpcy5waW5nSW50ZXJ2YWxEdXJhdGlvbiA9IHJlc3AubWVzc2FnZS52YWx1ZS5waW5nSW50ZXJ2YWw7XG5cbiAgICAgICAgICAgICAgaWYgKHRoaXMucGluZ1RpbWVvdXREdXJhdGlvbiAmJiB0aGlzLnBpbmdUaW1lb3V0RHVyYXRpb24gPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2cuZGVidWcoJ3BpbmcgY29uZmlnJywge1xuICAgICAgICAgICAgICAgICAgLi4udGhpcy5sb2dDb250ZXh0LFxuICAgICAgICAgICAgICAgICAgdGltZW91dDogdGhpcy5waW5nVGltZW91dER1cmF0aW9uLFxuICAgICAgICAgICAgICAgICAgaW50ZXJ2YWw6IHRoaXMucGluZ0ludGVydmFsRHVyYXRpb24sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydFBpbmdJbnRlcnZhbCgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJlc29sdmUocmVzcC5tZXNzYWdlLnZhbHVlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICAgIHRoaXMuc3RhdGUgPT09IFNpZ25hbENvbm5lY3Rpb25TdGF0ZS5SRUNPTk5FQ1RJTkcgJiZcbiAgICAgICAgICAgICAgcmVzcC5tZXNzYWdlLmNhc2UgIT09ICdsZWF2ZSdcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAvLyBpbiByZWNvbm5lY3RpbmcsIGFueSBtZXNzYWdlIHJlY2VpdmVkIG1lYW5zIHNpZ25hbCByZWNvbm5lY3RlZFxuICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gU2lnbmFsQ29ubmVjdGlvblN0YXRlLkNPTk5FQ1RFRDtcbiAgICAgICAgICAgICAgYWJvcnRTaWduYWw/LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgYWJvcnRIYW5kbGVyKTtcbiAgICAgICAgICAgICAgdGhpcy5zdGFydFBpbmdJbnRlcnZhbCgpO1xuICAgICAgICAgICAgICBpZiAocmVzcC5tZXNzYWdlPy5jYXNlID09PSAncmVjb25uZWN0Jykge1xuICAgICAgICAgICAgICAgIHJlc29sdmUocmVzcC5tZXNzYWdlPy52YWx1ZSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIHNob3VsZFByb2Nlc3NNZXNzYWdlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmlzRXN0YWJsaXNoaW5nQ29ubmVjdGlvbiAmJiByZXNwLm1lc3NhZ2UuY2FzZSA9PT0gJ2xlYXZlJykge1xuICAgICAgICAgICAgICByZWplY3QoXG4gICAgICAgICAgICAgICAgbmV3IENvbm5lY3Rpb25FcnJvcihcbiAgICAgICAgICAgICAgICAgICdSZWNlaXZlZCBsZWF2ZSByZXF1ZXN0IHdoaWxlIHRyeWluZyB0byAocmUpY29ubmVjdCcsXG4gICAgICAgICAgICAgICAgICBDb25uZWN0aW9uRXJyb3JSZWFzb24uTGVhdmVSZXF1ZXN0LFxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFvcHRzLnJlY29ubmVjdCkge1xuICAgICAgICAgICAgICAvLyBub24tcmVjb25uZWN0IGNhc2UsIHNob3VsZCByZWNlaXZlIGpvaW4gcmVzcG9uc2UgZmlyc3RcbiAgICAgICAgICAgICAgcmVqZWN0KFxuICAgICAgICAgICAgICAgIG5ldyBDb25uZWN0aW9uRXJyb3IoXG4gICAgICAgICAgICAgICAgICBgZGlkIG5vdCByZWNlaXZlIGpvaW4gcmVzcG9uc2UsIGdvdCAke3Jlc3AubWVzc2FnZT8uY2FzZX0gaW5zdGVhZGAsXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghc2hvdWxkUHJvY2Vzc01lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh0aGlzLnNpZ25hbExhdGVuY3kpIHtcbiAgICAgICAgICAgIGF3YWl0IHNsZWVwKHRoaXMuc2lnbmFsTGF0ZW5jeSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuaGFuZGxlU2lnbmFsUmVzcG9uc2UocmVzcCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy53cy5vbmNsb3NlID0gKGV2OiBDbG9zZUV2ZW50KSA9PiB7XG4gICAgICAgICAgaWYgKHRoaXMuaXNFc3RhYmxpc2hpbmdDb25uZWN0aW9uKSB7XG4gICAgICAgICAgICByZWplY3QobmV3IENvbm5lY3Rpb25FcnJvcignV2Vic29ja2V0IGdvdCBjbG9zZWQgZHVyaW5nIGEgKHJlKWNvbm5lY3Rpb24gYXR0ZW1wdCcpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLmxvZy53YXJuKGB3ZWJzb2NrZXQgY2xvc2VkYCwge1xuICAgICAgICAgICAgLi4udGhpcy5sb2dDb250ZXh0LFxuICAgICAgICAgICAgcmVhc29uOiBldi5yZWFzb24sXG4gICAgICAgICAgICBzdGF0ZTogdGhpcy5zdGF0ZSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0aGlzLmhhbmRsZU9uQ2xvc2UoZXYucmVhc29uKTtcbiAgICAgICAgfTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHVubG9jaygpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICByZXNldENhbGxiYWNrcyA9ICgpID0+IHtcbiAgICB0aGlzLm9uQW5zd2VyID0gdW5kZWZpbmVkO1xuICAgIHRoaXMub25MZWF2ZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLm9uTG9jYWxUcmFja1B1Ymxpc2hlZCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLm9uTG9jYWxUcmFja1VucHVibGlzaGVkID0gdW5kZWZpbmVkO1xuICAgIHRoaXMub25OZWdvdGlhdGVSZXF1ZXN0ZWQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5vbk9mZmVyID0gdW5kZWZpbmVkO1xuICAgIHRoaXMub25SZW1vdGVNdXRlQ2hhbmdlZCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLm9uU3Vic2NyaWJlZFF1YWxpdHlVcGRhdGUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5vblRva2VuUmVmcmVzaCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLm9uVHJpY2tsZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLm9uQ2xvc2UgPSB1bmRlZmluZWQ7XG4gIH07XG5cbiAgYXN5bmMgY2xvc2UodXBkYXRlU3RhdGU6IGJvb2xlYW4gPSB0cnVlKSB7XG4gICAgY29uc3QgdW5sb2NrID0gYXdhaXQgdGhpcy5jbG9zaW5nTG9jay5sb2NrKCk7XG4gICAgdHJ5IHtcbiAgICAgIGlmICh1cGRhdGVTdGF0ZSkge1xuICAgICAgICB0aGlzLnN0YXRlID0gU2lnbmFsQ29ubmVjdGlvblN0YXRlLkRJU0NPTk5FQ1RJTkc7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy53cykge1xuICAgICAgICB0aGlzLndzLm9ubWVzc2FnZSA9IG51bGw7XG4gICAgICAgIHRoaXMud3Mub25vcGVuID0gbnVsbDtcbiAgICAgICAgdGhpcy53cy5vbmNsb3NlID0gbnVsbDtcblxuICAgICAgICAvLyBjYWxsaW5nIGB3cy5jbG9zZSgpYCBvbmx5IHN0YXJ0cyB0aGUgY2xvc2luZyBoYW5kc2hha2UgKENMT1NJTkcgc3RhdGUpLCBwcmVmZXIgdG8gd2FpdCB1bnRpbCBzdGF0ZSBpcyBhY3R1YWxseSBDTE9TRURcbiAgICAgICAgY29uc3QgY2xvc2VQcm9taXNlID0gbmV3IFByb21pc2U8dm9pZD4oKHJlc29sdmUpID0+IHtcbiAgICAgICAgICBpZiAodGhpcy53cykge1xuICAgICAgICAgICAgdGhpcy53cy5vbmNsb3NlID0gKCkgPT4ge1xuICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAodGhpcy53cy5yZWFkeVN0YXRlIDwgdGhpcy53cy5DTE9TSU5HKSB7XG4gICAgICAgICAgdGhpcy53cy5jbG9zZSgpO1xuICAgICAgICAgIC8vIDI1MG1zIGdyYWNlIHBlcmlvZCBmb3Igd3MgdG8gY2xvc2UgZ3JhY2VmdWxseVxuICAgICAgICAgIGF3YWl0IFByb21pc2UucmFjZShbY2xvc2VQcm9taXNlLCBzbGVlcCgyNTApXSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy53cyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKHVwZGF0ZVN0YXRlKSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBTaWduYWxDb25uZWN0aW9uU3RhdGUuRElTQ09OTkVDVEVEO1xuICAgICAgfVxuICAgICAgdGhpcy5jbGVhclBpbmdJbnRlcnZhbCgpO1xuICAgICAgdW5sb2NrKCk7XG4gICAgfVxuICB9XG5cbiAgLy8gaW5pdGlhbCBvZmZlciBhZnRlciBqb2luaW5nXG4gIHNlbmRPZmZlcihvZmZlcjogUlRDU2Vzc2lvbkRlc2NyaXB0aW9uSW5pdCkge1xuICAgIHRoaXMubG9nLmRlYnVnKCdzZW5kaW5nIG9mZmVyJywgeyAuLi50aGlzLmxvZ0NvbnRleHQsIG9mZmVyU2RwOiBvZmZlci5zZHAgfSk7XG4gICAgdGhpcy5zZW5kUmVxdWVzdCh7XG4gICAgICBjYXNlOiAnb2ZmZXInLFxuICAgICAgdmFsdWU6IHRvUHJvdG9TZXNzaW9uRGVzY3JpcHRpb24ob2ZmZXIpLFxuICAgIH0pO1xuICB9XG5cbiAgLy8gYW5zd2VyIGEgc2VydmVyLWluaXRpYXRlZCBvZmZlclxuICBzZW5kQW5zd2VyKGFuc3dlcjogUlRDU2Vzc2lvbkRlc2NyaXB0aW9uSW5pdCkge1xuICAgIHRoaXMubG9nLmRlYnVnKCdzZW5kaW5nIGFuc3dlcicsIHsgLi4udGhpcy5sb2dDb250ZXh0LCBhbnN3ZXJTZHA6IGFuc3dlci5zZHAgfSk7XG4gICAgcmV0dXJuIHRoaXMuc2VuZFJlcXVlc3Qoe1xuICAgICAgY2FzZTogJ2Fuc3dlcicsXG4gICAgICB2YWx1ZTogdG9Qcm90b1Nlc3Npb25EZXNjcmlwdGlvbihhbnN3ZXIpLFxuICAgIH0pO1xuICB9XG5cbiAgc2VuZEljZUNhbmRpZGF0ZShjYW5kaWRhdGU6IFJUQ0ljZUNhbmRpZGF0ZUluaXQsIHRhcmdldDogU2lnbmFsVGFyZ2V0KSB7XG4gICAgdGhpcy5sb2cudHJhY2UoJ3NlbmRpbmcgaWNlIGNhbmRpZGF0ZScsIHsgLi4udGhpcy5sb2dDb250ZXh0LCBjYW5kaWRhdGUgfSk7XG4gICAgcmV0dXJuIHRoaXMuc2VuZFJlcXVlc3Qoe1xuICAgICAgY2FzZTogJ3RyaWNrbGUnLFxuICAgICAgdmFsdWU6IG5ldyBUcmlja2xlUmVxdWVzdCh7XG4gICAgICAgIGNhbmRpZGF0ZUluaXQ6IEpTT04uc3RyaW5naWZ5KGNhbmRpZGF0ZSksXG4gICAgICAgIHRhcmdldCxcbiAgICAgIH0pLFxuICAgIH0pO1xuICB9XG5cbiAgc2VuZE11dGVUcmFjayh0cmFja1NpZDogc3RyaW5nLCBtdXRlZDogYm9vbGVhbikge1xuICAgIHJldHVybiB0aGlzLnNlbmRSZXF1ZXN0KHtcbiAgICAgIGNhc2U6ICdtdXRlJyxcbiAgICAgIHZhbHVlOiBuZXcgTXV0ZVRyYWNrUmVxdWVzdCh7XG4gICAgICAgIHNpZDogdHJhY2tTaWQsXG4gICAgICAgIG11dGVkLFxuICAgICAgfSksXG4gICAgfSk7XG4gIH1cblxuICBzZW5kQWRkVHJhY2socmVxOiBBZGRUcmFja1JlcXVlc3QpIHtcbiAgICByZXR1cm4gdGhpcy5zZW5kUmVxdWVzdCh7XG4gICAgICBjYXNlOiAnYWRkVHJhY2snLFxuICAgICAgdmFsdWU6IHJlcSxcbiAgICB9KTtcbiAgfVxuXG4gIHNlbmRVcGRhdGVMb2NhbE1ldGFkYXRhKG1ldGFkYXRhOiBzdHJpbmcsIG5hbWU6IHN0cmluZykge1xuICAgIHJldHVybiB0aGlzLnNlbmRSZXF1ZXN0KHtcbiAgICAgIGNhc2U6ICd1cGRhdGVNZXRhZGF0YScsXG4gICAgICB2YWx1ZTogbmV3IFVwZGF0ZVBhcnRpY2lwYW50TWV0YWRhdGEoe1xuICAgICAgICBtZXRhZGF0YSxcbiAgICAgICAgbmFtZSxcbiAgICAgIH0pLFxuICAgIH0pO1xuICB9XG5cbiAgc2VuZFVwZGF0ZVRyYWNrU2V0dGluZ3Moc2V0dGluZ3M6IFVwZGF0ZVRyYWNrU2V0dGluZ3MpIHtcbiAgICB0aGlzLnNlbmRSZXF1ZXN0KHtcbiAgICAgIGNhc2U6ICd0cmFja1NldHRpbmcnLFxuICAgICAgdmFsdWU6IHNldHRpbmdzLFxuICAgIH0pO1xuICB9XG5cbiAgc2VuZFVwZGF0ZVN1YnNjcmlwdGlvbihzdWI6IFVwZGF0ZVN1YnNjcmlwdGlvbikge1xuICAgIHJldHVybiB0aGlzLnNlbmRSZXF1ZXN0KHtcbiAgICAgIGNhc2U6ICdzdWJzY3JpcHRpb24nLFxuICAgICAgdmFsdWU6IHN1YixcbiAgICB9KTtcbiAgfVxuXG4gIHNlbmRTeW5jU3RhdGUoc3luYzogU3luY1N0YXRlKSB7XG4gICAgcmV0dXJuIHRoaXMuc2VuZFJlcXVlc3Qoe1xuICAgICAgY2FzZTogJ3N5bmNTdGF0ZScsXG4gICAgICB2YWx1ZTogc3luYyxcbiAgICB9KTtcbiAgfVxuXG4gIHNlbmRVcGRhdGVWaWRlb0xheWVycyh0cmFja1NpZDogc3RyaW5nLCBsYXllcnM6IFZpZGVvTGF5ZXJbXSkge1xuICAgIHJldHVybiB0aGlzLnNlbmRSZXF1ZXN0KHtcbiAgICAgIGNhc2U6ICd1cGRhdGVMYXllcnMnLFxuICAgICAgdmFsdWU6IG5ldyBVcGRhdGVWaWRlb0xheWVycyh7XG4gICAgICAgIHRyYWNrU2lkLFxuICAgICAgICBsYXllcnMsXG4gICAgICB9KSxcbiAgICB9KTtcbiAgfVxuXG4gIHNlbmRVcGRhdGVTdWJzY3JpcHRpb25QZXJtaXNzaW9ucyhhbGxQYXJ0aWNpcGFudHM6IGJvb2xlYW4sIHRyYWNrUGVybWlzc2lvbnM6IFRyYWNrUGVybWlzc2lvbltdKSB7XG4gICAgcmV0dXJuIHRoaXMuc2VuZFJlcXVlc3Qoe1xuICAgICAgY2FzZTogJ3N1YnNjcmlwdGlvblBlcm1pc3Npb24nLFxuICAgICAgdmFsdWU6IG5ldyBTdWJzY3JpcHRpb25QZXJtaXNzaW9uKHtcbiAgICAgICAgYWxsUGFydGljaXBhbnRzLFxuICAgICAgICB0cmFja1Blcm1pc3Npb25zLFxuICAgICAgfSksXG4gICAgfSk7XG4gIH1cblxuICBzZW5kU2ltdWxhdGVTY2VuYXJpbyhzY2VuYXJpbzogU2ltdWxhdGVTY2VuYXJpbykge1xuICAgIHJldHVybiB0aGlzLnNlbmRSZXF1ZXN0KHtcbiAgICAgIGNhc2U6ICdzaW11bGF0ZScsXG4gICAgICB2YWx1ZTogc2NlbmFyaW8sXG4gICAgfSk7XG4gIH1cblxuICBzZW5kUGluZygpIHtcbiAgICAvKiogc2VuZCBib3RoIG9mIHBpbmcgYW5kIHBpbmdSZXEgZm9yIGNvbXBhdGliaWxpdHkgdG8gb2xkIGFuZCBuZXcgc2VydmVyICovXG4gICAgcmV0dXJuIFByb21pc2UuYWxsKFtcbiAgICAgIHRoaXMuc2VuZFJlcXVlc3Qoe1xuICAgICAgICBjYXNlOiAncGluZycsXG4gICAgICAgIHZhbHVlOiBwcm90b0ludDY0LnBhcnNlKERhdGUubm93KCkpLFxuICAgICAgfSksXG4gICAgICB0aGlzLnNlbmRSZXF1ZXN0KHtcbiAgICAgICAgY2FzZTogJ3BpbmdSZXEnLFxuICAgICAgICB2YWx1ZTogbmV3IFBpbmcoe1xuICAgICAgICAgIHRpbWVzdGFtcDogcHJvdG9JbnQ2NC5wYXJzZShEYXRlLm5vdygpKSxcbiAgICAgICAgICBydHQ6IHByb3RvSW50NjQucGFyc2UodGhpcy5ydHQpLFxuICAgICAgICB9KSxcbiAgICAgIH0pLFxuICAgIF0pO1xuICB9XG5cbiAgc2VuZExlYXZlKCkge1xuICAgIHJldHVybiB0aGlzLnNlbmRSZXF1ZXN0KHtcbiAgICAgIGNhc2U6ICdsZWF2ZScsXG4gICAgICB2YWx1ZTogbmV3IExlYXZlUmVxdWVzdCh7XG4gICAgICAgIGNhblJlY29ubmVjdDogZmFsc2UsXG4gICAgICAgIHJlYXNvbjogRGlzY29ubmVjdFJlYXNvbi5DTElFTlRfSU5JVElBVEVELFxuICAgICAgfSksXG4gICAgfSk7XG4gIH1cblxuICBhc3luYyBzZW5kUmVxdWVzdChtZXNzYWdlOiBTaWduYWxNZXNzYWdlLCBmcm9tUXVldWU6IGJvb2xlYW4gPSBmYWxzZSkge1xuICAgIC8vIGNhcHR1cmUgYWxsIHJlcXVlc3RzIHdoaWxlIHJlY29ubmVjdGluZyBhbmQgcHV0IHRoZW0gaW4gYSBxdWV1ZVxuICAgIC8vIHVubGVzcyB0aGUgcmVxdWVzdCBvcmlnaW5hdGVzIGZyb20gdGhlIHF1ZXVlLCB0aGVuIGRvbid0IGVucXVldWUgYWdhaW5cbiAgICBjb25zdCBjYW5RdWV1ZSA9ICFmcm9tUXVldWUgJiYgIWNhblBhc3NUaHJvdWdoUXVldWUobWVzc2FnZSk7XG4gICAgaWYgKGNhblF1ZXVlICYmIHRoaXMuc3RhdGUgPT09IFNpZ25hbENvbm5lY3Rpb25TdGF0ZS5SRUNPTk5FQ1RJTkcpIHtcbiAgICAgIHRoaXMucXVldWVkUmVxdWVzdHMucHVzaChhc3luYyAoKSA9PiB7XG4gICAgICAgIGF3YWl0IHRoaXMuc2VuZFJlcXVlc3QobWVzc2FnZSwgdHJ1ZSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gbWFrZSBzdXJlIHByZXZpb3VzbHkgcXVldWVkIHJlcXVlc3RzIGFyZSBiZWluZyBzZW50IGZpcnN0XG4gICAgaWYgKCFmcm9tUXVldWUpIHtcbiAgICAgIGF3YWl0IHRoaXMucmVxdWVzdFF1ZXVlLmZsdXNoKCk7XG4gICAgfVxuICAgIGlmICh0aGlzLnNpZ25hbExhdGVuY3kpIHtcbiAgICAgIGF3YWl0IHNsZWVwKHRoaXMuc2lnbmFsTGF0ZW5jeSk7XG4gICAgfVxuICAgIGlmICghdGhpcy53cyB8fCB0aGlzLndzLnJlYWR5U3RhdGUgIT09IHRoaXMud3MuT1BFTikge1xuICAgICAgdGhpcy5sb2cuZXJyb3IoXG4gICAgICAgIGBjYW5ub3Qgc2VuZCBzaWduYWwgcmVxdWVzdCBiZWZvcmUgY29ubmVjdGVkLCB0eXBlOiAke21lc3NhZ2U/LmNhc2V9YCxcbiAgICAgICAgdGhpcy5sb2dDb250ZXh0LFxuICAgICAgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgcmVxID0gbmV3IFNpZ25hbFJlcXVlc3QoeyBtZXNzYWdlIH0pO1xuXG4gICAgdHJ5IHtcbiAgICAgIGlmICh0aGlzLnVzZUpTT04pIHtcbiAgICAgICAgdGhpcy53cy5zZW5kKHJlcS50b0pzb25TdHJpbmcoKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLndzLnNlbmQocmVxLnRvQmluYXJ5KCkpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRoaXMubG9nLmVycm9yKCdlcnJvciBzZW5kaW5nIHNpZ25hbCBtZXNzYWdlJywgeyAuLi50aGlzLmxvZ0NvbnRleHQsIGVycm9yOiBlIH0pO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgaGFuZGxlU2lnbmFsUmVzcG9uc2UocmVzOiBTaWduYWxSZXNwb25zZSkge1xuICAgIGNvbnN0IG1zZyA9IHJlcy5tZXNzYWdlO1xuICAgIGlmIChtc2cgPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLmxvZy5kZWJ1ZygncmVjZWl2ZWQgdW5zdXBwb3J0ZWQgbWVzc2FnZScsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbGV0IHBpbmdIYW5kbGVkID0gZmFsc2U7XG4gICAgaWYgKG1zZy5jYXNlID09PSAnYW5zd2VyJykge1xuICAgICAgY29uc3Qgc2QgPSBmcm9tUHJvdG9TZXNzaW9uRGVzY3JpcHRpb24obXNnLnZhbHVlKTtcbiAgICAgIGlmICh0aGlzLm9uQW5zd2VyKSB7XG4gICAgICAgIHRoaXMub25BbnN3ZXIoc2QpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobXNnLmNhc2UgPT09ICdvZmZlcicpIHtcbiAgICAgIGNvbnN0IHNkID0gZnJvbVByb3RvU2Vzc2lvbkRlc2NyaXB0aW9uKG1zZy52YWx1ZSk7XG4gICAgICBpZiAodGhpcy5vbk9mZmVyKSB7XG4gICAgICAgIHRoaXMub25PZmZlcihzZCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChtc2cuY2FzZSA9PT0gJ3RyaWNrbGUnKSB7XG4gICAgICBjb25zdCBjYW5kaWRhdGU6IFJUQ0ljZUNhbmRpZGF0ZUluaXQgPSBKU09OLnBhcnNlKG1zZy52YWx1ZS5jYW5kaWRhdGVJbml0ISk7XG4gICAgICBpZiAodGhpcy5vblRyaWNrbGUpIHtcbiAgICAgICAgdGhpcy5vblRyaWNrbGUoY2FuZGlkYXRlLCBtc2cudmFsdWUudGFyZ2V0KTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG1zZy5jYXNlID09PSAndXBkYXRlJykge1xuICAgICAgaWYgKHRoaXMub25QYXJ0aWNpcGFudFVwZGF0ZSkge1xuICAgICAgICB0aGlzLm9uUGFydGljaXBhbnRVcGRhdGUobXNnLnZhbHVlLnBhcnRpY2lwYW50cyA/PyBbXSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChtc2cuY2FzZSA9PT0gJ3RyYWNrUHVibGlzaGVkJykge1xuICAgICAgaWYgKHRoaXMub25Mb2NhbFRyYWNrUHVibGlzaGVkKSB7XG4gICAgICAgIHRoaXMub25Mb2NhbFRyYWNrUHVibGlzaGVkKG1zZy52YWx1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChtc2cuY2FzZSA9PT0gJ3NwZWFrZXJzQ2hhbmdlZCcpIHtcbiAgICAgIGlmICh0aGlzLm9uU3BlYWtlcnNDaGFuZ2VkKSB7XG4gICAgICAgIHRoaXMub25TcGVha2Vyc0NoYW5nZWQobXNnLnZhbHVlLnNwZWFrZXJzID8/IFtdKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG1zZy5jYXNlID09PSAnbGVhdmUnKSB7XG4gICAgICBpZiAodGhpcy5vbkxlYXZlKSB7XG4gICAgICAgIHRoaXMub25MZWF2ZShtc2cudmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobXNnLmNhc2UgPT09ICdtdXRlJykge1xuICAgICAgaWYgKHRoaXMub25SZW1vdGVNdXRlQ2hhbmdlZCkge1xuICAgICAgICB0aGlzLm9uUmVtb3RlTXV0ZUNoYW5nZWQobXNnLnZhbHVlLnNpZCwgbXNnLnZhbHVlLm11dGVkKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG1zZy5jYXNlID09PSAncm9vbVVwZGF0ZScpIHtcbiAgICAgIGlmICh0aGlzLm9uUm9vbVVwZGF0ZSAmJiBtc2cudmFsdWUucm9vbSkge1xuICAgICAgICB0aGlzLm9uUm9vbVVwZGF0ZShtc2cudmFsdWUucm9vbSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChtc2cuY2FzZSA9PT0gJ2Nvbm5lY3Rpb25RdWFsaXR5Jykge1xuICAgICAgaWYgKHRoaXMub25Db25uZWN0aW9uUXVhbGl0eSkge1xuICAgICAgICB0aGlzLm9uQ29ubmVjdGlvblF1YWxpdHkobXNnLnZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG1zZy5jYXNlID09PSAnc3RyZWFtU3RhdGVVcGRhdGUnKSB7XG4gICAgICBpZiAodGhpcy5vblN0cmVhbVN0YXRlVXBkYXRlKSB7XG4gICAgICAgIHRoaXMub25TdHJlYW1TdGF0ZVVwZGF0ZShtc2cudmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobXNnLmNhc2UgPT09ICdzdWJzY3JpYmVkUXVhbGl0eVVwZGF0ZScpIHtcbiAgICAgIGlmICh0aGlzLm9uU3Vic2NyaWJlZFF1YWxpdHlVcGRhdGUpIHtcbiAgICAgICAgdGhpcy5vblN1YnNjcmliZWRRdWFsaXR5VXBkYXRlKG1zZy52YWx1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChtc2cuY2FzZSA9PT0gJ3N1YnNjcmlwdGlvblBlcm1pc3Npb25VcGRhdGUnKSB7XG4gICAgICBpZiAodGhpcy5vblN1YnNjcmlwdGlvblBlcm1pc3Npb25VcGRhdGUpIHtcbiAgICAgICAgdGhpcy5vblN1YnNjcmlwdGlvblBlcm1pc3Npb25VcGRhdGUobXNnLnZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG1zZy5jYXNlID09PSAncmVmcmVzaFRva2VuJykge1xuICAgICAgaWYgKHRoaXMub25Ub2tlblJlZnJlc2gpIHtcbiAgICAgICAgdGhpcy5vblRva2VuUmVmcmVzaChtc2cudmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobXNnLmNhc2UgPT09ICd0cmFja1VucHVibGlzaGVkJykge1xuICAgICAgaWYgKHRoaXMub25Mb2NhbFRyYWNrVW5wdWJsaXNoZWQpIHtcbiAgICAgICAgdGhpcy5vbkxvY2FsVHJhY2tVbnB1Ymxpc2hlZChtc2cudmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobXNnLmNhc2UgPT09ICdzdWJzY3JpcHRpb25SZXNwb25zZScpIHtcbiAgICAgIGlmICh0aGlzLm9uU3Vic2NyaXB0aW9uRXJyb3IpIHtcbiAgICAgICAgdGhpcy5vblN1YnNjcmlwdGlvbkVycm9yKG1zZy52YWx1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChtc2cuY2FzZSA9PT0gJ3BvbmcnKSB7XG4gICAgfSBlbHNlIGlmIChtc2cuY2FzZSA9PT0gJ3BvbmdSZXNwJykge1xuICAgICAgdGhpcy5ydHQgPSBEYXRlLm5vdygpIC0gTnVtYmVyLnBhcnNlSW50KG1zZy52YWx1ZS5sYXN0UGluZ1RpbWVzdGFtcC50b1N0cmluZygpKTtcbiAgICAgIHRoaXMucmVzZXRQaW5nVGltZW91dCgpO1xuICAgICAgcGluZ0hhbmRsZWQgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmxvZy5kZWJ1ZygndW5zdXBwb3J0ZWQgbWVzc2FnZScsIHsgLi4udGhpcy5sb2dDb250ZXh0LCBtc2dDYXNlOiBtc2cuY2FzZSB9KTtcbiAgICB9XG5cbiAgICBpZiAoIXBpbmdIYW5kbGVkKSB7XG4gICAgICB0aGlzLnJlc2V0UGluZ1RpbWVvdXQoKTtcbiAgICB9XG4gIH1cblxuICBzZXRSZWNvbm5lY3RlZCgpIHtcbiAgICB3aGlsZSAodGhpcy5xdWV1ZWRSZXF1ZXN0cy5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCByZXEgPSB0aGlzLnF1ZXVlZFJlcXVlc3RzLnNoaWZ0KCk7XG4gICAgICBpZiAocmVxKSB7XG4gICAgICAgIHRoaXMucmVxdWVzdFF1ZXVlLnJ1bihyZXEpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgaGFuZGxlT25DbG9zZShyZWFzb246IHN0cmluZykge1xuICAgIGlmICh0aGlzLnN0YXRlID09PSBTaWduYWxDb25uZWN0aW9uU3RhdGUuRElTQ09OTkVDVEVEKSByZXR1cm47XG4gICAgY29uc3Qgb25DbG9zZUNhbGxiYWNrID0gdGhpcy5vbkNsb3NlO1xuICAgIGF3YWl0IHRoaXMuY2xvc2UoKTtcbiAgICB0aGlzLmxvZy5kZWJ1Zyhgd2Vic29ja2V0IGNvbm5lY3Rpb24gY2xvc2VkOiAke3JlYXNvbn1gLCB7IC4uLnRoaXMubG9nQ29udGV4dCwgcmVhc29uIH0pO1xuICAgIGlmIChvbkNsb3NlQ2FsbGJhY2spIHtcbiAgICAgIG9uQ2xvc2VDYWxsYmFjayhyZWFzb24pO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgaGFuZGxlV1NFcnJvcihldjogRXZlbnQpIHtcbiAgICB0aGlzLmxvZy5lcnJvcignd2Vic29ja2V0IGVycm9yJywgeyAuLi50aGlzLmxvZ0NvbnRleHQsIGVycm9yOiBldiB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNldHMgdGhlIHBpbmcgdGltZW91dCBhbmQgc3RhcnRzIGEgbmV3IHRpbWVvdXQuXG4gICAqIENhbGwgdGhpcyBhZnRlciByZWNlaXZpbmcgYSBwb25nIG1lc3NhZ2VcbiAgICovXG4gIHByaXZhdGUgcmVzZXRQaW5nVGltZW91dCgpIHtcbiAgICB0aGlzLmNsZWFyUGluZ1RpbWVvdXQoKTtcbiAgICBpZiAoIXRoaXMucGluZ1RpbWVvdXREdXJhdGlvbikge1xuICAgICAgdGhpcy5sb2cud2FybigncGluZyB0aW1lb3V0IGR1cmF0aW9uIG5vdCBzZXQnLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnBpbmdUaW1lb3V0ID0gQ3JpdGljYWxUaW1lcnMuc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLmxvZy53YXJuKFxuICAgICAgICBgcGluZyB0aW1lb3V0IHRyaWdnZXJlZC4gbGFzdCBwb25nIHJlY2VpdmVkIGF0OiAke25ldyBEYXRlKFxuICAgICAgICAgIERhdGUubm93KCkgLSB0aGlzLnBpbmdUaW1lb3V0RHVyYXRpb24hICogMTAwMCxcbiAgICAgICAgKS50b1VUQ1N0cmluZygpfWAsXG4gICAgICAgIHRoaXMubG9nQ29udGV4dCxcbiAgICAgICk7XG4gICAgICB0aGlzLmhhbmRsZU9uQ2xvc2UoJ3BpbmcgdGltZW91dCcpO1xuICAgIH0sIHRoaXMucGluZ1RpbWVvdXREdXJhdGlvbiAqIDEwMDApO1xuICB9XG5cbiAgLyoqXG4gICAqIENsZWFycyBwaW5nIHRpbWVvdXQgKGRvZXMgbm90IHN0YXJ0IGEgbmV3IHRpbWVvdXQpXG4gICAqL1xuICBwcml2YXRlIGNsZWFyUGluZ1RpbWVvdXQoKSB7XG4gICAgaWYgKHRoaXMucGluZ1RpbWVvdXQpIHtcbiAgICAgIENyaXRpY2FsVGltZXJzLmNsZWFyVGltZW91dCh0aGlzLnBpbmdUaW1lb3V0KTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHN0YXJ0UGluZ0ludGVydmFsKCkge1xuICAgIHRoaXMuY2xlYXJQaW5nSW50ZXJ2YWwoKTtcbiAgICB0aGlzLnJlc2V0UGluZ1RpbWVvdXQoKTtcbiAgICBpZiAoIXRoaXMucGluZ0ludGVydmFsRHVyYXRpb24pIHtcbiAgICAgIHRoaXMubG9nLndhcm4oJ3BpbmcgaW50ZXJ2YWwgZHVyYXRpb24gbm90IHNldCcsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMubG9nLmRlYnVnKCdzdGFydCBwaW5nIGludGVydmFsJywgdGhpcy5sb2dDb250ZXh0KTtcbiAgICB0aGlzLnBpbmdJbnRlcnZhbCA9IENyaXRpY2FsVGltZXJzLnNldEludGVydmFsKCgpID0+IHtcbiAgICAgIHRoaXMuc2VuZFBpbmcoKTtcbiAgICB9LCB0aGlzLnBpbmdJbnRlcnZhbER1cmF0aW9uICogMTAwMCk7XG4gIH1cblxuICBwcml2YXRlIGNsZWFyUGluZ0ludGVydmFsKCkge1xuICAgIHRoaXMubG9nLmRlYnVnKCdjbGVhcmluZyBwaW5nIGludGVydmFsJywgdGhpcy5sb2dDb250ZXh0KTtcbiAgICB0aGlzLmNsZWFyUGluZ1RpbWVvdXQoKTtcbiAgICBpZiAodGhpcy5waW5nSW50ZXJ2YWwpIHtcbiAgICAgIENyaXRpY2FsVGltZXJzLmNsZWFySW50ZXJ2YWwodGhpcy5waW5nSW50ZXJ2YWwpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBmcm9tUHJvdG9TZXNzaW9uRGVzY3JpcHRpb24oc2Q6IFNlc3Npb25EZXNjcmlwdGlvbik6IFJUQ1Nlc3Npb25EZXNjcmlwdGlvbkluaXQge1xuICBjb25zdCByc2Q6IFJUQ1Nlc3Npb25EZXNjcmlwdGlvbkluaXQgPSB7XG4gICAgdHlwZTogJ29mZmVyJyxcbiAgICBzZHA6IHNkLnNkcCxcbiAgfTtcbiAgc3dpdGNoIChzZC50eXBlKSB7XG4gICAgY2FzZSAnYW5zd2VyJzpcbiAgICBjYXNlICdvZmZlcic6XG4gICAgY2FzZSAncHJhbnN3ZXInOlxuICAgIGNhc2UgJ3JvbGxiYWNrJzpcbiAgICAgIHJzZC50eXBlID0gc2QudHlwZTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBicmVhaztcbiAgfVxuICByZXR1cm4gcnNkO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdG9Qcm90b1Nlc3Npb25EZXNjcmlwdGlvbihcbiAgcnNkOiBSVENTZXNzaW9uRGVzY3JpcHRpb24gfCBSVENTZXNzaW9uRGVzY3JpcHRpb25Jbml0LFxuKTogU2Vzc2lvbkRlc2NyaXB0aW9uIHtcbiAgY29uc3Qgc2QgPSBuZXcgU2Vzc2lvbkRlc2NyaXB0aW9uKHtcbiAgICBzZHA6IHJzZC5zZHAhLFxuICAgIHR5cGU6IHJzZC50eXBlISxcbiAgfSk7XG4gIHJldHVybiBzZDtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ29ubmVjdGlvblBhcmFtcyh0b2tlbjogc3RyaW5nLCBpbmZvOiBDbGllbnRJbmZvLCBvcHRzOiBDb25uZWN0T3B0cyk6IHN0cmluZyB7XG4gIGNvbnN0IHBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKTtcbiAgcGFyYW1zLnNldCgnYWNjZXNzX3Rva2VuJywgdG9rZW4pO1xuXG4gIC8vIG9wdHNcbiAgaWYgKG9wdHMucmVjb25uZWN0KSB7XG4gICAgcGFyYW1zLnNldCgncmVjb25uZWN0JywgJzEnKTtcbiAgICBpZiAob3B0cy5zaWQpIHtcbiAgICAgIHBhcmFtcy5zZXQoJ3NpZCcsIG9wdHMuc2lkKTtcbiAgICB9XG4gIH1cblxuICBwYXJhbXMuc2V0KCdhdXRvX3N1YnNjcmliZScsIG9wdHMuYXV0b1N1YnNjcmliZSA/ICcxJyA6ICcwJyk7XG5cbiAgLy8gQ2xpZW50SW5mb1xuICBwYXJhbXMuc2V0KCdzZGsnLCBpc1JlYWN0TmF0aXZlKCkgPyAncmVhY3RuYXRpdmUnIDogJ2pzJyk7XG4gIHBhcmFtcy5zZXQoJ3ZlcnNpb24nLCBpbmZvLnZlcnNpb24hKTtcbiAgcGFyYW1zLnNldCgncHJvdG9jb2wnLCBpbmZvLnByb3RvY29sIS50b1N0cmluZygpKTtcbiAgaWYgKGluZm8uZGV2aWNlTW9kZWwpIHtcbiAgICBwYXJhbXMuc2V0KCdkZXZpY2VfbW9kZWwnLCBpbmZvLmRldmljZU1vZGVsKTtcbiAgfVxuICBpZiAoaW5mby5vcykge1xuICAgIHBhcmFtcy5zZXQoJ29zJywgaW5mby5vcyk7XG4gIH1cbiAgaWYgKGluZm8ub3NWZXJzaW9uKSB7XG4gICAgcGFyYW1zLnNldCgnb3NfdmVyc2lvbicsIGluZm8ub3NWZXJzaW9uKTtcbiAgfVxuICBpZiAoaW5mby5icm93c2VyKSB7XG4gICAgcGFyYW1zLnNldCgnYnJvd3NlcicsIGluZm8uYnJvd3Nlcik7XG4gIH1cbiAgaWYgKGluZm8uYnJvd3NlclZlcnNpb24pIHtcbiAgICBwYXJhbXMuc2V0KCdicm93c2VyX3ZlcnNpb24nLCBpbmZvLmJyb3dzZXJWZXJzaW9uKTtcbiAgfVxuXG4gIGlmIChvcHRzLnB1Ymxpc2hPbmx5ICE9PSB1bmRlZmluZWQpIHtcbiAgICBwYXJhbXMuc2V0KCdwdWJsaXNoJywgb3B0cy5wdWJsaXNoT25seSk7XG4gIH1cblxuICBpZiAob3B0cy5hZGFwdGl2ZVN0cmVhbSkge1xuICAgIHBhcmFtcy5zZXQoJ2FkYXB0aXZlX3N0cmVhbScsICcxJyk7XG4gIH1cblxuICBpZiAob3B0cy5yZWNvbm5lY3RSZWFzb24pIHtcbiAgICBwYXJhbXMuc2V0KCdyZWNvbm5lY3RfcmVhc29uJywgb3B0cy5yZWNvbm5lY3RSZWFzb24udG9TdHJpbmcoKSk7XG4gIH1cblxuICAvLyBAdHMtaWdub3JlXG4gIGlmIChuYXZpZ2F0b3IuY29ubmVjdGlvbj8udHlwZSkge1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBwYXJhbXMuc2V0KCduZXR3b3JrJywgbmF2aWdhdG9yLmNvbm5lY3Rpb24udHlwZSk7XG4gIH1cblxuICByZXR1cm4gYD8ke3BhcmFtcy50b1N0cmluZygpfWA7XG59XG4iLCJ2YXIgZ3JhbW1hciA9IG1vZHVsZS5leHBvcnRzID0ge1xuICB2OiBbe1xuICAgIG5hbWU6ICd2ZXJzaW9uJyxcbiAgICByZWc6IC9eKFxcZCopJC9cbiAgfV0sXG4gIG86IFt7XG4gICAgLy8gbz0tIDIwNTE4IDAgSU4gSVA0IDIwMy4wLjExMy4xXG4gICAgLy8gTkI6IHNlc3Npb25JZCB3aWxsIGJlIGEgU3RyaW5nIGluIG1vc3QgY2FzZXMgYmVjYXVzZSBpdCBpcyBodWdlXG4gICAgbmFtZTogJ29yaWdpbicsXG4gICAgcmVnOiAvXihcXFMqKSAoXFxkKikgKFxcZCopIChcXFMqKSBJUChcXGQpIChcXFMqKS8sXG4gICAgbmFtZXM6IFsndXNlcm5hbWUnLCAnc2Vzc2lvbklkJywgJ3Nlc3Npb25WZXJzaW9uJywgJ25ldFR5cGUnLCAnaXBWZXInLCAnYWRkcmVzcyddLFxuICAgIGZvcm1hdDogJyVzICVzICVkICVzIElQJWQgJXMnXG4gIH1dLFxuICAvLyBkZWZhdWx0IHBhcnNpbmcgb2YgdGhlc2Ugb25seSAodGhvdWdoIHNvbWUgb2YgdGhlc2UgZmVlbCBvdXRkYXRlZClcbiAgczogW3sgbmFtZTogJ25hbWUnIH1dLFxuICBpOiBbeyBuYW1lOiAnZGVzY3JpcHRpb24nIH1dLFxuICB1OiBbeyBuYW1lOiAndXJpJyB9XSxcbiAgZTogW3sgbmFtZTogJ2VtYWlsJyB9XSxcbiAgcDogW3sgbmFtZTogJ3Bob25lJyB9XSxcbiAgejogW3sgbmFtZTogJ3RpbWV6b25lcycgfV0sIC8vIFRPRE86IHRoaXMgb25lIGNhbiBhY3R1YWxseSBiZSBwYXJzZWQgcHJvcGVybHkuLi5cbiAgcjogW3sgbmFtZTogJ3JlcGVhdHMnIH1dLCAgIC8vIFRPRE86IHRoaXMgb25lIGNhbiBhbHNvIGJlIHBhcnNlZCBwcm9wZXJseVxuICAvLyBrOiBbe31dLCAvLyBvdXRkYXRlZCB0aGluZyBpZ25vcmVkXG4gIHQ6IFt7XG4gICAgLy8gdD0wIDBcbiAgICBuYW1lOiAndGltaW5nJyxcbiAgICByZWc6IC9eKFxcZCopIChcXGQqKS8sXG4gICAgbmFtZXM6IFsnc3RhcnQnLCAnc3RvcCddLFxuICAgIGZvcm1hdDogJyVkICVkJ1xuICB9XSxcbiAgYzogW3tcbiAgICAvLyBjPUlOIElQNCAxMC40Ny4xOTcuMjZcbiAgICBuYW1lOiAnY29ubmVjdGlvbicsXG4gICAgcmVnOiAvXklOIElQKFxcZCkgKFxcUyopLyxcbiAgICBuYW1lczogWyd2ZXJzaW9uJywgJ2lwJ10sXG4gICAgZm9ybWF0OiAnSU4gSVAlZCAlcydcbiAgfV0sXG4gIGI6IFt7XG4gICAgLy8gYj1BUzo0MDAwXG4gICAgcHVzaDogJ2JhbmR3aWR0aCcsXG4gICAgcmVnOiAvXihUSUFTfEFTfENUfFJSfFJTKTooXFxkKikvLFxuICAgIG5hbWVzOiBbJ3R5cGUnLCAnbGltaXQnXSxcbiAgICBmb3JtYXQ6ICclczolcydcbiAgfV0sXG4gIG06IFt7XG4gICAgLy8gbT12aWRlbyA1MTc0NCBSVFAvQVZQIDEyNiA5NyA5OCAzNCAzMVxuICAgIC8vIE5COiBzcGVjaWFsIC0gcHVzaGVzIHRvIHNlc3Npb25cbiAgICAvLyBUT0RPOiBydHAvZm10cCBzaG91bGQgYmUgZmlsdGVyZWQgYnkgdGhlIHBheWxvYWRzIGZvdW5kIGhlcmU/XG4gICAgcmVnOiAvXihcXHcqKSAoXFxkKikgKFtcXHcvXSopKD86ICguKikpPy8sXG4gICAgbmFtZXM6IFsndHlwZScsICdwb3J0JywgJ3Byb3RvY29sJywgJ3BheWxvYWRzJ10sXG4gICAgZm9ybWF0OiAnJXMgJWQgJXMgJXMnXG4gIH1dLFxuICBhOiBbXG4gICAge1xuICAgICAgLy8gYT1ydHBtYXA6MTEwIG9wdXMvNDgwMDAvMlxuICAgICAgcHVzaDogJ3J0cCcsXG4gICAgICByZWc6IC9ecnRwbWFwOihcXGQqKSAoW1xcd1xcLS5dKikoPzpcXHMqXFwvKFxcZCopKD86XFxzKlxcLyhcXFMqKSk/KT8vLFxuICAgICAgbmFtZXM6IFsncGF5bG9hZCcsICdjb2RlYycsICdyYXRlJywgJ2VuY29kaW5nJ10sXG4gICAgICBmb3JtYXQ6IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgIHJldHVybiAoby5lbmNvZGluZylcbiAgICAgICAgICA/ICdydHBtYXA6JWQgJXMvJXMvJXMnXG4gICAgICAgICAgOiBvLnJhdGVcbiAgICAgICAgICAgID8gJ3J0cG1hcDolZCAlcy8lcydcbiAgICAgICAgICAgIDogJ3J0cG1hcDolZCAlcyc7XG4gICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICAvLyBhPWZtdHA6MTA4IHByb2ZpbGUtbGV2ZWwtaWQ9MjQ7b2JqZWN0PTIzO2JpdHJhdGU9NjQwMDBcbiAgICAgIC8vIGE9Zm10cDoxMTEgbWlucHRpbWU9MTA7IHVzZWluYmFuZGZlYz0xXG4gICAgICBwdXNoOiAnZm10cCcsXG4gICAgICByZWc6IC9eZm10cDooXFxkKikgKFtcXFN8IF0qKS8sXG4gICAgICBuYW1lczogWydwYXlsb2FkJywgJ2NvbmZpZyddLFxuICAgICAgZm9ybWF0OiAnZm10cDolZCAlcydcbiAgICB9LFxuICAgIHtcbiAgICAgIC8vIGE9Y29udHJvbDpzdHJlYW1pZD0wXG4gICAgICBuYW1lOiAnY29udHJvbCcsXG4gICAgICByZWc6IC9eY29udHJvbDooLiopLyxcbiAgICAgIGZvcm1hdDogJ2NvbnRyb2w6JXMnXG4gICAgfSxcbiAgICB7XG4gICAgICAvLyBhPXJ0Y3A6NjUxNzkgSU4gSVA0IDE5My44NC43Ny4xOTRcbiAgICAgIG5hbWU6ICdydGNwJyxcbiAgICAgIHJlZzogL15ydGNwOihcXGQqKSg/OiAoXFxTKikgSVAoXFxkKSAoXFxTKikpPy8sXG4gICAgICBuYW1lczogWydwb3J0JywgJ25ldFR5cGUnLCAnaXBWZXInLCAnYWRkcmVzcyddLFxuICAgICAgZm9ybWF0OiBmdW5jdGlvbiAobykge1xuICAgICAgICByZXR1cm4gKG8uYWRkcmVzcyAhPSBudWxsKVxuICAgICAgICAgID8gJ3J0Y3A6JWQgJXMgSVAlZCAlcydcbiAgICAgICAgICA6ICdydGNwOiVkJztcbiAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgIC8vIGE9cnRjcC1mYjo5OCB0cnItaW50IDEwMFxuICAgICAgcHVzaDogJ3J0Y3BGYlRyckludCcsXG4gICAgICByZWc6IC9ecnRjcC1mYjooXFwqfFxcZCopIHRyci1pbnQgKFxcZCopLyxcbiAgICAgIG5hbWVzOiBbJ3BheWxvYWQnLCAndmFsdWUnXSxcbiAgICAgIGZvcm1hdDogJ3J0Y3AtZmI6JXMgdHJyLWludCAlZCdcbiAgICB9LFxuICAgIHtcbiAgICAgIC8vIGE9cnRjcC1mYjo5OCBuYWNrIHJwc2lcbiAgICAgIHB1c2g6ICdydGNwRmInLFxuICAgICAgcmVnOiAvXnJ0Y3AtZmI6KFxcKnxcXGQqKSAoW1xcdy1fXSopKD86IChbXFx3LV9dKikpPy8sXG4gICAgICBuYW1lczogWydwYXlsb2FkJywgJ3R5cGUnLCAnc3VidHlwZSddLFxuICAgICAgZm9ybWF0OiBmdW5jdGlvbiAobykge1xuICAgICAgICByZXR1cm4gKG8uc3VidHlwZSAhPSBudWxsKVxuICAgICAgICAgID8gJ3J0Y3AtZmI6JXMgJXMgJXMnXG4gICAgICAgICAgOiAncnRjcC1mYjolcyAlcyc7XG4gICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICAvLyBhPWV4dG1hcDoyIHVybjppZXRmOnBhcmFtczpydHAtaGRyZXh0OnRvZmZzZXRcbiAgICAgIC8vIGE9ZXh0bWFwOjEvcmVjdm9ubHkgVVJJLWdwcy1zdHJpbmdcbiAgICAgIC8vIGE9ZXh0bWFwOjMgdXJuOmlldGY6cGFyYW1zOnJ0cC1oZHJleHQ6ZW5jcnlwdCB1cm46aWV0ZjpwYXJhbXM6cnRwLWhkcmV4dDpzbXB0ZS10YyAyNUA2MDAvMjRcbiAgICAgIHB1c2g6ICdleHQnLFxuICAgICAgcmVnOiAvXmV4dG1hcDooXFxkKykoPzpcXC8oXFx3KykpPyg/OiAodXJuOmlldGY6cGFyYW1zOnJ0cC1oZHJleHQ6ZW5jcnlwdCkpPyAoXFxTKikoPzogKFxcUyopKT8vLFxuICAgICAgbmFtZXM6IFsndmFsdWUnLCAnZGlyZWN0aW9uJywgJ2VuY3J5cHQtdXJpJywgJ3VyaScsICdjb25maWcnXSxcbiAgICAgIGZvcm1hdDogZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAnZXh0bWFwOiVkJyArXG4gICAgICAgICAgKG8uZGlyZWN0aW9uID8gJy8lcycgOiAnJXYnKSArXG4gICAgICAgICAgKG9bJ2VuY3J5cHQtdXJpJ10gPyAnICVzJyA6ICcldicpICtcbiAgICAgICAgICAnICVzJyArXG4gICAgICAgICAgKG8uY29uZmlnID8gJyAlcycgOiAnJylcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgIC8vIGE9ZXh0bWFwLWFsbG93LW1peGVkXG4gICAgICBuYW1lOiAnZXh0bWFwQWxsb3dNaXhlZCcsXG4gICAgICByZWc6IC9eKGV4dG1hcC1hbGxvdy1taXhlZCkvXG4gICAgfSxcbiAgICB7XG4gICAgICAvLyBhPWNyeXB0bzoxIEFFU19DTV8xMjhfSE1BQ19TSEExXzgwIGlubGluZTpQUzF1UUNWZWVDRkNhblZtY2prcFB5d2pOV2hjWUQwbVhYdHhhVkJSfDJeMjB8MTozMlxuICAgICAgcHVzaDogJ2NyeXB0bycsXG4gICAgICByZWc6IC9eY3J5cHRvOihcXGQqKSAoW1xcd19dKikgKFxcUyopKD86IChcXFMqKSk/LyxcbiAgICAgIG5hbWVzOiBbJ2lkJywgJ3N1aXRlJywgJ2NvbmZpZycsICdzZXNzaW9uQ29uZmlnJ10sXG4gICAgICBmb3JtYXQ6IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgIHJldHVybiAoby5zZXNzaW9uQ29uZmlnICE9IG51bGwpXG4gICAgICAgICAgPyAnY3J5cHRvOiVkICVzICVzICVzJ1xuICAgICAgICAgIDogJ2NyeXB0bzolZCAlcyAlcyc7XG4gICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICAvLyBhPXNldHVwOmFjdHBhc3NcbiAgICAgIG5hbWU6ICdzZXR1cCcsXG4gICAgICByZWc6IC9ec2V0dXA6KFxcdyopLyxcbiAgICAgIGZvcm1hdDogJ3NldHVwOiVzJ1xuICAgIH0sXG4gICAge1xuICAgICAgLy8gYT1jb25uZWN0aW9uOm5ld1xuICAgICAgbmFtZTogJ2Nvbm5lY3Rpb25UeXBlJyxcbiAgICAgIHJlZzogL15jb25uZWN0aW9uOihuZXd8ZXhpc3RpbmcpLyxcbiAgICAgIGZvcm1hdDogJ2Nvbm5lY3Rpb246JXMnXG4gICAgfSxcbiAgICB7XG4gICAgICAvLyBhPW1pZDoxXG4gICAgICBuYW1lOiAnbWlkJyxcbiAgICAgIHJlZzogL15taWQ6KFteXFxzXSopLyxcbiAgICAgIGZvcm1hdDogJ21pZDolcydcbiAgICB9LFxuICAgIHtcbiAgICAgIC8vIGE9bXNpZDowYzhiMDY0ZC1kODA3LTQzYjQtYjQzNC1mOTJhODg5ZDg1ODcgOTgxNzg2ODUtZDQwOS00NmUwLThlMTYtN2VmMGRiMGRiNjRhXG4gICAgICBuYW1lOiAnbXNpZCcsXG4gICAgICByZWc6IC9ebXNpZDooLiopLyxcbiAgICAgIGZvcm1hdDogJ21zaWQ6JXMnXG4gICAgfSxcbiAgICB7XG4gICAgICAvLyBhPXB0aW1lOjIwXG4gICAgICBuYW1lOiAncHRpbWUnLFxuICAgICAgcmVnOiAvXnB0aW1lOihcXGQqKD86XFwuXFxkKikqKS8sXG4gICAgICBmb3JtYXQ6ICdwdGltZTolZCdcbiAgICB9LFxuICAgIHtcbiAgICAgIC8vIGE9bWF4cHRpbWU6NjBcbiAgICAgIG5hbWU6ICdtYXhwdGltZScsXG4gICAgICByZWc6IC9ebWF4cHRpbWU6KFxcZCooPzpcXC5cXGQqKSopLyxcbiAgICAgIGZvcm1hdDogJ21heHB0aW1lOiVkJ1xuICAgIH0sXG4gICAge1xuICAgICAgLy8gYT1zZW5kcmVjdlxuICAgICAgbmFtZTogJ2RpcmVjdGlvbicsXG4gICAgICByZWc6IC9eKHNlbmRyZWN2fHJlY3Zvbmx5fHNlbmRvbmx5fGluYWN0aXZlKS9cbiAgICB9LFxuICAgIHtcbiAgICAgIC8vIGE9aWNlLWxpdGVcbiAgICAgIG5hbWU6ICdpY2VsaXRlJyxcbiAgICAgIHJlZzogL14oaWNlLWxpdGUpL1xuICAgIH0sXG4gICAge1xuICAgICAgLy8gYT1pY2UtdWZyYWc6RjdnSVxuICAgICAgbmFtZTogJ2ljZVVmcmFnJyxcbiAgICAgIHJlZzogL15pY2UtdWZyYWc6KFxcUyopLyxcbiAgICAgIGZvcm1hdDogJ2ljZS11ZnJhZzolcydcbiAgICB9LFxuICAgIHtcbiAgICAgIC8vIGE9aWNlLXB3ZDp4OWNtbC9ZemljaFYyK1hsaGlNdThnXG4gICAgICBuYW1lOiAnaWNlUHdkJyxcbiAgICAgIHJlZzogL15pY2UtcHdkOihcXFMqKS8sXG4gICAgICBmb3JtYXQ6ICdpY2UtcHdkOiVzJ1xuICAgIH0sXG4gICAge1xuICAgICAgLy8gYT1maW5nZXJwcmludDpTSEEtMSAwMDoxMToyMjozMzo0NDo1NTo2Njo3Nzo4ODo5OTpBQTpCQjpDQzpERDpFRTpGRjowMDoxMToyMjozM1xuICAgICAgbmFtZTogJ2ZpbmdlcnByaW50JyxcbiAgICAgIHJlZzogL15maW5nZXJwcmludDooXFxTKikgKFxcUyopLyxcbiAgICAgIG5hbWVzOiBbJ3R5cGUnLCAnaGFzaCddLFxuICAgICAgZm9ybWF0OiAnZmluZ2VycHJpbnQ6JXMgJXMnXG4gICAgfSxcbiAgICB7XG4gICAgICAvLyBhPWNhbmRpZGF0ZTowIDEgVURQIDIxMTM2NjczMjcgMjAzLjAuMTEzLjEgNTQ0MDAgdHlwIGhvc3RcbiAgICAgIC8vIGE9Y2FuZGlkYXRlOjExNjI4NzUwODEgMSB1ZHAgMjExMzkzNzE1MSAxOTIuMTY4LjM0Ljc1IDYwMDE3IHR5cCBob3N0IGdlbmVyYXRpb24gMCBuZXR3b3JrLWlkIDMgbmV0d29yay1jb3N0IDEwXG4gICAgICAvLyBhPWNhbmRpZGF0ZTozMjg5OTEyOTU3IDIgdWRwIDE4NDU1MDE2OTUgMTkzLjg0Ljc3LjE5NCA2MDAxNyB0eXAgc3JmbHggcmFkZHIgMTkyLjE2OC4zNC43NSBycG9ydCA2MDAxNyBnZW5lcmF0aW9uIDAgbmV0d29yay1pZCAzIG5ldHdvcmstY29zdCAxMFxuICAgICAgLy8gYT1jYW5kaWRhdGU6MjI5ODE1NjIwIDEgdGNwIDE1MTgyODA0NDcgMTkyLjE2OC4xNTAuMTkgNjAwMTcgdHlwIGhvc3QgdGNwdHlwZSBhY3RpdmUgZ2VuZXJhdGlvbiAwIG5ldHdvcmstaWQgMyBuZXR3b3JrLWNvc3QgMTBcbiAgICAgIC8vIGE9Y2FuZGlkYXRlOjMyODk5MTI5NTcgMiB0Y3AgMTg0NTUwMTY5NSAxOTMuODQuNzcuMTk0IDYwMDE3IHR5cCBzcmZseCByYWRkciAxOTIuMTY4LjM0Ljc1IHJwb3J0IDYwMDE3IHRjcHR5cGUgcGFzc2l2ZSBnZW5lcmF0aW9uIDAgbmV0d29yay1pZCAzIG5ldHdvcmstY29zdCAxMFxuICAgICAgcHVzaDonY2FuZGlkYXRlcycsXG4gICAgICByZWc6IC9eY2FuZGlkYXRlOihcXFMqKSAoXFxkKikgKFxcUyopIChcXGQqKSAoXFxTKikgKFxcZCopIHR5cCAoXFxTKikoPzogcmFkZHIgKFxcUyopIHJwb3J0IChcXGQqKSk/KD86IHRjcHR5cGUgKFxcUyopKT8oPzogZ2VuZXJhdGlvbiAoXFxkKikpPyg/OiBuZXR3b3JrLWlkIChcXGQqKSk/KD86IG5ldHdvcmstY29zdCAoXFxkKikpPy8sXG4gICAgICBuYW1lczogWydmb3VuZGF0aW9uJywgJ2NvbXBvbmVudCcsICd0cmFuc3BvcnQnLCAncHJpb3JpdHknLCAnaXAnLCAncG9ydCcsICd0eXBlJywgJ3JhZGRyJywgJ3Jwb3J0JywgJ3RjcHR5cGUnLCAnZ2VuZXJhdGlvbicsICduZXR3b3JrLWlkJywgJ25ldHdvcmstY29zdCddLFxuICAgICAgZm9ybWF0OiBmdW5jdGlvbiAobykge1xuICAgICAgICB2YXIgc3RyID0gJ2NhbmRpZGF0ZTolcyAlZCAlcyAlZCAlcyAlZCB0eXAgJXMnO1xuXG4gICAgICAgIHN0ciArPSAoby5yYWRkciAhPSBudWxsKSA/ICcgcmFkZHIgJXMgcnBvcnQgJWQnIDogJyV2JXYnO1xuXG4gICAgICAgIC8vIE5COiBjYW5kaWRhdGUgaGFzIHRocmVlIG9wdGlvbmFsIGNodW5rcywgc28gJXZvaWQgbWlkZGxlcyBvbmUgaWYgaXQncyBtaXNzaW5nXG4gICAgICAgIHN0ciArPSAoby50Y3B0eXBlICE9IG51bGwpID8gJyB0Y3B0eXBlICVzJyA6ICcldic7XG5cbiAgICAgICAgaWYgKG8uZ2VuZXJhdGlvbiAhPSBudWxsKSB7XG4gICAgICAgICAgc3RyICs9ICcgZ2VuZXJhdGlvbiAlZCc7XG4gICAgICAgIH1cblxuICAgICAgICBzdHIgKz0gKG9bJ25ldHdvcmstaWQnXSAhPSBudWxsKSA/ICcgbmV0d29yay1pZCAlZCcgOiAnJXYnO1xuICAgICAgICBzdHIgKz0gKG9bJ25ldHdvcmstY29zdCddICE9IG51bGwpID8gJyBuZXR3b3JrLWNvc3QgJWQnIDogJyV2JztcbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgIC8vIGE9ZW5kLW9mLWNhbmRpZGF0ZXMgKGtlZXAgYWZ0ZXIgdGhlIGNhbmRpZGF0ZXMgbGluZSBmb3IgcmVhZGFiaWxpdHkpXG4gICAgICBuYW1lOiAnZW5kT2ZDYW5kaWRhdGVzJyxcbiAgICAgIHJlZzogL14oZW5kLW9mLWNhbmRpZGF0ZXMpL1xuICAgIH0sXG4gICAge1xuICAgICAgLy8gYT1yZW1vdGUtY2FuZGlkYXRlczoxIDIwMy4wLjExMy4xIDU0NDAwIDIgMjAzLjAuMTEzLjEgNTQ0MDEgLi4uXG4gICAgICBuYW1lOiAncmVtb3RlQ2FuZGlkYXRlcycsXG4gICAgICByZWc6IC9ecmVtb3RlLWNhbmRpZGF0ZXM6KC4qKS8sXG4gICAgICBmb3JtYXQ6ICdyZW1vdGUtY2FuZGlkYXRlczolcydcbiAgICB9LFxuICAgIHtcbiAgICAgIC8vIGE9aWNlLW9wdGlvbnM6Z29vZ2xlLWljZVxuICAgICAgbmFtZTogJ2ljZU9wdGlvbnMnLFxuICAgICAgcmVnOiAvXmljZS1vcHRpb25zOihcXFMqKS8sXG4gICAgICBmb3JtYXQ6ICdpY2Utb3B0aW9uczolcydcbiAgICB9LFxuICAgIHtcbiAgICAgIC8vIGE9c3NyYzoyNTY2MTA3NTY5IGNuYW1lOnQ5WVU4TTFVeFRGOFkxQTFcbiAgICAgIHB1c2g6ICdzc3JjcycsXG4gICAgICByZWc6IC9ec3NyYzooXFxkKikgKFtcXHdfLV0qKSg/OjooLiopKT8vLFxuICAgICAgbmFtZXM6IFsnaWQnLCAnYXR0cmlidXRlJywgJ3ZhbHVlJ10sXG4gICAgICBmb3JtYXQ6IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgIHZhciBzdHIgPSAnc3NyYzolZCc7XG4gICAgICAgIGlmIChvLmF0dHJpYnV0ZSAhPSBudWxsKSB7XG4gICAgICAgICAgc3RyICs9ICcgJXMnO1xuICAgICAgICAgIGlmIChvLnZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHN0ciArPSAnOiVzJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgIC8vIGE9c3NyYy1ncm91cDpGRUMgMSAyXG4gICAgICAvLyBhPXNzcmMtZ3JvdXA6RkVDLUZSIDMwMDQzNjQxOTUgMTA4MDc3MjI0MVxuICAgICAgcHVzaDogJ3NzcmNHcm91cHMnLFxuICAgICAgLy8gdG9rZW4tY2hhciA9ICV4MjEgLyAleDIzLTI3IC8gJXgyQS0yQiAvICV4MkQtMkUgLyAleDMwLTM5IC8gJXg0MS01QSAvICV4NUUtN0VcbiAgICAgIHJlZzogL15zc3JjLWdyb3VwOihbXFx4MjFcXHgyM1xceDI0XFx4MjVcXHgyNlxceDI3XFx4MkFcXHgyQlxceDJEXFx4MkVcXHddKikgKC4qKS8sXG4gICAgICBuYW1lczogWydzZW1hbnRpY3MnLCAnc3NyY3MnXSxcbiAgICAgIGZvcm1hdDogJ3NzcmMtZ3JvdXA6JXMgJXMnXG4gICAgfSxcbiAgICB7XG4gICAgICAvLyBhPW1zaWQtc2VtYW50aWM6IFdNUyBKdmxhbTVYM1NYMU9QNnBuMjB6V29ndmFLSno1SGpmOU9ubFZcbiAgICAgIG5hbWU6ICdtc2lkU2VtYW50aWMnLFxuICAgICAgcmVnOiAvXm1zaWQtc2VtYW50aWM6XFxzPyhcXHcqKSAoXFxTKikvLFxuICAgICAgbmFtZXM6IFsnc2VtYW50aWMnLCAndG9rZW4nXSxcbiAgICAgIGZvcm1hdDogJ21zaWQtc2VtYW50aWM6ICVzICVzJyAvLyBzcGFjZSBhZnRlciAnOicgaXMgbm90IGFjY2lkZW50YWxcbiAgICB9LFxuICAgIHtcbiAgICAgIC8vIGE9Z3JvdXA6QlVORExFIGF1ZGlvIHZpZGVvXG4gICAgICBwdXNoOiAnZ3JvdXBzJyxcbiAgICAgIHJlZzogL15ncm91cDooXFx3KikgKC4qKS8sXG4gICAgICBuYW1lczogWyd0eXBlJywgJ21pZHMnXSxcbiAgICAgIGZvcm1hdDogJ2dyb3VwOiVzICVzJ1xuICAgIH0sXG4gICAge1xuICAgICAgLy8gYT1ydGNwLW11eFxuICAgICAgbmFtZTogJ3J0Y3BNdXgnLFxuICAgICAgcmVnOiAvXihydGNwLW11eCkvXG4gICAgfSxcbiAgICB7XG4gICAgICAvLyBhPXJ0Y3AtcnNpemVcbiAgICAgIG5hbWU6ICdydGNwUnNpemUnLFxuICAgICAgcmVnOiAvXihydGNwLXJzaXplKS9cbiAgICB9LFxuICAgIHtcbiAgICAgIC8vIGE9c2N0cG1hcDo1MDAwIHdlYnJ0Yy1kYXRhY2hhbm5lbCAxMDI0XG4gICAgICBuYW1lOiAnc2N0cG1hcCcsXG4gICAgICByZWc6IC9ec2N0cG1hcDooW1xcd18vXSopIChcXFMqKSg/OiAoXFxTKikpPy8sXG4gICAgICBuYW1lczogWydzY3RwbWFwTnVtYmVyJywgJ2FwcCcsICdtYXhNZXNzYWdlU2l6ZSddLFxuICAgICAgZm9ybWF0OiBmdW5jdGlvbiAobykge1xuICAgICAgICByZXR1cm4gKG8ubWF4TWVzc2FnZVNpemUgIT0gbnVsbClcbiAgICAgICAgICA/ICdzY3RwbWFwOiVzICVzICVzJ1xuICAgICAgICAgIDogJ3NjdHBtYXA6JXMgJXMnO1xuICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgLy8gYT14LWdvb2dsZS1mbGFnOmNvbmZlcmVuY2VcbiAgICAgIG5hbWU6ICd4R29vZ2xlRmxhZycsXG4gICAgICByZWc6IC9eeC1nb29nbGUtZmxhZzooW15cXHNdKikvLFxuICAgICAgZm9ybWF0OiAneC1nb29nbGUtZmxhZzolcydcbiAgICB9LFxuICAgIHtcbiAgICAgIC8vIGE9cmlkOjEgc2VuZCBtYXgtd2lkdGg9MTI4MDttYXgtaGVpZ2h0PTcyMDttYXgtZnBzPTMwO2RlcGVuZD0wXG4gICAgICBwdXNoOiAncmlkcycsXG4gICAgICByZWc6IC9ecmlkOihbXFxkXFx3XSspIChcXHcrKSg/OiAoW1xcU3wgXSopKT8vLFxuICAgICAgbmFtZXM6IFsnaWQnLCAnZGlyZWN0aW9uJywgJ3BhcmFtcyddLFxuICAgICAgZm9ybWF0OiBmdW5jdGlvbiAobykge1xuICAgICAgICByZXR1cm4gKG8ucGFyYW1zKSA/ICdyaWQ6JXMgJXMgJXMnIDogJ3JpZDolcyAlcyc7XG4gICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICAvLyBhPWltYWdlYXR0cjo5NyBzZW5kIFt4PTgwMCx5PTY0MCxzYXI9MS4xLHE9MC42XSBbeD00ODAseT0zMjBdIHJlY3YgW3g9MzMwLHk9MjUwXVxuICAgICAgLy8gYT1pbWFnZWF0dHI6KiBzZW5kIFt4PTgwMCx5PTY0MF0gcmVjdiAqXG4gICAgICAvLyBhPWltYWdlYXR0cjoxMDAgcmVjdiBbeD0zMjAseT0yNDBdXG4gICAgICBwdXNoOiAnaW1hZ2VhdHRycycsXG4gICAgICByZWc6IG5ldyBSZWdFeHAoXG4gICAgICAgIC8vIGE9aW1hZ2VhdHRyOjk3XG4gICAgICAgICdeaW1hZ2VhdHRyOihcXFxcZCt8XFxcXCopJyArXG4gICAgICAgIC8vIHNlbmQgW3g9ODAwLHk9NjQwLHNhcj0xLjEscT0wLjZdIFt4PTQ4MCx5PTMyMF1cbiAgICAgICAgJ1tcXFxcc1xcXFx0XSsoc2VuZHxyZWN2KVtcXFxcc1xcXFx0XSsoXFxcXCp8XFxcXFtcXFxcUytcXFxcXSg/OltcXFxcc1xcXFx0XStcXFxcW1xcXFxTK1xcXFxdKSopJyArXG4gICAgICAgIC8vIHJlY3YgW3g9MzMwLHk9MjUwXVxuICAgICAgICAnKD86W1xcXFxzXFxcXHRdKyhyZWN2fHNlbmQpW1xcXFxzXFxcXHRdKyhcXFxcKnxcXFxcW1xcXFxTK1xcXFxdKD86W1xcXFxzXFxcXHRdK1xcXFxbXFxcXFMrXFxcXF0pKikpPydcbiAgICAgICksXG4gICAgICBuYW1lczogWydwdCcsICdkaXIxJywgJ2F0dHJzMScsICdkaXIyJywgJ2F0dHJzMiddLFxuICAgICAgZm9ybWF0OiBmdW5jdGlvbiAobykge1xuICAgICAgICByZXR1cm4gJ2ltYWdlYXR0cjolcyAlcyAlcycgKyAoby5kaXIyID8gJyAlcyAlcycgOiAnJyk7XG4gICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICAvLyBhPXNpbXVsY2FzdDpzZW5kIDEsMiwzO340LH41IHJlY3YgNjt+Nyx+OFxuICAgICAgLy8gYT1zaW11bGNhc3Q6cmVjdiAxOzQsNSBzZW5kIDY7N1xuICAgICAgbmFtZTogJ3NpbXVsY2FzdCcsXG4gICAgICByZWc6IG5ldyBSZWdFeHAoXG4gICAgICAgIC8vIGE9c2ltdWxjYXN0OlxuICAgICAgICAnXnNpbXVsY2FzdDonICtcbiAgICAgICAgLy8gc2VuZCAxLDIsMzt+NCx+NVxuICAgICAgICAnKHNlbmR8cmVjdikgKFthLXpBLVowLTlcXFxcLV9+OyxdKyknICtcbiAgICAgICAgLy8gc3BhY2UgKyByZWN2IDY7fjcsfjhcbiAgICAgICAgJyg/OlxcXFxzPyhzZW5kfHJlY3YpIChbYS16QS1aMC05XFxcXC1ffjssXSspKT8nICtcbiAgICAgICAgLy8gZW5kXG4gICAgICAgICckJ1xuICAgICAgKSxcbiAgICAgIG5hbWVzOiBbJ2RpcjEnLCAnbGlzdDEnLCAnZGlyMicsICdsaXN0MiddLFxuICAgICAgZm9ybWF0OiBmdW5jdGlvbiAobykge1xuICAgICAgICByZXR1cm4gJ3NpbXVsY2FzdDolcyAlcycgKyAoby5kaXIyID8gJyAlcyAlcycgOiAnJyk7XG4gICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICAvLyBvbGQgc2ltdWxjYXN0IGRyYWZ0IDAzIChpbXBsZW1lbnRlZCBieSBGaXJlZm94KVxuICAgICAgLy8gICBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvZHJhZnQtaWV0Zi1tbXVzaWMtc2RwLXNpbXVsY2FzdC0wM1xuICAgICAgLy8gYT1zaW11bGNhc3Q6IHJlY3YgcHQ9OTc7OTggc2VuZCBwdD05N1xuICAgICAgLy8gYT1zaW11bGNhc3Q6IHNlbmQgcmlkPTU7Njs3IHBhdXNlZD02LDdcbiAgICAgIG5hbWU6ICdzaW11bGNhc3RfMDMnLFxuICAgICAgcmVnOiAvXnNpbXVsY2FzdDpbXFxzXFx0XSsoW1xcUytcXHNcXHRdKykkLyxcbiAgICAgIG5hbWVzOiBbJ3ZhbHVlJ10sXG4gICAgICBmb3JtYXQ6ICdzaW11bGNhc3Q6ICVzJ1xuICAgIH0sXG4gICAge1xuICAgICAgLy8gYT1mcmFtZXJhdGU6MjVcbiAgICAgIC8vIGE9ZnJhbWVyYXRlOjI5Ljk3XG4gICAgICBuYW1lOiAnZnJhbWVyYXRlJyxcbiAgICAgIHJlZzogL15mcmFtZXJhdGU6KFxcZCsoPzokfFxcLlxcZCspKS8sXG4gICAgICBmb3JtYXQ6ICdmcmFtZXJhdGU6JXMnXG4gICAgfSxcbiAgICB7XG4gICAgICAvLyBSRkM0NTcwXG4gICAgICAvLyBhPXNvdXJjZS1maWx0ZXI6IGluY2wgSU4gSVA0IDIzOS41LjIuMzEgMTAuMS4xNS41XG4gICAgICBuYW1lOiAnc291cmNlRmlsdGVyJyxcbiAgICAgIHJlZzogL15zb3VyY2UtZmlsdGVyOiAqKGV4Y2x8aW5jbCkgKFxcUyopIChJUDR8SVA2fFxcKikgKFxcUyopICguKikvLFxuICAgICAgbmFtZXM6IFsnZmlsdGVyTW9kZScsICduZXRUeXBlJywgJ2FkZHJlc3NUeXBlcycsICdkZXN0QWRkcmVzcycsICdzcmNMaXN0J10sXG4gICAgICBmb3JtYXQ6ICdzb3VyY2UtZmlsdGVyOiAlcyAlcyAlcyAlcyAlcydcbiAgICB9LFxuICAgIHtcbiAgICAgIC8vIGE9YnVuZGxlLW9ubHlcbiAgICAgIG5hbWU6ICdidW5kbGVPbmx5JyxcbiAgICAgIHJlZzogL14oYnVuZGxlLW9ubHkpL1xuICAgIH0sXG4gICAge1xuICAgICAgLy8gYT1sYWJlbDoxXG4gICAgICBuYW1lOiAnbGFiZWwnLFxuICAgICAgcmVnOiAvXmxhYmVsOiguKykvLFxuICAgICAgZm9ybWF0OiAnbGFiZWw6JXMnXG4gICAgfSxcbiAgICB7XG4gICAgICAvLyBSRkMgdmVyc2lvbiAyNiBmb3IgU0NUUCBvdmVyIERUTFNcbiAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9kcmFmdC1pZXRmLW1tdXNpYy1zY3RwLXNkcC0yNiNzZWN0aW9uLTVcbiAgICAgIG5hbWU6ICdzY3RwUG9ydCcsXG4gICAgICByZWc6IC9ec2N0cC1wb3J0OihcXGQrKSQvLFxuICAgICAgZm9ybWF0OiAnc2N0cC1wb3J0OiVzJ1xuICAgIH0sXG4gICAge1xuICAgICAgLy8gUkZDIHZlcnNpb24gMjYgZm9yIFNDVFAgb3ZlciBEVExTXG4gICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvZHJhZnQtaWV0Zi1tbXVzaWMtc2N0cC1zZHAtMjYjc2VjdGlvbi02XG4gICAgICBuYW1lOiAnbWF4TWVzc2FnZVNpemUnLFxuICAgICAgcmVnOiAvXm1heC1tZXNzYWdlLXNpemU6KFxcZCspJC8sXG4gICAgICBmb3JtYXQ6ICdtYXgtbWVzc2FnZS1zaXplOiVzJ1xuICAgIH0sXG4gICAge1xuICAgICAgLy8gUkZDNzI3M1xuICAgICAgLy8gYT10cy1yZWZjbGs6cHRwPUlFRUUxNTg4LTIwMDg6MzktQTctOTQtRkYtRkUtMDctQ0ItRDA6MzdcbiAgICAgIHB1c2g6J3RzUmVmQ2xvY2tzJyxcbiAgICAgIHJlZzogL150cy1yZWZjbGs6KFteXFxzPV0qKSg/Oj0oXFxTKikpPy8sXG4gICAgICBuYW1lczogWydjbGtzcmMnLCAnY2xrc3JjRXh0J10sXG4gICAgICBmb3JtYXQ6IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgIHJldHVybiAndHMtcmVmY2xrOiVzJyArIChvLmNsa3NyY0V4dCAhPSBudWxsID8gJz0lcycgOiAnJyk7XG4gICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICAvLyBSRkM3MjczXG4gICAgICAvLyBhPW1lZGlhY2xrOmRpcmVjdD05NjMyMTQ0MjRcbiAgICAgIG5hbWU6J21lZGlhQ2xrJyxcbiAgICAgIHJlZzogL15tZWRpYWNsazooPzppZD0oXFxTKikpPyAqKFteXFxzPV0qKSg/Oj0oXFxTKikpPyg/OiAqcmF0ZT0oXFxkKylcXC8oXFxkKykpPy8sXG4gICAgICBuYW1lczogWydpZCcsICdtZWRpYUNsb2NrTmFtZScsICdtZWRpYUNsb2NrVmFsdWUnLCAncmF0ZU51bWVyYXRvcicsICdyYXRlRGVub21pbmF0b3InXSxcbiAgICAgIGZvcm1hdDogZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgdmFyIHN0ciA9ICdtZWRpYWNsazonO1xuICAgICAgICBzdHIgKz0gKG8uaWQgIT0gbnVsbCA/ICdpZD0lcyAlcycgOiAnJXYlcycpO1xuICAgICAgICBzdHIgKz0gKG8ubWVkaWFDbG9ja1ZhbHVlICE9IG51bGwgPyAnPSVzJyA6ICcnKTtcbiAgICAgICAgc3RyICs9IChvLnJhdGVOdW1lcmF0b3IgIT0gbnVsbCA/ICcgcmF0ZT0lcycgOiAnJyk7XG4gICAgICAgIHN0ciArPSAoby5yYXRlRGVub21pbmF0b3IgIT0gbnVsbCA/ICcvJXMnIDogJycpO1xuICAgICAgICByZXR1cm4gc3RyO1xuICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgLy8gYT1rZXl3ZHM6a2V5d29yZHNcbiAgICAgIG5hbWU6ICdrZXl3b3JkcycsXG4gICAgICByZWc6IC9ea2V5d2RzOiguKykkLyxcbiAgICAgIGZvcm1hdDogJ2tleXdkczolcydcbiAgICB9LFxuICAgIHtcbiAgICAgIC8vIGE9Y29udGVudDptYWluXG4gICAgICBuYW1lOiAnY29udGVudCcsXG4gICAgICByZWc6IC9eY29udGVudDooLispLyxcbiAgICAgIGZvcm1hdDogJ2NvbnRlbnQ6JXMnXG4gICAgfSxcbiAgICAvLyBCRkNQIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM0NTgzXG4gICAge1xuICAgICAgLy8gYT1mbG9vcmN0cmw6Yy1zXG4gICAgICBuYW1lOiAnYmZjcEZsb29yQ3RybCcsXG4gICAgICByZWc6IC9eZmxvb3JjdHJsOihjLW9ubHl8cy1vbmx5fGMtcykvLFxuICAgICAgZm9ybWF0OiAnZmxvb3JjdHJsOiVzJ1xuICAgIH0sXG4gICAge1xuICAgICAgLy8gYT1jb25maWQ6MVxuICAgICAgbmFtZTogJ2JmY3BDb25mSWQnLFxuICAgICAgcmVnOiAvXmNvbmZpZDooXFxkKykvLFxuICAgICAgZm9ybWF0OiAnY29uZmlkOiVzJ1xuICAgIH0sXG4gICAge1xuICAgICAgLy8gYT11c2VyaWQ6MVxuICAgICAgbmFtZTogJ2JmY3BVc2VySWQnLFxuICAgICAgcmVnOiAvXnVzZXJpZDooXFxkKykvLFxuICAgICAgZm9ybWF0OiAndXNlcmlkOiVzJ1xuICAgIH0sXG4gICAge1xuICAgICAgLy8gYT1mbG9vcmlkOjFcbiAgICAgIG5hbWU6ICdiZmNwRmxvb3JJZCcsXG4gICAgICByZWc6IC9eZmxvb3JpZDooLispICg/Om0tc3RyZWFtfG1zdHJtKTooLispLyxcbiAgICAgIG5hbWVzOiBbJ2lkJywgJ21TdHJlYW0nXSxcbiAgICAgIGZvcm1hdDogJ2Zsb29yaWQ6JXMgbXN0cm06JXMnXG4gICAgfSxcbiAgICB7XG4gICAgICAvLyBhbnkgYT0gdGhhdCB3ZSBkb24ndCB1bmRlcnN0YW5kIGlzIGtlcHQgdmVyYmF0aW0gb24gbWVkaWEuaW52YWxpZFxuICAgICAgcHVzaDogJ2ludmFsaWQnLFxuICAgICAgbmFtZXM6IFsndmFsdWUnXVxuICAgIH1cbiAgXVxufTtcblxuLy8gc2V0IHNlbnNpYmxlIGRlZmF1bHRzIHRvIGF2b2lkIHBvbGx1dGluZyB0aGUgZ3JhbW1hciB3aXRoIGJvcmluZyBkZXRhaWxzXG5PYmplY3Qua2V5cyhncmFtbWFyKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgdmFyIG9ianMgPSBncmFtbWFyW2tleV07XG4gIG9ianMuZm9yRWFjaChmdW5jdGlvbiAob2JqKSB7XG4gICAgaWYgKCFvYmoucmVnKSB7XG4gICAgICBvYmoucmVnID0gLyguKikvO1xuICAgIH1cbiAgICBpZiAoIW9iai5mb3JtYXQpIHtcbiAgICAgIG9iai5mb3JtYXQgPSAnJXMnO1xuICAgIH1cbiAgfSk7XG59KTtcbiIsInZhciB0b0ludElmSW50ID0gZnVuY3Rpb24gKHYpIHtcbiAgcmV0dXJuIFN0cmluZyhOdW1iZXIodikpID09PSB2ID8gTnVtYmVyKHYpIDogdjtcbn07XG5cbnZhciBhdHRhY2hQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKG1hdGNoLCBsb2NhdGlvbiwgbmFtZXMsIHJhd05hbWUpIHtcbiAgaWYgKHJhd05hbWUgJiYgIW5hbWVzKSB7XG4gICAgbG9jYXRpb25bcmF3TmFtZV0gPSB0b0ludElmSW50KG1hdGNoWzFdKTtcbiAgfVxuICBlbHNlIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5hbWVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBpZiAobWF0Y2hbaSsxXSAhPSBudWxsKSB7XG4gICAgICAgIGxvY2F0aW9uW25hbWVzW2ldXSA9IHRvSW50SWZJbnQobWF0Y2hbaSsxXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG52YXIgcGFyc2VSZWcgPSBmdW5jdGlvbiAob2JqLCBsb2NhdGlvbiwgY29udGVudCkge1xuICB2YXIgbmVlZHNCbGFuayA9IG9iai5uYW1lICYmIG9iai5uYW1lcztcbiAgaWYgKG9iai5wdXNoICYmICFsb2NhdGlvbltvYmoucHVzaF0pIHtcbiAgICBsb2NhdGlvbltvYmoucHVzaF0gPSBbXTtcbiAgfVxuICBlbHNlIGlmIChuZWVkc0JsYW5rICYmICFsb2NhdGlvbltvYmoubmFtZV0pIHtcbiAgICBsb2NhdGlvbltvYmoubmFtZV0gPSB7fTtcbiAgfVxuICB2YXIga2V5TG9jYXRpb24gPSBvYmoucHVzaCA/XG4gICAge30gOiAgLy8gYmxhbmsgb2JqZWN0IHRoYXQgd2lsbCBiZSBwdXNoZWRcbiAgICBuZWVkc0JsYW5rID8gbG9jYXRpb25bb2JqLm5hbWVdIDogbG9jYXRpb247IC8vIG90aGVyd2lzZSwgbmFtZWQgbG9jYXRpb24gb3Igcm9vdFxuXG4gIGF0dGFjaFByb3BlcnRpZXMoY29udGVudC5tYXRjaChvYmoucmVnKSwga2V5TG9jYXRpb24sIG9iai5uYW1lcywgb2JqLm5hbWUpO1xuXG4gIGlmIChvYmoucHVzaCkge1xuICAgIGxvY2F0aW9uW29iai5wdXNoXS5wdXNoKGtleUxvY2F0aW9uKTtcbiAgfVxufTtcblxudmFyIGdyYW1tYXIgPSByZXF1aXJlKCcuL2dyYW1tYXInKTtcbnZhciB2YWxpZExpbmUgPSBSZWdFeHAucHJvdG90eXBlLnRlc3QuYmluZCgvXihbYS16XSk9KC4qKS8pO1xuXG5leHBvcnRzLnBhcnNlID0gZnVuY3Rpb24gKHNkcCkge1xuICB2YXIgc2Vzc2lvbiA9IHt9XG4gICAgLCBtZWRpYSA9IFtdXG4gICAgLCBsb2NhdGlvbiA9IHNlc3Npb247IC8vIHBvaW50cyBhdCB3aGVyZSBwcm9wZXJ0aWVzIGdvIHVuZGVyIChvbmUgb2YgdGhlIGFib3ZlKVxuXG4gIC8vIHBhcnNlIGxpbmVzIHdlIHVuZGVyc3RhbmRcbiAgc2RwLnNwbGl0KC8oXFxyXFxufFxccnxcXG4pLykuZmlsdGVyKHZhbGlkTGluZSkuZm9yRWFjaChmdW5jdGlvbiAobCkge1xuICAgIHZhciB0eXBlID0gbFswXTtcbiAgICB2YXIgY29udGVudCA9IGwuc2xpY2UoMik7XG4gICAgaWYgKHR5cGUgPT09ICdtJykge1xuICAgICAgbWVkaWEucHVzaCh7cnRwOiBbXSwgZm10cDogW119KTtcbiAgICAgIGxvY2F0aW9uID0gbWVkaWFbbWVkaWEubGVuZ3RoLTFdOyAvLyBwb2ludCBhdCBsYXRlc3QgbWVkaWEgbGluZVxuICAgIH1cblxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgKGdyYW1tYXJbdHlwZV0gfHwgW10pLmxlbmd0aDsgaiArPSAxKSB7XG4gICAgICB2YXIgb2JqID0gZ3JhbW1hclt0eXBlXVtqXTtcbiAgICAgIGlmIChvYmoucmVnLnRlc3QoY29udGVudCkpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlUmVnKG9iaiwgbG9jYXRpb24sIGNvbnRlbnQpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgc2Vzc2lvbi5tZWRpYSA9IG1lZGlhOyAvLyBsaW5rIGl0IHVwXG4gIHJldHVybiBzZXNzaW9uO1xufTtcblxudmFyIHBhcmFtUmVkdWNlciA9IGZ1bmN0aW9uIChhY2MsIGV4cHIpIHtcbiAgdmFyIHMgPSBleHByLnNwbGl0KC89KC4rKS8sIDIpO1xuICBpZiAocy5sZW5ndGggPT09IDIpIHtcbiAgICBhY2Nbc1swXV0gPSB0b0ludElmSW50KHNbMV0pO1xuICB9IGVsc2UgaWYgKHMubGVuZ3RoID09PSAxICYmIGV4cHIubGVuZ3RoID4gMSkge1xuICAgIGFjY1tzWzBdXSA9IHVuZGVmaW5lZDtcbiAgfVxuICByZXR1cm4gYWNjO1xufTtcblxuZXhwb3J0cy5wYXJzZVBhcmFtcyA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgcmV0dXJuIHN0ci5zcGxpdCgvO1xccz8vKS5yZWR1Y2UocGFyYW1SZWR1Y2VyLCB7fSk7XG59O1xuXG4vLyBGb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSAtIGFsaWFzIHdpbGwgYmUgcmVtb3ZlZCBpbiAzLjAuMFxuZXhwb3J0cy5wYXJzZUZtdHBDb25maWcgPSBleHBvcnRzLnBhcnNlUGFyYW1zO1xuXG5leHBvcnRzLnBhcnNlUGF5bG9hZHMgPSBmdW5jdGlvbiAoc3RyKSB7XG4gIHJldHVybiBzdHIudG9TdHJpbmcoKS5zcGxpdCgnICcpLm1hcChOdW1iZXIpO1xufTtcblxuZXhwb3J0cy5wYXJzZVJlbW90ZUNhbmRpZGF0ZXMgPSBmdW5jdGlvbiAoc3RyKSB7XG4gIHZhciBjYW5kaWRhdGVzID0gW107XG4gIHZhciBwYXJ0cyA9IHN0ci5zcGxpdCgnICcpLm1hcCh0b0ludElmSW50KTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGg7IGkgKz0gMykge1xuICAgIGNhbmRpZGF0ZXMucHVzaCh7XG4gICAgICBjb21wb25lbnQ6IHBhcnRzW2ldLFxuICAgICAgaXA6IHBhcnRzW2kgKyAxXSxcbiAgICAgIHBvcnQ6IHBhcnRzW2kgKyAyXVxuICAgIH0pO1xuICB9XG4gIHJldHVybiBjYW5kaWRhdGVzO1xufTtcblxuZXhwb3J0cy5wYXJzZUltYWdlQXR0cmlidXRlcyA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgcmV0dXJuIHN0ci5zcGxpdCgnICcpLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgIHJldHVybiBpdGVtLnN1YnN0cmluZygxLCBpdGVtLmxlbmd0aC0xKS5zcGxpdCgnLCcpLnJlZHVjZShwYXJhbVJlZHVjZXIsIHt9KTtcbiAgfSk7XG59O1xuXG5leHBvcnRzLnBhcnNlU2ltdWxjYXN0U3RyZWFtTGlzdCA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgcmV0dXJuIHN0ci5zcGxpdCgnOycpLm1hcChmdW5jdGlvbiAoc3RyZWFtKSB7XG4gICAgcmV0dXJuIHN0cmVhbS5zcGxpdCgnLCcpLm1hcChmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgICB2YXIgc2NpZCwgcGF1c2VkID0gZmFsc2U7XG5cbiAgICAgIGlmIChmb3JtYXRbMF0gIT09ICd+Jykge1xuICAgICAgICBzY2lkID0gdG9JbnRJZkludChmb3JtYXQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2NpZCA9IHRvSW50SWZJbnQoZm9ybWF0LnN1YnN0cmluZygxLCBmb3JtYXQubGVuZ3RoKSk7XG4gICAgICAgIHBhdXNlZCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHNjaWQ6IHNjaWQsXG4gICAgICAgIHBhdXNlZDogcGF1c2VkXG4gICAgICB9O1xuICAgIH0pO1xuICB9KTtcbn07XG4iLCJ2YXIgZ3JhbW1hciA9IHJlcXVpcmUoJy4vZ3JhbW1hcicpO1xuXG4vLyBjdXN0b21pemVkIHV0aWwuZm9ybWF0IC0gZGlzY2FyZHMgZXhjZXNzIGFyZ3VtZW50cyBhbmQgY2FuIHZvaWQgbWlkZGxlIG9uZXNcbnZhciBmb3JtYXRSZWdFeHAgPSAvJVtzZHYlXS9nO1xudmFyIGZvcm1hdCA9IGZ1bmN0aW9uIChmb3JtYXRTdHIpIHtcbiAgdmFyIGkgPSAxO1xuICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgdmFyIGxlbiA9IGFyZ3MubGVuZ3RoO1xuICByZXR1cm4gZm9ybWF0U3RyLnJlcGxhY2UoZm9ybWF0UmVnRXhwLCBmdW5jdGlvbiAoeCkge1xuICAgIGlmIChpID49IGxlbikge1xuICAgICAgcmV0dXJuIHg7IC8vIG1pc3NpbmcgYXJndW1lbnRcbiAgICB9XG4gICAgdmFyIGFyZyA9IGFyZ3NbaV07XG4gICAgaSArPSAxO1xuICAgIHN3aXRjaCAoeCkge1xuICAgIGNhc2UgJyUlJzpcbiAgICAgIHJldHVybiAnJSc7XG4gICAgY2FzZSAnJXMnOlxuICAgICAgcmV0dXJuIFN0cmluZyhhcmcpO1xuICAgIGNhc2UgJyVkJzpcbiAgICAgIHJldHVybiBOdW1iZXIoYXJnKTtcbiAgICBjYXNlICcldic6XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuICB9KTtcbiAgLy8gTkI6IHdlIGRpc2NhcmQgZXhjZXNzIGFyZ3VtZW50cyAtIHRoZXkgYXJlIHR5cGljYWxseSB1bmRlZmluZWQgZnJvbSBtYWtlTGluZVxufTtcblxudmFyIG1ha2VMaW5lID0gZnVuY3Rpb24gKHR5cGUsIG9iaiwgbG9jYXRpb24pIHtcbiAgdmFyIHN0ciA9IG9iai5mb3JtYXQgaW5zdGFuY2VvZiBGdW5jdGlvbiA/XG4gICAgKG9iai5mb3JtYXQob2JqLnB1c2ggPyBsb2NhdGlvbiA6IGxvY2F0aW9uW29iai5uYW1lXSkpIDpcbiAgICBvYmouZm9ybWF0O1xuXG4gIHZhciBhcmdzID0gW3R5cGUgKyAnPScgKyBzdHJdO1xuICBpZiAob2JqLm5hbWVzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmoubmFtZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIHZhciBuID0gb2JqLm5hbWVzW2ldO1xuICAgICAgaWYgKG9iai5uYW1lKSB7XG4gICAgICAgIGFyZ3MucHVzaChsb2NhdGlvbltvYmoubmFtZV1bbl0pO1xuICAgICAgfVxuICAgICAgZWxzZSB7IC8vIGZvciBtTGluZSBhbmQgcHVzaCBhdHRyaWJ1dGVzXG4gICAgICAgIGFyZ3MucHVzaChsb2NhdGlvbltvYmoubmFtZXNbaV1dKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZWxzZSB7XG4gICAgYXJncy5wdXNoKGxvY2F0aW9uW29iai5uYW1lXSk7XG4gIH1cbiAgcmV0dXJuIGZvcm1hdC5hcHBseShudWxsLCBhcmdzKTtcbn07XG5cbi8vIFJGQyBzcGVjaWZpZWQgb3JkZXJcbi8vIFRPRE86IGV4dGVuZCB0aGlzIHdpdGggYWxsIHRoZSByZXN0XG52YXIgZGVmYXVsdE91dGVyT3JkZXIgPSBbXG4gICd2JywgJ28nLCAncycsICdpJyxcbiAgJ3UnLCAnZScsICdwJywgJ2MnLFxuICAnYicsICd0JywgJ3InLCAneicsICdhJ1xuXTtcbnZhciBkZWZhdWx0SW5uZXJPcmRlciA9IFsnaScsICdjJywgJ2InLCAnYSddO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHNlc3Npb24sIG9wdHMpIHtcbiAgb3B0cyA9IG9wdHMgfHwge307XG4gIC8vIGVuc3VyZSBjZXJ0YWluIHByb3BlcnRpZXMgZXhpc3RcbiAgaWYgKHNlc3Npb24udmVyc2lvbiA9PSBudWxsKSB7XG4gICAgc2Vzc2lvbi52ZXJzaW9uID0gMDsgLy8gJ3Y9MCcgbXVzdCBiZSB0aGVyZSAob25seSBkZWZpbmVkIHZlcnNpb24gYXRtKVxuICB9XG4gIGlmIChzZXNzaW9uLm5hbWUgPT0gbnVsbCkge1xuICAgIHNlc3Npb24ubmFtZSA9ICcgJzsgLy8gJ3M9ICcgbXVzdCBiZSB0aGVyZSBpZiBubyBtZWFuaW5nZnVsIG5hbWUgc2V0XG4gIH1cbiAgc2Vzc2lvbi5tZWRpYS5mb3JFYWNoKGZ1bmN0aW9uIChtTGluZSkge1xuICAgIGlmIChtTGluZS5wYXlsb2FkcyA9PSBudWxsKSB7XG4gICAgICBtTGluZS5wYXlsb2FkcyA9ICcnO1xuICAgIH1cbiAgfSk7XG5cbiAgdmFyIG91dGVyT3JkZXIgPSBvcHRzLm91dGVyT3JkZXIgfHwgZGVmYXVsdE91dGVyT3JkZXI7XG4gIHZhciBpbm5lck9yZGVyID0gb3B0cy5pbm5lck9yZGVyIHx8IGRlZmF1bHRJbm5lck9yZGVyO1xuICB2YXIgc2RwID0gW107XG5cbiAgLy8gbG9vcCB0aHJvdWdoIG91dGVyT3JkZXIgZm9yIG1hdGNoaW5nIHByb3BlcnRpZXMgb24gc2Vzc2lvblxuICBvdXRlck9yZGVyLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICBncmFtbWFyW3R5cGVdLmZvckVhY2goZnVuY3Rpb24gKG9iaikge1xuICAgICAgaWYgKG9iai5uYW1lIGluIHNlc3Npb24gJiYgc2Vzc2lvbltvYmoubmFtZV0gIT0gbnVsbCkge1xuICAgICAgICBzZHAucHVzaChtYWtlTGluZSh0eXBlLCBvYmosIHNlc3Npb24pKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKG9iai5wdXNoIGluIHNlc3Npb24gJiYgc2Vzc2lvbltvYmoucHVzaF0gIT0gbnVsbCkge1xuICAgICAgICBzZXNzaW9uW29iai5wdXNoXS5mb3JFYWNoKGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgIHNkcC5wdXNoKG1ha2VMaW5lKHR5cGUsIG9iaiwgZWwpKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuXG4gIC8vIHRoZW4gZm9yIGVhY2ggbWVkaWEgbGluZSwgZm9sbG93IHRoZSBpbm5lck9yZGVyXG4gIHNlc3Npb24ubWVkaWEuZm9yRWFjaChmdW5jdGlvbiAobUxpbmUpIHtcbiAgICBzZHAucHVzaChtYWtlTGluZSgnbScsIGdyYW1tYXIubVswXSwgbUxpbmUpKTtcblxuICAgIGlubmVyT3JkZXIuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgICAgZ3JhbW1hclt0eXBlXS5mb3JFYWNoKGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgaWYgKG9iai5uYW1lIGluIG1MaW5lICYmIG1MaW5lW29iai5uYW1lXSAhPSBudWxsKSB7XG4gICAgICAgICAgc2RwLnB1c2gobWFrZUxpbmUodHlwZSwgb2JqLCBtTGluZSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9iai5wdXNoIGluIG1MaW5lICYmIG1MaW5lW29iai5wdXNoXSAhPSBudWxsKSB7XG4gICAgICAgICAgbUxpbmVbb2JqLnB1c2hdLmZvckVhY2goZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICBzZHAucHVzaChtYWtlTGluZSh0eXBlLCBvYmosIGVsKSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcblxuICByZXR1cm4gc2RwLmpvaW4oJ1xcclxcbicpICsgJ1xcclxcbic7XG59O1xuIiwidmFyIHBhcnNlciA9IHJlcXVpcmUoJy4vcGFyc2VyJyk7XG52YXIgd3JpdGVyID0gcmVxdWlyZSgnLi93cml0ZXInKTtcblxuZXhwb3J0cy53cml0ZSA9IHdyaXRlcjtcbmV4cG9ydHMucGFyc2UgPSBwYXJzZXIucGFyc2U7XG5leHBvcnRzLnBhcnNlUGFyYW1zID0gcGFyc2VyLnBhcnNlUGFyYW1zO1xuZXhwb3J0cy5wYXJzZUZtdHBDb25maWcgPSBwYXJzZXIucGFyc2VGbXRwQ29uZmlnOyAvLyBBbGlhcyBvZiBwYXJzZVBhcmFtcygpLlxuZXhwb3J0cy5wYXJzZVBheWxvYWRzID0gcGFyc2VyLnBhcnNlUGF5bG9hZHM7XG5leHBvcnRzLnBhcnNlUmVtb3RlQ2FuZGlkYXRlcyA9IHBhcnNlci5wYXJzZVJlbW90ZUNhbmRpZGF0ZXM7XG5leHBvcnRzLnBhcnNlSW1hZ2VBdHRyaWJ1dGVzID0gcGFyc2VyLnBhcnNlSW1hZ2VBdHRyaWJ1dGVzO1xuZXhwb3J0cy5wYXJzZVNpbXVsY2FzdFN0cmVhbUxpc3QgPSBwYXJzZXIucGFyc2VTaW11bGNhc3RTdHJlYW1MaXN0O1xuIiwiaW1wb3J0IHsgRXZlbnRFbWl0dGVyIH0gZnJvbSAnZXZlbnRzJztcbmltcG9ydCB0eXBlIHsgTWVkaWFEZXNjcmlwdGlvbiB9IGZyb20gJ3NkcC10cmFuc2Zvcm0nO1xuaW1wb3J0IHsgcGFyc2UsIHdyaXRlIH0gZnJvbSAnc2RwLXRyYW5zZm9ybSc7XG5pbXBvcnQgeyBkZWJvdW5jZSB9IGZyb20gJ3RzLWRlYm91bmNlJztcbmltcG9ydCBsb2csIHsgTG9nZ2VyTmFtZXMsIGdldExvZ2dlciB9IGZyb20gJy4uL2xvZ2dlcic7XG5pbXBvcnQgeyBOZWdvdGlhdGlvbkVycm9yLCBVbmV4cGVjdGVkQ29ubmVjdGlvblN0YXRlIH0gZnJvbSAnLi9lcnJvcnMnO1xuaW1wb3J0IHR5cGUgeyBMb2dnZXJPcHRpb25zIH0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQgeyBkZEV4dGVuc2lvblVSSSwgaXNDaHJvbWl1bUJhc2VkLCBpc1NWQ0NvZGVjIH0gZnJvbSAnLi91dGlscyc7XG5cbi8qKiBAaW50ZXJuYWwgKi9cbmludGVyZmFjZSBUcmFja0JpdHJhdGVJbmZvIHtcbiAgY2lkPzogc3RyaW5nO1xuICB0cmFuc2NlaXZlcj86IFJUQ1J0cFRyYW5zY2VpdmVyO1xuICBjb2RlYzogc3RyaW5nO1xuICBtYXhicjogbnVtYmVyO1xufVxuXG4vKiBUaGUgc3ZjIGNvZGVjIChhdjEvdnA5KSB3b3VsZCB1c2UgYSB2ZXJ5IGxvdyBiaXRyYXRlIGF0IHRoZSBiZWdpbmluZyBhbmRcbmluY3JlYXNlIHNsb3dseSBieSB0aGUgYmFuZHdpZHRoIGVzdGltYXRvciB1bnRpbCBpdCByZWFjaCB0aGUgdGFyZ2V0IGJpdHJhdGUuIFRoZVxucHJvY2VzcyBjb21tb25seSBjb3N0IG1vcmUgdGhhbiAxMCBzZWNvbmRzIGNhdXNlIHN1YnNjcmliZXIgd2lsbCBnZXQgYmx1ciB2aWRlbyBhdFxudGhlIGZpcnN0IGZldyBzZWNvbmRzLiBTbyB3ZSB1c2UgYSA3MCUgb2YgdGFyZ2V0IGJpdHJhdGUgaGVyZSBhcyB0aGUgc3RhcnQgYml0cmF0ZSB0b1xuZWxpbWluYXRlIHRoaXMgaXNzdWUuXG4qL1xuY29uc3Qgc3RhcnRCaXRyYXRlRm9yU1ZDID0gMC43O1xuXG5leHBvcnQgY29uc3QgUENFdmVudHMgPSB7XG4gIE5lZ290aWF0aW9uU3RhcnRlZDogJ25lZ290aWF0aW9uU3RhcnRlZCcsXG4gIE5lZ290aWF0aW9uQ29tcGxldGU6ICduZWdvdGlhdGlvbkNvbXBsZXRlJyxcbiAgUlRQVmlkZW9QYXlsb2FkVHlwZXM6ICdydHBWaWRlb1BheWxvYWRUeXBlcycsXG59IGFzIGNvbnN0O1xuXG4vKiogQGludGVybmFsICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQQ1RyYW5zcG9ydCBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIHByaXZhdGUgX3BjOiBSVENQZWVyQ29ubmVjdGlvbiB8IG51bGw7XG5cbiAgcHJpdmF0ZSBnZXQgcGMoKSB7XG4gICAgaWYgKCF0aGlzLl9wYykge1xuICAgICAgdGhpcy5fcGMgPSB0aGlzLmNyZWF0ZVBDKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9wYztcbiAgfVxuXG4gIHByaXZhdGUgY29uZmlnPzogUlRDQ29uZmlndXJhdGlvbjtcblxuICBwcml2YXRlIG1lZGlhQ29uc3RyYWludHM6IFJlY29yZDxzdHJpbmcsIHVua25vd24+O1xuXG4gIHByaXZhdGUgbG9nID0gbG9nO1xuXG4gIHByaXZhdGUgbG9nZ2VyT3B0aW9uczogTG9nZ2VyT3B0aW9ucztcblxuICBwZW5kaW5nQ2FuZGlkYXRlczogUlRDSWNlQ2FuZGlkYXRlSW5pdFtdID0gW107XG5cbiAgcmVzdGFydGluZ0ljZTogYm9vbGVhbiA9IGZhbHNlO1xuXG4gIHJlbmVnb3RpYXRlOiBib29sZWFuID0gZmFsc2U7XG5cbiAgdHJhY2tCaXRyYXRlczogVHJhY2tCaXRyYXRlSW5mb1tdID0gW107XG5cbiAgcmVtb3RlU3RlcmVvTWlkczogc3RyaW5nW10gPSBbXTtcblxuICByZW1vdGVOYWNrTWlkczogc3RyaW5nW10gPSBbXTtcblxuICBvbk9mZmVyPzogKG9mZmVyOiBSVENTZXNzaW9uRGVzY3JpcHRpb25Jbml0KSA9PiB2b2lkO1xuXG4gIG9uSWNlQ2FuZGlkYXRlPzogKGNhbmRpZGF0ZTogUlRDSWNlQ2FuZGlkYXRlKSA9PiB2b2lkO1xuXG4gIG9uSWNlQ2FuZGlkYXRlRXJyb3I/OiAoZXY6IEV2ZW50KSA9PiB2b2lkO1xuXG4gIG9uQ29ubmVjdGlvblN0YXRlQ2hhbmdlPzogKHN0YXRlOiBSVENQZWVyQ29ubmVjdGlvblN0YXRlKSA9PiB2b2lkO1xuXG4gIG9uSWNlQ29ubmVjdGlvblN0YXRlQ2hhbmdlPzogKHN0YXRlOiBSVENJY2VDb25uZWN0aW9uU3RhdGUpID0+IHZvaWQ7XG5cbiAgb25TaWduYWxpbmdTdGF0ZWNoYW5nZT86IChzdGF0ZTogUlRDU2lnbmFsaW5nU3RhdGUpID0+IHZvaWQ7XG5cbiAgb25EYXRhQ2hhbm5lbD86IChldjogUlRDRGF0YUNoYW5uZWxFdmVudCkgPT4gdm9pZDtcblxuICBvblRyYWNrPzogKGV2OiBSVENUcmFja0V2ZW50KSA9PiB2b2lkO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIGNvbmZpZz86IFJUQ0NvbmZpZ3VyYXRpb24sXG4gICAgbWVkaWFDb25zdHJhaW50czogUmVjb3JkPHN0cmluZywgdW5rbm93bj4gPSB7fSxcbiAgICBsb2dnZXJPcHRpb25zOiBMb2dnZXJPcHRpb25zID0ge30sXG4gICkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5sb2cgPSBnZXRMb2dnZXIobG9nZ2VyT3B0aW9ucy5sb2dnZXJOYW1lID8/IExvZ2dlck5hbWVzLlBDVHJhbnNwb3J0KTtcbiAgICB0aGlzLmxvZ2dlck9wdGlvbnMgPSBsb2dnZXJPcHRpb25zO1xuICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgIHRoaXMubWVkaWFDb25zdHJhaW50cyA9IG1lZGlhQ29uc3RyYWludHM7XG4gICAgdGhpcy5fcGMgPSB0aGlzLmNyZWF0ZVBDKCk7XG4gIH1cblxuICBwcml2YXRlIGNyZWF0ZVBDKCkge1xuICAgIGNvbnN0IHBjID0gaXNDaHJvbWl1bUJhc2VkKClcbiAgICAgID8gLy8gQHRzLWV4cGVjdC1lcnJvciBjaHJvbWUgYWxsb3dzIGFkZGl0aW9uYWwgbWVkaWEgY29uc3RyYWludHMgdG8gYmUgcGFzc2VkIGludG8gdGhlIFJUQ1BlZXJDb25uZWN0aW9uIGNvbnN0cnVjdG9yXG4gICAgICAgIG5ldyBSVENQZWVyQ29ubmVjdGlvbih0aGlzLmNvbmZpZywgdGhpcy5tZWRpYUNvbnN0cmFpbnRzKVxuICAgICAgOiBuZXcgUlRDUGVlckNvbm5lY3Rpb24odGhpcy5jb25maWcpO1xuXG4gICAgcGMub25pY2VjYW5kaWRhdGUgPSAoZXYpID0+IHtcbiAgICAgIGlmICghZXYuY2FuZGlkYXRlKSByZXR1cm47XG4gICAgICB0aGlzLm9uSWNlQ2FuZGlkYXRlPy4oZXYuY2FuZGlkYXRlKTtcbiAgICB9O1xuICAgIHBjLm9uaWNlY2FuZGlkYXRlZXJyb3IgPSAoZXYpID0+IHtcbiAgICAgIHRoaXMub25JY2VDYW5kaWRhdGVFcnJvcj8uKGV2KTtcbiAgICB9O1xuXG4gICAgcGMub25pY2Vjb25uZWN0aW9uc3RhdGVjaGFuZ2UgPSAoKSA9PiB7XG4gICAgICB0aGlzLm9uSWNlQ29ubmVjdGlvblN0YXRlQ2hhbmdlPy4ocGMuaWNlQ29ubmVjdGlvblN0YXRlKTtcbiAgICB9O1xuXG4gICAgcGMub25zaWduYWxpbmdzdGF0ZWNoYW5nZSA9ICgpID0+IHtcbiAgICAgIHRoaXMub25TaWduYWxpbmdTdGF0ZWNoYW5nZT8uKHBjLnNpZ25hbGluZ1N0YXRlKTtcbiAgICB9O1xuXG4gICAgcGMub25jb25uZWN0aW9uc3RhdGVjaGFuZ2UgPSAoKSA9PiB7XG4gICAgICB0aGlzLm9uQ29ubmVjdGlvblN0YXRlQ2hhbmdlPy4ocGMuY29ubmVjdGlvblN0YXRlKTtcbiAgICB9O1xuICAgIHBjLm9uZGF0YWNoYW5uZWwgPSAoZXYpID0+IHtcbiAgICAgIHRoaXMub25EYXRhQ2hhbm5lbD8uKGV2KTtcbiAgICB9O1xuICAgIHBjLm9udHJhY2sgPSAoZXYpID0+IHtcbiAgICAgIHRoaXMub25UcmFjaz8uKGV2KTtcbiAgICB9O1xuICAgIHJldHVybiBwYztcbiAgfVxuXG4gIHByaXZhdGUgZ2V0IGxvZ0NvbnRleHQoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnRoaXMubG9nZ2VyT3B0aW9ucy5sb2dnZXJDb250ZXh0Q2I/LigpLFxuICAgIH07XG4gIH1cblxuICBnZXQgaXNJQ0VDb25uZWN0ZWQoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIChcbiAgICAgIHRoaXMuX3BjICE9PSBudWxsICYmXG4gICAgICAodGhpcy5wYy5pY2VDb25uZWN0aW9uU3RhdGUgPT09ICdjb25uZWN0ZWQnIHx8IHRoaXMucGMuaWNlQ29ubmVjdGlvblN0YXRlID09PSAnY29tcGxldGVkJylcbiAgICApO1xuICB9XG5cbiAgYXN5bmMgYWRkSWNlQ2FuZGlkYXRlKGNhbmRpZGF0ZTogUlRDSWNlQ2FuZGlkYXRlSW5pdCk6IFByb21pc2U8dm9pZD4ge1xuICAgIGlmICh0aGlzLnBjLnJlbW90ZURlc2NyaXB0aW9uICYmICF0aGlzLnJlc3RhcnRpbmdJY2UpIHtcbiAgICAgIHJldHVybiB0aGlzLnBjLmFkZEljZUNhbmRpZGF0ZShjYW5kaWRhdGUpO1xuICAgIH1cbiAgICB0aGlzLnBlbmRpbmdDYW5kaWRhdGVzLnB1c2goY2FuZGlkYXRlKTtcbiAgfVxuXG4gIGFzeW5jIHNldFJlbW90ZURlc2NyaXB0aW9uKHNkOiBSVENTZXNzaW9uRGVzY3JpcHRpb25Jbml0KTogUHJvbWlzZTx2b2lkPiB7XG4gICAgbGV0IG11bmdlZFNEUDogc3RyaW5nIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuICAgIGlmIChzZC50eXBlID09PSAnb2ZmZXInKSB7XG4gICAgICBsZXQgeyBzdGVyZW9NaWRzLCBuYWNrTWlkcyB9ID0gZXh0cmFjdFN0ZXJlb0FuZE5hY2tBdWRpb0Zyb21PZmZlcihzZCk7XG4gICAgICB0aGlzLnJlbW90ZVN0ZXJlb01pZHMgPSBzdGVyZW9NaWRzO1xuICAgICAgdGhpcy5yZW1vdGVOYWNrTWlkcyA9IG5hY2tNaWRzO1xuICAgIH0gZWxzZSBpZiAoc2QudHlwZSA9PT0gJ2Fuc3dlcicpIHtcbiAgICAgIGNvbnN0IHNkcFBhcnNlZCA9IHBhcnNlKHNkLnNkcCA/PyAnJyk7XG4gICAgICBzZHBQYXJzZWQubWVkaWEuZm9yRWFjaCgobWVkaWEpID0+IHtcbiAgICAgICAgaWYgKG1lZGlhLnR5cGUgPT09ICdhdWRpbycpIHtcbiAgICAgICAgICAvLyBtdW5nIHNkcCBmb3Igb3B1cyBiaXRyYXRlIHNldHRpbmdzXG4gICAgICAgICAgdGhpcy50cmFja0JpdHJhdGVzLnNvbWUoKHRyYWNrYnIpOiBib29sZWFuID0+IHtcbiAgICAgICAgICAgIGlmICghdHJhY2tici50cmFuc2NlaXZlciB8fCBtZWRpYS5taWQgIT0gdHJhY2tici50cmFuc2NlaXZlci5taWQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgY29kZWNQYXlsb2FkID0gMDtcbiAgICAgICAgICAgIG1lZGlhLnJ0cC5zb21lKChydHApOiBib29sZWFuID0+IHtcbiAgICAgICAgICAgICAgaWYgKHJ0cC5jb2RlYy50b1VwcGVyQ2FzZSgpID09PSB0cmFja2JyLmNvZGVjLnRvVXBwZXJDYXNlKCkpIHtcbiAgICAgICAgICAgICAgICBjb2RlY1BheWxvYWQgPSBydHAucGF5bG9hZDtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKGNvZGVjUGF5bG9hZCA9PT0gMCkge1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV0IGZtdHBGb3VuZCA9IGZhbHNlO1xuICAgICAgICAgICAgZm9yIChjb25zdCBmbXRwIG9mIG1lZGlhLmZtdHApIHtcbiAgICAgICAgICAgICAgaWYgKGZtdHAucGF5bG9hZCA9PT0gY29kZWNQYXlsb2FkKSB7XG4gICAgICAgICAgICAgICAgZm10cC5jb25maWcgPSBmbXRwLmNvbmZpZ1xuICAgICAgICAgICAgICAgICAgLnNwbGl0KCc7JylcbiAgICAgICAgICAgICAgICAgIC5maWx0ZXIoKGF0dHIpID0+ICFhdHRyLmluY2x1ZGVzKCdtYXhhdmVyYWdlYml0cmF0ZScpKVxuICAgICAgICAgICAgICAgICAgLmpvaW4oJzsnKTtcbiAgICAgICAgICAgICAgICBpZiAodHJhY2tici5tYXhiciA+IDApIHtcbiAgICAgICAgICAgICAgICAgIGZtdHAuY29uZmlnICs9IGA7bWF4YXZlcmFnZWJpdHJhdGU9JHt0cmFja2JyLm1heGJyICogMTAwMH1gO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmbXRwRm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghZm10cEZvdW5kKSB7XG4gICAgICAgICAgICAgIGlmICh0cmFja2JyLm1heGJyID4gMCkge1xuICAgICAgICAgICAgICAgIG1lZGlhLmZtdHAucHVzaCh7XG4gICAgICAgICAgICAgICAgICBwYXlsb2FkOiBjb2RlY1BheWxvYWQsXG4gICAgICAgICAgICAgICAgICBjb25maWc6IGBtYXhhdmVyYWdlYml0cmF0ZT0ke3RyYWNrYnIubWF4YnIgKiAxMDAwfWAsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgbXVuZ2VkU0RQID0gd3JpdGUoc2RwUGFyc2VkKTtcbiAgICB9XG4gICAgYXdhaXQgdGhpcy5zZXRNdW5nZWRTRFAoc2QsIG11bmdlZFNEUCwgdHJ1ZSk7XG5cbiAgICB0aGlzLnBlbmRpbmdDYW5kaWRhdGVzLmZvckVhY2goKGNhbmRpZGF0ZSkgPT4ge1xuICAgICAgdGhpcy5wYy5hZGRJY2VDYW5kaWRhdGUoY2FuZGlkYXRlKTtcbiAgICB9KTtcbiAgICB0aGlzLnBlbmRpbmdDYW5kaWRhdGVzID0gW107XG4gICAgdGhpcy5yZXN0YXJ0aW5nSWNlID0gZmFsc2U7XG5cbiAgICBpZiAodGhpcy5yZW5lZ290aWF0ZSkge1xuICAgICAgdGhpcy5yZW5lZ290aWF0ZSA9IGZhbHNlO1xuICAgICAgYXdhaXQgdGhpcy5jcmVhdGVBbmRTZW5kT2ZmZXIoKTtcbiAgICB9IGVsc2UgaWYgKHNkLnR5cGUgPT09ICdhbnN3ZXInKSB7XG4gICAgICB0aGlzLmVtaXQoUENFdmVudHMuTmVnb3RpYXRpb25Db21wbGV0ZSk7XG4gICAgICBpZiAoc2Quc2RwKSB7XG4gICAgICAgIGNvbnN0IHNkcFBhcnNlZCA9IHBhcnNlKHNkLnNkcCk7XG4gICAgICAgIHNkcFBhcnNlZC5tZWRpYS5mb3JFYWNoKChtZWRpYSkgPT4ge1xuICAgICAgICAgIGlmIChtZWRpYS50eXBlID09PSAndmlkZW8nKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoUENFdmVudHMuUlRQVmlkZW9QYXlsb2FkVHlwZXMsIG1lZGlhLnJ0cCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBkZWJvdW5jZWQgbmVnb3RpYXRlIGludGVyZmFjZVxuICBuZWdvdGlhdGUgPSBkZWJvdW5jZShhc3luYyAob25FcnJvcj86IChlOiBFcnJvcikgPT4gdm9pZCkgPT4ge1xuICAgIHRoaXMuZW1pdChQQ0V2ZW50cy5OZWdvdGlhdGlvblN0YXJ0ZWQpO1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCB0aGlzLmNyZWF0ZUFuZFNlbmRPZmZlcigpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmIChvbkVycm9yKSB7XG4gICAgICAgIG9uRXJyb3IoZSBhcyBFcnJvcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgIH1cbiAgfSwgMTAwKTtcblxuICBhc3luYyBjcmVhdGVBbmRTZW5kT2ZmZXIob3B0aW9ucz86IFJUQ09mZmVyT3B0aW9ucykge1xuICAgIGlmICh0aGlzLm9uT2ZmZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zPy5pY2VSZXN0YXJ0KSB7XG4gICAgICB0aGlzLmxvZy5kZWJ1ZygncmVzdGFydGluZyBJQ0UnLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgdGhpcy5yZXN0YXJ0aW5nSWNlID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fcGMgJiYgdGhpcy5fcGMuc2lnbmFsaW5nU3RhdGUgPT09ICdoYXZlLWxvY2FsLW9mZmVyJykge1xuICAgICAgLy8gd2UncmUgd2FpdGluZyBmb3IgdGhlIHBlZXIgdG8gYWNjZXB0IG91ciBvZmZlciwgc28gd2UnbGwganVzdCB3YWl0XG4gICAgICAvLyB0aGUgb25seSBleGNlcHRpb24gdG8gdGhpcyBpcyB3aGVuIElDRSByZXN0YXJ0IGlzIG5lZWRlZFxuICAgICAgY29uc3QgY3VycmVudFNEID0gdGhpcy5fcGMucmVtb3RlRGVzY3JpcHRpb247XG4gICAgICBpZiAob3B0aW9ucz8uaWNlUmVzdGFydCAmJiBjdXJyZW50U0QpIHtcbiAgICAgICAgLy8gVE9ETzogaGFuZGxlIHdoZW4gSUNFIHJlc3RhcnQgaXMgbmVlZGVkIGJ1dCB3ZSBkb24ndCBoYXZlIGEgcmVtb3RlIGRlc2NyaXB0aW9uXG4gICAgICAgIC8vIHRoZSBiZXN0IHRoaW5nIHRvIGRvIGlzIHRvIHJlY3JlYXRlIHRoZSBwZWVyY29ubmVjdGlvblxuICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihjdXJyZW50U0QpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5yZW5lZ290aWF0ZSA9IHRydWU7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCF0aGlzLl9wYyB8fCB0aGlzLl9wYy5zaWduYWxpbmdTdGF0ZSA9PT0gJ2Nsb3NlZCcpIHtcbiAgICAgIHRoaXMubG9nLndhcm4oJ2NvdWxkIG5vdCBjcmVhdGVPZmZlciB3aXRoIGNsb3NlZCBwZWVyIGNvbm5lY3Rpb24nLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGFjdHVhbGx5IG5lZ290aWF0ZVxuICAgIHRoaXMubG9nLmRlYnVnKCdzdGFydGluZyB0byBuZWdvdGlhdGUnLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgIGNvbnN0IG9mZmVyID0gYXdhaXQgdGhpcy5wYy5jcmVhdGVPZmZlcihvcHRpb25zKTtcblxuICAgIGNvbnN0IHNkcFBhcnNlZCA9IHBhcnNlKG9mZmVyLnNkcCA/PyAnJyk7XG4gICAgc2RwUGFyc2VkLm1lZGlhLmZvckVhY2goKG1lZGlhKSA9PiB7XG4gICAgICBpZiAobWVkaWEudHlwZSA9PT0gJ2F1ZGlvJykge1xuICAgICAgICBlbnN1cmVBdWRpb05hY2tBbmRTdGVyZW8obWVkaWEsIFtdLCBbXSk7XG4gICAgICB9IGVsc2UgaWYgKG1lZGlhLnR5cGUgPT09ICd2aWRlbycpIHtcbiAgICAgICAgZW5zdXJlVmlkZW9EREV4dGVuc2lvbkZvclNWQyhtZWRpYSk7XG4gICAgICAgIC8vIG11bmcgc2RwIGZvciBjb2RlYyBiaXRyYXRlIHNldHRpbmcgdGhhdCBjYW4ndCBhcHBseSBieSBzZW5kRW5jb2RpbmdcbiAgICAgICAgdGhpcy50cmFja0JpdHJhdGVzLnNvbWUoKHRyYWNrYnIpOiBib29sZWFuID0+IHtcbiAgICAgICAgICBpZiAoIW1lZGlhLm1zaWQgfHwgIXRyYWNrYnIuY2lkIHx8ICFtZWRpYS5tc2lkLmluY2x1ZGVzKHRyYWNrYnIuY2lkKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGxldCBjb2RlY1BheWxvYWQgPSAwO1xuICAgICAgICAgIG1lZGlhLnJ0cC5zb21lKChydHApOiBib29sZWFuID0+IHtcbiAgICAgICAgICAgIGlmIChydHAuY29kZWMudG9VcHBlckNhc2UoKSA9PT0gdHJhY2tici5jb2RlYy50b1VwcGVyQ2FzZSgpKSB7XG4gICAgICAgICAgICAgIGNvZGVjUGF5bG9hZCA9IHJ0cC5wYXlsb2FkO1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGlmIChjb2RlY1BheWxvYWQgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGxldCBmbXRwRm91bmQgPSBmYWxzZTtcbiAgICAgICAgICBmb3IgKGNvbnN0IGZtdHAgb2YgbWVkaWEuZm10cCkge1xuICAgICAgICAgICAgaWYgKGZtdHAucGF5bG9hZCA9PT0gY29kZWNQYXlsb2FkKSB7XG4gICAgICAgICAgICAgIGlmICghZm10cC5jb25maWcuaW5jbHVkZXMoJ3gtZ29vZ2xlLXN0YXJ0LWJpdHJhdGUnKSkge1xuICAgICAgICAgICAgICAgIGZtdHAuY29uZmlnICs9IGA7eC1nb29nbGUtc3RhcnQtYml0cmF0ZT0ke01hdGgucm91bmQoXG4gICAgICAgICAgICAgICAgICB0cmFja2JyLm1heGJyICogc3RhcnRCaXRyYXRlRm9yU1ZDLFxuICAgICAgICAgICAgICAgICl9YDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoIWZtdHAuY29uZmlnLmluY2x1ZGVzKCd4LWdvb2dsZS1tYXgtYml0cmF0ZScpKSB7XG4gICAgICAgICAgICAgICAgZm10cC5jb25maWcgKz0gYDt4LWdvb2dsZS1tYXgtYml0cmF0ZT0ke3RyYWNrYnIubWF4YnJ9YDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBmbXRwRm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIWZtdHBGb3VuZCkge1xuICAgICAgICAgICAgbWVkaWEuZm10cC5wdXNoKHtcbiAgICAgICAgICAgICAgcGF5bG9hZDogY29kZWNQYXlsb2FkLFxuICAgICAgICAgICAgICBjb25maWc6IGB4LWdvb2dsZS1zdGFydC1iaXRyYXRlPSR7TWF0aC5yb3VuZChcbiAgICAgICAgICAgICAgICB0cmFja2JyLm1heGJyICogc3RhcnRCaXRyYXRlRm9yU1ZDLFxuICAgICAgICAgICAgICApfTt4LWdvb2dsZS1tYXgtYml0cmF0ZT0ke3RyYWNrYnIubWF4YnJ9YCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGF3YWl0IHRoaXMuc2V0TXVuZ2VkU0RQKG9mZmVyLCB3cml0ZShzZHBQYXJzZWQpKTtcbiAgICB0aGlzLm9uT2ZmZXIob2ZmZXIpO1xuICB9XG5cbiAgYXN5bmMgY3JlYXRlQW5kU2V0QW5zd2VyKCk6IFByb21pc2U8UlRDU2Vzc2lvbkRlc2NyaXB0aW9uSW5pdD4ge1xuICAgIGNvbnN0IGFuc3dlciA9IGF3YWl0IHRoaXMucGMuY3JlYXRlQW5zd2VyKCk7XG4gICAgY29uc3Qgc2RwUGFyc2VkID0gcGFyc2UoYW5zd2VyLnNkcCA/PyAnJyk7XG4gICAgc2RwUGFyc2VkLm1lZGlhLmZvckVhY2goKG1lZGlhKSA9PiB7XG4gICAgICBpZiAobWVkaWEudHlwZSA9PT0gJ2F1ZGlvJykge1xuICAgICAgICBlbnN1cmVBdWRpb05hY2tBbmRTdGVyZW8obWVkaWEsIHRoaXMucmVtb3RlU3RlcmVvTWlkcywgdGhpcy5yZW1vdGVOYWNrTWlkcyk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgYXdhaXQgdGhpcy5zZXRNdW5nZWRTRFAoYW5zd2VyLCB3cml0ZShzZHBQYXJzZWQpKTtcbiAgICByZXR1cm4gYW5zd2VyO1xuICB9XG5cbiAgY3JlYXRlRGF0YUNoYW5uZWwobGFiZWw6IHN0cmluZywgZGF0YUNoYW5uZWxEaWN0OiBSVENEYXRhQ2hhbm5lbEluaXQpIHtcbiAgICByZXR1cm4gdGhpcy5wYy5jcmVhdGVEYXRhQ2hhbm5lbChsYWJlbCwgZGF0YUNoYW5uZWxEaWN0KTtcbiAgfVxuXG4gIGFkZFRyYW5zY2VpdmVyKG1lZGlhU3RyZWFtVHJhY2s6IE1lZGlhU3RyZWFtVHJhY2ssIHRyYW5zY2VpdmVySW5pdDogUlRDUnRwVHJhbnNjZWl2ZXJJbml0KSB7XG4gICAgcmV0dXJuIHRoaXMucGMuYWRkVHJhbnNjZWl2ZXIobWVkaWFTdHJlYW1UcmFjaywgdHJhbnNjZWl2ZXJJbml0KTtcbiAgfVxuXG4gIGFkZFRyYWNrKHRyYWNrOiBNZWRpYVN0cmVhbVRyYWNrKSB7XG4gICAgaWYgKCF0aGlzLl9wYykge1xuICAgICAgdGhyb3cgbmV3IFVuZXhwZWN0ZWRDb25uZWN0aW9uU3RhdGUoJ1BDIGNsb3NlZCwgY2Fubm90IGFkZCB0cmFjaycpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcGMuYWRkVHJhY2sodHJhY2spO1xuICB9XG5cbiAgc2V0VHJhY2tDb2RlY0JpdHJhdGUoaW5mbzogVHJhY2tCaXRyYXRlSW5mbykge1xuICAgIHRoaXMudHJhY2tCaXRyYXRlcy5wdXNoKGluZm8pO1xuICB9XG5cbiAgc2V0Q29uZmlndXJhdGlvbihydGNDb25maWc6IFJUQ0NvbmZpZ3VyYXRpb24pIHtcbiAgICBpZiAoIXRoaXMuX3BjKSB7XG4gICAgICB0aHJvdyBuZXcgVW5leHBlY3RlZENvbm5lY3Rpb25TdGF0ZSgnUEMgY2xvc2VkLCBjYW5ub3QgY29uZmlndXJlJyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9wYz8uc2V0Q29uZmlndXJhdGlvbihydGNDb25maWcpO1xuICB9XG5cbiAgY2FuUmVtb3ZlVHJhY2soKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuICEhdGhpcy5fcGM/LnJlbW92ZVRyYWNrO1xuICB9XG5cbiAgcmVtb3ZlVHJhY2soc2VuZGVyOiBSVENSdHBTZW5kZXIpIHtcbiAgICByZXR1cm4gdGhpcy5fcGM/LnJlbW92ZVRyYWNrKHNlbmRlcik7XG4gIH1cblxuICBnZXRDb25uZWN0aW9uU3RhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BjPy5jb25uZWN0aW9uU3RhdGUgPz8gJ2Nsb3NlZCc7XG4gIH1cblxuICBnZXRJQ0VDb25uZWN0aW9uU3RhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BjPy5pY2VDb25uZWN0aW9uU3RhdGUgPz8gJ2Nsb3NlZCc7XG4gIH1cblxuICBnZXRTaWduYWxsaW5nU3RhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BjPy5zaWduYWxpbmdTdGF0ZSA/PyAnY2xvc2VkJztcbiAgfVxuXG4gIGdldFRyYW5zY2VpdmVycygpIHtcbiAgICByZXR1cm4gdGhpcy5fcGM/LmdldFRyYW5zY2VpdmVycygpID8/IFtdO1xuICB9XG5cbiAgZ2V0U2VuZGVycygpIHtcbiAgICByZXR1cm4gdGhpcy5fcGM/LmdldFNlbmRlcnMoKSA/PyBbXTtcbiAgfVxuXG4gIGdldExvY2FsRGVzY3JpcHRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BjPy5sb2NhbERlc2NyaXB0aW9uO1xuICB9XG5cbiAgZ2V0UmVtb3RlRGVzY3JpcHRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucGM/LnJlbW90ZURlc2NyaXB0aW9uO1xuICB9XG5cbiAgZ2V0U3RhdHMoKSB7XG4gICAgcmV0dXJuIHRoaXMucGMuZ2V0U3RhdHMoKTtcbiAgfVxuXG4gIGFzeW5jIGdldENvbm5lY3RlZEFkZHJlc3MoKTogUHJvbWlzZTxzdHJpbmcgfCB1bmRlZmluZWQ+IHtcbiAgICBpZiAoIXRoaXMuX3BjKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBzZWxlY3RlZENhbmRpZGF0ZVBhaXJJZCA9ICcnO1xuICAgIGNvbnN0IGNhbmRpZGF0ZVBhaXJzID0gbmV3IE1hcDxzdHJpbmcsIFJUQ0ljZUNhbmRpZGF0ZVBhaXJTdGF0cz4oKTtcbiAgICAvLyBpZCAtPiBjYW5kaWRhdGUgaXBcbiAgICBjb25zdCBjYW5kaWRhdGVzID0gbmV3IE1hcDxzdHJpbmcsIHN0cmluZz4oKTtcbiAgICBjb25zdCBzdGF0czogUlRDU3RhdHNSZXBvcnQgPSBhd2FpdCB0aGlzLl9wYy5nZXRTdGF0cygpO1xuICAgIHN0YXRzLmZvckVhY2goKHYpID0+IHtcbiAgICAgIHN3aXRjaCAodi50eXBlKSB7XG4gICAgICAgIGNhc2UgJ3RyYW5zcG9ydCc6XG4gICAgICAgICAgc2VsZWN0ZWRDYW5kaWRhdGVQYWlySWQgPSB2LnNlbGVjdGVkQ2FuZGlkYXRlUGFpcklkO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdjYW5kaWRhdGUtcGFpcic6XG4gICAgICAgICAgaWYgKHNlbGVjdGVkQ2FuZGlkYXRlUGFpcklkID09PSAnJyAmJiB2LnNlbGVjdGVkKSB7XG4gICAgICAgICAgICBzZWxlY3RlZENhbmRpZGF0ZVBhaXJJZCA9IHYuaWQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhbmRpZGF0ZVBhaXJzLnNldCh2LmlkLCB2KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAncmVtb3RlLWNhbmRpZGF0ZSc6XG4gICAgICAgICAgY2FuZGlkYXRlcy5zZXQodi5pZCwgYCR7di5hZGRyZXNzfToke3YucG9ydH1gKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmIChzZWxlY3RlZENhbmRpZGF0ZVBhaXJJZCA9PT0gJycpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGNvbnN0IHNlbGVjdGVkSUQgPSBjYW5kaWRhdGVQYWlycy5nZXQoc2VsZWN0ZWRDYW5kaWRhdGVQYWlySWQpPy5yZW1vdGVDYW5kaWRhdGVJZDtcbiAgICBpZiAoc2VsZWN0ZWRJRCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICByZXR1cm4gY2FuZGlkYXRlcy5nZXQoc2VsZWN0ZWRJRCk7XG4gIH1cblxuICBjbG9zZSA9ICgpID0+IHtcbiAgICBpZiAoIXRoaXMuX3BjKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX3BjLmNsb3NlKCk7XG4gICAgdGhpcy5fcGMub25jb25uZWN0aW9uc3RhdGVjaGFuZ2UgPSBudWxsO1xuICAgIHRoaXMuX3BjLm9uaWNlY29ubmVjdGlvbnN0YXRlY2hhbmdlID0gbnVsbDtcbiAgICB0aGlzLl9wYy5vbmljZWdhdGhlcmluZ3N0YXRlY2hhbmdlID0gbnVsbDtcbiAgICB0aGlzLl9wYy5vbmRhdGFjaGFubmVsID0gbnVsbDtcbiAgICB0aGlzLl9wYy5vbm5lZ290aWF0aW9ubmVlZGVkID0gbnVsbDtcbiAgICB0aGlzLl9wYy5vbnNpZ25hbGluZ3N0YXRlY2hhbmdlID0gbnVsbDtcbiAgICB0aGlzLl9wYy5vbmljZWNhbmRpZGF0ZSA9IG51bGw7XG4gICAgdGhpcy5fcGMub25kYXRhY2hhbm5lbCA9IG51bGw7XG4gICAgdGhpcy5fcGMub250cmFjayA9IG51bGw7XG4gICAgdGhpcy5fcGMub25jb25uZWN0aW9uc3RhdGVjaGFuZ2UgPSBudWxsO1xuICAgIHRoaXMuX3BjLm9uaWNlY29ubmVjdGlvbnN0YXRlY2hhbmdlID0gbnVsbDtcbiAgICB0aGlzLl9wYyA9IG51bGw7XG4gIH07XG5cbiAgcHJpdmF0ZSBhc3luYyBzZXRNdW5nZWRTRFAoc2Q6IFJUQ1Nlc3Npb25EZXNjcmlwdGlvbkluaXQsIG11bmdlZD86IHN0cmluZywgcmVtb3RlPzogYm9vbGVhbikge1xuICAgIGlmIChtdW5nZWQpIHtcbiAgICAgIGNvbnN0IG9yaWdpbmFsU2RwID0gc2Quc2RwO1xuICAgICAgc2Quc2RwID0gbXVuZ2VkO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy5sb2cuZGVidWcoXG4gICAgICAgICAgYHNldHRpbmcgbXVuZ2VkICR7cmVtb3RlID8gJ3JlbW90ZScgOiAnbG9jYWwnfSBkZXNjcmlwdGlvbmAsXG4gICAgICAgICAgdGhpcy5sb2dDb250ZXh0LFxuICAgICAgICApO1xuICAgICAgICBpZiAocmVtb3RlKSB7XG4gICAgICAgICAgYXdhaXQgdGhpcy5wYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihzZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYXdhaXQgdGhpcy5wYy5zZXRMb2NhbERlc2NyaXB0aW9uKHNkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHRoaXMubG9nLndhcm4oYG5vdCBhYmxlIHRvIHNldCAke3NkLnR5cGV9LCBmYWxsaW5nIGJhY2sgdG8gdW5tb2RpZmllZCBzZHBgLCB7XG4gICAgICAgICAgLi4udGhpcy5sb2dDb250ZXh0LFxuICAgICAgICAgIGVycm9yOiBlLFxuICAgICAgICAgIHNkcDogbXVuZ2VkLFxuICAgICAgICB9KTtcbiAgICAgICAgc2Quc2RwID0gb3JpZ2luYWxTZHA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGlmIChyZW1vdGUpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5wYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihzZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhd2FpdCB0aGlzLnBjLnNldExvY2FsRGVzY3JpcHRpb24oc2QpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIHRoaXMgZXJyb3IgY2Fubm90IGFsd2F5cyBiZSBjYXVnaHQuXG4gICAgICAvLyBJZiB0aGUgbG9jYWwgZGVzY3JpcHRpb24gaGFzIGEgc2V0Q29kZWNQcmVmZXJlbmNlcyBlcnJvciwgdGhpcyBlcnJvciB3aWxsIGJlIHVuY2F1Z2h0XG4gICAgICBsZXQgbXNnID0gJ3Vua25vd24gZXJyb3InO1xuICAgICAgaWYgKGUgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICBtc2cgPSBlLm1lc3NhZ2U7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBlID09PSAnc3RyaW5nJykge1xuICAgICAgICBtc2cgPSBlO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBmaWVsZHM6IGFueSA9IHtcbiAgICAgICAgZXJyb3I6IG1zZyxcbiAgICAgICAgc2RwOiBzZC5zZHAsXG4gICAgICB9O1xuICAgICAgaWYgKCFyZW1vdGUgJiYgdGhpcy5wYy5yZW1vdGVEZXNjcmlwdGlvbikge1xuICAgICAgICBmaWVsZHMucmVtb3RlU2RwID0gdGhpcy5wYy5yZW1vdGVEZXNjcmlwdGlvbjtcbiAgICAgIH1cbiAgICAgIHRoaXMubG9nLmVycm9yKGB1bmFibGUgdG8gc2V0ICR7c2QudHlwZX1gLCB7IC4uLnRoaXMubG9nQ29udGV4dCwgZmllbGRzIH0pO1xuICAgICAgdGhyb3cgbmV3IE5lZ290aWF0aW9uRXJyb3IobXNnKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZW5zdXJlQXVkaW9OYWNrQW5kU3RlcmVvKFxuICBtZWRpYToge1xuICAgIHR5cGU6IHN0cmluZztcbiAgICBwb3J0OiBudW1iZXI7XG4gICAgcHJvdG9jb2w6IHN0cmluZztcbiAgICBwYXlsb2Fkcz86IHN0cmluZyB8IHVuZGVmaW5lZDtcbiAgfSAmIE1lZGlhRGVzY3JpcHRpb24sXG4gIHN0ZXJlb01pZHM6IHN0cmluZ1tdLFxuICBuYWNrTWlkczogc3RyaW5nW10sXG4pIHtcbiAgLy8gZm91bmQgb3B1cyBjb2RlYyB0byBhZGQgbmFjayBmYlxuICBsZXQgb3B1c1BheWxvYWQgPSAwO1xuICBtZWRpYS5ydHAuc29tZSgocnRwKTogYm9vbGVhbiA9PiB7XG4gICAgaWYgKHJ0cC5jb2RlYyA9PT0gJ29wdXMnKSB7XG4gICAgICBvcHVzUGF5bG9hZCA9IHJ0cC5wYXlsb2FkO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfSk7XG5cbiAgLy8gYWRkIG5hY2sgcnRjcGZiIGlmIG5vdCBleGlzdFxuICBpZiAob3B1c1BheWxvYWQgPiAwKSB7XG4gICAgaWYgKCFtZWRpYS5ydGNwRmIpIHtcbiAgICAgIG1lZGlhLnJ0Y3BGYiA9IFtdO1xuICAgIH1cblxuICAgIGlmIChcbiAgICAgIG5hY2tNaWRzLmluY2x1ZGVzKG1lZGlhLm1pZCEpICYmXG4gICAgICAhbWVkaWEucnRjcEZiLnNvbWUoKGZiKSA9PiBmYi5wYXlsb2FkID09PSBvcHVzUGF5bG9hZCAmJiBmYi50eXBlID09PSAnbmFjaycpXG4gICAgKSB7XG4gICAgICBtZWRpYS5ydGNwRmIucHVzaCh7XG4gICAgICAgIHBheWxvYWQ6IG9wdXNQYXlsb2FkLFxuICAgICAgICB0eXBlOiAnbmFjaycsXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoc3RlcmVvTWlkcy5pbmNsdWRlcyhtZWRpYS5taWQhKSkge1xuICAgICAgbWVkaWEuZm10cC5zb21lKChmbXRwKTogYm9vbGVhbiA9PiB7XG4gICAgICAgIGlmIChmbXRwLnBheWxvYWQgPT09IG9wdXNQYXlsb2FkKSB7XG4gICAgICAgICAgaWYgKCFmbXRwLmNvbmZpZy5pbmNsdWRlcygnc3RlcmVvPTEnKSkge1xuICAgICAgICAgICAgZm10cC5jb25maWcgKz0gJztzdGVyZW89MSc7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBlbnN1cmVWaWRlb0RERXh0ZW5zaW9uRm9yU1ZDKFxuICBtZWRpYToge1xuICAgIHR5cGU6IHN0cmluZztcbiAgICBwb3J0OiBudW1iZXI7XG4gICAgcHJvdG9jb2w6IHN0cmluZztcbiAgICBwYXlsb2Fkcz86IHN0cmluZyB8IHVuZGVmaW5lZDtcbiAgfSAmIE1lZGlhRGVzY3JpcHRpb24sXG4pIHtcbiAgY29uc3QgY29kZWMgPSBtZWRpYS5ydHBbMF0/LmNvZGVjPy50b0xvd2VyQ2FzZSgpO1xuICBpZiAoIWlzU1ZDQ29kZWMoY29kZWMpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgbGV0IG1heElEID0gMDtcbiAgY29uc3QgZGRGb3VuZCA9IG1lZGlhLmV4dD8uc29tZSgoZXh0KTogYm9vbGVhbiA9PiB7XG4gICAgaWYgKGV4dC51cmkgPT09IGRkRXh0ZW5zaW9uVVJJKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGV4dC52YWx1ZSA+IG1heElEKSB7XG4gICAgICBtYXhJRCA9IGV4dC52YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9KTtcblxuICBpZiAoIWRkRm91bmQpIHtcbiAgICBtZWRpYS5leHQ/LnB1c2goe1xuICAgICAgdmFsdWU6IG1heElEICsgMSxcbiAgICAgIHVyaTogZGRFeHRlbnNpb25VUkksXG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZXh0cmFjdFN0ZXJlb0FuZE5hY2tBdWRpb0Zyb21PZmZlcihvZmZlcjogUlRDU2Vzc2lvbkRlc2NyaXB0aW9uSW5pdCk6IHtcbiAgc3RlcmVvTWlkczogc3RyaW5nW107XG4gIG5hY2tNaWRzOiBzdHJpbmdbXTtcbn0ge1xuICBjb25zdCBzdGVyZW9NaWRzOiBzdHJpbmdbXSA9IFtdO1xuICBjb25zdCBuYWNrTWlkczogc3RyaW5nW10gPSBbXTtcbiAgY29uc3Qgc2RwUGFyc2VkID0gcGFyc2Uob2ZmZXIuc2RwID8/ICcnKTtcbiAgbGV0IG9wdXNQYXlsb2FkID0gMDtcbiAgc2RwUGFyc2VkLm1lZGlhLmZvckVhY2goKG1lZGlhKSA9PiB7XG4gICAgaWYgKG1lZGlhLnR5cGUgPT09ICdhdWRpbycpIHtcbiAgICAgIG1lZGlhLnJ0cC5zb21lKChydHApOiBib29sZWFuID0+IHtcbiAgICAgICAgaWYgKHJ0cC5jb2RlYyA9PT0gJ29wdXMnKSB7XG4gICAgICAgICAgb3B1c1BheWxvYWQgPSBydHAucGF5bG9hZDtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9KTtcblxuICAgICAgaWYgKG1lZGlhLnJ0Y3BGYj8uc29tZSgoZmIpID0+IGZiLnBheWxvYWQgPT09IG9wdXNQYXlsb2FkICYmIGZiLnR5cGUgPT09ICduYWNrJykpIHtcbiAgICAgICAgbmFja01pZHMucHVzaChtZWRpYS5taWQhKTtcbiAgICAgIH1cblxuICAgICAgbWVkaWEuZm10cC5zb21lKChmbXRwKTogYm9vbGVhbiA9PiB7XG4gICAgICAgIGlmIChmbXRwLnBheWxvYWQgPT09IG9wdXNQYXlsb2FkKSB7XG4gICAgICAgICAgaWYgKGZtdHAuY29uZmlnLmluY2x1ZGVzKCdzcHJvcC1zdGVyZW89MScpKSB7XG4gICAgICAgICAgICBzdGVyZW9NaWRzLnB1c2gobWVkaWEubWlkISk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiB7IHN0ZXJlb01pZHMsIG5hY2tNaWRzIH07XG59XG4iLCJpbXBvcnQgdHlwZSB7IEludGVybmFsUm9vbUNvbm5lY3RPcHRpb25zLCBJbnRlcm5hbFJvb21PcHRpb25zIH0gZnJvbSAnLi4vb3B0aW9ucyc7XG5pbXBvcnQgRGVmYXVsdFJlY29ubmVjdFBvbGljeSBmcm9tICcuL0RlZmF1bHRSZWNvbm5lY3RQb2xpY3knO1xuaW1wb3J0IHR5cGUge1xuICBBdWRpb0NhcHR1cmVPcHRpb25zLFxuICBUcmFja1B1Ymxpc2hEZWZhdWx0cyxcbiAgVmlkZW9DYXB0dXJlT3B0aW9ucyxcbn0gZnJvbSAnLi90cmFjay9vcHRpb25zJztcbmltcG9ydCB7IEF1ZGlvUHJlc2V0cywgU2NyZWVuU2hhcmVQcmVzZXRzLCBWaWRlb1ByZXNldHMgfSBmcm9tICcuL3RyYWNrL29wdGlvbnMnO1xuXG5leHBvcnQgY29uc3QgZGVmYXVsdFZpZGVvQ29kZWMgPSAndnA4JztcblxuZXhwb3J0IGNvbnN0IHB1Ymxpc2hEZWZhdWx0czogVHJhY2tQdWJsaXNoRGVmYXVsdHMgPSB7XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZFxuICAgKi9cbiAgYXVkaW9CaXRyYXRlOiBBdWRpb1ByZXNldHMubXVzaWMubWF4Qml0cmF0ZSxcbiAgYXVkaW9QcmVzZXQ6IEF1ZGlvUHJlc2V0cy5tdXNpYyxcbiAgZHR4OiB0cnVlLFxuICByZWQ6IHRydWUsXG4gIGZvcmNlU3RlcmVvOiBmYWxzZSxcbiAgc2ltdWxjYXN0OiB0cnVlLFxuICBzY3JlZW5TaGFyZUVuY29kaW5nOiBTY3JlZW5TaGFyZVByZXNldHMuaDEwODBmcHMxNS5lbmNvZGluZyxcbiAgc3RvcE1pY1RyYWNrT25NdXRlOiBmYWxzZSxcbiAgdmlkZW9Db2RlYzogZGVmYXVsdFZpZGVvQ29kZWMsXG4gIGJhY2t1cENvZGVjOiB0cnVlLFxufSBhcyBjb25zdDtcblxuZXhwb3J0IGNvbnN0IGF1ZGlvRGVmYXVsdHM6IEF1ZGlvQ2FwdHVyZU9wdGlvbnMgPSB7XG4gIGF1dG9HYWluQ29udHJvbDogdHJ1ZSxcbiAgZWNob0NhbmNlbGxhdGlvbjogdHJ1ZSxcbiAgbm9pc2VTdXBwcmVzc2lvbjogdHJ1ZSxcbn07XG5cbmV4cG9ydCBjb25zdCB2aWRlb0RlZmF1bHRzOiBWaWRlb0NhcHR1cmVPcHRpb25zID0ge1xuICByZXNvbHV0aW9uOiBWaWRlb1ByZXNldHMuaDcyMC5yZXNvbHV0aW9uLFxufTtcblxuZXhwb3J0IGNvbnN0IHJvb21PcHRpb25EZWZhdWx0czogSW50ZXJuYWxSb29tT3B0aW9ucyA9IHtcbiAgYWRhcHRpdmVTdHJlYW06IGZhbHNlLFxuICBkeW5hY2FzdDogZmFsc2UsXG4gIHN0b3BMb2NhbFRyYWNrT25VbnB1Ymxpc2g6IHRydWUsXG4gIHJlY29ubmVjdFBvbGljeTogbmV3IERlZmF1bHRSZWNvbm5lY3RQb2xpY3koKSxcbiAgZGlzY29ubmVjdE9uUGFnZUxlYXZlOiB0cnVlLFxuICBleHBXZWJBdWRpb01peDogZmFsc2UsXG59IGFzIGNvbnN0O1xuXG5leHBvcnQgY29uc3Qgcm9vbUNvbm5lY3RPcHRpb25EZWZhdWx0czogSW50ZXJuYWxSb29tQ29ubmVjdE9wdGlvbnMgPSB7XG4gIGF1dG9TdWJzY3JpYmU6IHRydWUsXG4gIG1heFJldHJpZXM6IDEsXG4gIHBlZXJDb25uZWN0aW9uVGltZW91dDogMTVfMDAwLFxuICB3ZWJzb2NrZXRUaW1lb3V0OiAxNV8wMDAsXG59IGFzIGNvbnN0O1xuIiwiaW1wb3J0IGxvZywgeyBMb2dnZXJOYW1lcywgZ2V0TG9nZ2VyIH0gZnJvbSAnLi4vbG9nZ2VyJztcbmltcG9ydCB7IFNpZ25hbFRhcmdldCB9IGZyb20gJy4uL3Byb3RvL2xpdmVraXRfcnRjX3BiJztcbmltcG9ydCBQQ1RyYW5zcG9ydCwgeyBQQ0V2ZW50cyB9IGZyb20gJy4vUENUcmFuc3BvcnQnO1xuaW1wb3J0IHsgcm9vbUNvbm5lY3RPcHRpb25EZWZhdWx0cyB9IGZyb20gJy4vZGVmYXVsdHMnO1xuaW1wb3J0IHsgQ29ubmVjdGlvbkVycm9yLCBDb25uZWN0aW9uRXJyb3JSZWFzb24gfSBmcm9tICcuL2Vycm9ycyc7XG5pbXBvcnQgQ3JpdGljYWxUaW1lcnMgZnJvbSAnLi90aW1lcnMnO1xuaW1wb3J0IHR5cGUgeyBMb2dnZXJPcHRpb25zIH0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQgeyBNdXRleCwgc2xlZXAgfSBmcm9tICcuL3V0aWxzJztcblxuZXhwb3J0IGVudW0gUENUcmFuc3BvcnRTdGF0ZSB7XG4gIE5FVyxcbiAgQ09OTkVDVElORyxcbiAgQ09OTkVDVEVELFxuICBGQUlMRUQsXG4gIENMT1NJTkcsXG4gIENMT1NFRCxcbn1cblxuZXhwb3J0IGNsYXNzIFBDVHJhbnNwb3J0TWFuYWdlciB7XG4gIHB1YmxpYyBwdWJsaXNoZXI6IFBDVHJhbnNwb3J0O1xuXG4gIHB1YmxpYyBzdWJzY3JpYmVyOiBQQ1RyYW5zcG9ydDtcblxuICBwdWJsaWMgcGVlckNvbm5lY3Rpb25UaW1lb3V0OiBudW1iZXIgPSByb29tQ29ubmVjdE9wdGlvbkRlZmF1bHRzLnBlZXJDb25uZWN0aW9uVGltZW91dDtcblxuICBwdWJsaWMgZ2V0IG5lZWRzUHVibGlzaGVyKCkge1xuICAgIHJldHVybiB0aGlzLmlzUHVibGlzaGVyQ29ubmVjdGlvblJlcXVpcmVkO1xuICB9XG5cbiAgcHVibGljIGdldCBuZWVkc1N1YnNjcmliZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNTdWJzY3JpYmVyQ29ubmVjdGlvblJlcXVpcmVkO1xuICB9XG5cbiAgcHVibGljIGdldCBjdXJyZW50U3RhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGU7XG4gIH1cblxuICBwdWJsaWMgb25TdGF0ZUNoYW5nZT86IChcbiAgICBzdGF0ZTogUENUcmFuc3BvcnRTdGF0ZSxcbiAgICBwdWJTdGF0ZTogUlRDUGVlckNvbm5lY3Rpb25TdGF0ZSxcbiAgICBzdWJTdGF0ZTogUlRDUGVlckNvbm5lY3Rpb25TdGF0ZSxcbiAgKSA9PiB2b2lkO1xuXG4gIHB1YmxpYyBvbkljZUNhbmRpZGF0ZT86IChldjogUlRDSWNlQ2FuZGlkYXRlLCB0YXJnZXQ6IFNpZ25hbFRhcmdldCkgPT4gdm9pZDtcblxuICBwdWJsaWMgb25EYXRhQ2hhbm5lbD86IChldjogUlRDRGF0YUNoYW5uZWxFdmVudCkgPT4gdm9pZDtcblxuICBwdWJsaWMgb25UcmFjaz86IChldjogUlRDVHJhY2tFdmVudCkgPT4gdm9pZDtcblxuICBwdWJsaWMgb25QdWJsaXNoZXJPZmZlcj86IChvZmZlcjogUlRDU2Vzc2lvbkRlc2NyaXB0aW9uSW5pdCkgPT4gdm9pZDtcblxuICBwcml2YXRlIGlzUHVibGlzaGVyQ29ubmVjdGlvblJlcXVpcmVkOiBib29sZWFuO1xuXG4gIHByaXZhdGUgaXNTdWJzY3JpYmVyQ29ubmVjdGlvblJlcXVpcmVkOiBib29sZWFuO1xuXG4gIHByaXZhdGUgc3RhdGU6IFBDVHJhbnNwb3J0U3RhdGU7XG5cbiAgcHJpdmF0ZSBjb25uZWN0aW9uTG9jazogTXV0ZXg7XG5cbiAgcHJpdmF0ZSBsb2cgPSBsb2c7XG5cbiAgcHJpdmF0ZSBsb2dnZXJPcHRpb25zOiBMb2dnZXJPcHRpb25zO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHJ0Y0NvbmZpZzogUlRDQ29uZmlndXJhdGlvbixcbiAgICBzdWJzY3JpYmVyUHJpbWFyeTogYm9vbGVhbixcbiAgICBsb2dnZXJPcHRpb25zOiBMb2dnZXJPcHRpb25zLFxuICApIHtcbiAgICB0aGlzLmxvZyA9IGdldExvZ2dlcihsb2dnZXJPcHRpb25zLmxvZ2dlck5hbWUgPz8gTG9nZ2VyTmFtZXMuUENNYW5hZ2VyKTtcbiAgICB0aGlzLmxvZ2dlck9wdGlvbnMgPSBsb2dnZXJPcHRpb25zO1xuXG4gICAgdGhpcy5pc1B1Ymxpc2hlckNvbm5lY3Rpb25SZXF1aXJlZCA9ICFzdWJzY3JpYmVyUHJpbWFyeTtcbiAgICB0aGlzLmlzU3Vic2NyaWJlckNvbm5lY3Rpb25SZXF1aXJlZCA9IHN1YnNjcmliZXJQcmltYXJ5O1xuICAgIGNvbnN0IGdvb2dDb25zdHJhaW50cyA9IHsgb3B0aW9uYWw6IFt7IGdvb2dEc2NwOiB0cnVlIH1dIH07XG4gICAgdGhpcy5wdWJsaXNoZXIgPSBuZXcgUENUcmFuc3BvcnQocnRjQ29uZmlnLCBnb29nQ29uc3RyYWludHMsIGxvZ2dlck9wdGlvbnMpO1xuICAgIHRoaXMuc3Vic2NyaWJlciA9IG5ldyBQQ1RyYW5zcG9ydChydGNDb25maWcsIGxvZ2dlck9wdGlvbnMpO1xuXG4gICAgdGhpcy5wdWJsaXNoZXIub25Db25uZWN0aW9uU3RhdGVDaGFuZ2UgPSB0aGlzLnVwZGF0ZVN0YXRlO1xuICAgIHRoaXMuc3Vic2NyaWJlci5vbkNvbm5lY3Rpb25TdGF0ZUNoYW5nZSA9IHRoaXMudXBkYXRlU3RhdGU7XG4gICAgdGhpcy5wdWJsaXNoZXIub25JY2VDb25uZWN0aW9uU3RhdGVDaGFuZ2UgPSB0aGlzLnVwZGF0ZVN0YXRlO1xuICAgIHRoaXMuc3Vic2NyaWJlci5vbkljZUNvbm5lY3Rpb25TdGF0ZUNoYW5nZSA9IHRoaXMudXBkYXRlU3RhdGU7XG4gICAgdGhpcy5wdWJsaXNoZXIub25TaWduYWxpbmdTdGF0ZWNoYW5nZSA9IHRoaXMudXBkYXRlU3RhdGU7XG4gICAgdGhpcy5zdWJzY3JpYmVyLm9uU2lnbmFsaW5nU3RhdGVjaGFuZ2UgPSB0aGlzLnVwZGF0ZVN0YXRlO1xuICAgIHRoaXMucHVibGlzaGVyLm9uSWNlQ2FuZGlkYXRlID0gKGNhbmRpZGF0ZSkgPT4ge1xuICAgICAgdGhpcy5vbkljZUNhbmRpZGF0ZT8uKGNhbmRpZGF0ZSwgU2lnbmFsVGFyZ2V0LlBVQkxJU0hFUik7XG4gICAgfTtcbiAgICB0aGlzLnN1YnNjcmliZXIub25JY2VDYW5kaWRhdGUgPSAoY2FuZGlkYXRlKSA9PiB7XG4gICAgICB0aGlzLm9uSWNlQ2FuZGlkYXRlPy4oY2FuZGlkYXRlLCBTaWduYWxUYXJnZXQuU1VCU0NSSUJFUik7XG4gICAgfTtcbiAgICAvLyBpbiBzdWJzY3JpYmVyIHByaW1hcnkgbW9kZSwgc2VydmVyIHNpZGUgb3BlbnMgc3ViIGRhdGEgY2hhbm5lbHMuXG4gICAgdGhpcy5zdWJzY3JpYmVyLm9uRGF0YUNoYW5uZWwgPSAoZXYpID0+IHtcbiAgICAgIHRoaXMub25EYXRhQ2hhbm5lbD8uKGV2KTtcbiAgICB9O1xuICAgIHRoaXMuc3Vic2NyaWJlci5vblRyYWNrID0gKGV2KSA9PiB7XG4gICAgICB0aGlzLm9uVHJhY2s/Lihldik7XG4gICAgfTtcbiAgICB0aGlzLnB1Ymxpc2hlci5vbk9mZmVyID0gKG9mZmVyKSA9PiB7XG4gICAgICB0aGlzLm9uUHVibGlzaGVyT2ZmZXI/LihvZmZlcik7XG4gICAgfTtcblxuICAgIHRoaXMuc3RhdGUgPSBQQ1RyYW5zcG9ydFN0YXRlLk5FVztcblxuICAgIHRoaXMuY29ubmVjdGlvbkxvY2sgPSBuZXcgTXV0ZXgoKTtcbiAgfVxuXG4gIHByaXZhdGUgZ2V0IGxvZ0NvbnRleHQoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnRoaXMubG9nZ2VyT3B0aW9ucy5sb2dnZXJDb250ZXh0Q2I/LigpLFxuICAgIH07XG4gIH1cblxuICByZXF1aXJlUHVibGlzaGVyKHJlcXVpcmUgPSB0cnVlKSB7XG4gICAgdGhpcy5pc1B1Ymxpc2hlckNvbm5lY3Rpb25SZXF1aXJlZCA9IHJlcXVpcmU7XG4gICAgdGhpcy51cGRhdGVTdGF0ZSgpO1xuICB9XG5cbiAgcmVxdWlyZVN1YnNjcmliZXIocmVxdWlyZSA9IHRydWUpIHtcbiAgICB0aGlzLmlzU3Vic2NyaWJlckNvbm5lY3Rpb25SZXF1aXJlZCA9IHJlcXVpcmU7XG4gICAgdGhpcy51cGRhdGVTdGF0ZSgpO1xuICB9XG5cbiAgY3JlYXRlQW5kU2VuZFB1Ymxpc2hlck9mZmVyKG9wdGlvbnM/OiBSVENPZmZlck9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5wdWJsaXNoZXIuY3JlYXRlQW5kU2VuZE9mZmVyKG9wdGlvbnMpO1xuICB9XG5cbiAgc2V0UHVibGlzaGVyQW5zd2VyKHNkOiBSVENTZXNzaW9uRGVzY3JpcHRpb25Jbml0KSB7XG4gICAgcmV0dXJuIHRoaXMucHVibGlzaGVyLnNldFJlbW90ZURlc2NyaXB0aW9uKHNkKTtcbiAgfVxuXG4gIHJlbW92ZVRyYWNrKHNlbmRlcjogUlRDUnRwU2VuZGVyKSB7XG4gICAgcmV0dXJuIHRoaXMucHVibGlzaGVyLnJlbW92ZVRyYWNrKHNlbmRlcik7XG4gIH1cblxuICBhc3luYyBjbG9zZSgpIHtcbiAgICBpZiAodGhpcy5wdWJsaXNoZXIgJiYgdGhpcy5wdWJsaXNoZXIuZ2V0U2lnbmFsbGluZ1N0YXRlKCkgIT09ICdjbG9zZWQnKSB7XG4gICAgICBjb25zdCBwdWJsaXNoZXIgPSB0aGlzLnB1Ymxpc2hlcjtcbiAgICAgIGZvciAoY29uc3Qgc2VuZGVyIG9mIHB1Ymxpc2hlci5nZXRTZW5kZXJzKCkpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBUT0RPOiByZWFjdC1uYXRpdmUtd2VicnRjIGRvZXNuJ3QgaGF2ZSByZW1vdmVUcmFjayB5ZXQuXG4gICAgICAgICAgaWYgKHB1Ymxpc2hlci5jYW5SZW1vdmVUcmFjaygpKSB7XG4gICAgICAgICAgICBwdWJsaXNoZXIucmVtb3ZlVHJhY2soc2VuZGVyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICB0aGlzLmxvZy53YXJuKCdjb3VsZCBub3QgcmVtb3ZlVHJhY2snLCB7IC4uLnRoaXMubG9nQ29udGV4dCwgZXJyb3I6IGUgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgYXdhaXQgUHJvbWlzZS5hbGwoW3RoaXMucHVibGlzaGVyLmNsb3NlKCksIHRoaXMuc3Vic2NyaWJlci5jbG9zZSgpXSk7XG4gICAgdGhpcy51cGRhdGVTdGF0ZSgpO1xuICB9XG5cbiAgYXN5bmMgdHJpZ2dlckljZVJlc3RhcnQoKSB7XG4gICAgdGhpcy5zdWJzY3JpYmVyLnJlc3RhcnRpbmdJY2UgPSB0cnVlO1xuICAgIC8vIG9ubHkgcmVzdGFydCBwdWJsaXNoZXIgaWYgaXQncyBuZWVkZWRcbiAgICBpZiAodGhpcy5uZWVkc1B1Ymxpc2hlcikge1xuICAgICAgYXdhaXQgdGhpcy5jcmVhdGVBbmRTZW5kUHVibGlzaGVyT2ZmZXIoeyBpY2VSZXN0YXJ0OiB0cnVlIH0pO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGFkZEljZUNhbmRpZGF0ZShjYW5kaWRhdGU6IFJUQ0ljZUNhbmRpZGF0ZUluaXQsIHRhcmdldDogU2lnbmFsVGFyZ2V0KSB7XG4gICAgaWYgKHRhcmdldCA9PT0gU2lnbmFsVGFyZ2V0LlBVQkxJU0hFUikge1xuICAgICAgYXdhaXQgdGhpcy5wdWJsaXNoZXIuYWRkSWNlQ2FuZGlkYXRlKGNhbmRpZGF0ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGF3YWl0IHRoaXMuc3Vic2NyaWJlci5hZGRJY2VDYW5kaWRhdGUoY2FuZGlkYXRlKTtcbiAgICB9XG4gIH1cblxuICBhc3luYyBjcmVhdGVTdWJzY3JpYmVyQW5zd2VyRnJvbU9mZmVyKHNkOiBSVENTZXNzaW9uRGVzY3JpcHRpb25Jbml0KSB7XG4gICAgdGhpcy5sb2cuZGVidWcoJ3JlY2VpdmVkIHNlcnZlciBvZmZlcicsIHtcbiAgICAgIC4uLnRoaXMubG9nQ29udGV4dCxcbiAgICAgIFJUQ1NkcFR5cGU6IHNkLnR5cGUsXG4gICAgICBzZHA6IHNkLnNkcCxcbiAgICAgIHNpZ25hbGluZ1N0YXRlOiB0aGlzLnN1YnNjcmliZXIuZ2V0U2lnbmFsbGluZ1N0YXRlKCkudG9TdHJpbmcoKSxcbiAgICB9KTtcbiAgICBhd2FpdCB0aGlzLnN1YnNjcmliZXIuc2V0UmVtb3RlRGVzY3JpcHRpb24oc2QpO1xuXG4gICAgLy8gYW5zd2VyIHRoZSBvZmZlclxuICAgIGNvbnN0IGFuc3dlciA9IGF3YWl0IHRoaXMuc3Vic2NyaWJlci5jcmVhdGVBbmRTZXRBbnN3ZXIoKTtcbiAgICByZXR1cm4gYW5zd2VyO1xuICB9XG5cbiAgdXBkYXRlQ29uZmlndXJhdGlvbihjb25maWc6IFJUQ0NvbmZpZ3VyYXRpb24sIGljZVJlc3RhcnQ/OiBib29sZWFuKSB7XG4gICAgdGhpcy5wdWJsaXNoZXIuc2V0Q29uZmlndXJhdGlvbihjb25maWcpO1xuICAgIHRoaXMuc3Vic2NyaWJlci5zZXRDb25maWd1cmF0aW9uKGNvbmZpZyk7XG4gICAgaWYgKGljZVJlc3RhcnQpIHtcbiAgICAgIHRoaXMudHJpZ2dlckljZVJlc3RhcnQoKTtcbiAgICB9XG4gIH1cblxuICBhc3luYyBlbnN1cmVQQ1RyYW5zcG9ydENvbm5lY3Rpb24oYWJvcnRDb250cm9sbGVyPzogQWJvcnRDb250cm9sbGVyLCB0aW1lb3V0PzogbnVtYmVyKSB7XG4gICAgY29uc3QgdW5sb2NrID0gYXdhaXQgdGhpcy5jb25uZWN0aW9uTG9jay5sb2NrKCk7XG4gICAgdHJ5IHtcbiAgICAgIGlmIChcbiAgICAgICAgdGhpcy5pc1B1Ymxpc2hlckNvbm5lY3Rpb25SZXF1aXJlZCAmJlxuICAgICAgICB0aGlzLnB1Ymxpc2hlci5nZXRDb25uZWN0aW9uU3RhdGUoKSAhPT0gJ2Nvbm5lY3RlZCcgJiZcbiAgICAgICAgdGhpcy5wdWJsaXNoZXIuZ2V0Q29ubmVjdGlvblN0YXRlKCkgIT09ICdjb25uZWN0aW5nJ1xuICAgICAgKSB7XG4gICAgICAgIHRoaXMubG9nLmRlYnVnKCduZWdvdGlhdGlvbiByZXF1aXJlZCwgc3RhcnQgbmVnb3RpYXRpbmcnLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgICB0aGlzLnB1Ymxpc2hlci5uZWdvdGlhdGUoKTtcbiAgICAgIH1cbiAgICAgIGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgICB0aGlzLnJlcXVpcmVkVHJhbnNwb3J0cz8ubWFwKCh0cmFuc3BvcnQpID0+XG4gICAgICAgICAgdGhpcy5lbnN1cmVUcmFuc3BvcnRDb25uZWN0ZWQodHJhbnNwb3J0LCBhYm9ydENvbnRyb2xsZXIsIHRpbWVvdXQpLFxuICAgICAgICApLFxuICAgICAgKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdW5sb2NrKCk7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgbmVnb3RpYXRlKGFib3J0Q29udHJvbGxlcjogQWJvcnRDb250cm9sbGVyKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlPHZvaWQ+KGFzeW5jIChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNvbnN0IG5lZ290aWF0aW9uVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICByZWplY3QoJ25lZ290aWF0aW9uIHRpbWVkIG91dCcpO1xuICAgICAgfSwgdGhpcy5wZWVyQ29ubmVjdGlvblRpbWVvdXQpO1xuXG4gICAgICBjb25zdCBhYm9ydEhhbmRsZXIgPSAoKSA9PiB7XG4gICAgICAgIGNsZWFyVGltZW91dChuZWdvdGlhdGlvblRpbWVvdXQpO1xuICAgICAgICByZWplY3QoJ25lZ290aWF0aW9uIGFib3J0ZWQnKTtcbiAgICAgIH07XG5cbiAgICAgIGFib3J0Q29udHJvbGxlci5zaWduYWwuYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBhYm9ydEhhbmRsZXIpO1xuICAgICAgdGhpcy5wdWJsaXNoZXIub25jZShQQ0V2ZW50cy5OZWdvdGlhdGlvblN0YXJ0ZWQsICgpID0+IHtcbiAgICAgICAgaWYgKGFib3J0Q29udHJvbGxlci5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnB1Ymxpc2hlci5vbmNlKFBDRXZlbnRzLk5lZ290aWF0aW9uQ29tcGxldGUsICgpID0+IHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQobmVnb3RpYXRpb25UaW1lb3V0KTtcbiAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIGF3YWl0IHRoaXMucHVibGlzaGVyLm5lZ290aWF0ZSgoZSkgPT4ge1xuICAgICAgICBjbGVhclRpbWVvdXQobmVnb3RpYXRpb25UaW1lb3V0KTtcbiAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBhZGRQdWJsaXNoZXJUcmFuc2NlaXZlcih0cmFjazogTWVkaWFTdHJlYW1UcmFjaywgdHJhbnNjZWl2ZXJJbml0OiBSVENSdHBUcmFuc2NlaXZlckluaXQpIHtcbiAgICByZXR1cm4gdGhpcy5wdWJsaXNoZXIuYWRkVHJhbnNjZWl2ZXIodHJhY2ssIHRyYW5zY2VpdmVySW5pdCk7XG4gIH1cblxuICBhZGRQdWJsaXNoZXJUcmFjayh0cmFjazogTWVkaWFTdHJlYW1UcmFjaykge1xuICAgIHJldHVybiB0aGlzLnB1Ymxpc2hlci5hZGRUcmFjayh0cmFjayk7XG4gIH1cblxuICBjcmVhdGVQdWJsaXNoZXJEYXRhQ2hhbm5lbChsYWJlbDogc3RyaW5nLCBkYXRhQ2hhbm5lbERpY3Q6IFJUQ0RhdGFDaGFubmVsSW5pdCkge1xuICAgIHJldHVybiB0aGlzLnB1Ymxpc2hlci5jcmVhdGVEYXRhQ2hhbm5lbChsYWJlbCwgZGF0YUNoYW5uZWxEaWN0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBmaXJzdCByZXF1aXJlZCB0cmFuc3BvcnQncyBhZGRyZXNzIGlmIG5vIGV4cGxpY2l0IHRhcmdldCBpcyBzcGVjaWZpZWRcbiAgICovXG4gIGdldENvbm5lY3RlZEFkZHJlc3ModGFyZ2V0PzogU2lnbmFsVGFyZ2V0KSB7XG4gICAgaWYgKHRhcmdldCA9PT0gU2lnbmFsVGFyZ2V0LlBVQkxJU0hFUikge1xuICAgICAgcmV0dXJuIHRoaXMucHVibGlzaGVyLmdldENvbm5lY3RlZEFkZHJlc3MoKTtcbiAgICB9IGVsc2UgaWYgKHRhcmdldCA9PT0gU2lnbmFsVGFyZ2V0LlNVQlNDUklCRVIpIHtcbiAgICAgIHJldHVybiB0aGlzLnB1Ymxpc2hlci5nZXRDb25uZWN0ZWRBZGRyZXNzKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnJlcXVpcmVkVHJhbnNwb3J0c1swXS5nZXRDb25uZWN0ZWRBZGRyZXNzKCk7XG4gIH1cblxuICBwcml2YXRlIGdldCByZXF1aXJlZFRyYW5zcG9ydHMoKSB7XG4gICAgY29uc3QgdHJhbnNwb3J0czogUENUcmFuc3BvcnRbXSA9IFtdO1xuICAgIGlmICh0aGlzLmlzUHVibGlzaGVyQ29ubmVjdGlvblJlcXVpcmVkKSB7XG4gICAgICB0cmFuc3BvcnRzLnB1c2godGhpcy5wdWJsaXNoZXIpO1xuICAgIH1cbiAgICBpZiAodGhpcy5pc1N1YnNjcmliZXJDb25uZWN0aW9uUmVxdWlyZWQpIHtcbiAgICAgIHRyYW5zcG9ydHMucHVzaCh0aGlzLnN1YnNjcmliZXIpO1xuICAgIH1cbiAgICByZXR1cm4gdHJhbnNwb3J0cztcbiAgfVxuXG4gIHByaXZhdGUgdXBkYXRlU3RhdGUgPSAoKSA9PiB7XG4gICAgY29uc3QgcHJldmlvdXNTdGF0ZSA9IHRoaXMuc3RhdGU7XG5cbiAgICBjb25zdCBjb25uZWN0aW9uU3RhdGVzID0gdGhpcy5yZXF1aXJlZFRyYW5zcG9ydHMubWFwKCh0cikgPT4gdHIuZ2V0Q29ubmVjdGlvblN0YXRlKCkpO1xuICAgIGlmIChjb25uZWN0aW9uU3RhdGVzLmV2ZXJ5KChzdCkgPT4gc3QgPT09ICdjb25uZWN0ZWQnKSkge1xuICAgICAgdGhpcy5zdGF0ZSA9IFBDVHJhbnNwb3J0U3RhdGUuQ09OTkVDVEVEO1xuICAgIH0gZWxzZSBpZiAoY29ubmVjdGlvblN0YXRlcy5zb21lKChzdCkgPT4gc3QgPT09ICdmYWlsZWQnKSkge1xuICAgICAgdGhpcy5zdGF0ZSA9IFBDVHJhbnNwb3J0U3RhdGUuRkFJTEVEO1xuICAgIH0gZWxzZSBpZiAoY29ubmVjdGlvblN0YXRlcy5zb21lKChzdCkgPT4gc3QgPT09ICdjb25uZWN0aW5nJykpIHtcbiAgICAgIHRoaXMuc3RhdGUgPSBQQ1RyYW5zcG9ydFN0YXRlLkNPTk5FQ1RJTkc7XG4gICAgfSBlbHNlIGlmIChjb25uZWN0aW9uU3RhdGVzLmV2ZXJ5KChzdCkgPT4gc3QgPT09ICdjbG9zZWQnKSkge1xuICAgICAgdGhpcy5zdGF0ZSA9IFBDVHJhbnNwb3J0U3RhdGUuQ0xPU0VEO1xuICAgIH0gZWxzZSBpZiAoY29ubmVjdGlvblN0YXRlcy5zb21lKChzdCkgPT4gc3QgPT09ICdjbG9zZWQnKSkge1xuICAgICAgdGhpcy5zdGF0ZSA9IFBDVHJhbnNwb3J0U3RhdGUuQ0xPU0lORztcbiAgICB9IGVsc2UgaWYgKGNvbm5lY3Rpb25TdGF0ZXMuZXZlcnkoKHN0KSA9PiBzdCA9PT0gJ25ldycpKSB7XG4gICAgICB0aGlzLnN0YXRlID0gUENUcmFuc3BvcnRTdGF0ZS5ORVc7XG4gICAgfVxuXG4gICAgaWYgKHByZXZpb3VzU3RhdGUgIT09IHRoaXMuc3RhdGUpIHtcbiAgICAgIHRoaXMubG9nLmRlYnVnKFxuICAgICAgICBgcGMgc3RhdGUgY2hhbmdlOiBmcm9tICR7UENUcmFuc3BvcnRTdGF0ZVtwcmV2aW91c1N0YXRlXX0gdG8gJHtcbiAgICAgICAgICBQQ1RyYW5zcG9ydFN0YXRlW3RoaXMuc3RhdGVdXG4gICAgICAgIH1gLFxuICAgICAgICB0aGlzLmxvZ0NvbnRleHQsXG4gICAgICApO1xuICAgICAgdGhpcy5vblN0YXRlQ2hhbmdlPy4oXG4gICAgICAgIHRoaXMuc3RhdGUsXG4gICAgICAgIHRoaXMucHVibGlzaGVyLmdldENvbm5lY3Rpb25TdGF0ZSgpLFxuICAgICAgICB0aGlzLnN1YnNjcmliZXIuZ2V0Q29ubmVjdGlvblN0YXRlKCksXG4gICAgICApO1xuICAgIH1cbiAgfTtcblxuICBwcml2YXRlIGFzeW5jIGVuc3VyZVRyYW5zcG9ydENvbm5lY3RlZChcbiAgICBwY1RyYW5zcG9ydDogUENUcmFuc3BvcnQsXG4gICAgYWJvcnRDb250cm9sbGVyPzogQWJvcnRDb250cm9sbGVyLFxuICAgIHRpbWVvdXQ6IG51bWJlciA9IHRoaXMucGVlckNvbm5lY3Rpb25UaW1lb3V0LFxuICApIHtcbiAgICBjb25zdCBjb25uZWN0aW9uU3RhdGUgPSBwY1RyYW5zcG9ydC5nZXRDb25uZWN0aW9uU3RhdGUoKTtcbiAgICBpZiAoY29ubmVjdGlvblN0YXRlID09PSAnY29ubmVjdGVkJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgUHJvbWlzZTx2b2lkPihhc3luYyAocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjb25zdCBhYm9ydEhhbmRsZXIgPSAoKSA9PiB7XG4gICAgICAgIHRoaXMubG9nLndhcm4oJ2Fib3J0IHRyYW5zcG9ydCBjb25uZWN0aW9uJywgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgICAgQ3JpdGljYWxUaW1lcnMuY2xlYXJUaW1lb3V0KGNvbm5lY3RUaW1lb3V0KTtcblxuICAgICAgICByZWplY3QoXG4gICAgICAgICAgbmV3IENvbm5lY3Rpb25FcnJvcihcbiAgICAgICAgICAgICdyb29tIGNvbm5lY3Rpb24gaGFzIGJlZW4gY2FuY2VsbGVkJyxcbiAgICAgICAgICAgIENvbm5lY3Rpb25FcnJvclJlYXNvbi5DYW5jZWxsZWQsXG4gICAgICAgICAgKSxcbiAgICAgICAgKTtcbiAgICAgIH07XG4gICAgICBpZiAoYWJvcnRDb250cm9sbGVyPy5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgICBhYm9ydEhhbmRsZXIoKTtcbiAgICAgIH1cbiAgICAgIGFib3J0Q29udHJvbGxlcj8uc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgYWJvcnRIYW5kbGVyKTtcblxuICAgICAgY29uc3QgY29ubmVjdFRpbWVvdXQgPSBDcml0aWNhbFRpbWVycy5zZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgYWJvcnRDb250cm9sbGVyPy5zaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBhYm9ydEhhbmRsZXIpO1xuICAgICAgICByZWplY3QobmV3IENvbm5lY3Rpb25FcnJvcignY291bGQgbm90IGVzdGFibGlzaCBwYyBjb25uZWN0aW9uJykpO1xuICAgICAgfSwgdGltZW91dCk7XG5cbiAgICAgIHdoaWxlICh0aGlzLnN0YXRlICE9PSBQQ1RyYW5zcG9ydFN0YXRlLkNPTk5FQ1RFRCkge1xuICAgICAgICBhd2FpdCBzbGVlcCg1MCk7IC8vIEZJWE1FIHdlIHNob3VsZG4ndCByZWx5IG9uIGBzbGVlcGAgaW4gdGhlIGNvbm5lY3Rpb24gcGF0aHMsIGFzIGl0IGludm9rZXMgYHNldFRpbWVvdXRgIHdoaWNoIGNhbiBiZSBkcmFzdGljYWxseSB0aHJvdHRsZWQgYnkgYnJvd3NlciBpbXBsZW1lbnRhdGlvbnNcbiAgICAgICAgaWYgKGFib3J0Q29udHJvbGxlcj8uc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgICByZWplY3QoXG4gICAgICAgICAgICBuZXcgQ29ubmVjdGlvbkVycm9yKFxuICAgICAgICAgICAgICAncm9vbSBjb25uZWN0aW9uIGhhcyBiZWVuIGNhbmNlbGxlZCcsXG4gICAgICAgICAgICAgIENvbm5lY3Rpb25FcnJvclJlYXNvbi5DYW5jZWxsZWQsXG4gICAgICAgICAgICApLFxuICAgICAgICAgICk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBDcml0aWNhbFRpbWVycy5jbGVhclRpbWVvdXQoY29ubmVjdFRpbWVvdXQpO1xuICAgICAgYWJvcnRDb250cm9sbGVyPy5zaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBhYm9ydEhhbmRsZXIpO1xuICAgICAgcmVzb2x2ZSgpO1xuICAgIH0pO1xuICB9XG59XG4iLCJpbXBvcnQgeyBFdmVudEVtaXR0ZXIgfSBmcm9tICdldmVudHMnO1xuaW1wb3J0IHR5cGUgeyBNZWRpYUF0dHJpYnV0ZXMgfSBmcm9tICdzZHAtdHJhbnNmb3JtJztcbmltcG9ydCB0eXBlIFR5cGVkRXZlbnRFbWl0dGVyIGZyb20gJ3R5cGVkLWVtaXR0ZXInO1xuaW1wb3J0IHR5cGUgeyBTaWduYWxPcHRpb25zIH0gZnJvbSAnLi4vYXBpL1NpZ25hbENsaWVudCc7XG5pbXBvcnQge1xuICBTaWduYWxDbGllbnQsXG4gIFNpZ25hbENvbm5lY3Rpb25TdGF0ZSxcbiAgdG9Qcm90b1Nlc3Npb25EZXNjcmlwdGlvbixcbn0gZnJvbSAnLi4vYXBpL1NpZ25hbENsaWVudCc7XG5pbXBvcnQgbG9nLCB7IExvZ2dlck5hbWVzLCBnZXRMb2dnZXIgfSBmcm9tICcuLi9sb2dnZXInO1xuaW1wb3J0IHR5cGUgeyBJbnRlcm5hbFJvb21PcHRpb25zIH0gZnJvbSAnLi4vb3B0aW9ucyc7XG5pbXBvcnQge1xuICBDbGllbnRDb25maWdTZXR0aW5nLFxuICBDbGllbnRDb25maWd1cmF0aW9uLFxuICBEYXRhUGFja2V0LFxuICBEYXRhUGFja2V0X0tpbmQsXG4gIERpc2Nvbm5lY3RSZWFzb24sXG4gIFBhcnRpY2lwYW50SW5mbyxcbiAgUmVjb25uZWN0UmVhc29uLFxuICBSb29tIGFzIFJvb21Nb2RlbCxcbiAgU3BlYWtlckluZm8sXG4gIFRyYWNrSW5mbyxcbiAgVXNlclBhY2tldCxcbn0gZnJvbSAnLi4vcHJvdG8vbGl2ZWtpdF9tb2RlbHNfcGInO1xuaW1wb3J0IHtcbiAgdHlwZSBBZGRUcmFja1JlcXVlc3QsXG4gIHR5cGUgQ29ubmVjdGlvblF1YWxpdHlVcGRhdGUsXG4gIERhdGFDaGFubmVsSW5mbyxcbiAgdHlwZSBKb2luUmVzcG9uc2UsXG4gIHR5cGUgTGVhdmVSZXF1ZXN0LFxuICB0eXBlIFJlY29ubmVjdFJlc3BvbnNlLFxuICBTaWduYWxUYXJnZXQsXG4gIHR5cGUgU3RyZWFtU3RhdGVVcGRhdGUsXG4gIFN1YnNjcmliZWRRdWFsaXR5VXBkYXRlLFxuICB0eXBlIFN1YnNjcmlwdGlvblBlcm1pc3Npb25VcGRhdGUsXG4gIHR5cGUgU3Vic2NyaXB0aW9uUmVzcG9uc2UsXG4gIFN5bmNTdGF0ZSxcbiAgdHlwZSBUcmFja1B1Ymxpc2hlZFJlc3BvbnNlLFxuICBUcmFja1VucHVibGlzaGVkUmVzcG9uc2UsXG4gIFVwZGF0ZVN1YnNjcmlwdGlvbixcbn0gZnJvbSAnLi4vcHJvdG8vbGl2ZWtpdF9ydGNfcGInO1xuaW1wb3J0IFBDVHJhbnNwb3J0LCB7IFBDRXZlbnRzIH0gZnJvbSAnLi9QQ1RyYW5zcG9ydCc7XG5pbXBvcnQgeyBQQ1RyYW5zcG9ydE1hbmFnZXIsIFBDVHJhbnNwb3J0U3RhdGUgfSBmcm9tICcuL1BDVHJhbnNwb3J0TWFuYWdlcic7XG5pbXBvcnQgdHlwZSB7IFJlY29ubmVjdENvbnRleHQsIFJlY29ubmVjdFBvbGljeSB9IGZyb20gJy4vUmVjb25uZWN0UG9saWN5JztcbmltcG9ydCB0eXBlIHsgUmVnaW9uVXJsUHJvdmlkZXIgfSBmcm9tICcuL1JlZ2lvblVybFByb3ZpZGVyJztcbmltcG9ydCB7IHJvb21Db25uZWN0T3B0aW9uRGVmYXVsdHMgfSBmcm9tICcuL2RlZmF1bHRzJztcbmltcG9ydCB7XG4gIENvbm5lY3Rpb25FcnJvcixcbiAgQ29ubmVjdGlvbkVycm9yUmVhc29uLFxuICBOZWdvdGlhdGlvbkVycm9yLFxuICBUcmFja0ludmFsaWRFcnJvcixcbiAgVW5leHBlY3RlZENvbm5lY3Rpb25TdGF0ZSxcbn0gZnJvbSAnLi9lcnJvcnMnO1xuaW1wb3J0IHsgRW5naW5lRXZlbnQgfSBmcm9tICcuL2V2ZW50cyc7XG5pbXBvcnQgQ3JpdGljYWxUaW1lcnMgZnJvbSAnLi90aW1lcnMnO1xuaW1wb3J0IHR5cGUgTG9jYWxUcmFjayBmcm9tICcuL3RyYWNrL0xvY2FsVHJhY2snO1xuaW1wb3J0IHR5cGUgTG9jYWxUcmFja1B1YmxpY2F0aW9uIGZyb20gJy4vdHJhY2svTG9jYWxUcmFja1B1YmxpY2F0aW9uJztcbmltcG9ydCB0eXBlIExvY2FsVmlkZW9UcmFjayBmcm9tICcuL3RyYWNrL0xvY2FsVmlkZW9UcmFjayc7XG5pbXBvcnQgdHlwZSB7IFNpbXVsY2FzdFRyYWNrSW5mbyB9IGZyb20gJy4vdHJhY2svTG9jYWxWaWRlb1RyYWNrJztcbmltcG9ydCB0eXBlIFJlbW90ZVRyYWNrUHVibGljYXRpb24gZnJvbSAnLi90cmFjay9SZW1vdGVUcmFja1B1YmxpY2F0aW9uJztcbmltcG9ydCB7IFRyYWNrIH0gZnJvbSAnLi90cmFjay9UcmFjayc7XG5pbXBvcnQgdHlwZSB7IFRyYWNrUHVibGlzaE9wdGlvbnMsIFZpZGVvQ29kZWMgfSBmcm9tICcuL3RyYWNrL29wdGlvbnMnO1xuaW1wb3J0IHsgZ2V0VHJhY2tQdWJsaWNhdGlvbkluZm8gfSBmcm9tICcuL3RyYWNrL3V0aWxzJztcbmltcG9ydCB0eXBlIHsgTG9nZ2VyT3B0aW9ucyB9IGZyb20gJy4vdHlwZXMnO1xuaW1wb3J0IHtcbiAgTXV0ZXgsXG4gIGlzVmlkZW9Db2RlYyxcbiAgaXNXZWIsXG4gIHNsZWVwLFxuICBzdXBwb3J0c0FkZFRyYWNrLFxuICBzdXBwb3J0c1NldENvZGVjUHJlZmVyZW5jZXMsXG4gIHN1cHBvcnRzVHJhbnNjZWl2ZXIsXG59IGZyb20gJy4vdXRpbHMnO1xuXG5jb25zdCBsb3NzeURhdGFDaGFubmVsID0gJ19sb3NzeSc7XG5jb25zdCByZWxpYWJsZURhdGFDaGFubmVsID0gJ19yZWxpYWJsZSc7XG5jb25zdCBtaW5SZWNvbm5lY3RXYWl0ID0gMiAqIDEwMDA7XG5jb25zdCBsZWF2ZVJlY29ubmVjdCA9ICdsZWF2ZS1yZWNvbm5lY3QnO1xuXG5lbnVtIFBDU3RhdGUge1xuICBOZXcsXG4gIENvbm5lY3RlZCxcbiAgRGlzY29ubmVjdGVkLFxuICBSZWNvbm5lY3RpbmcsXG4gIENsb3NlZCxcbn1cblxuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUlRDRW5naW5lIGV4dGVuZHMgKEV2ZW50RW1pdHRlciBhcyBuZXcgKCkgPT4gVHlwZWRFdmVudEVtaXR0ZXI8RW5naW5lRXZlbnRDYWxsYmFja3M+KSB7XG4gIGNsaWVudDogU2lnbmFsQ2xpZW50O1xuXG4gIHJ0Y0NvbmZpZzogUlRDQ29uZmlndXJhdGlvbiA9IHt9O1xuXG4gIHBlZXJDb25uZWN0aW9uVGltZW91dDogbnVtYmVyID0gcm9vbUNvbm5lY3RPcHRpb25EZWZhdWx0cy5wZWVyQ29ubmVjdGlvblRpbWVvdXQ7XG5cbiAgZnVsbFJlY29ubmVjdE9uTmV4dDogYm9vbGVhbiA9IGZhbHNlO1xuXG4gIHBjTWFuYWdlcj86IFBDVHJhbnNwb3J0TWFuYWdlcjtcblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBsYXRlc3RKb2luUmVzcG9uc2U/OiBKb2luUmVzcG9uc2U7XG5cbiAgZ2V0IGlzQ2xvc2VkKCkge1xuICAgIHJldHVybiB0aGlzLl9pc0Nsb3NlZDtcbiAgfVxuXG4gIHByaXZhdGUgbG9zc3lEQz86IFJUQ0RhdGFDaGFubmVsO1xuXG4gIC8vIEB0cy1pZ25vcmUgbm9VbnVzZWRMb2NhbHNcbiAgcHJpdmF0ZSBsb3NzeURDU3ViPzogUlRDRGF0YUNoYW5uZWw7XG5cbiAgcHJpdmF0ZSByZWxpYWJsZURDPzogUlRDRGF0YUNoYW5uZWw7XG5cbiAgcHJpdmF0ZSBkY0J1ZmZlclN0YXR1czogTWFwPERhdGFQYWNrZXRfS2luZCwgYm9vbGVhbj47XG5cbiAgLy8gQHRzLWlnbm9yZSBub1VudXNlZExvY2Fsc1xuICBwcml2YXRlIHJlbGlhYmxlRENTdWI/OiBSVENEYXRhQ2hhbm5lbDtcblxuICBwcml2YXRlIHN1YnNjcmliZXJQcmltYXJ5OiBib29sZWFuID0gZmFsc2U7XG5cbiAgcHJpdmF0ZSBwY1N0YXRlOiBQQ1N0YXRlID0gUENTdGF0ZS5OZXc7XG5cbiAgcHJpdmF0ZSBfaXNDbG9zZWQ6IGJvb2xlYW4gPSB0cnVlO1xuXG4gIHByaXZhdGUgcGVuZGluZ1RyYWNrUmVzb2x2ZXJzOiB7XG4gICAgW2tleTogc3RyaW5nXTogeyByZXNvbHZlOiAoaW5mbzogVHJhY2tJbmZvKSA9PiB2b2lkOyByZWplY3Q6ICgpID0+IHZvaWQgfTtcbiAgfSA9IHt9O1xuXG4gIC8vIGtlZXAgam9pbiBpbmZvIGFyb3VuZCBmb3IgcmVjb25uZWN0LCB0aGlzIGNvdWxkIGJlIGEgcmVnaW9uIHVybFxuICBwcml2YXRlIHVybD86IHN0cmluZztcblxuICBwcml2YXRlIHRva2VuPzogc3RyaW5nO1xuXG4gIHByaXZhdGUgc2lnbmFsT3B0cz86IFNpZ25hbE9wdGlvbnM7XG5cbiAgcHJpdmF0ZSByZWNvbm5lY3RBdHRlbXB0czogbnVtYmVyID0gMDtcblxuICBwcml2YXRlIHJlY29ubmVjdFN0YXJ0OiBudW1iZXIgPSAwO1xuXG4gIHByaXZhdGUgY2xpZW50Q29uZmlndXJhdGlvbj86IENsaWVudENvbmZpZ3VyYXRpb247XG5cbiAgcHJpdmF0ZSBhdHRlbXB0aW5nUmVjb25uZWN0OiBib29sZWFuID0gZmFsc2U7XG5cbiAgcHJpdmF0ZSByZWNvbm5lY3RQb2xpY3k6IFJlY29ubmVjdFBvbGljeTtcblxuICBwcml2YXRlIHJlY29ubmVjdFRpbWVvdXQ/OiBSZXR1cm5UeXBlPHR5cGVvZiBzZXRUaW1lb3V0PjtcblxuICBwcml2YXRlIHBhcnRpY2lwYW50U2lkPzogc3RyaW5nO1xuXG4gIC8qKiBrZWVwcyB0cmFjayBvZiBob3cgb2Z0ZW4gYW4gaW5pdGlhbCBqb2luIGNvbm5lY3Rpb24gaGFzIGJlZW4gdHJpZWQgKi9cbiAgcHJpdmF0ZSBqb2luQXR0ZW1wdHM6IG51bWJlciA9IDA7XG5cbiAgLyoqIHNwZWNpZmllcyBob3cgb2Z0ZW4gYW4gaW5pdGlhbCBqb2luIGNvbm5lY3Rpb24gaXMgYWxsb3dlZCB0byByZXRyeSAqL1xuICBwcml2YXRlIG1heEpvaW5BdHRlbXB0czogbnVtYmVyID0gMTtcblxuICBwcml2YXRlIGNsb3NpbmdMb2NrOiBNdXRleDtcblxuICBwcml2YXRlIGRhdGFQcm9jZXNzTG9jazogTXV0ZXg7XG5cbiAgcHJpdmF0ZSBzaG91bGRGYWlsTmV4dDogYm9vbGVhbiA9IGZhbHNlO1xuXG4gIHByaXZhdGUgcmVnaW9uVXJsUHJvdmlkZXI/OiBSZWdpb25VcmxQcm92aWRlcjtcblxuICBwcml2YXRlIGxvZyA9IGxvZztcblxuICBwcml2YXRlIGxvZ2dlck9wdGlvbnM6IExvZ2dlck9wdGlvbnM7XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSBvcHRpb25zOiBJbnRlcm5hbFJvb21PcHRpb25zKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmxvZyA9IGdldExvZ2dlcihvcHRpb25zLmxvZ2dlck5hbWUgPz8gTG9nZ2VyTmFtZXMuRW5naW5lKTtcbiAgICB0aGlzLmxvZ2dlck9wdGlvbnMgPSB7XG4gICAgICBsb2dnZXJOYW1lOiBvcHRpb25zLmxvZ2dlck5hbWUsXG4gICAgICBsb2dnZXJDb250ZXh0Q2I6ICgpID0+IHRoaXMubG9nQ29udGV4dCxcbiAgICB9O1xuICAgIHRoaXMuY2xpZW50ID0gbmV3IFNpZ25hbENsaWVudCh1bmRlZmluZWQsIHRoaXMubG9nZ2VyT3B0aW9ucyk7XG4gICAgdGhpcy5jbGllbnQuc2lnbmFsTGF0ZW5jeSA9IHRoaXMub3B0aW9ucy5leHBTaWduYWxMYXRlbmN5O1xuICAgIHRoaXMucmVjb25uZWN0UG9saWN5ID0gdGhpcy5vcHRpb25zLnJlY29ubmVjdFBvbGljeTtcbiAgICB0aGlzLnJlZ2lzdGVyT25MaW5lTGlzdGVuZXIoKTtcbiAgICB0aGlzLmNsb3NpbmdMb2NrID0gbmV3IE11dGV4KCk7XG4gICAgdGhpcy5kYXRhUHJvY2Vzc0xvY2sgPSBuZXcgTXV0ZXgoKTtcbiAgICB0aGlzLmRjQnVmZmVyU3RhdHVzID0gbmV3IE1hcChbXG4gICAgICBbRGF0YVBhY2tldF9LaW5kLkxPU1NZLCB0cnVlXSxcbiAgICAgIFtEYXRhUGFja2V0X0tpbmQuUkVMSUFCTEUsIHRydWVdLFxuICAgIF0pO1xuXG4gICAgdGhpcy5jbGllbnQub25QYXJ0aWNpcGFudFVwZGF0ZSA9ICh1cGRhdGVzKSA9PlxuICAgICAgdGhpcy5lbWl0KEVuZ2luZUV2ZW50LlBhcnRpY2lwYW50VXBkYXRlLCB1cGRhdGVzKTtcbiAgICB0aGlzLmNsaWVudC5vbkNvbm5lY3Rpb25RdWFsaXR5ID0gKHVwZGF0ZSkgPT5cbiAgICAgIHRoaXMuZW1pdChFbmdpbmVFdmVudC5Db25uZWN0aW9uUXVhbGl0eVVwZGF0ZSwgdXBkYXRlKTtcbiAgICB0aGlzLmNsaWVudC5vblJvb21VcGRhdGUgPSAodXBkYXRlKSA9PiB0aGlzLmVtaXQoRW5naW5lRXZlbnQuUm9vbVVwZGF0ZSwgdXBkYXRlKTtcbiAgICB0aGlzLmNsaWVudC5vblN1YnNjcmlwdGlvbkVycm9yID0gKHJlc3ApID0+IHRoaXMuZW1pdChFbmdpbmVFdmVudC5TdWJzY3JpcHRpb25FcnJvciwgcmVzcCk7XG4gICAgdGhpcy5jbGllbnQub25TdWJzY3JpcHRpb25QZXJtaXNzaW9uVXBkYXRlID0gKHVwZGF0ZSkgPT5cbiAgICAgIHRoaXMuZW1pdChFbmdpbmVFdmVudC5TdWJzY3JpcHRpb25QZXJtaXNzaW9uVXBkYXRlLCB1cGRhdGUpO1xuICAgIHRoaXMuY2xpZW50Lm9uU3BlYWtlcnNDaGFuZ2VkID0gKHVwZGF0ZSkgPT4gdGhpcy5lbWl0KEVuZ2luZUV2ZW50LlNwZWFrZXJzQ2hhbmdlZCwgdXBkYXRlKTtcbiAgICB0aGlzLmNsaWVudC5vblN0cmVhbVN0YXRlVXBkYXRlID0gKHVwZGF0ZSkgPT4gdGhpcy5lbWl0KEVuZ2luZUV2ZW50LlN0cmVhbVN0YXRlQ2hhbmdlZCwgdXBkYXRlKTtcbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgZ2V0IGxvZ0NvbnRleHQoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJvb206IHRoaXMubGF0ZXN0Sm9pblJlc3BvbnNlPy5yb29tPy5uYW1lLFxuICAgICAgcm9vbVNpZDogdGhpcy5sYXRlc3RKb2luUmVzcG9uc2U/LnJvb20/LnNpZCxcbiAgICAgIGlkZW50aXR5OiB0aGlzLmxhdGVzdEpvaW5SZXNwb25zZT8ucGFydGljaXBhbnQ/LmlkZW50aXR5LFxuICAgIH07XG4gIH1cblxuICBhc3luYyBqb2luKFxuICAgIHVybDogc3RyaW5nLFxuICAgIHRva2VuOiBzdHJpbmcsXG4gICAgb3B0czogU2lnbmFsT3B0aW9ucyxcbiAgICBhYm9ydFNpZ25hbD86IEFib3J0U2lnbmFsLFxuICApOiBQcm9taXNlPEpvaW5SZXNwb25zZT4ge1xuICAgIHRoaXMudXJsID0gdXJsO1xuICAgIHRoaXMudG9rZW4gPSB0b2tlbjtcbiAgICB0aGlzLnNpZ25hbE9wdHMgPSBvcHRzO1xuICAgIHRoaXMubWF4Sm9pbkF0dGVtcHRzID0gb3B0cy5tYXhSZXRyaWVzO1xuICAgIHRyeSB7XG4gICAgICB0aGlzLmpvaW5BdHRlbXB0cyArPSAxO1xuXG4gICAgICB0aGlzLnNldHVwU2lnbmFsQ2xpZW50Q2FsbGJhY2tzKCk7XG4gICAgICBjb25zdCBqb2luUmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNsaWVudC5qb2luKHVybCwgdG9rZW4sIG9wdHMsIGFib3J0U2lnbmFsKTtcbiAgICAgIHRoaXMuX2lzQ2xvc2VkID0gZmFsc2U7XG4gICAgICB0aGlzLmxhdGVzdEpvaW5SZXNwb25zZSA9IGpvaW5SZXNwb25zZTtcblxuICAgICAgdGhpcy5zdWJzY3JpYmVyUHJpbWFyeSA9IGpvaW5SZXNwb25zZS5zdWJzY3JpYmVyUHJpbWFyeTtcbiAgICAgIGlmICghdGhpcy5wY01hbmFnZXIpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5jb25maWd1cmUoam9pblJlc3BvbnNlKTtcbiAgICAgIH1cblxuICAgICAgLy8gY3JlYXRlIG9mZmVyXG4gICAgICBpZiAoIXRoaXMuc3Vic2NyaWJlclByaW1hcnkpIHtcbiAgICAgICAgdGhpcy5uZWdvdGlhdGUoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5jbGllbnRDb25maWd1cmF0aW9uID0gam9pblJlc3BvbnNlLmNsaWVudENvbmZpZ3VyYXRpb247XG4gICAgICByZXR1cm4gam9pblJlc3BvbnNlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmIChlIGluc3RhbmNlb2YgQ29ubmVjdGlvbkVycm9yKSB7XG4gICAgICAgIGlmIChlLnJlYXNvbiA9PT0gQ29ubmVjdGlvbkVycm9yUmVhc29uLlNlcnZlclVucmVhY2hhYmxlKSB7XG4gICAgICAgICAgdGhpcy5sb2cud2FybihcbiAgICAgICAgICAgIGBDb3VsZG4ndCBjb25uZWN0IHRvIHNlcnZlciwgYXR0ZW1wdCAke3RoaXMuam9pbkF0dGVtcHRzfSBvZiAke3RoaXMubWF4Sm9pbkF0dGVtcHRzfWAsXG4gICAgICAgICAgICB0aGlzLmxvZ0NvbnRleHQsXG4gICAgICAgICAgKTtcbiAgICAgICAgICBpZiAodGhpcy5qb2luQXR0ZW1wdHMgPCB0aGlzLm1heEpvaW5BdHRlbXB0cykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuam9pbih1cmwsIHRva2VuLCBvcHRzLCBhYm9ydFNpZ25hbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aHJvdyBlO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGNsb3NlKCkge1xuICAgIGNvbnN0IHVubG9jayA9IGF3YWl0IHRoaXMuY2xvc2luZ0xvY2subG9jaygpO1xuICAgIGlmICh0aGlzLmlzQ2xvc2VkKSB7XG4gICAgICB1bmxvY2soKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuX2lzQ2xvc2VkID0gdHJ1ZTtcbiAgICAgIHRoaXMuZW1pdChFbmdpbmVFdmVudC5DbG9zaW5nKTtcbiAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgICB0aGlzLmRlcmVnaXN0ZXJPbkxpbmVMaXN0ZW5lcigpO1xuICAgICAgdGhpcy5jbGVhclBlbmRpbmdSZWNvbm5lY3QoKTtcbiAgICAgIGF3YWl0IHRoaXMuY2xlYW51cFBlZXJDb25uZWN0aW9ucygpO1xuICAgICAgYXdhaXQgdGhpcy5jbGVhbnVwQ2xpZW50KCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHVubG9jaygpO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGNsZWFudXBQZWVyQ29ubmVjdGlvbnMoKSB7XG4gICAgYXdhaXQgdGhpcy5wY01hbmFnZXI/LmNsb3NlKCk7XG4gICAgdGhpcy5wY01hbmFnZXIgPSB1bmRlZmluZWQ7XG5cbiAgICBjb25zdCBkY0NsZWFudXAgPSAoZGM6IFJUQ0RhdGFDaGFubmVsIHwgdW5kZWZpbmVkKSA9PiB7XG4gICAgICBpZiAoIWRjKSByZXR1cm47XG4gICAgICBkYy5jbG9zZSgpO1xuICAgICAgZGMub25idWZmZXJlZGFtb3VudGxvdyA9IG51bGw7XG4gICAgICBkYy5vbmNsb3NlID0gbnVsbDtcbiAgICAgIGRjLm9uY2xvc2luZyA9IG51bGw7XG4gICAgICBkYy5vbmVycm9yID0gbnVsbDtcbiAgICAgIGRjLm9ubWVzc2FnZSA9IG51bGw7XG4gICAgICBkYy5vbm9wZW4gPSBudWxsO1xuICAgIH07XG4gICAgZGNDbGVhbnVwKHRoaXMubG9zc3lEQyk7XG4gICAgZGNDbGVhbnVwKHRoaXMubG9zc3lEQ1N1Yik7XG4gICAgZGNDbGVhbnVwKHRoaXMucmVsaWFibGVEQyk7XG4gICAgZGNDbGVhbnVwKHRoaXMucmVsaWFibGVEQ1N1Yik7XG5cbiAgICB0aGlzLmxvc3N5REMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5sb3NzeURDU3ViID0gdW5kZWZpbmVkO1xuICAgIHRoaXMucmVsaWFibGVEQyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnJlbGlhYmxlRENTdWIgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBhc3luYyBjbGVhbnVwQ2xpZW50KCkge1xuICAgIGF3YWl0IHRoaXMuY2xpZW50LmNsb3NlKCk7XG4gICAgdGhpcy5jbGllbnQucmVzZXRDYWxsYmFja3MoKTtcbiAgfVxuXG4gIGFkZFRyYWNrKHJlcTogQWRkVHJhY2tSZXF1ZXN0KTogUHJvbWlzZTxUcmFja0luZm8+IHtcbiAgICBpZiAodGhpcy5wZW5kaW5nVHJhY2tSZXNvbHZlcnNbcmVxLmNpZF0pIHtcbiAgICAgIHRocm93IG5ldyBUcmFja0ludmFsaWRFcnJvcignYSB0cmFjayB3aXRoIHRoZSBzYW1lIElEIGhhcyBhbHJlYWR5IGJlZW4gcHVibGlzaGVkJyk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgUHJvbWlzZTxUcmFja0luZm8+KChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNvbnN0IHB1YmxpY2F0aW9uVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBkZWxldGUgdGhpcy5wZW5kaW5nVHJhY2tSZXNvbHZlcnNbcmVxLmNpZF07XG4gICAgICAgIHJlamVjdChcbiAgICAgICAgICBuZXcgQ29ubmVjdGlvbkVycm9yKCdwdWJsaWNhdGlvbiBvZiBsb2NhbCB0cmFjayB0aW1lZCBvdXQsIG5vIHJlc3BvbnNlIGZyb20gc2VydmVyJyksXG4gICAgICAgICk7XG4gICAgICB9LCAxMF8wMDApO1xuICAgICAgdGhpcy5wZW5kaW5nVHJhY2tSZXNvbHZlcnNbcmVxLmNpZF0gPSB7XG4gICAgICAgIHJlc29sdmU6IChpbmZvOiBUcmFja0luZm8pID0+IHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQocHVibGljYXRpb25UaW1lb3V0KTtcbiAgICAgICAgICByZXNvbHZlKGluZm8pO1xuICAgICAgICB9LFxuICAgICAgICByZWplY3Q6ICgpID0+IHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQocHVibGljYXRpb25UaW1lb3V0KTtcbiAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdDYW5jZWxsZWQgcHVibGljYXRpb24gYnkgY2FsbGluZyB1bnB1Ymxpc2gnKSk7XG4gICAgICAgIH0sXG4gICAgICB9O1xuICAgICAgdGhpcy5jbGllbnQuc2VuZEFkZFRyYWNrKHJlcSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyBzZW5kZXIgZnJvbSBQZWVyQ29ubmVjdGlvbiwgcmV0dXJuaW5nIHRydWUgaWYgaXQgd2FzIHJlbW92ZWQgc3VjY2Vzc2Z1bGx5XG4gICAqIGFuZCBhIG5lZ290aWF0aW9uIGlzIG5lY2Vzc2FyeVxuICAgKiBAcGFyYW0gc2VuZGVyXG4gICAqIEByZXR1cm5zXG4gICAqL1xuICByZW1vdmVUcmFjayhzZW5kZXI6IFJUQ1J0cFNlbmRlcik6IGJvb2xlYW4ge1xuICAgIGlmIChzZW5kZXIudHJhY2sgJiYgdGhpcy5wZW5kaW5nVHJhY2tSZXNvbHZlcnNbc2VuZGVyLnRyYWNrLmlkXSkge1xuICAgICAgY29uc3QgeyByZWplY3QgfSA9IHRoaXMucGVuZGluZ1RyYWNrUmVzb2x2ZXJzW3NlbmRlci50cmFjay5pZF07XG4gICAgICBpZiAocmVqZWN0KSB7XG4gICAgICAgIHJlamVjdCgpO1xuICAgICAgfVxuICAgICAgZGVsZXRlIHRoaXMucGVuZGluZ1RyYWNrUmVzb2x2ZXJzW3NlbmRlci50cmFjay5pZF07XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICB0aGlzLnBjTWFuYWdlciEucmVtb3ZlVHJhY2soc2VuZGVyKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGU6IHVua25vd24pIHtcbiAgICAgIHRoaXMubG9nLndhcm4oJ2ZhaWxlZCB0byByZW1vdmUgdHJhY2snLCB7IC4uLnRoaXMubG9nQ29udGV4dCwgZXJyb3I6IGUgfSk7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHVwZGF0ZU11dGVTdGF0dXModHJhY2tTaWQ6IHN0cmluZywgbXV0ZWQ6IGJvb2xlYW4pIHtcbiAgICB0aGlzLmNsaWVudC5zZW5kTXV0ZVRyYWNrKHRyYWNrU2lkLCBtdXRlZCk7XG4gIH1cblxuICBnZXQgZGF0YVN1YnNjcmliZXJSZWFkeVN0YXRlKCk6IHN0cmluZyB8IHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIHRoaXMucmVsaWFibGVEQ1N1Yj8ucmVhZHlTdGF0ZTtcbiAgfVxuXG4gIGFzeW5jIGdldENvbm5lY3RlZFNlcnZlckFkZHJlc3MoKTogUHJvbWlzZTxzdHJpbmcgfCB1bmRlZmluZWQ+IHtcbiAgICByZXR1cm4gdGhpcy5wY01hbmFnZXI/LmdldENvbm5lY3RlZEFkZHJlc3MoKTtcbiAgfVxuXG4gIC8qIEBpbnRlcm5hbCAqL1xuICBzZXRSZWdpb25VcmxQcm92aWRlcihwcm92aWRlcjogUmVnaW9uVXJsUHJvdmlkZXIpIHtcbiAgICB0aGlzLnJlZ2lvblVybFByb3ZpZGVyID0gcHJvdmlkZXI7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGNvbmZpZ3VyZShqb2luUmVzcG9uc2U6IEpvaW5SZXNwb25zZSkge1xuICAgIC8vIGFscmVhZHkgY29uZmlndXJlZFxuICAgIGlmICh0aGlzLnBjTWFuYWdlciAmJiB0aGlzLnBjTWFuYWdlci5jdXJyZW50U3RhdGUgIT09IFBDVHJhbnNwb3J0U3RhdGUuTkVXKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5wYXJ0aWNpcGFudFNpZCA9IGpvaW5SZXNwb25zZS5wYXJ0aWNpcGFudD8uc2lkO1xuXG4gICAgY29uc3QgcnRjQ29uZmlnID0gdGhpcy5tYWtlUlRDQ29uZmlndXJhdGlvbihqb2luUmVzcG9uc2UpO1xuXG4gICAgdGhpcy5wY01hbmFnZXIgPSBuZXcgUENUcmFuc3BvcnRNYW5hZ2VyKFxuICAgICAgcnRjQ29uZmlnLFxuICAgICAgam9pblJlc3BvbnNlLnN1YnNjcmliZXJQcmltYXJ5LFxuICAgICAgdGhpcy5sb2dnZXJPcHRpb25zLFxuICAgICk7XG5cbiAgICB0aGlzLmVtaXQoRW5naW5lRXZlbnQuVHJhbnNwb3J0c0NyZWF0ZWQsIHRoaXMucGNNYW5hZ2VyLnB1Ymxpc2hlciwgdGhpcy5wY01hbmFnZXIuc3Vic2NyaWJlcik7XG5cbiAgICB0aGlzLnBjTWFuYWdlci5vbkljZUNhbmRpZGF0ZSA9IChjYW5kaWRhdGUsIHRhcmdldCkgPT4ge1xuICAgICAgdGhpcy5jbGllbnQuc2VuZEljZUNhbmRpZGF0ZShjYW5kaWRhdGUsIHRhcmdldCk7XG4gICAgfTtcblxuICAgIHRoaXMucGNNYW5hZ2VyLm9uUHVibGlzaGVyT2ZmZXIgPSAob2ZmZXIpID0+IHtcbiAgICAgIHRoaXMuY2xpZW50LnNlbmRPZmZlcihvZmZlcik7XG4gICAgfTtcblxuICAgIHRoaXMucGNNYW5hZ2VyLm9uRGF0YUNoYW5uZWwgPSB0aGlzLmhhbmRsZURhdGFDaGFubmVsO1xuICAgIHRoaXMucGNNYW5hZ2VyLm9uU3RhdGVDaGFuZ2UgPSBhc3luYyAoY29ubmVjdGlvblN0YXRlLCBwdWJsaXNoZXJTdGF0ZSwgc3Vic2NyaWJlclN0YXRlKSA9PiB7XG4gICAgICB0aGlzLmxvZy5kZWJ1ZyhgcHJpbWFyeSBQQyBzdGF0ZSBjaGFuZ2VkICR7Y29ubmVjdGlvblN0YXRlfWAsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICBpZiAoY29ubmVjdGlvblN0YXRlID09PSBQQ1RyYW5zcG9ydFN0YXRlLkNPTk5FQ1RFRCkge1xuICAgICAgICBjb25zdCBzaG91bGRFbWl0ID0gdGhpcy5wY1N0YXRlID09PSBQQ1N0YXRlLk5ldztcbiAgICAgICAgdGhpcy5wY1N0YXRlID0gUENTdGF0ZS5Db25uZWN0ZWQ7XG4gICAgICAgIGlmIChzaG91bGRFbWl0KSB7XG4gICAgICAgICAgdGhpcy5lbWl0KEVuZ2luZUV2ZW50LkNvbm5lY3RlZCwgam9pblJlc3BvbnNlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChjb25uZWN0aW9uU3RhdGUgPT09IFBDVHJhbnNwb3J0U3RhdGUuRkFJTEVEKSB7XG4gICAgICAgIC8vIG9uIFNhZmFyaSwgUGVlckNvbm5lY3Rpb24gd2lsbCBzd2l0Y2ggdG8gJ2Rpc2Nvbm5lY3RlZCcgZHVyaW5nIHJlbmVnb3RpYXRpb25cbiAgICAgICAgaWYgKHRoaXMucGNTdGF0ZSA9PT0gUENTdGF0ZS5Db25uZWN0ZWQpIHtcbiAgICAgICAgICB0aGlzLnBjU3RhdGUgPSBQQ1N0YXRlLkRpc2Nvbm5lY3RlZDtcblxuICAgICAgICAgIHRoaXMuaGFuZGxlRGlzY29ubmVjdChcbiAgICAgICAgICAgICdwZWVyY29ubmVjdGlvbiBmYWlsZWQnLFxuICAgICAgICAgICAgc3Vic2NyaWJlclN0YXRlID09PSAnZmFpbGVkJ1xuICAgICAgICAgICAgICA/IFJlY29ubmVjdFJlYXNvbi5SUl9TVUJTQ1JJQkVSX0ZBSUxFRFxuICAgICAgICAgICAgICA6IFJlY29ubmVjdFJlYXNvbi5SUl9QVUJMSVNIRVJfRkFJTEVELFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMucGNNYW5hZ2VyLm9uVHJhY2sgPSAoZXY6IFJUQ1RyYWNrRXZlbnQpID0+IHtcbiAgICAgIHRoaXMuZW1pdChFbmdpbmVFdmVudC5NZWRpYVRyYWNrQWRkZWQsIGV2LnRyYWNrLCBldi5zdHJlYW1zWzBdLCBldi5yZWNlaXZlcik7XG4gICAgfTtcblxuICAgIHRoaXMuY3JlYXRlRGF0YUNoYW5uZWxzKCk7XG4gIH1cblxuICBwcml2YXRlIHNldHVwU2lnbmFsQ2xpZW50Q2FsbGJhY2tzKCkge1xuICAgIC8vIGNvbmZpZ3VyZSBzaWduYWxpbmcgY2xpZW50XG4gICAgdGhpcy5jbGllbnQub25BbnN3ZXIgPSBhc3luYyAoc2QpID0+IHtcbiAgICAgIGlmICghdGhpcy5wY01hbmFnZXIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5sb2cuZGVidWcoJ3JlY2VpdmVkIHNlcnZlciBhbnN3ZXInLCB7IC4uLnRoaXMubG9nQ29udGV4dCwgUlRDU2RwVHlwZTogc2QudHlwZSB9KTtcbiAgICAgIGF3YWl0IHRoaXMucGNNYW5hZ2VyLnNldFB1Ymxpc2hlckFuc3dlcihzZCk7XG4gICAgfTtcblxuICAgIC8vIGFkZCBjYW5kaWRhdGUgb24gdHJpY2tsZVxuICAgIHRoaXMuY2xpZW50Lm9uVHJpY2tsZSA9IChjYW5kaWRhdGUsIHRhcmdldCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLnBjTWFuYWdlcikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLmxvZy50cmFjZSgnZ290IElDRSBjYW5kaWRhdGUgZnJvbSBwZWVyJywgeyAuLi50aGlzLmxvZ0NvbnRleHQsIGNhbmRpZGF0ZSwgdGFyZ2V0IH0pO1xuICAgICAgdGhpcy5wY01hbmFnZXIuYWRkSWNlQ2FuZGlkYXRlKGNhbmRpZGF0ZSwgdGFyZ2V0KTtcbiAgICB9O1xuXG4gICAgLy8gd2hlbiBzZXJ2ZXIgY3JlYXRlcyBhbiBvZmZlciBmb3IgdGhlIGNsaWVudFxuICAgIHRoaXMuY2xpZW50Lm9uT2ZmZXIgPSBhc3luYyAoc2QpID0+IHtcbiAgICAgIGlmICghdGhpcy5wY01hbmFnZXIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgYW5zd2VyID0gYXdhaXQgdGhpcy5wY01hbmFnZXIuY3JlYXRlU3Vic2NyaWJlckFuc3dlckZyb21PZmZlcihzZCk7XG4gICAgICB0aGlzLmNsaWVudC5zZW5kQW5zd2VyKGFuc3dlcik7XG4gICAgfTtcblxuICAgIHRoaXMuY2xpZW50Lm9uTG9jYWxUcmFja1B1Ymxpc2hlZCA9IChyZXM6IFRyYWNrUHVibGlzaGVkUmVzcG9uc2UpID0+IHtcbiAgICAgIHRoaXMubG9nLmRlYnVnKCdyZWNlaXZlZCB0cmFja1B1Ymxpc2hlZFJlc3BvbnNlJywge1xuICAgICAgICAuLi50aGlzLmxvZ0NvbnRleHQsXG4gICAgICAgIGNpZDogcmVzLmNpZCxcbiAgICAgICAgdHJhY2s6IHJlcy50cmFjaz8uc2lkLFxuICAgICAgfSk7XG4gICAgICBpZiAoIXRoaXMucGVuZGluZ1RyYWNrUmVzb2x2ZXJzW3Jlcy5jaWRdKSB7XG4gICAgICAgIHRoaXMubG9nLmVycm9yKGBtaXNzaW5nIHRyYWNrIHJlc29sdmVyIGZvciAke3Jlcy5jaWR9YCwge1xuICAgICAgICAgIC4uLnRoaXMubG9nQ29udGV4dCxcbiAgICAgICAgICBjaWQ6IHJlcy5jaWQsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCB7IHJlc29sdmUgfSA9IHRoaXMucGVuZGluZ1RyYWNrUmVzb2x2ZXJzW3Jlcy5jaWRdO1xuICAgICAgZGVsZXRlIHRoaXMucGVuZGluZ1RyYWNrUmVzb2x2ZXJzW3Jlcy5jaWRdO1xuICAgICAgcmVzb2x2ZShyZXMudHJhY2shKTtcbiAgICB9O1xuXG4gICAgdGhpcy5jbGllbnQub25Mb2NhbFRyYWNrVW5wdWJsaXNoZWQgPSAocmVzcG9uc2U6IFRyYWNrVW5wdWJsaXNoZWRSZXNwb25zZSkgPT4ge1xuICAgICAgdGhpcy5lbWl0KEVuZ2luZUV2ZW50LkxvY2FsVHJhY2tVbnB1Ymxpc2hlZCwgcmVzcG9uc2UpO1xuICAgIH07XG5cbiAgICB0aGlzLmNsaWVudC5vblRva2VuUmVmcmVzaCA9ICh0b2tlbjogc3RyaW5nKSA9PiB7XG4gICAgICB0aGlzLnRva2VuID0gdG9rZW47XG4gICAgfTtcblxuICAgIHRoaXMuY2xpZW50Lm9uUmVtb3RlTXV0ZUNoYW5nZWQgPSAodHJhY2tTaWQ6IHN0cmluZywgbXV0ZWQ6IGJvb2xlYW4pID0+IHtcbiAgICAgIHRoaXMuZW1pdChFbmdpbmVFdmVudC5SZW1vdGVNdXRlLCB0cmFja1NpZCwgbXV0ZWQpO1xuICAgIH07XG5cbiAgICB0aGlzLmNsaWVudC5vblN1YnNjcmliZWRRdWFsaXR5VXBkYXRlID0gKHVwZGF0ZTogU3Vic2NyaWJlZFF1YWxpdHlVcGRhdGUpID0+IHtcbiAgICAgIHRoaXMuZW1pdChFbmdpbmVFdmVudC5TdWJzY3JpYmVkUXVhbGl0eVVwZGF0ZSwgdXBkYXRlKTtcbiAgICB9O1xuXG4gICAgdGhpcy5jbGllbnQub25DbG9zZSA9ICgpID0+IHtcbiAgICAgIHRoaXMuaGFuZGxlRGlzY29ubmVjdCgnc2lnbmFsJywgUmVjb25uZWN0UmVhc29uLlJSX1NJR05BTF9ESVNDT05ORUNURUQpO1xuICAgIH07XG5cbiAgICB0aGlzLmNsaWVudC5vbkxlYXZlID0gKGxlYXZlPzogTGVhdmVSZXF1ZXN0KSA9PiB7XG4gICAgICBpZiAobGVhdmU/LmNhblJlY29ubmVjdCkge1xuICAgICAgICB0aGlzLmZ1bGxSZWNvbm5lY3RPbk5leHQgPSB0cnVlO1xuICAgICAgICAvLyByZWNvbm5lY3QgaW1tZWRpYXRlbHkgaW5zdGVhZCBvZiB3YWl0aW5nIGZvciBuZXh0IGF0dGVtcHRcbiAgICAgICAgdGhpcy5oYW5kbGVEaXNjb25uZWN0KGxlYXZlUmVjb25uZWN0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZW1pdChFbmdpbmVFdmVudC5EaXNjb25uZWN0ZWQsIGxlYXZlPy5yZWFzb24pO1xuICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICB9XG4gICAgICB0aGlzLmxvZy5kZWJ1ZygnY2xpZW50IGxlYXZlIHJlcXVlc3QnLCB7IC4uLnRoaXMubG9nQ29udGV4dCwgcmVhc29uOiBsZWF2ZT8ucmVhc29uIH0pO1xuICAgIH07XG4gIH1cblxuICBwcml2YXRlIG1ha2VSVENDb25maWd1cmF0aW9uKHNlcnZlclJlc3BvbnNlOiBKb2luUmVzcG9uc2UgfCBSZWNvbm5lY3RSZXNwb25zZSk6IFJUQ0NvbmZpZ3VyYXRpb24ge1xuICAgIGNvbnN0IHJ0Y0NvbmZpZyA9IHsgLi4udGhpcy5ydGNDb25maWcgfTtcblxuICAgIGlmICh0aGlzLnNpZ25hbE9wdHM/LmUyZWVFbmFibGVkKSB7XG4gICAgICB0aGlzLmxvZy5kZWJ1ZygnRTJFRSAtIHNldHRpbmcgdXAgdHJhbnNwb3J0cyB3aXRoIGluc2VydGFibGUgc3RyZWFtcycsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICAvLyAgdGhpcyBtYWtlcyBzdXJlIHRoYXQgbm8gZGF0YSBpcyBzZW50IGJlZm9yZSB0aGUgdHJhbnNmb3JtcyBhcmUgcmVhZHlcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIHJ0Y0NvbmZpZy5lbmNvZGVkSW5zZXJ0YWJsZVN0cmVhbXMgPSB0cnVlO1xuICAgIH1cblxuICAgIC8vIHVwZGF0ZSBJQ0Ugc2VydmVycyBiZWZvcmUgY3JlYXRpbmcgUGVlckNvbm5lY3Rpb25cbiAgICBpZiAoc2VydmVyUmVzcG9uc2UuaWNlU2VydmVycyAmJiAhcnRjQ29uZmlnLmljZVNlcnZlcnMpIHtcbiAgICAgIGNvbnN0IHJ0Y0ljZVNlcnZlcnM6IFJUQ0ljZVNlcnZlcltdID0gW107XG4gICAgICBzZXJ2ZXJSZXNwb25zZS5pY2VTZXJ2ZXJzLmZvckVhY2goKGljZVNlcnZlcikgPT4ge1xuICAgICAgICBjb25zdCBydGNJY2VTZXJ2ZXI6IFJUQ0ljZVNlcnZlciA9IHtcbiAgICAgICAgICB1cmxzOiBpY2VTZXJ2ZXIudXJscyxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGljZVNlcnZlci51c2VybmFtZSkgcnRjSWNlU2VydmVyLnVzZXJuYW1lID0gaWNlU2VydmVyLnVzZXJuYW1lO1xuICAgICAgICBpZiAoaWNlU2VydmVyLmNyZWRlbnRpYWwpIHtcbiAgICAgICAgICBydGNJY2VTZXJ2ZXIuY3JlZGVudGlhbCA9IGljZVNlcnZlci5jcmVkZW50aWFsO1xuICAgICAgICB9XG4gICAgICAgIHJ0Y0ljZVNlcnZlcnMucHVzaChydGNJY2VTZXJ2ZXIpO1xuICAgICAgfSk7XG4gICAgICBydGNDb25maWcuaWNlU2VydmVycyA9IHJ0Y0ljZVNlcnZlcnM7XG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgc2VydmVyUmVzcG9uc2UuY2xpZW50Q29uZmlndXJhdGlvbiAmJlxuICAgICAgc2VydmVyUmVzcG9uc2UuY2xpZW50Q29uZmlndXJhdGlvbi5mb3JjZVJlbGF5ID09PSBDbGllbnRDb25maWdTZXR0aW5nLkVOQUJMRURcbiAgICApIHtcbiAgICAgIHJ0Y0NvbmZpZy5pY2VUcmFuc3BvcnRQb2xpY3kgPSAncmVsYXknO1xuICAgIH1cblxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBydGNDb25maWcuc2RwU2VtYW50aWNzID0gJ3VuaWZpZWQtcGxhbic7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHJ0Y0NvbmZpZy5jb250aW51YWxHYXRoZXJpbmdQb2xpY3kgPSAnZ2F0aGVyX2NvbnRpbnVhbGx5JztcblxuICAgIHJldHVybiBydGNDb25maWc7XG4gIH1cblxuICBwcml2YXRlIGNyZWF0ZURhdGFDaGFubmVscygpIHtcbiAgICBpZiAoIXRoaXMucGNNYW5hZ2VyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gY2xlYXIgb2xkIGRhdGEgY2hhbm5lbCBjYWxsYmFja3MgaWYgcmVjcmVhdGVcbiAgICBpZiAodGhpcy5sb3NzeURDKSB7XG4gICAgICB0aGlzLmxvc3N5REMub25tZXNzYWdlID0gbnVsbDtcbiAgICAgIHRoaXMubG9zc3lEQy5vbmVycm9yID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKHRoaXMucmVsaWFibGVEQykge1xuICAgICAgdGhpcy5yZWxpYWJsZURDLm9ubWVzc2FnZSA9IG51bGw7XG4gICAgICB0aGlzLnJlbGlhYmxlREMub25lcnJvciA9IG51bGw7XG4gICAgfVxuXG4gICAgLy8gY3JlYXRlIGRhdGEgY2hhbm5lbHNcbiAgICB0aGlzLmxvc3N5REMgPSB0aGlzLnBjTWFuYWdlci5jcmVhdGVQdWJsaXNoZXJEYXRhQ2hhbm5lbChsb3NzeURhdGFDaGFubmVsLCB7XG4gICAgICAvLyB3aWxsIGRyb3Agb2xkZXIgcGFja2V0cyB0aGF0IGFycml2ZVxuICAgICAgb3JkZXJlZDogdHJ1ZSxcbiAgICAgIG1heFJldHJhbnNtaXRzOiAwLFxuICAgIH0pO1xuICAgIHRoaXMucmVsaWFibGVEQyA9IHRoaXMucGNNYW5hZ2VyLmNyZWF0ZVB1Ymxpc2hlckRhdGFDaGFubmVsKHJlbGlhYmxlRGF0YUNoYW5uZWwsIHtcbiAgICAgIG9yZGVyZWQ6IHRydWUsXG4gICAgfSk7XG5cbiAgICAvLyBhbHNvIGhhbmRsZSBtZXNzYWdlcyBvdmVyIHRoZSBwdWIgY2hhbm5lbCwgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG4gICAgdGhpcy5sb3NzeURDLm9ubWVzc2FnZSA9IHRoaXMuaGFuZGxlRGF0YU1lc3NhZ2U7XG4gICAgdGhpcy5yZWxpYWJsZURDLm9ubWVzc2FnZSA9IHRoaXMuaGFuZGxlRGF0YU1lc3NhZ2U7XG5cbiAgICAvLyBoYW5kbGUgZGF0YWNoYW5uZWwgZXJyb3JzXG4gICAgdGhpcy5sb3NzeURDLm9uZXJyb3IgPSB0aGlzLmhhbmRsZURhdGFFcnJvcjtcbiAgICB0aGlzLnJlbGlhYmxlREMub25lcnJvciA9IHRoaXMuaGFuZGxlRGF0YUVycm9yO1xuXG4gICAgLy8gc2V0IHVwIGRjIGJ1ZmZlciB0aHJlc2hvbGQsIHNldCB0byA2NGtCIChvdGhlcndpc2UgMCBieSBkZWZhdWx0KVxuICAgIHRoaXMubG9zc3lEQy5idWZmZXJlZEFtb3VudExvd1RocmVzaG9sZCA9IDY1NTM1O1xuICAgIHRoaXMucmVsaWFibGVEQy5idWZmZXJlZEFtb3VudExvd1RocmVzaG9sZCA9IDY1NTM1O1xuXG4gICAgLy8gaGFuZGxlIGJ1ZmZlciBhbW91bnQgbG93IGV2ZW50c1xuICAgIHRoaXMubG9zc3lEQy5vbmJ1ZmZlcmVkYW1vdW50bG93ID0gdGhpcy5oYW5kbGVCdWZmZXJlZEFtb3VudExvdztcbiAgICB0aGlzLnJlbGlhYmxlREMub25idWZmZXJlZGFtb3VudGxvdyA9IHRoaXMuaGFuZGxlQnVmZmVyZWRBbW91bnRMb3c7XG4gIH1cblxuICBwcml2YXRlIGhhbmRsZURhdGFDaGFubmVsID0gYXN5bmMgKHsgY2hhbm5lbCB9OiBSVENEYXRhQ2hhbm5lbEV2ZW50KSA9PiB7XG4gICAgaWYgKCFjaGFubmVsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChjaGFubmVsLmxhYmVsID09PSByZWxpYWJsZURhdGFDaGFubmVsKSB7XG4gICAgICB0aGlzLnJlbGlhYmxlRENTdWIgPSBjaGFubmVsO1xuICAgIH0gZWxzZSBpZiAoY2hhbm5lbC5sYWJlbCA9PT0gbG9zc3lEYXRhQ2hhbm5lbCkge1xuICAgICAgdGhpcy5sb3NzeURDU3ViID0gY2hhbm5lbDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmxvZy5kZWJ1Zyhgb24gZGF0YSBjaGFubmVsICR7Y2hhbm5lbC5pZH0sICR7Y2hhbm5lbC5sYWJlbH1gLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgIGNoYW5uZWwub25tZXNzYWdlID0gdGhpcy5oYW5kbGVEYXRhTWVzc2FnZTtcbiAgfTtcblxuICBwcml2YXRlIGhhbmRsZURhdGFNZXNzYWdlID0gYXN5bmMgKG1lc3NhZ2U6IE1lc3NhZ2VFdmVudCkgPT4ge1xuICAgIC8vIG1ha2Ugc3VyZSB0byByZXNwZWN0IGluY29taW5nIGRhdGEgbWVzc2FnZSBvcmRlciBieSBwcm9jZXNzaW5nIG1lc3NhZ2UgZXZlbnRzIG9uZSBhZnRlciB0aGUgb3RoZXJcbiAgICBjb25zdCB1bmxvY2sgPSBhd2FpdCB0aGlzLmRhdGFQcm9jZXNzTG9jay5sb2NrKCk7XG4gICAgdHJ5IHtcbiAgICAgIC8vIGRlY29kZVxuICAgICAgbGV0IGJ1ZmZlcjogQXJyYXlCdWZmZXIgfCB1bmRlZmluZWQ7XG4gICAgICBpZiAobWVzc2FnZS5kYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgYnVmZmVyID0gbWVzc2FnZS5kYXRhO1xuICAgICAgfSBlbHNlIGlmIChtZXNzYWdlLmRhdGEgaW5zdGFuY2VvZiBCbG9iKSB7XG4gICAgICAgIGJ1ZmZlciA9IGF3YWl0IG1lc3NhZ2UuZGF0YS5hcnJheUJ1ZmZlcigpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5sb2cuZXJyb3IoJ3Vuc3VwcG9ydGVkIGRhdGEgdHlwZScsIHsgLi4udGhpcy5sb2dDb250ZXh0LCBkYXRhOiBtZXNzYWdlLmRhdGEgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGRwID0gRGF0YVBhY2tldC5mcm9tQmluYXJ5KG5ldyBVaW50OEFycmF5KGJ1ZmZlcikpO1xuICAgICAgaWYgKGRwLnZhbHVlPy5jYXNlID09PSAnc3BlYWtlcicpIHtcbiAgICAgICAgLy8gZGlzcGF0Y2ggc3BlYWtlciB1cGRhdGVzXG4gICAgICAgIHRoaXMuZW1pdChFbmdpbmVFdmVudC5BY3RpdmVTcGVha2Vyc1VwZGF0ZSwgZHAudmFsdWUudmFsdWUuc3BlYWtlcnMpO1xuICAgICAgfSBlbHNlIGlmIChkcC52YWx1ZT8uY2FzZSA9PT0gJ3VzZXInKSB7XG4gICAgICAgIHRoaXMuZW1pdChFbmdpbmVFdmVudC5EYXRhUGFja2V0UmVjZWl2ZWQsIGRwLnZhbHVlLnZhbHVlLCBkcC5raW5kKTtcbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgdW5sb2NrKCk7XG4gICAgfVxuICB9O1xuXG4gIHByaXZhdGUgaGFuZGxlRGF0YUVycm9yID0gKGV2ZW50OiBFdmVudCkgPT4ge1xuICAgIGNvbnN0IGNoYW5uZWwgPSBldmVudC5jdXJyZW50VGFyZ2V0IGFzIFJUQ0RhdGFDaGFubmVsO1xuICAgIGNvbnN0IGNoYW5uZWxLaW5kID0gY2hhbm5lbC5tYXhSZXRyYW5zbWl0cyA9PT0gMCA/ICdsb3NzeScgOiAncmVsaWFibGUnO1xuXG4gICAgaWYgKGV2ZW50IGluc3RhbmNlb2YgRXJyb3JFdmVudCAmJiBldmVudC5lcnJvcikge1xuICAgICAgY29uc3QgeyBlcnJvciB9ID0gZXZlbnQuZXJyb3I7XG4gICAgICB0aGlzLmxvZy5lcnJvcihgRGF0YUNoYW5uZWwgZXJyb3Igb24gJHtjaGFubmVsS2luZH06ICR7ZXZlbnQubWVzc2FnZX1gLCB7XG4gICAgICAgIC4uLnRoaXMubG9nQ29udGV4dCxcbiAgICAgICAgZXJyb3IsXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5sb2cuZXJyb3IoYFVua25vd24gRGF0YUNoYW5uZWwgZXJyb3Igb24gJHtjaGFubmVsS2luZH1gLCB7IC4uLnRoaXMubG9nQ29udGV4dCwgZXZlbnQgfSk7XG4gICAgfVxuICB9O1xuXG4gIHByaXZhdGUgaGFuZGxlQnVmZmVyZWRBbW91bnRMb3cgPSAoZXZlbnQ6IEV2ZW50KSA9PiB7XG4gICAgY29uc3QgY2hhbm5lbCA9IGV2ZW50LmN1cnJlbnRUYXJnZXQgYXMgUlRDRGF0YUNoYW5uZWw7XG4gICAgY29uc3QgY2hhbm5lbEtpbmQgPVxuICAgICAgY2hhbm5lbC5tYXhSZXRyYW5zbWl0cyA9PT0gMCA/IERhdGFQYWNrZXRfS2luZC5MT1NTWSA6IERhdGFQYWNrZXRfS2luZC5SRUxJQUJMRTtcblxuICAgIHRoaXMudXBkYXRlQW5kRW1pdERDQnVmZmVyU3RhdHVzKGNoYW5uZWxLaW5kKTtcbiAgfTtcblxuICBwcml2YXRlIHNldFByZWZlcnJlZENvZGVjKFxuICAgIHRyYW5zY2VpdmVyOiBSVENSdHBUcmFuc2NlaXZlcixcbiAgICBraW5kOiBUcmFjay5LaW5kLFxuICAgIHZpZGVvQ29kZWM6IFZpZGVvQ29kZWMsXG4gICkge1xuICAgIGlmICghKCdnZXRDYXBhYmlsaXRpZXMnIGluIFJUQ1J0cFNlbmRlcikpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY2FwID0gUlRDUnRwU2VuZGVyLmdldENhcGFiaWxpdGllcyhraW5kKTtcbiAgICBpZiAoIWNhcCkgcmV0dXJuO1xuICAgIHRoaXMubG9nLmRlYnVnKCdnZXQgc2VuZGVyIGNhcGFiaWxpdGllcycsIHsgLi4udGhpcy5sb2dDb250ZXh0LCBjYXAgfSk7XG4gICAgY29uc3QgbWF0Y2hlZDogUlRDUnRwQ29kZWNDYXBhYmlsaXR5W10gPSBbXTtcbiAgICBjb25zdCBwYXJ0aWFsTWF0Y2hlZDogUlRDUnRwQ29kZWNDYXBhYmlsaXR5W10gPSBbXTtcbiAgICBjb25zdCB1bm1hdGNoZWQ6IFJUQ1J0cENvZGVjQ2FwYWJpbGl0eVtdID0gW107XG4gICAgY2FwLmNvZGVjcy5mb3JFYWNoKChjKSA9PiB7XG4gICAgICBjb25zdCBjb2RlYyA9IGMubWltZVR5cGUudG9Mb3dlckNhc2UoKTtcbiAgICAgIGlmIChjb2RlYyA9PT0gJ2F1ZGlvL29wdXMnKSB7XG4gICAgICAgIG1hdGNoZWQucHVzaChjKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgbWF0Y2hlc1ZpZGVvQ29kZWMgPSBjb2RlYyA9PT0gYHZpZGVvLyR7dmlkZW9Db2RlY31gO1xuICAgICAgaWYgKCFtYXRjaGVzVmlkZW9Db2RlYykge1xuICAgICAgICB1bm1hdGNoZWQucHVzaChjKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gZm9yIGgyNjQgY29kZWNzIHRoYXQgaGF2ZSBzZHBGbXRwTGluZSBhdmFpbGFibGUsIHVzZSBvbmx5IGlmIHRoZVxuICAgICAgLy8gcHJvZmlsZS1sZXZlbC1pZCBpcyA0MmUwMWYgZm9yIGNyb3NzLWJyb3dzZXIgY29tcGF0aWJpbGl0eVxuICAgICAgaWYgKHZpZGVvQ29kZWMgPT09ICdoMjY0Jykge1xuICAgICAgICBpZiAoYy5zZHBGbXRwTGluZSAmJiBjLnNkcEZtdHBMaW5lLmluY2x1ZGVzKCdwcm9maWxlLWxldmVsLWlkPTQyZTAxZicpKSB7XG4gICAgICAgICAgbWF0Y2hlZC5wdXNoKGMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhcnRpYWxNYXRjaGVkLnB1c2goYyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBtYXRjaGVkLnB1c2goYyk7XG4gICAgfSk7XG5cbiAgICBpZiAoc3VwcG9ydHNTZXRDb2RlY1ByZWZlcmVuY2VzKHRyYW5zY2VpdmVyKSkge1xuICAgICAgdHJhbnNjZWl2ZXIuc2V0Q29kZWNQcmVmZXJlbmNlcyhtYXRjaGVkLmNvbmNhdChwYXJ0aWFsTWF0Y2hlZCwgdW5tYXRjaGVkKSk7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgY3JlYXRlU2VuZGVyKFxuICAgIHRyYWNrOiBMb2NhbFRyYWNrLFxuICAgIG9wdHM6IFRyYWNrUHVibGlzaE9wdGlvbnMsXG4gICAgZW5jb2RpbmdzPzogUlRDUnRwRW5jb2RpbmdQYXJhbWV0ZXJzW10sXG4gICkge1xuICAgIGlmIChzdXBwb3J0c1RyYW5zY2VpdmVyKCkpIHtcbiAgICAgIGNvbnN0IHNlbmRlciA9IGF3YWl0IHRoaXMuY3JlYXRlVHJhbnNjZWl2ZXJSVENSdHBTZW5kZXIodHJhY2ssIG9wdHMsIGVuY29kaW5ncyk7XG4gICAgICByZXR1cm4gc2VuZGVyO1xuICAgIH1cbiAgICBpZiAoc3VwcG9ydHNBZGRUcmFjaygpKSB7XG4gICAgICB0aGlzLmxvZy53YXJuKCd1c2luZyBhZGQtdHJhY2sgZmFsbGJhY2snLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgY29uc3Qgc2VuZGVyID0gYXdhaXQgdGhpcy5jcmVhdGVSVENSdHBTZW5kZXIodHJhY2subWVkaWFTdHJlYW1UcmFjayk7XG4gICAgICByZXR1cm4gc2VuZGVyO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgVW5leHBlY3RlZENvbm5lY3Rpb25TdGF0ZSgnUmVxdWlyZWQgd2ViUlRDIEFQSXMgbm90IHN1cHBvcnRlZCBvbiB0aGlzIGRldmljZScpO1xuICB9XG5cbiAgYXN5bmMgY3JlYXRlU2ltdWxjYXN0U2VuZGVyKFxuICAgIHRyYWNrOiBMb2NhbFZpZGVvVHJhY2ssXG4gICAgc2ltdWxjYXN0VHJhY2s6IFNpbXVsY2FzdFRyYWNrSW5mbyxcbiAgICBvcHRzOiBUcmFja1B1Ymxpc2hPcHRpb25zLFxuICAgIGVuY29kaW5ncz86IFJUQ1J0cEVuY29kaW5nUGFyYW1ldGVyc1tdLFxuICApIHtcbiAgICAvLyBzdG9yZSBSVENSdHBTZW5kZXJcbiAgICBpZiAoc3VwcG9ydHNUcmFuc2NlaXZlcigpKSB7XG4gICAgICByZXR1cm4gdGhpcy5jcmVhdGVTaW11bGNhc3RUcmFuc2NlaXZlclNlbmRlcih0cmFjaywgc2ltdWxjYXN0VHJhY2ssIG9wdHMsIGVuY29kaW5ncyk7XG4gICAgfVxuICAgIGlmIChzdXBwb3J0c0FkZFRyYWNrKCkpIHtcbiAgICAgIHRoaXMubG9nLmRlYnVnKCd1c2luZyBhZGQtdHJhY2sgZmFsbGJhY2snLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlUlRDUnRwU2VuZGVyKHRyYWNrLm1lZGlhU3RyZWFtVHJhY2spO1xuICAgIH1cblxuICAgIHRocm93IG5ldyBVbmV4cGVjdGVkQ29ubmVjdGlvblN0YXRlKCdDYW5ub3Qgc3RyZWFtIG9uIHRoaXMgZGV2aWNlJyk7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGNyZWF0ZVRyYW5zY2VpdmVyUlRDUnRwU2VuZGVyKFxuICAgIHRyYWNrOiBMb2NhbFRyYWNrLFxuICAgIG9wdHM6IFRyYWNrUHVibGlzaE9wdGlvbnMsXG4gICAgZW5jb2RpbmdzPzogUlRDUnRwRW5jb2RpbmdQYXJhbWV0ZXJzW10sXG4gICkge1xuICAgIGlmICghdGhpcy5wY01hbmFnZXIpIHtcbiAgICAgIHRocm93IG5ldyBVbmV4cGVjdGVkQ29ubmVjdGlvblN0YXRlKCdwdWJsaXNoZXIgaXMgY2xvc2VkJyk7XG4gICAgfVxuXG4gICAgY29uc3Qgc3RyZWFtczogTWVkaWFTdHJlYW1bXSA9IFtdO1xuXG4gICAgaWYgKHRyYWNrLm1lZGlhU3RyZWFtKSB7XG4gICAgICBzdHJlYW1zLnB1c2godHJhY2subWVkaWFTdHJlYW0pO1xuICAgIH1cblxuICAgIGNvbnN0IHRyYW5zY2VpdmVySW5pdDogUlRDUnRwVHJhbnNjZWl2ZXJJbml0ID0geyBkaXJlY3Rpb246ICdzZW5kb25seScsIHN0cmVhbXMgfTtcbiAgICBpZiAoZW5jb2RpbmdzKSB7XG4gICAgICB0cmFuc2NlaXZlckluaXQuc2VuZEVuY29kaW5ncyA9IGVuY29kaW5ncztcbiAgICB9XG4gICAgLy8gYWRkVHJhbnNjZWl2ZXIgZm9yIHJlYWN0LW5hdGl2ZSBpcyBhc3luYy4gd2ViIGlzIHN5bmNocm9ub3VzLCBidXQgYXdhaXQgd29uJ3QgZWZmZWN0IGl0LlxuICAgIGNvbnN0IHRyYW5zY2VpdmVyID0gYXdhaXQgdGhpcy5wY01hbmFnZXIuYWRkUHVibGlzaGVyVHJhbnNjZWl2ZXIoXG4gICAgICB0cmFjay5tZWRpYVN0cmVhbVRyYWNrLFxuICAgICAgdHJhbnNjZWl2ZXJJbml0LFxuICAgICk7XG5cbiAgICBpZiAodHJhY2sua2luZCA9PT0gVHJhY2suS2luZC5WaWRlbyAmJiBvcHRzLnZpZGVvQ29kZWMpIHtcbiAgICAgIHRoaXMuc2V0UHJlZmVycmVkQ29kZWModHJhbnNjZWl2ZXIsIHRyYWNrLmtpbmQsIG9wdHMudmlkZW9Db2RlYyk7XG4gICAgICB0cmFjay5jb2RlYyA9IG9wdHMudmlkZW9Db2RlYztcbiAgICB9XG4gICAgcmV0dXJuIHRyYW5zY2VpdmVyLnNlbmRlcjtcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgY3JlYXRlU2ltdWxjYXN0VHJhbnNjZWl2ZXJTZW5kZXIoXG4gICAgdHJhY2s6IExvY2FsVmlkZW9UcmFjayxcbiAgICBzaW11bGNhc3RUcmFjazogU2ltdWxjYXN0VHJhY2tJbmZvLFxuICAgIG9wdHM6IFRyYWNrUHVibGlzaE9wdGlvbnMsXG4gICAgZW5jb2RpbmdzPzogUlRDUnRwRW5jb2RpbmdQYXJhbWV0ZXJzW10sXG4gICkge1xuICAgIGlmICghdGhpcy5wY01hbmFnZXIpIHtcbiAgICAgIHRocm93IG5ldyBVbmV4cGVjdGVkQ29ubmVjdGlvblN0YXRlKCdwdWJsaXNoZXIgaXMgY2xvc2VkJyk7XG4gICAgfVxuICAgIGNvbnN0IHRyYW5zY2VpdmVySW5pdDogUlRDUnRwVHJhbnNjZWl2ZXJJbml0ID0geyBkaXJlY3Rpb246ICdzZW5kb25seScgfTtcbiAgICBpZiAoZW5jb2RpbmdzKSB7XG4gICAgICB0cmFuc2NlaXZlckluaXQuc2VuZEVuY29kaW5ncyA9IGVuY29kaW5ncztcbiAgICB9XG4gICAgLy8gYWRkVHJhbnNjZWl2ZXIgZm9yIHJlYWN0LW5hdGl2ZSBpcyBhc3luYy4gd2ViIGlzIHN5bmNocm9ub3VzLCBidXQgYXdhaXQgd29uJ3QgZWZmZWN0IGl0LlxuICAgIGNvbnN0IHRyYW5zY2VpdmVyID0gYXdhaXQgdGhpcy5wY01hbmFnZXIuYWRkUHVibGlzaGVyVHJhbnNjZWl2ZXIoXG4gICAgICBzaW11bGNhc3RUcmFjay5tZWRpYVN0cmVhbVRyYWNrLFxuICAgICAgdHJhbnNjZWl2ZXJJbml0LFxuICAgICk7XG4gICAgaWYgKCFvcHRzLnZpZGVvQ29kZWMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5zZXRQcmVmZXJyZWRDb2RlYyh0cmFuc2NlaXZlciwgdHJhY2sua2luZCwgb3B0cy52aWRlb0NvZGVjKTtcbiAgICB0cmFjay5zZXRTaW11bGNhc3RUcmFja1NlbmRlcihvcHRzLnZpZGVvQ29kZWMsIHRyYW5zY2VpdmVyLnNlbmRlcik7XG4gICAgcmV0dXJuIHRyYW5zY2VpdmVyLnNlbmRlcjtcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgY3JlYXRlUlRDUnRwU2VuZGVyKHRyYWNrOiBNZWRpYVN0cmVhbVRyYWNrKSB7XG4gICAgaWYgKCF0aGlzLnBjTWFuYWdlcikge1xuICAgICAgdGhyb3cgbmV3IFVuZXhwZWN0ZWRDb25uZWN0aW9uU3RhdGUoJ3B1Ymxpc2hlciBpcyBjbG9zZWQnKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucGNNYW5hZ2VyLmFkZFB1Ymxpc2hlclRyYWNrKHRyYWNrKTtcbiAgfVxuXG4gIC8vIHdlYnNvY2tldCByZWNvbm5lY3QgYmVoYXZpb3IuIGlmIHdlYnNvY2tldCBpcyBpbnRlcnJ1cHRlZCwgYW5kIHRoZSBQZWVyQ29ubmVjdGlvblxuICAvLyBjb250aW51ZXMgdG8gd29yaywgd2UgY2FuIHJlY29ubmVjdCB0byB3ZWJzb2NrZXQgdG8gY29udGludWUgdGhlIHNlc3Npb25cbiAgLy8gYWZ0ZXIgYSBudW1iZXIgb2YgcmV0cmllcywgd2UnbGwgY2xvc2UgYW5kIGdpdmUgdXAgcGVybWFuZW50bHlcbiAgcHJpdmF0ZSBoYW5kbGVEaXNjb25uZWN0ID0gKGNvbm5lY3Rpb246IHN0cmluZywgZGlzY29ubmVjdFJlYXNvbj86IFJlY29ubmVjdFJlYXNvbikgPT4ge1xuICAgIGlmICh0aGlzLl9pc0Nsb3NlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMubG9nLndhcm4oYCR7Y29ubmVjdGlvbn0gZGlzY29ubmVjdGVkYCwgdGhpcy5sb2dDb250ZXh0KTtcbiAgICBpZiAodGhpcy5yZWNvbm5lY3RBdHRlbXB0cyA9PT0gMCkge1xuICAgICAgLy8gb25seSByZXNldCBzdGFydCB0aW1lIG9uIHRoZSBmaXJzdCB0cnlcbiAgICAgIHRoaXMucmVjb25uZWN0U3RhcnQgPSBEYXRlLm5vdygpO1xuICAgIH1cblxuICAgIGNvbnN0IGRpc2Nvbm5lY3QgPSAoZHVyYXRpb246IG51bWJlcikgPT4ge1xuICAgICAgdGhpcy5sb2cud2FybihcbiAgICAgICAgYGNvdWxkIG5vdCByZWNvdmVyIGNvbm5lY3Rpb24gYWZ0ZXIgJHt0aGlzLnJlY29ubmVjdEF0dGVtcHRzfSBhdHRlbXB0cywgJHtkdXJhdGlvbn1tcy4gZ2l2aW5nIHVwYCxcbiAgICAgICAgdGhpcy5sb2dDb250ZXh0LFxuICAgICAgKTtcbiAgICAgIHRoaXMuZW1pdChFbmdpbmVFdmVudC5EaXNjb25uZWN0ZWQpO1xuICAgICAgdGhpcy5jbG9zZSgpO1xuICAgIH07XG5cbiAgICBjb25zdCBkdXJhdGlvbiA9IERhdGUubm93KCkgLSB0aGlzLnJlY29ubmVjdFN0YXJ0O1xuICAgIGxldCBkZWxheSA9IHRoaXMuZ2V0TmV4dFJldHJ5RGVsYXkoe1xuICAgICAgZWxhcHNlZE1zOiBkdXJhdGlvbixcbiAgICAgIHJldHJ5Q291bnQ6IHRoaXMucmVjb25uZWN0QXR0ZW1wdHMsXG4gICAgfSk7XG5cbiAgICBpZiAoZGVsYXkgPT09IG51bGwpIHtcbiAgICAgIGRpc2Nvbm5lY3QoZHVyYXRpb24pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoY29ubmVjdGlvbiA9PT0gbGVhdmVSZWNvbm5lY3QpIHtcbiAgICAgIGRlbGF5ID0gMDtcbiAgICB9XG5cbiAgICB0aGlzLmxvZy5kZWJ1ZyhgcmVjb25uZWN0aW5nIGluICR7ZGVsYXl9bXNgLCB0aGlzLmxvZ0NvbnRleHQpO1xuXG4gICAgdGhpcy5jbGVhclJlY29ubmVjdFRpbWVvdXQoKTtcbiAgICBpZiAodGhpcy50b2tlbiAmJiB0aGlzLnJlZ2lvblVybFByb3ZpZGVyKSB7XG4gICAgICAvLyB0b2tlbiBtYXkgaGF2ZSBiZWVuIHJlZnJlc2hlZCwgd2UgZG8gbm90IHdhbnQgdG8gcmVjcmVhdGUgdGhlIHJlZ2lvblVybFByb3ZpZGVyXG4gICAgICAvLyBzaW5jZSB0aGUgY3VycmVudCBlbmdpbmUgbWF5IGhhdmUgaW5oZXJpdGVkIGEgcmVnaW9uYWwgdXJsXG4gICAgICB0aGlzLnJlZ2lvblVybFByb3ZpZGVyLnVwZGF0ZVRva2VuKHRoaXMudG9rZW4pO1xuICAgIH1cbiAgICB0aGlzLnJlY29ubmVjdFRpbWVvdXQgPSBDcml0aWNhbFRpbWVycy5zZXRUaW1lb3V0KFxuICAgICAgKCkgPT4gdGhpcy5hdHRlbXB0UmVjb25uZWN0KGRpc2Nvbm5lY3RSZWFzb24pLFxuICAgICAgZGVsYXksXG4gICAgKTtcbiAgfTtcblxuICBwcml2YXRlIGFzeW5jIGF0dGVtcHRSZWNvbm5lY3QocmVhc29uPzogUmVjb25uZWN0UmVhc29uKSB7XG4gICAgaWYgKHRoaXMuX2lzQ2xvc2VkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIGd1YXJkIGZvciBhdHRlbXB0aW5nIHJlY29ubmVjdGlvbiBtdWx0aXBsZSB0aW1lcyB3aGlsZSBvbmUgYXR0ZW1wdCBpcyBzdGlsbCBub3QgZmluaXNoZWRcbiAgICBpZiAodGhpcy5hdHRlbXB0aW5nUmVjb25uZWN0KSB7XG4gICAgICBsb2cud2FybignYWxyZWFkeSBhdHRlbXB0aW5nIHJlY29ubmVjdCwgcmV0dXJuaW5nIGVhcmx5JywgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKFxuICAgICAgdGhpcy5jbGllbnRDb25maWd1cmF0aW9uPy5yZXN1bWVDb25uZWN0aW9uID09PSBDbGllbnRDb25maWdTZXR0aW5nLkRJU0FCTEVEIHx8XG4gICAgICAvLyBzaWduYWxpbmcgc3RhdGUgY291bGQgY2hhbmdlIHRvIGNsb3NlZCBkdWUgdG8gaGFyZHdhcmUgc2xlZXBcbiAgICAgIC8vIHRob3NlIGNvbm5lY3Rpb25zIGNhbm5vdCBiZSByZXN1bWVkXG4gICAgICAodGhpcy5wY01hbmFnZXI/LmN1cnJlbnRTdGF0ZSA/PyBQQ1RyYW5zcG9ydFN0YXRlLk5FVykgPT09IFBDVHJhbnNwb3J0U3RhdGUuTkVXXG4gICAgKSB7XG4gICAgICB0aGlzLmZ1bGxSZWNvbm5lY3RPbk5leHQgPSB0cnVlO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICB0aGlzLmF0dGVtcHRpbmdSZWNvbm5lY3QgPSB0cnVlO1xuICAgICAgaWYgKHRoaXMuZnVsbFJlY29ubmVjdE9uTmV4dCkge1xuICAgICAgICBhd2FpdCB0aGlzLnJlc3RhcnRDb25uZWN0aW9uKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhd2FpdCB0aGlzLnJlc3VtZUNvbm5lY3Rpb24ocmVhc29uKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuY2xlYXJQZW5kaW5nUmVjb25uZWN0KCk7XG4gICAgICB0aGlzLmZ1bGxSZWNvbm5lY3RPbk5leHQgPSBmYWxzZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aGlzLnJlY29ubmVjdEF0dGVtcHRzICs9IDE7XG4gICAgICBsZXQgcmVjb3ZlcmFibGUgPSB0cnVlO1xuICAgICAgaWYgKGUgaW5zdGFuY2VvZiBVbmV4cGVjdGVkQ29ubmVjdGlvblN0YXRlKSB7XG4gICAgICAgIHRoaXMubG9nLmRlYnVnKCdyZWNlaXZlZCB1bnJlY292ZXJhYmxlIGVycm9yJywgeyAuLi50aGlzLmxvZ0NvbnRleHQsIGVycm9yOiBlIH0pO1xuICAgICAgICAvLyB1bnJlY292ZXJhYmxlXG4gICAgICAgIHJlY292ZXJhYmxlID0gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKCEoZSBpbnN0YW5jZW9mIFNpZ25hbFJlY29ubmVjdEVycm9yKSkge1xuICAgICAgICAvLyBjYW5ub3QgcmVzdW1lXG4gICAgICAgIHRoaXMuZnVsbFJlY29ubmVjdE9uTmV4dCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZWNvdmVyYWJsZSkge1xuICAgICAgICB0aGlzLmhhbmRsZURpc2Nvbm5lY3QoJ3JlY29ubmVjdCcsIFJlY29ubmVjdFJlYXNvbi5SUl9VTktOT1dOKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubG9nLmluZm8oXG4gICAgICAgICAgYGNvdWxkIG5vdCByZWNvdmVyIGNvbm5lY3Rpb24gYWZ0ZXIgJHt0aGlzLnJlY29ubmVjdEF0dGVtcHRzfSBhdHRlbXB0cywgJHtcbiAgICAgICAgICAgIERhdGUubm93KCkgLSB0aGlzLnJlY29ubmVjdFN0YXJ0XG4gICAgICAgICAgfW1zLiBnaXZpbmcgdXBgLFxuICAgICAgICAgIHRoaXMubG9nQ29udGV4dCxcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5lbWl0KEVuZ2luZUV2ZW50LkRpc2Nvbm5lY3RlZCk7XG4gICAgICAgIGF3YWl0IHRoaXMuY2xvc2UoKTtcbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgdGhpcy5hdHRlbXB0aW5nUmVjb25uZWN0ID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBnZXROZXh0UmV0cnlEZWxheShjb250ZXh0OiBSZWNvbm5lY3RDb250ZXh0KSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB0aGlzLnJlY29ubmVjdFBvbGljeS5uZXh0UmV0cnlEZWxheUluTXMoY29udGV4dCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhpcy5sb2cud2FybignZW5jb3VudGVyZWQgZXJyb3IgaW4gcmVjb25uZWN0IHBvbGljeScsIHsgLi4udGhpcy5sb2dDb250ZXh0LCBlcnJvcjogZSB9KTtcbiAgICB9XG5cbiAgICAvLyBlcnJvciBpbiB1c2VyIGNvZGUgd2l0aCBwcm92aWRlZCByZWNvbm5lY3QgcG9saWN5LCBzdG9wIHJlY29ubmVjdGluZ1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyByZXN0YXJ0Q29ubmVjdGlvbihyZWdpb25Vcmw/OiBzdHJpbmcpIHtcbiAgICB0cnkge1xuICAgICAgaWYgKCF0aGlzLnVybCB8fCAhdGhpcy50b2tlbikge1xuICAgICAgICAvLyBwZXJtYW5lbnQgZmFpbHVyZSwgZG9uJ3QgYXR0ZW1wdCByZWNvbm5lY3Rpb25cbiAgICAgICAgdGhyb3cgbmV3IFVuZXhwZWN0ZWRDb25uZWN0aW9uU3RhdGUoJ2NvdWxkIG5vdCByZWNvbm5lY3QsIHVybCBvciB0b2tlbiBub3Qgc2F2ZWQnKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5sb2cuaW5mbyhgcmVjb25uZWN0aW5nLCBhdHRlbXB0OiAke3RoaXMucmVjb25uZWN0QXR0ZW1wdHN9YCwgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgIHRoaXMuZW1pdChFbmdpbmVFdmVudC5SZXN0YXJ0aW5nKTtcblxuICAgICAgaWYgKCF0aGlzLmNsaWVudC5pc0Rpc2Nvbm5lY3RlZCkge1xuICAgICAgICBhd2FpdCB0aGlzLmNsaWVudC5zZW5kTGVhdmUoKTtcbiAgICAgIH1cbiAgICAgIGF3YWl0IHRoaXMuY2xlYW51cFBlZXJDb25uZWN0aW9ucygpO1xuICAgICAgYXdhaXQgdGhpcy5jbGVhbnVwQ2xpZW50KCk7XG5cbiAgICAgIGxldCBqb2luUmVzcG9uc2U6IEpvaW5SZXNwb25zZTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICghdGhpcy5zaWduYWxPcHRzKSB7XG4gICAgICAgICAgdGhpcy5sb2cud2FybihcbiAgICAgICAgICAgICdhdHRlbXB0ZWQgY29ubmVjdGlvbiByZXN0YXJ0LCB3aXRob3V0IHNpZ25hbCBvcHRpb25zIHByZXNlbnQnLFxuICAgICAgICAgICAgdGhpcy5sb2dDb250ZXh0LFxuICAgICAgICAgICk7XG4gICAgICAgICAgdGhyb3cgbmV3IFNpZ25hbFJlY29ubmVjdEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaW4gY2FzZSBhIHJlZ2lvblVybCBpcyBwYXNzZWQsIHRoZSByZWdpb24gVVJMIHRha2VzIHByZWNlZGVuY2VcbiAgICAgICAgam9pblJlc3BvbnNlID0gYXdhaXQgdGhpcy5qb2luKHJlZ2lvblVybCA/PyB0aGlzLnVybCwgdGhpcy50b2tlbiwgdGhpcy5zaWduYWxPcHRzKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBDb25uZWN0aW9uRXJyb3IgJiYgZS5yZWFzb24gPT09IENvbm5lY3Rpb25FcnJvclJlYXNvbi5Ob3RBbGxvd2VkKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFVuZXhwZWN0ZWRDb25uZWN0aW9uU3RhdGUoJ2NvdWxkIG5vdCByZWNvbm5lY3QsIHRva2VuIG1pZ2h0IGJlIGV4cGlyZWQnKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgU2lnbmFsUmVjb25uZWN0RXJyb3IoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuc2hvdWxkRmFpbE5leHQpIHtcbiAgICAgICAgdGhpcy5zaG91bGRGYWlsTmV4dCA9IGZhbHNlO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NpbXVsYXRlZCBmYWlsdXJlJyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY2xpZW50LnNldFJlY29ubmVjdGVkKCk7XG4gICAgICB0aGlzLmVtaXQoRW5naW5lRXZlbnQuU2lnbmFsUmVzdGFydGVkLCBqb2luUmVzcG9uc2UpO1xuXG4gICAgICBhd2FpdCB0aGlzLndhaXRGb3JQQ1JlY29ubmVjdGVkKCk7XG5cbiAgICAgIC8vIHJlLWNoZWNrIHNpZ25hbCBjb25uZWN0aW9uIHN0YXRlIGJlZm9yZSBzZXR0aW5nIGVuZ2luZSBhcyByZXN1bWVkXG4gICAgICBpZiAodGhpcy5jbGllbnQuY3VycmVudFN0YXRlICE9PSBTaWduYWxDb25uZWN0aW9uU3RhdGUuQ09OTkVDVEVEKSB7XG4gICAgICAgIHRocm93IG5ldyBTaWduYWxSZWNvbm5lY3RFcnJvcignU2lnbmFsIGNvbm5lY3Rpb24gZ290IHNldmVyZWQgZHVyaW5nIHJlY29ubmVjdCcpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnJlZ2lvblVybFByb3ZpZGVyPy5yZXNldEF0dGVtcHRzKCk7XG4gICAgICAvLyByZWNvbm5lY3Qgc3VjY2Vzc1xuICAgICAgdGhpcy5lbWl0KEVuZ2luZUV2ZW50LlJlc3RhcnRlZCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnN0IG5leHRSZWdpb25VcmwgPSBhd2FpdCB0aGlzLnJlZ2lvblVybFByb3ZpZGVyPy5nZXROZXh0QmVzdFJlZ2lvblVybCgpO1xuICAgICAgaWYgKG5leHRSZWdpb25VcmwpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5yZXN0YXJ0Q29ubmVjdGlvbihuZXh0UmVnaW9uVXJsKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gbm8gbW9yZSByZWdpb25zIHRvIHRyeSAob3Igd2UncmUgbm90IG9uIGNsb3VkKVxuICAgICAgICB0aGlzLnJlZ2lvblVybFByb3ZpZGVyPy5yZXNldEF0dGVtcHRzKCk7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgcmVzdW1lQ29ubmVjdGlvbihyZWFzb24/OiBSZWNvbm5lY3RSZWFzb24pOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBpZiAoIXRoaXMudXJsIHx8ICF0aGlzLnRva2VuKSB7XG4gICAgICAvLyBwZXJtYW5lbnQgZmFpbHVyZSwgZG9uJ3QgYXR0ZW1wdCByZWNvbm5lY3Rpb25cbiAgICAgIHRocm93IG5ldyBVbmV4cGVjdGVkQ29ubmVjdGlvblN0YXRlKCdjb3VsZCBub3QgcmVjb25uZWN0LCB1cmwgb3IgdG9rZW4gbm90IHNhdmVkJyk7XG4gICAgfVxuICAgIC8vIHRyaWdnZXIgcHVibGlzaGVyIHJlY29ubmVjdFxuICAgIGlmICghdGhpcy5wY01hbmFnZXIpIHtcbiAgICAgIHRocm93IG5ldyBVbmV4cGVjdGVkQ29ubmVjdGlvblN0YXRlKCdwdWJsaXNoZXIgYW5kIHN1YnNjcmliZXIgY29ubmVjdGlvbnMgdW5zZXQnKTtcbiAgICB9XG5cbiAgICB0aGlzLmxvZy5pbmZvKGByZXN1bWluZyBzaWduYWwgY29ubmVjdGlvbiwgYXR0ZW1wdCAke3RoaXMucmVjb25uZWN0QXR0ZW1wdHN9YCwgdGhpcy5sb2dDb250ZXh0KTtcbiAgICB0aGlzLmVtaXQoRW5naW5lRXZlbnQuUmVzdW1pbmcpO1xuXG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuc2V0dXBTaWduYWxDbGllbnRDYWxsYmFja3MoKTtcbiAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuY2xpZW50LnJlY29ubmVjdCh0aGlzLnVybCwgdGhpcy50b2tlbiwgdGhpcy5wYXJ0aWNpcGFudFNpZCwgcmVhc29uKTtcbiAgICAgIGlmIChyZXMpIHtcbiAgICAgICAgY29uc3QgcnRjQ29uZmlnID0gdGhpcy5tYWtlUlRDQ29uZmlndXJhdGlvbihyZXMpO1xuICAgICAgICB0aGlzLnBjTWFuYWdlci51cGRhdGVDb25maWd1cmF0aW9uKHJ0Y0NvbmZpZyk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGxldCBtZXNzYWdlID0gJyc7XG4gICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICBtZXNzYWdlID0gZXJyb3IubWVzc2FnZTtcbiAgICAgICAgdGhpcy5sb2cuZXJyb3IoZXJyb3IubWVzc2FnZSwgeyAuLi50aGlzLmxvZ0NvbnRleHQsIGVycm9yIH0pO1xuICAgICAgfVxuICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgQ29ubmVjdGlvbkVycm9yICYmIGVycm9yLnJlYXNvbiA9PT0gQ29ubmVjdGlvbkVycm9yUmVhc29uLk5vdEFsbG93ZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IFVuZXhwZWN0ZWRDb25uZWN0aW9uU3RhdGUoJ2NvdWxkIG5vdCByZWNvbm5lY3QsIHRva2VuIG1pZ2h0IGJlIGV4cGlyZWQnKTtcbiAgICAgIH1cbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIENvbm5lY3Rpb25FcnJvciAmJiBlcnJvci5yZWFzb24gPT09IENvbm5lY3Rpb25FcnJvclJlYXNvbi5MZWF2ZVJlcXVlc3QpIHtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgU2lnbmFsUmVjb25uZWN0RXJyb3IobWVzc2FnZSk7XG4gICAgfVxuICAgIHRoaXMuZW1pdChFbmdpbmVFdmVudC5TaWduYWxSZXN1bWVkKTtcblxuICAgIGlmICh0aGlzLnNob3VsZEZhaWxOZXh0KSB7XG4gICAgICB0aGlzLnNob3VsZEZhaWxOZXh0ID0gZmFsc2U7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NpbXVsYXRlZCBmYWlsdXJlJyk7XG4gICAgfVxuXG4gICAgYXdhaXQgdGhpcy5wY01hbmFnZXIudHJpZ2dlckljZVJlc3RhcnQoKTtcblxuICAgIGF3YWl0IHRoaXMud2FpdEZvclBDUmVjb25uZWN0ZWQoKTtcblxuICAgIC8vIHJlLWNoZWNrIHNpZ25hbCBjb25uZWN0aW9uIHN0YXRlIGJlZm9yZSBzZXR0aW5nIGVuZ2luZSBhcyByZXN1bWVkXG4gICAgaWYgKHRoaXMuY2xpZW50LmN1cnJlbnRTdGF0ZSAhPT0gU2lnbmFsQ29ubmVjdGlvblN0YXRlLkNPTk5FQ1RFRCkge1xuICAgICAgdGhyb3cgbmV3IFNpZ25hbFJlY29ubmVjdEVycm9yKCdTaWduYWwgY29ubmVjdGlvbiBnb3Qgc2V2ZXJlZCBkdXJpbmcgcmVjb25uZWN0Jyk7XG4gICAgfVxuXG4gICAgdGhpcy5jbGllbnQuc2V0UmVjb25uZWN0ZWQoKTtcblxuICAgIC8vIHJlY3JlYXRlIHB1Ymxpc2ggZGF0YWNoYW5uZWwgaWYgaXQncyBpZCBpcyBudWxsXG4gICAgLy8gKGZvciBzYWZhcmkgaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTE4NDY4OClcbiAgICBpZiAodGhpcy5yZWxpYWJsZURDPy5yZWFkeVN0YXRlID09PSAnb3BlbicgJiYgdGhpcy5yZWxpYWJsZURDLmlkID09PSBudWxsKSB7XG4gICAgICB0aGlzLmNyZWF0ZURhdGFDaGFubmVscygpO1xuICAgIH1cblxuICAgIC8vIHJlc3VtZSBzdWNjZXNzXG4gICAgdGhpcy5lbWl0KEVuZ2luZUV2ZW50LlJlc3VtZWQpO1xuICB9XG5cbiAgYXN5bmMgd2FpdEZvclBDSW5pdGlhbENvbm5lY3Rpb24odGltZW91dD86IG51bWJlciwgYWJvcnRDb250cm9sbGVyPzogQWJvcnRDb250cm9sbGVyKSB7XG4gICAgaWYgKCF0aGlzLnBjTWFuYWdlcikge1xuICAgICAgdGhyb3cgbmV3IFVuZXhwZWN0ZWRDb25uZWN0aW9uU3RhdGUoJ1BDIG1hbmFnZXIgaXMgY2xvc2VkJyk7XG4gICAgfVxuICAgIGF3YWl0IHRoaXMucGNNYW5hZ2VyLmVuc3VyZVBDVHJhbnNwb3J0Q29ubmVjdGlvbihhYm9ydENvbnRyb2xsZXIsIHRpbWVvdXQpO1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyB3YWl0Rm9yUENSZWNvbm5lY3RlZCgpIHtcbiAgICB0aGlzLnBjU3RhdGUgPSBQQ1N0YXRlLlJlY29ubmVjdGluZztcblxuICAgIHRoaXMubG9nLmRlYnVnKCd3YWl0aW5nIGZvciBwZWVyIGNvbm5lY3Rpb24gdG8gcmVjb25uZWN0JywgdGhpcy5sb2dDb250ZXh0KTtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgc2xlZXAobWluUmVjb25uZWN0V2FpdCk7IC8vIEZJWE1FIHNldFRpbWVvdXQgYWdhaW4gbm90IGlkZWFsIGZvciBhIGNvbm5lY3Rpb24gY3JpdGljYWwgcGF0aFxuICAgICAgaWYgKCF0aGlzLnBjTWFuYWdlcikge1xuICAgICAgICB0aHJvdyBuZXcgVW5leHBlY3RlZENvbm5lY3Rpb25TdGF0ZSgnUEMgbWFuYWdlciBpcyBjbG9zZWQnKTtcbiAgICAgIH1cbiAgICAgIGF3YWl0IHRoaXMucGNNYW5hZ2VyLmVuc3VyZVBDVHJhbnNwb3J0Q29ubmVjdGlvbih1bmRlZmluZWQsIHRoaXMucGVlckNvbm5lY3Rpb25UaW1lb3V0KTtcbiAgICAgIHRoaXMucGNTdGF0ZSA9IFBDU3RhdGUuQ29ubmVjdGVkO1xuICAgIH0gY2F0Y2ggKGU6IGFueSkge1xuICAgICAgLy8gVE9ETyBkbyB3ZSBuZWVkIGEgYGZhaWxlZGAgc3RhdGUgaGVyZSBmb3IgdGhlIFBDP1xuICAgICAgdGhpcy5wY1N0YXRlID0gUENTdGF0ZS5EaXNjb25uZWN0ZWQ7XG4gICAgICB0aHJvdyBuZXcgQ29ubmVjdGlvbkVycm9yKGBjb3VsZCBub3QgZXN0YWJsaXNoIFBDIGNvbm5lY3Rpb24sICR7ZS5tZXNzYWdlfWApO1xuICAgIH1cbiAgfVxuXG4gIHdhaXRGb3JSZXN0YXJ0ZWQgPSAoKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlPHZvaWQ+KChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGlmICh0aGlzLnBjU3RhdGUgPT09IFBDU3RhdGUuQ29ubmVjdGVkKSB7XG4gICAgICAgIHJlc29sdmUoKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG9uUmVzdGFydGVkID0gKCkgPT4ge1xuICAgICAgICB0aGlzLm9mZihFbmdpbmVFdmVudC5EaXNjb25uZWN0ZWQsIG9uRGlzY29ubmVjdGVkKTtcbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IG9uRGlzY29ubmVjdGVkID0gKCkgPT4ge1xuICAgICAgICB0aGlzLm9mZihFbmdpbmVFdmVudC5SZXN0YXJ0ZWQsIG9uUmVzdGFydGVkKTtcbiAgICAgICAgcmVqZWN0KCk7XG4gICAgICB9O1xuICAgICAgdGhpcy5vbmNlKEVuZ2luZUV2ZW50LlJlc3RhcnRlZCwgb25SZXN0YXJ0ZWQpO1xuICAgICAgdGhpcy5vbmNlKEVuZ2luZUV2ZW50LkRpc2Nvbm5lY3RlZCwgb25EaXNjb25uZWN0ZWQpO1xuICAgIH0pO1xuICB9O1xuXG4gIC8qIEBpbnRlcm5hbCAqL1xuICBhc3luYyBzZW5kRGF0YVBhY2tldChwYWNrZXQ6IERhdGFQYWNrZXQsIGtpbmQ6IERhdGFQYWNrZXRfS2luZCkge1xuICAgIGNvbnN0IG1zZyA9IHBhY2tldC50b0JpbmFyeSgpO1xuXG4gICAgLy8gbWFrZSBzdXJlIHdlIGRvIGhhdmUgYSBkYXRhIGNvbm5lY3Rpb25cbiAgICBhd2FpdCB0aGlzLmVuc3VyZVB1Ymxpc2hlckNvbm5lY3RlZChraW5kKTtcblxuICAgIGNvbnN0IGRjID0gdGhpcy5kYXRhQ2hhbm5lbEZvcktpbmQoa2luZCk7XG4gICAgaWYgKGRjKSB7XG4gICAgICBkYy5zZW5kKG1zZyk7XG4gICAgfVxuXG4gICAgdGhpcy51cGRhdGVBbmRFbWl0RENCdWZmZXJTdGF0dXMoa2luZCk7XG4gIH1cblxuICBwcml2YXRlIHVwZGF0ZUFuZEVtaXREQ0J1ZmZlclN0YXR1cyA9IChraW5kOiBEYXRhUGFja2V0X0tpbmQpID0+IHtcbiAgICBjb25zdCBzdGF0dXMgPSB0aGlzLmlzQnVmZmVyU3RhdHVzTG93KGtpbmQpO1xuICAgIGlmICh0eXBlb2Ygc3RhdHVzICE9PSAndW5kZWZpbmVkJyAmJiBzdGF0dXMgIT09IHRoaXMuZGNCdWZmZXJTdGF0dXMuZ2V0KGtpbmQpKSB7XG4gICAgICB0aGlzLmRjQnVmZmVyU3RhdHVzLnNldChraW5kLCBzdGF0dXMpO1xuICAgICAgdGhpcy5lbWl0KEVuZ2luZUV2ZW50LkRDQnVmZmVyU3RhdHVzQ2hhbmdlZCwgc3RhdHVzLCBraW5kKTtcbiAgICB9XG4gIH07XG5cbiAgcHJpdmF0ZSBpc0J1ZmZlclN0YXR1c0xvdyA9IChraW5kOiBEYXRhUGFja2V0X0tpbmQpOiBib29sZWFuIHwgdW5kZWZpbmVkID0+IHtcbiAgICBjb25zdCBkYyA9IHRoaXMuZGF0YUNoYW5uZWxGb3JLaW5kKGtpbmQpO1xuICAgIGlmIChkYykge1xuICAgICAgcmV0dXJuIGRjLmJ1ZmZlcmVkQW1vdW50IDw9IGRjLmJ1ZmZlcmVkQW1vdW50TG93VGhyZXNob2xkO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBhc3luYyBlbnN1cmVEYXRhVHJhbnNwb3J0Q29ubmVjdGVkKFxuICAgIGtpbmQ6IERhdGFQYWNrZXRfS2luZCxcbiAgICBzdWJzY3JpYmVyOiBib29sZWFuID0gdGhpcy5zdWJzY3JpYmVyUHJpbWFyeSxcbiAgKSB7XG4gICAgaWYgKCF0aGlzLnBjTWFuYWdlcikge1xuICAgICAgdGhyb3cgbmV3IFVuZXhwZWN0ZWRDb25uZWN0aW9uU3RhdGUoJ1BDIG1hbmFnZXIgaXMgY2xvc2VkJyk7XG4gICAgfVxuICAgIGNvbnN0IHRyYW5zcG9ydCA9IHN1YnNjcmliZXIgPyB0aGlzLnBjTWFuYWdlci5zdWJzY3JpYmVyIDogdGhpcy5wY01hbmFnZXIucHVibGlzaGVyO1xuICAgIGNvbnN0IHRyYW5zcG9ydE5hbWUgPSBzdWJzY3JpYmVyID8gJ1N1YnNjcmliZXInIDogJ1B1Ymxpc2hlcic7XG4gICAgaWYgKCF0cmFuc3BvcnQpIHtcbiAgICAgIHRocm93IG5ldyBDb25uZWN0aW9uRXJyb3IoYCR7dHJhbnNwb3J0TmFtZX0gY29ubmVjdGlvbiBub3Qgc2V0YCk7XG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgIXN1YnNjcmliZXIgJiZcbiAgICAgICF0aGlzLnBjTWFuYWdlci5wdWJsaXNoZXIuaXNJQ0VDb25uZWN0ZWQgJiZcbiAgICAgIHRoaXMucGNNYW5hZ2VyLnB1Ymxpc2hlci5nZXRJQ0VDb25uZWN0aW9uU3RhdGUoKSAhPT0gJ2NoZWNraW5nJ1xuICAgICkge1xuICAgICAgLy8gc3RhcnQgbmVnb3RpYXRpb25cbiAgICAgIHRoaXMubmVnb3RpYXRlKCk7XG4gICAgfVxuXG4gICAgY29uc3QgdGFyZ2V0Q2hhbm5lbCA9IHRoaXMuZGF0YUNoYW5uZWxGb3JLaW5kKGtpbmQsIHN1YnNjcmliZXIpO1xuICAgIGlmICh0YXJnZXRDaGFubmVsPy5yZWFkeVN0YXRlID09PSAnb3BlbicpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyB3YWl0IHVudGlsIElDRSBjb25uZWN0ZWRcbiAgICBjb25zdCBlbmRUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCkgKyB0aGlzLnBlZXJDb25uZWN0aW9uVGltZW91dDtcbiAgICB3aGlsZSAobmV3IERhdGUoKS5nZXRUaW1lKCkgPCBlbmRUaW1lKSB7XG4gICAgICBpZiAoXG4gICAgICAgIHRyYW5zcG9ydC5pc0lDRUNvbm5lY3RlZCAmJlxuICAgICAgICB0aGlzLmRhdGFDaGFubmVsRm9yS2luZChraW5kLCBzdWJzY3JpYmVyKT8ucmVhZHlTdGF0ZSA9PT0gJ29wZW4nXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgYXdhaXQgc2xlZXAoNTApO1xuICAgIH1cblxuICAgIHRocm93IG5ldyBDb25uZWN0aW9uRXJyb3IoXG4gICAgICBgY291bGQgbm90IGVzdGFibGlzaCAke3RyYW5zcG9ydE5hbWV9IGNvbm5lY3Rpb24sIHN0YXRlOiAke3RyYW5zcG9ydC5nZXRJQ0VDb25uZWN0aW9uU3RhdGUoKX1gLFxuICAgICk7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGVuc3VyZVB1Ymxpc2hlckNvbm5lY3RlZChraW5kOiBEYXRhUGFja2V0X0tpbmQpIHtcbiAgICBhd2FpdCB0aGlzLmVuc3VyZURhdGFUcmFuc3BvcnRDb25uZWN0ZWQoa2luZCwgZmFsc2UpO1xuICB9XG5cbiAgLyogQGludGVybmFsICovXG4gIHZlcmlmeVRyYW5zcG9ydCgpOiBib29sZWFuIHtcbiAgICBpZiAoIXRoaXMucGNNYW5hZ2VyKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIHByaW1hcnkgY29ubmVjdGlvblxuICAgIGlmICh0aGlzLnBjTWFuYWdlci5jdXJyZW50U3RhdGUgIT09IFBDVHJhbnNwb3J0U3RhdGUuQ09OTkVDVEVEKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gZW5zdXJlIHNpZ25hbCBpcyBjb25uZWN0ZWRcbiAgICBpZiAoIXRoaXMuY2xpZW50LndzIHx8IHRoaXMuY2xpZW50LndzLnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5DTE9TRUQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKiogQGludGVybmFsICovXG4gIGFzeW5jIG5lZ290aWF0ZSgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAvLyBvYnNlcnZlIHNpZ25hbCBzdGF0ZVxuICAgIHJldHVybiBuZXcgUHJvbWlzZTx2b2lkPihhc3luYyAocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBpZiAoIXRoaXMucGNNYW5hZ2VyKSB7XG4gICAgICAgIHJlamVjdChuZXcgTmVnb3RpYXRpb25FcnJvcignUEMgbWFuYWdlciBpcyBjbG9zZWQnKSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5wY01hbmFnZXIucmVxdWlyZVB1Ymxpc2hlcigpO1xuXG4gICAgICBjb25zdCBhYm9ydENvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG5cbiAgICAgIGNvbnN0IGhhbmRsZUNsb3NlZCA9ICgpID0+IHtcbiAgICAgICAgYWJvcnRDb250cm9sbGVyLmFib3J0KCk7XG4gICAgICAgIHRoaXMubG9nLmRlYnVnKCdlbmdpbmUgZGlzY29ubmVjdGVkIHdoaWxlIG5lZ290aWF0aW9uIHdhcyBvbmdvaW5nJywgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9O1xuXG4gICAgICBpZiAodGhpcy5pc0Nsb3NlZCkge1xuICAgICAgICByZWplY3QoJ2Nhbm5vdCBuZWdvdGlhdGUgb24gY2xvc2VkIGVuZ2luZScpO1xuICAgICAgfVxuICAgICAgdGhpcy5vbihFbmdpbmVFdmVudC5DbG9zaW5nLCBoYW5kbGVDbG9zZWQpO1xuXG4gICAgICB0aGlzLnBjTWFuYWdlci5wdWJsaXNoZXIub25jZShcbiAgICAgICAgUENFdmVudHMuUlRQVmlkZW9QYXlsb2FkVHlwZXMsXG4gICAgICAgIChydHBUeXBlczogTWVkaWFBdHRyaWJ1dGVzWydydHAnXSkgPT4ge1xuICAgICAgICAgIGNvbnN0IHJ0cE1hcCA9IG5ldyBNYXA8bnVtYmVyLCBWaWRlb0NvZGVjPigpO1xuICAgICAgICAgIHJ0cFR5cGVzLmZvckVhY2goKHJ0cCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgY29kZWMgPSBydHAuY29kZWMudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIGlmIChpc1ZpZGVvQ29kZWMoY29kZWMpKSB7XG4gICAgICAgICAgICAgIHJ0cE1hcC5zZXQocnRwLnBheWxvYWQsIGNvZGVjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0aGlzLmVtaXQoRW5naW5lRXZlbnQuUlRQVmlkZW9NYXBVcGRhdGUsIHJ0cE1hcCk7XG4gICAgICAgIH0sXG4gICAgICApO1xuXG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCB0aGlzLnBjTWFuYWdlci5uZWdvdGlhdGUoYWJvcnRDb250cm9sbGVyKTtcbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgfSBjYXRjaCAoZTogYW55KSB7XG4gICAgICAgIGlmIChlIGluc3RhbmNlb2YgTmVnb3RpYXRpb25FcnJvcikge1xuICAgICAgICAgIHRoaXMuZnVsbFJlY29ubmVjdE9uTmV4dCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5oYW5kbGVEaXNjb25uZWN0KCduZWdvdGlhdGlvbicsIFJlY29ubmVjdFJlYXNvbi5SUl9VTktOT1dOKTtcbiAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdGhpcy5vZmYoRW5naW5lRXZlbnQuQ2xvc2luZywgaGFuZGxlQ2xvc2VkKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGRhdGFDaGFubmVsRm9yS2luZChraW5kOiBEYXRhUGFja2V0X0tpbmQsIHN1Yj86IGJvb2xlYW4pOiBSVENEYXRhQ2hhbm5lbCB8IHVuZGVmaW5lZCB7XG4gICAgaWYgKCFzdWIpIHtcbiAgICAgIGlmIChraW5kID09PSBEYXRhUGFja2V0X0tpbmQuTE9TU1kpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9zc3lEQztcbiAgICAgIH1cbiAgICAgIGlmIChraW5kID09PSBEYXRhUGFja2V0X0tpbmQuUkVMSUFCTEUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVsaWFibGVEQztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGtpbmQgPT09IERhdGFQYWNrZXRfS2luZC5MT1NTWSkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb3NzeURDU3ViO1xuICAgICAgfVxuICAgICAgaWYgKGtpbmQgPT09IERhdGFQYWNrZXRfS2luZC5SRUxJQUJMRSkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZWxpYWJsZURDU3ViO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgc2VuZFN5bmNTdGF0ZShyZW1vdGVUcmFja3M6IFJlbW90ZVRyYWNrUHVibGljYXRpb25bXSwgbG9jYWxUcmFja3M6IExvY2FsVHJhY2tQdWJsaWNhdGlvbltdKSB7XG4gICAgaWYgKCF0aGlzLnBjTWFuYWdlcikge1xuICAgICAgdGhpcy5sb2cud2Fybignc3luYyBzdGF0ZSBjYW5ub3QgYmUgc2VudCB3aXRob3V0IHBlZXIgY29ubmVjdGlvbiBzZXR1cCcsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHByZXZpb3VzQW5zd2VyID0gdGhpcy5wY01hbmFnZXIuc3Vic2NyaWJlci5nZXRMb2NhbERlc2NyaXB0aW9uKCk7XG4gICAgY29uc3QgcHJldmlvdXNPZmZlciA9IHRoaXMucGNNYW5hZ2VyLnN1YnNjcmliZXIuZ2V0UmVtb3RlRGVzY3JpcHRpb24oKTtcblxuICAgIC8qIDEuIGF1dG9zdWJzY3JpYmUgb24sIHNvIHN1YnNjcmliZWQgdHJhY2tzID0gYWxsIHRyYWNrcyAtIHVuc3ViIHRyYWNrcyxcbiAgICAgICAgICBpbiB0aGlzIGNhc2UsIHdlIHNlbmQgdW5zdWIgdHJhY2tzLCBzbyBzZXJ2ZXIgYWRkIGFsbCB0cmFja3MgdG8gdGhpc1xuICAgICAgICAgIHN1YnNjcmliZSBwYyBhbmQgdW5zdWIgc3BlY2lhbCB0cmFja3MgZnJvbSBpdC5cbiAgICAgICAyLiBhdXRvc3Vic2NyaWJlIG9mZiwgd2Ugc2VuZCBzdWJzY3JpYmVkIHRyYWNrcy5cbiAgICAqL1xuICAgIGNvbnN0IGF1dG9TdWJzY3JpYmUgPSB0aGlzLnNpZ25hbE9wdHM/LmF1dG9TdWJzY3JpYmUgPz8gdHJ1ZTtcbiAgICBjb25zdCB0cmFja1NpZHMgPSBuZXcgQXJyYXk8c3RyaW5nPigpO1xuXG4gICAgcmVtb3RlVHJhY2tzLmZvckVhY2goKHRyYWNrKSA9PiB7XG4gICAgICBpZiAodHJhY2suaXNEZXNpcmVkICE9PSBhdXRvU3Vic2NyaWJlKSB7XG4gICAgICAgIHRyYWNrU2lkcy5wdXNoKHRyYWNrLnRyYWNrU2lkKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHRoaXMuY2xpZW50LnNlbmRTeW5jU3RhdGUoXG4gICAgICBuZXcgU3luY1N0YXRlKHtcbiAgICAgICAgYW5zd2VyOiBwcmV2aW91c0Fuc3dlclxuICAgICAgICAgID8gdG9Qcm90b1Nlc3Npb25EZXNjcmlwdGlvbih7XG4gICAgICAgICAgICAgIHNkcDogcHJldmlvdXNBbnN3ZXIuc2RwLFxuICAgICAgICAgICAgICB0eXBlOiBwcmV2aW91c0Fuc3dlci50eXBlLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgb2ZmZXI6IHByZXZpb3VzT2ZmZXJcbiAgICAgICAgICA/IHRvUHJvdG9TZXNzaW9uRGVzY3JpcHRpb24oe1xuICAgICAgICAgICAgICBzZHA6IHByZXZpb3VzT2ZmZXIuc2RwLFxuICAgICAgICAgICAgICB0eXBlOiBwcmV2aW91c09mZmVyLnR5cGUsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICBzdWJzY3JpcHRpb246IG5ldyBVcGRhdGVTdWJzY3JpcHRpb24oe1xuICAgICAgICAgIHRyYWNrU2lkcyxcbiAgICAgICAgICBzdWJzY3JpYmU6ICFhdXRvU3Vic2NyaWJlLFxuICAgICAgICAgIHBhcnRpY2lwYW50VHJhY2tzOiBbXSxcbiAgICAgICAgfSksXG4gICAgICAgIHB1Ymxpc2hUcmFja3M6IGdldFRyYWNrUHVibGljYXRpb25JbmZvKGxvY2FsVHJhY2tzKSxcbiAgICAgICAgZGF0YUNoYW5uZWxzOiB0aGlzLmRhdGFDaGFubmVsc0luZm8oKSxcbiAgICAgIH0pLFxuICAgICk7XG4gIH1cblxuICAvKiBAaW50ZXJuYWwgKi9cbiAgZmFpbE5leHQoKSB7XG4gICAgLy8gZGVidWdnaW5nIG1ldGhvZCB0byBmYWlsIHRoZSBuZXh0IHJlY29ubmVjdC9yZXN1bWUgYXR0ZW1wdFxuICAgIHRoaXMuc2hvdWxkRmFpbE5leHQgPSB0cnVlO1xuICB9XG5cbiAgcHJpdmF0ZSBkYXRhQ2hhbm5lbHNJbmZvKCk6IERhdGFDaGFubmVsSW5mb1tdIHtcbiAgICBjb25zdCBpbmZvczogRGF0YUNoYW5uZWxJbmZvW10gPSBbXTtcbiAgICBjb25zdCBnZXRJbmZvID0gKGRjOiBSVENEYXRhQ2hhbm5lbCB8IHVuZGVmaW5lZCwgdGFyZ2V0OiBTaWduYWxUYXJnZXQpID0+IHtcbiAgICAgIGlmIChkYz8uaWQgIT09IHVuZGVmaW5lZCAmJiBkYy5pZCAhPT0gbnVsbCkge1xuICAgICAgICBpbmZvcy5wdXNoKFxuICAgICAgICAgIG5ldyBEYXRhQ2hhbm5lbEluZm8oe1xuICAgICAgICAgICAgbGFiZWw6IGRjLmxhYmVsLFxuICAgICAgICAgICAgaWQ6IGRjLmlkLFxuICAgICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgIH0pLFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH07XG4gICAgZ2V0SW5mbyh0aGlzLmRhdGFDaGFubmVsRm9yS2luZChEYXRhUGFja2V0X0tpbmQuTE9TU1kpLCBTaWduYWxUYXJnZXQuUFVCTElTSEVSKTtcbiAgICBnZXRJbmZvKHRoaXMuZGF0YUNoYW5uZWxGb3JLaW5kKERhdGFQYWNrZXRfS2luZC5SRUxJQUJMRSksIFNpZ25hbFRhcmdldC5QVUJMSVNIRVIpO1xuICAgIGdldEluZm8odGhpcy5kYXRhQ2hhbm5lbEZvcktpbmQoRGF0YVBhY2tldF9LaW5kLkxPU1NZLCB0cnVlKSwgU2lnbmFsVGFyZ2V0LlNVQlNDUklCRVIpO1xuICAgIGdldEluZm8odGhpcy5kYXRhQ2hhbm5lbEZvcktpbmQoRGF0YVBhY2tldF9LaW5kLlJFTElBQkxFLCB0cnVlKSwgU2lnbmFsVGFyZ2V0LlNVQlNDUklCRVIpO1xuICAgIHJldHVybiBpbmZvcztcbiAgfVxuXG4gIHByaXZhdGUgY2xlYXJSZWNvbm5lY3RUaW1lb3V0KCkge1xuICAgIGlmICh0aGlzLnJlY29ubmVjdFRpbWVvdXQpIHtcbiAgICAgIENyaXRpY2FsVGltZXJzLmNsZWFyVGltZW91dCh0aGlzLnJlY29ubmVjdFRpbWVvdXQpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgY2xlYXJQZW5kaW5nUmVjb25uZWN0KCkge1xuICAgIHRoaXMuY2xlYXJSZWNvbm5lY3RUaW1lb3V0KCk7XG4gICAgdGhpcy5yZWNvbm5lY3RBdHRlbXB0cyA9IDA7XG4gIH1cblxuICBwcml2YXRlIGhhbmRsZUJyb3dzZXJPbkxpbmUgPSAoKSA9PiB7XG4gICAgLy8gaW4gY2FzZSB0aGUgZW5naW5lIGlzIGN1cnJlbnRseSByZWNvbm5lY3RpbmcsIGF0dGVtcHQgYSByZWNvbm5lY3QgaW1tZWRpYXRlbHkgYWZ0ZXIgdGhlIGJyb3dzZXIgc3RhdGUgaGFzIGNoYW5nZWQgdG8gJ29uTGluZSdcbiAgICBpZiAodGhpcy5jbGllbnQuY3VycmVudFN0YXRlID09PSBTaWduYWxDb25uZWN0aW9uU3RhdGUuUkVDT05ORUNUSU5HKSB7XG4gICAgICB0aGlzLmNsZWFyUmVjb25uZWN0VGltZW91dCgpO1xuICAgICAgdGhpcy5hdHRlbXB0UmVjb25uZWN0KFJlY29ubmVjdFJlYXNvbi5SUl9TSUdOQUxfRElTQ09OTkVDVEVEKTtcbiAgICB9XG4gIH07XG5cbiAgcHJpdmF0ZSByZWdpc3Rlck9uTGluZUxpc3RlbmVyKCkge1xuICAgIGlmIChpc1dlYigpKSB7XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignb25saW5lJywgdGhpcy5oYW5kbGVCcm93c2VyT25MaW5lKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGRlcmVnaXN0ZXJPbkxpbmVMaXN0ZW5lcigpIHtcbiAgICBpZiAoaXNXZWIoKSkge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ29ubGluZScsIHRoaXMuaGFuZGxlQnJvd3Nlck9uTGluZSk7XG4gICAgfVxuICB9XG59XG5cbmNsYXNzIFNpZ25hbFJlY29ubmVjdEVycm9yIGV4dGVuZHMgRXJyb3Ige31cblxuZXhwb3J0IHR5cGUgRW5naW5lRXZlbnRDYWxsYmFja3MgPSB7XG4gIGNvbm5lY3RlZDogKGpvaW5SZXNwOiBKb2luUmVzcG9uc2UpID0+IHZvaWQ7XG4gIGRpc2Nvbm5lY3RlZDogKHJlYXNvbj86IERpc2Nvbm5lY3RSZWFzb24pID0+IHZvaWQ7XG4gIHJlc3VtaW5nOiAoKSA9PiB2b2lkO1xuICByZXN1bWVkOiAoKSA9PiB2b2lkO1xuICByZXN0YXJ0aW5nOiAoKSA9PiB2b2lkO1xuICByZXN0YXJ0ZWQ6ICgpID0+IHZvaWQ7XG4gIHNpZ25hbFJlc3VtZWQ6ICgpID0+IHZvaWQ7XG4gIHNpZ25hbFJlc3RhcnRlZDogKGpvaW5SZXNwOiBKb2luUmVzcG9uc2UpID0+IHZvaWQ7XG4gIGNsb3Npbmc6ICgpID0+IHZvaWQ7XG4gIG1lZGlhVHJhY2tBZGRlZDogKFxuICAgIHRyYWNrOiBNZWRpYVN0cmVhbVRyYWNrLFxuICAgIHN0cmVhbXM6IE1lZGlhU3RyZWFtLFxuICAgIHJlY2VpdmVyPzogUlRDUnRwUmVjZWl2ZXIsXG4gICkgPT4gdm9pZDtcbiAgYWN0aXZlU3BlYWtlcnNVcGRhdGU6IChzcGVha2VyczogQXJyYXk8U3BlYWtlckluZm8+KSA9PiB2b2lkO1xuICBkYXRhUGFja2V0UmVjZWl2ZWQ6ICh1c2VyUGFja2V0OiBVc2VyUGFja2V0LCBraW5kOiBEYXRhUGFja2V0X0tpbmQpID0+IHZvaWQ7XG4gIHRyYW5zcG9ydHNDcmVhdGVkOiAocHVibGlzaGVyOiBQQ1RyYW5zcG9ydCwgc3Vic2NyaWJlcjogUENUcmFuc3BvcnQpID0+IHZvaWQ7XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgdHJhY2tTZW5kZXJBZGRlZDogKHRyYWNrOiBUcmFjaywgc2VuZGVyOiBSVENSdHBTZW5kZXIpID0+IHZvaWQ7XG4gIHJ0cFZpZGVvTWFwVXBkYXRlOiAocnRwTWFwOiBNYXA8bnVtYmVyLCBWaWRlb0NvZGVjPikgPT4gdm9pZDtcbiAgZGNCdWZmZXJTdGF0dXNDaGFuZ2VkOiAoaXNMb3c6IGJvb2xlYW4sIGtpbmQ6IERhdGFQYWNrZXRfS2luZCkgPT4gdm9pZDtcbiAgcGFydGljaXBhbnRVcGRhdGU6IChpbmZvczogUGFydGljaXBhbnRJbmZvW10pID0+IHZvaWQ7XG4gIHJvb21VcGRhdGU6IChyb29tOiBSb29tTW9kZWwpID0+IHZvaWQ7XG4gIGNvbm5lY3Rpb25RdWFsaXR5VXBkYXRlOiAodXBkYXRlOiBDb25uZWN0aW9uUXVhbGl0eVVwZGF0ZSkgPT4gdm9pZDtcbiAgc3BlYWtlcnNDaGFuZ2VkOiAoc3BlYWtlclVwZGF0ZXM6IFNwZWFrZXJJbmZvW10pID0+IHZvaWQ7XG4gIHN0cmVhbVN0YXRlQ2hhbmdlZDogKHVwZGF0ZTogU3RyZWFtU3RhdGVVcGRhdGUpID0+IHZvaWQ7XG4gIHN1YnNjcmlwdGlvbkVycm9yOiAocmVzcDogU3Vic2NyaXB0aW9uUmVzcG9uc2UpID0+IHZvaWQ7XG4gIHN1YnNjcmlwdGlvblBlcm1pc3Npb25VcGRhdGU6ICh1cGRhdGU6IFN1YnNjcmlwdGlvblBlcm1pc3Npb25VcGRhdGUpID0+IHZvaWQ7XG4gIHN1YnNjcmliZWRRdWFsaXR5VXBkYXRlOiAodXBkYXRlOiBTdWJzY3JpYmVkUXVhbGl0eVVwZGF0ZSkgPT4gdm9pZDtcbiAgbG9jYWxUcmFja1VucHVibGlzaGVkOiAodW5wdWJsaXNoZWRSZXNwb25zZTogVHJhY2tVbnB1Ymxpc2hlZFJlc3BvbnNlKSA9PiB2b2lkO1xuICByZW1vdGVNdXRlOiAodHJhY2tTaWQ6IHN0cmluZywgbXV0ZWQ6IGJvb2xlYW4pID0+IHZvaWQ7XG59O1xuIiwiaW1wb3J0IGxvZyBmcm9tICcuLi9sb2dnZXInO1xuaW1wb3J0IHR5cGUgeyBSZWdpb25JbmZvLCBSZWdpb25TZXR0aW5ncyB9IGZyb20gJy4uL3Byb3RvL2xpdmVraXRfcnRjX3BiJztcbmltcG9ydCB7IENvbm5lY3Rpb25FcnJvciwgQ29ubmVjdGlvbkVycm9yUmVhc29uIH0gZnJvbSAnLi9lcnJvcnMnO1xuaW1wb3J0IHsgaXNDbG91ZCB9IGZyb20gJy4vdXRpbHMnO1xuXG5leHBvcnQgY2xhc3MgUmVnaW9uVXJsUHJvdmlkZXIge1xuICBwcml2YXRlIHNlcnZlclVybDogVVJMO1xuXG4gIHByaXZhdGUgdG9rZW46IHN0cmluZztcblxuICBwcml2YXRlIHJlZ2lvblNldHRpbmdzOiBSZWdpb25TZXR0aW5ncyB8IHVuZGVmaW5lZDtcblxuICBwcml2YXRlIGxhc3RVcGRhdGVBdDogbnVtYmVyID0gMDtcblxuICBwcml2YXRlIHNldHRpbmdzQ2FjaGVUaW1lID0gM18wMDA7XG5cbiAgcHJpdmF0ZSBhdHRlbXB0ZWRSZWdpb25zOiBSZWdpb25JbmZvW10gPSBbXTtcblxuICBjb25zdHJ1Y3Rvcih1cmw6IHN0cmluZywgdG9rZW46IHN0cmluZykge1xuICAgIHRoaXMuc2VydmVyVXJsID0gbmV3IFVSTCh1cmwpO1xuICAgIHRoaXMudG9rZW4gPSB0b2tlbjtcbiAgfVxuXG4gIHVwZGF0ZVRva2VuKHRva2VuOiBzdHJpbmcpIHtcbiAgICB0aGlzLnRva2VuID0gdG9rZW47XG4gIH1cblxuICBpc0Nsb3VkKCkge1xuICAgIHJldHVybiBpc0Nsb3VkKHRoaXMuc2VydmVyVXJsKTtcbiAgfVxuXG4gIGdldFNlcnZlclVybCgpIHtcbiAgICByZXR1cm4gdGhpcy5zZXJ2ZXJVcmw7XG4gIH1cblxuICBhc3luYyBnZXROZXh0QmVzdFJlZ2lvblVybChhYm9ydFNpZ25hbD86IEFib3J0U2lnbmFsKSB7XG4gICAgaWYgKCF0aGlzLmlzQ2xvdWQoKSkge1xuICAgICAgdGhyb3cgRXJyb3IoJ3JlZ2lvbiBhdmFpbGFiaWxpdHkgaXMgb25seSBzdXBwb3J0ZWQgZm9yIExpdmVLaXQgQ2xvdWQgZG9tYWlucycpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMucmVnaW9uU2V0dGluZ3MgfHwgRGF0ZS5ub3coKSAtIHRoaXMubGFzdFVwZGF0ZUF0ID4gdGhpcy5zZXR0aW5nc0NhY2hlVGltZSkge1xuICAgICAgdGhpcy5yZWdpb25TZXR0aW5ncyA9IGF3YWl0IHRoaXMuZmV0Y2hSZWdpb25TZXR0aW5ncyhhYm9ydFNpZ25hbCk7XG4gICAgfVxuICAgIGNvbnN0IHJlZ2lvbnNMZWZ0ID0gdGhpcy5yZWdpb25TZXR0aW5ncy5yZWdpb25zLmZpbHRlcihcbiAgICAgIChyZWdpb24pID0+ICF0aGlzLmF0dGVtcHRlZFJlZ2lvbnMuZmluZCgoYXR0ZW1wdGVkKSA9PiBhdHRlbXB0ZWQudXJsID09PSByZWdpb24udXJsKSxcbiAgICApO1xuICAgIGlmIChyZWdpb25zTGVmdC5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBuZXh0UmVnaW9uID0gcmVnaW9uc0xlZnRbMF07XG4gICAgICB0aGlzLmF0dGVtcHRlZFJlZ2lvbnMucHVzaChuZXh0UmVnaW9uKTtcbiAgICAgIGxvZy5kZWJ1ZyhgbmV4dCByZWdpb246ICR7bmV4dFJlZ2lvbi5yZWdpb259YCk7XG4gICAgICByZXR1cm4gbmV4dFJlZ2lvbi51cmw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuXG4gIHJlc2V0QXR0ZW1wdHMoKSB7XG4gICAgdGhpcy5hdHRlbXB0ZWRSZWdpb25zID0gW107XG4gIH1cblxuICAvKiBAaW50ZXJuYWwgKi9cbiAgYXN5bmMgZmV0Y2hSZWdpb25TZXR0aW5ncyhzaWduYWw/OiBBYm9ydFNpZ25hbCkge1xuICAgIGNvbnN0IHJlZ2lvblNldHRpbmdzUmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtnZXRDbG91ZENvbmZpZ1VybCh0aGlzLnNlcnZlclVybCl9L3JlZ2lvbnNgLCB7XG4gICAgICBoZWFkZXJzOiB7IGF1dGhvcml6YXRpb246IGBCZWFyZXIgJHt0aGlzLnRva2VufWAgfSxcbiAgICAgIHNpZ25hbCxcbiAgICB9KTtcbiAgICBpZiAocmVnaW9uU2V0dGluZ3NSZXNwb25zZS5vaykge1xuICAgICAgY29uc3QgcmVnaW9uU2V0dGluZ3MgPSAoYXdhaXQgcmVnaW9uU2V0dGluZ3NSZXNwb25zZS5qc29uKCkpIGFzIFJlZ2lvblNldHRpbmdzO1xuICAgICAgdGhpcy5sYXN0VXBkYXRlQXQgPSBEYXRlLm5vdygpO1xuICAgICAgcmV0dXJuIHJlZ2lvblNldHRpbmdzO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgQ29ubmVjdGlvbkVycm9yKFxuICAgICAgICBgQ291bGQgbm90IGZldGNoIHJlZ2lvbiBzZXR0aW5nczogJHtyZWdpb25TZXR0aW5nc1Jlc3BvbnNlLnN0YXR1c1RleHR9YCxcbiAgICAgICAgcmVnaW9uU2V0dGluZ3NSZXNwb25zZS5zdGF0dXMgPT09IDQwMSA/IENvbm5lY3Rpb25FcnJvclJlYXNvbi5Ob3RBbGxvd2VkIDogdW5kZWZpbmVkLFxuICAgICAgICByZWdpb25TZXR0aW5nc1Jlc3BvbnNlLnN0YXR1cyxcbiAgICAgICk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGdldENsb3VkQ29uZmlnVXJsKHNlcnZlclVybDogVVJMKSB7XG4gIHJldHVybiBgJHtzZXJ2ZXJVcmwucHJvdG9jb2wucmVwbGFjZSgnd3MnLCAnaHR0cCcpfS8vJHtzZXJ2ZXJVcmwuaG9zdH0vc2V0dGluZ3NgO1xufVxuIiwiZXhwb3J0IGNvbnN0IG1vbml0b3JGcmVxdWVuY3kgPSAyMDAwO1xuXG4vLyBrZXkgc3RhdHMgZm9yIHNlbmRlcnMgYW5kIHJlY2VpdmVyc1xuaW50ZXJmYWNlIFNlbmRlclN0YXRzIHtcbiAgLyoqIG51bWJlciBvZiBwYWNrZXRzIHNlbnQgKi9cbiAgcGFja2V0c1NlbnQ/OiBudW1iZXI7XG5cbiAgLyoqIG51bWJlciBvZiBieXRlcyBzZW50ICovXG4gIGJ5dGVzU2VudD86IG51bWJlcjtcblxuICAvKiogaml0dGVyIGFzIHBlcmNlaXZlZCBieSByZW1vdGUgKi9cbiAgaml0dGVyPzogbnVtYmVyO1xuXG4gIC8qKiBwYWNrZXRzIHJlcG9ydGVkIGxvc3QgYnkgcmVtb3RlICovXG4gIHBhY2tldHNMb3N0PzogbnVtYmVyO1xuXG4gIC8qKiBSVFQgcmVwb3J0ZWQgYnkgcmVtb3RlICovXG4gIHJvdW5kVHJpcFRpbWU/OiBudW1iZXI7XG5cbiAgLyoqIElEIG9mIHRoZSBvdXRib3VuZCBzdHJlYW0gKi9cbiAgc3RyZWFtSWQ/OiBzdHJpbmc7XG5cbiAgdGltZXN0YW1wOiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQXVkaW9TZW5kZXJTdGF0cyBleHRlbmRzIFNlbmRlclN0YXRzIHtcbiAgdHlwZTogJ2F1ZGlvJztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBWaWRlb1NlbmRlclN0YXRzIGV4dGVuZHMgU2VuZGVyU3RhdHMge1xuICB0eXBlOiAndmlkZW8nO1xuXG4gIGZpckNvdW50OiBudW1iZXI7XG5cbiAgcGxpQ291bnQ6IG51bWJlcjtcblxuICBuYWNrQ291bnQ6IG51bWJlcjtcblxuICByaWQ6IHN0cmluZztcblxuICBmcmFtZVdpZHRoOiBudW1iZXI7XG5cbiAgZnJhbWVIZWlnaHQ6IG51bWJlcjtcblxuICBmcmFtZXNTZW50OiBudW1iZXI7XG5cbiAgLy8gYmFuZHdpZHRoLCBjcHUsIG90aGVyLCBub25lXG4gIHF1YWxpdHlMaW1pdGF0aW9uUmVhc29uOiBzdHJpbmc7XG5cbiAgcXVhbGl0eUxpbWl0YXRpb25SZXNvbHV0aW9uQ2hhbmdlczogbnVtYmVyO1xuXG4gIHJldHJhbnNtaXR0ZWRQYWNrZXRzU2VudDogbnVtYmVyO1xufVxuXG5pbnRlcmZhY2UgUmVjZWl2ZXJTdGF0cyB7XG4gIGppdHRlckJ1ZmZlckRlbGF5PzogbnVtYmVyO1xuXG4gIC8qKiBwYWNrZXRzIHJlcG9ydGVkIGxvc3QgYnkgcmVtb3RlICovXG4gIHBhY2tldHNMb3N0PzogbnVtYmVyO1xuXG4gIC8qKiBudW1iZXIgb2YgcGFja2V0cyBzZW50ICovXG4gIHBhY2tldHNSZWNlaXZlZD86IG51bWJlcjtcblxuICBieXRlc1JlY2VpdmVkPzogbnVtYmVyO1xuXG4gIHN0cmVhbUlkPzogc3RyaW5nO1xuXG4gIGppdHRlcj86IG51bWJlcjtcblxuICB0aW1lc3RhbXA6IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBBdWRpb1JlY2VpdmVyU3RhdHMgZXh0ZW5kcyBSZWNlaXZlclN0YXRzIHtcbiAgdHlwZTogJ2F1ZGlvJztcblxuICBjb25jZWFsZWRTYW1wbGVzPzogbnVtYmVyO1xuXG4gIGNvbmNlYWxtZW50RXZlbnRzPzogbnVtYmVyO1xuXG4gIHNpbGVudENvbmNlYWxlZFNhbXBsZXM/OiBudW1iZXI7XG5cbiAgc2lsZW50Q29uY2VhbG1lbnRFdmVudHM/OiBudW1iZXI7XG5cbiAgdG90YWxBdWRpb0VuZXJneT86IG51bWJlcjtcblxuICB0b3RhbFNhbXBsZXNEdXJhdGlvbj86IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBWaWRlb1JlY2VpdmVyU3RhdHMgZXh0ZW5kcyBSZWNlaXZlclN0YXRzIHtcbiAgdHlwZTogJ3ZpZGVvJztcblxuICBmcmFtZXNEZWNvZGVkOiBudW1iZXI7XG5cbiAgZnJhbWVzRHJvcHBlZDogbnVtYmVyO1xuXG4gIGZyYW1lc1JlY2VpdmVkOiBudW1iZXI7XG5cbiAgZnJhbWVXaWR0aD86IG51bWJlcjtcblxuICBmcmFtZUhlaWdodD86IG51bWJlcjtcblxuICBmaXJDb3VudD86IG51bWJlcjtcblxuICBwbGlDb3VudD86IG51bWJlcjtcblxuICBuYWNrQ291bnQ/OiBudW1iZXI7XG5cbiAgZGVjb2RlckltcGxlbWVudGF0aW9uPzogc3RyaW5nO1xuXG4gIG1pbWVUeXBlPzogc3RyaW5nO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY29tcHV0ZUJpdHJhdGU8VCBleHRlbmRzIFJlY2VpdmVyU3RhdHMgfCBTZW5kZXJTdGF0cz4oXG4gIGN1cnJlbnRTdGF0czogVCxcbiAgcHJldlN0YXRzPzogVCxcbik6IG51bWJlciB7XG4gIGlmICghcHJldlN0YXRzKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgbGV0IGJ5dGVzTm93OiBudW1iZXIgfCB1bmRlZmluZWQ7XG4gIGxldCBieXRlc1ByZXY6IG51bWJlciB8IHVuZGVmaW5lZDtcbiAgaWYgKCdieXRlc1JlY2VpdmVkJyBpbiBjdXJyZW50U3RhdHMpIHtcbiAgICBieXRlc05vdyA9IChjdXJyZW50U3RhdHMgYXMgUmVjZWl2ZXJTdGF0cykuYnl0ZXNSZWNlaXZlZDtcbiAgICBieXRlc1ByZXYgPSAocHJldlN0YXRzIGFzIFJlY2VpdmVyU3RhdHMpLmJ5dGVzUmVjZWl2ZWQ7XG4gIH0gZWxzZSBpZiAoJ2J5dGVzU2VudCcgaW4gY3VycmVudFN0YXRzKSB7XG4gICAgYnl0ZXNOb3cgPSAoY3VycmVudFN0YXRzIGFzIFNlbmRlclN0YXRzKS5ieXRlc1NlbnQ7XG4gICAgYnl0ZXNQcmV2ID0gKHByZXZTdGF0cyBhcyBTZW5kZXJTdGF0cykuYnl0ZXNTZW50O1xuICB9XG4gIGlmIChcbiAgICBieXRlc05vdyA9PT0gdW5kZWZpbmVkIHx8XG4gICAgYnl0ZXNQcmV2ID09PSB1bmRlZmluZWQgfHxcbiAgICBjdXJyZW50U3RhdHMudGltZXN0YW1wID09PSB1bmRlZmluZWQgfHxcbiAgICBwcmV2U3RhdHMudGltZXN0YW1wID09PSB1bmRlZmluZWRcbiAgKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgcmV0dXJuICgoYnl0ZXNOb3cgLSBieXRlc1ByZXYpICogOCAqIDEwMDApIC8gKGN1cnJlbnRTdGF0cy50aW1lc3RhbXAgLSBwcmV2U3RhdHMudGltZXN0YW1wKTtcbn1cbiIsImltcG9ydCB7IFRyYWNrRXZlbnQgfSBmcm9tICcuLi9ldmVudHMnO1xuaW1wb3J0IHsgY29tcHV0ZUJpdHJhdGUsIG1vbml0b3JGcmVxdWVuY3kgfSBmcm9tICcuLi9zdGF0cyc7XG5pbXBvcnQgdHlwZSB7IEF1ZGlvU2VuZGVyU3RhdHMgfSBmcm9tICcuLi9zdGF0cyc7XG5pbXBvcnQgdHlwZSB7IExvZ2dlck9wdGlvbnMgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyBpc1dlYiwgdW53cmFwQ29uc3RyYWludCB9IGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCBMb2NhbFRyYWNrIGZyb20gJy4vTG9jYWxUcmFjayc7XG5pbXBvcnQgeyBUcmFjayB9IGZyb20gJy4vVHJhY2snO1xuaW1wb3J0IHR5cGUgeyBBdWRpb0NhcHR1cmVPcHRpb25zIH0gZnJvbSAnLi9vcHRpb25zJztcbmltcG9ydCB0eXBlIHsgVHJhY2tQcm9jZXNzb3IgfSBmcm9tICcuL3Byb2Nlc3Nvci90eXBlcyc7XG5pbXBvcnQgeyBjb25zdHJhaW50c0Zvck9wdGlvbnMsIGRldGVjdFNpbGVuY2UgfSBmcm9tICcuL3V0aWxzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTG9jYWxBdWRpb1RyYWNrIGV4dGVuZHMgTG9jYWxUcmFjayB7XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgc3RvcE9uTXV0ZTogYm9vbGVhbiA9IGZhbHNlO1xuXG4gIHByaXZhdGUgYXVkaW9Db250ZXh0PzogQXVkaW9Db250ZXh0O1xuXG4gIHByaXZhdGUgcHJldlN0YXRzPzogQXVkaW9TZW5kZXJTdGF0cztcblxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIG1lZGlhVHJhY2tcbiAgICogQHBhcmFtIGNvbnN0cmFpbnRzIE1lZGlhVHJhY2tDb25zdHJhaW50cyB0aGF0IGFyZSBiZWluZyB1c2VkIHdoZW4gcmVzdGFydGluZyBvciByZWFjcXVpcmluZyB0cmFja3NcbiAgICogQHBhcmFtIHVzZXJQcm92aWRlZFRyYWNrIFNpZ25hbHMgdG8gdGhlIFNESyB3aGV0aGVyIG9yIG5vdCB0aGUgbWVkaWFUcmFjayBzaG91bGQgYmUgbWFuYWdlZCAoaS5lLiByZWxlYXNlZCBhbmQgcmVhY3F1aXJlZCkgaW50ZXJuYWxseSBieSB0aGUgU0RLXG4gICAqL1xuICBjb25zdHJ1Y3RvcihcbiAgICBtZWRpYVRyYWNrOiBNZWRpYVN0cmVhbVRyYWNrLFxuICAgIGNvbnN0cmFpbnRzPzogTWVkaWFUcmFja0NvbnN0cmFpbnRzLFxuICAgIHVzZXJQcm92aWRlZFRyYWNrID0gdHJ1ZSxcbiAgICBhdWRpb0NvbnRleHQ/OiBBdWRpb0NvbnRleHQsXG4gICAgbG9nZ2VyT3B0aW9ucz86IExvZ2dlck9wdGlvbnMsXG4gICkge1xuICAgIHN1cGVyKG1lZGlhVHJhY2ssIFRyYWNrLktpbmQuQXVkaW8sIGNvbnN0cmFpbnRzLCB1c2VyUHJvdmlkZWRUcmFjaywgbG9nZ2VyT3B0aW9ucyk7XG4gICAgdGhpcy5hdWRpb0NvbnRleHQgPSBhdWRpb0NvbnRleHQ7XG4gICAgdGhpcy5jaGVja0ZvclNpbGVuY2UoKTtcbiAgfVxuXG4gIGFzeW5jIHNldERldmljZUlkKGRldmljZUlkOiBDb25zdHJhaW5ET01TdHJpbmcpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICBpZiAodGhpcy5fY29uc3RyYWludHMuZGV2aWNlSWQgPT09IGRldmljZUlkKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgdGhpcy5fY29uc3RyYWludHMuZGV2aWNlSWQgPSBkZXZpY2VJZDtcbiAgICBpZiAoIXRoaXMuaXNNdXRlZCkge1xuICAgICAgYXdhaXQgdGhpcy5yZXN0YXJ0VHJhY2soKTtcbiAgICB9XG4gICAgcmV0dXJuIChcbiAgICAgIHRoaXMuaXNNdXRlZCB8fCB1bndyYXBDb25zdHJhaW50KGRldmljZUlkKSA9PT0gdGhpcy5tZWRpYVN0cmVhbVRyYWNrLmdldFNldHRpbmdzKCkuZGV2aWNlSWRcbiAgICApO1xuICB9XG5cbiAgYXN5bmMgbXV0ZSgpOiBQcm9taXNlPExvY2FsQXVkaW9UcmFjaz4ge1xuICAgIGNvbnN0IHVubG9jayA9IGF3YWl0IHRoaXMubXV0ZUxvY2subG9jaygpO1xuICAgIHRyeSB7XG4gICAgICAvLyBkaXNhYmxlZCBzcGVjaWFsIGhhbmRsaW5nIGFzIGl0IHdpbGwgY2F1c2UgQlQgaGVhZHNldHMgdG8gc3dpdGNoIGNvbW11bmljYXRpb24gbW9kZXNcbiAgICAgIGlmICh0aGlzLnNvdXJjZSA9PT0gVHJhY2suU291cmNlLk1pY3JvcGhvbmUgJiYgdGhpcy5zdG9wT25NdXRlICYmICF0aGlzLmlzVXNlclByb3ZpZGVkKSB7XG4gICAgICAgIHRoaXMubG9nLmRlYnVnKCdzdG9wcGluZyBtaWMgdHJhY2snLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgICAvLyBhbHNvIHN0b3AgdGhlIHRyYWNrLCBzbyB0aGF0IG1pY3JvcGhvbmUgaW5kaWNhdG9yIGlzIHR1cm5lZCBvZmZcbiAgICAgICAgdGhpcy5fbWVkaWFTdHJlYW1UcmFjay5zdG9wKCk7XG4gICAgICB9XG4gICAgICBhd2FpdCBzdXBlci5tdXRlKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdW5sb2NrKCk7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgdW5tdXRlKCk6IFByb21pc2U8TG9jYWxBdWRpb1RyYWNrPiB7XG4gICAgY29uc3QgdW5sb2NrID0gYXdhaXQgdGhpcy5tdXRlTG9jay5sb2NrKCk7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGRldmljZUhhc0NoYW5nZWQgPVxuICAgICAgICB0aGlzLl9jb25zdHJhaW50cy5kZXZpY2VJZCAmJlxuICAgICAgICB0aGlzLl9tZWRpYVN0cmVhbVRyYWNrLmdldFNldHRpbmdzKCkuZGV2aWNlSWQgIT09XG4gICAgICAgICAgdW53cmFwQ29uc3RyYWludCh0aGlzLl9jb25zdHJhaW50cy5kZXZpY2VJZCk7XG5cbiAgICAgIGlmIChcbiAgICAgICAgdGhpcy5zb3VyY2UgPT09IFRyYWNrLlNvdXJjZS5NaWNyb3Bob25lICYmXG4gICAgICAgICh0aGlzLnN0b3BPbk11dGUgfHwgdGhpcy5fbWVkaWFTdHJlYW1UcmFjay5yZWFkeVN0YXRlID09PSAnZW5kZWQnIHx8IGRldmljZUhhc0NoYW5nZWQpICYmXG4gICAgICAgICF0aGlzLmlzVXNlclByb3ZpZGVkXG4gICAgICApIHtcbiAgICAgICAgdGhpcy5sb2cuZGVidWcoJ3JlYWNxdWlyaW5nIG1pYyB0cmFjaycsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICAgIGF3YWl0IHRoaXMucmVzdGFydFRyYWNrKCk7XG4gICAgICB9XG4gICAgICBhd2FpdCBzdXBlci51bm11dGUoKTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHVubG9jaygpO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIHJlc3RhcnRUcmFjayhvcHRpb25zPzogQXVkaW9DYXB0dXJlT3B0aW9ucykge1xuICAgIGxldCBjb25zdHJhaW50czogTWVkaWFUcmFja0NvbnN0cmFpbnRzIHwgdW5kZWZpbmVkO1xuICAgIGlmIChvcHRpb25zKSB7XG4gICAgICBjb25zdCBzdHJlYW1Db25zdHJhaW50cyA9IGNvbnN0cmFpbnRzRm9yT3B0aW9ucyh7IGF1ZGlvOiBvcHRpb25zIH0pO1xuICAgICAgaWYgKHR5cGVvZiBzdHJlYW1Db25zdHJhaW50cy5hdWRpbyAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIGNvbnN0cmFpbnRzID0gc3RyZWFtQ29uc3RyYWludHMuYXVkaW87XG4gICAgICB9XG4gICAgfVxuICAgIGF3YWl0IHRoaXMucmVzdGFydChjb25zdHJhaW50cyk7XG4gIH1cblxuICBwcm90ZWN0ZWQgYXN5bmMgcmVzdGFydChjb25zdHJhaW50cz86IE1lZGlhVHJhY2tDb25zdHJhaW50cyk6IFByb21pc2U8TG9jYWxUcmFjaz4ge1xuICAgIGNvbnN0IHRyYWNrID0gYXdhaXQgc3VwZXIucmVzdGFydChjb25zdHJhaW50cyk7XG4gICAgdGhpcy5jaGVja0ZvclNpbGVuY2UoKTtcbiAgICByZXR1cm4gdHJhY2s7XG4gIH1cblxuICAvKiBAaW50ZXJuYWwgKi9cbiAgc3RhcnRNb25pdG9yKCkge1xuICAgIGlmICghaXNXZWIoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5tb25pdG9ySW50ZXJ2YWwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5tb25pdG9ySW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICB0aGlzLm1vbml0b3JTZW5kZXIoKTtcbiAgICB9LCBtb25pdG9yRnJlcXVlbmN5KTtcbiAgfVxuXG4gIHByb3RlY3RlZCBtb25pdG9yU2VuZGVyID0gYXN5bmMgKCkgPT4ge1xuICAgIGlmICghdGhpcy5zZW5kZXIpIHtcbiAgICAgIHRoaXMuX2N1cnJlbnRCaXRyYXRlID0gMDtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsZXQgc3RhdHM6IEF1ZGlvU2VuZGVyU3RhdHMgfCB1bmRlZmluZWQ7XG4gICAgdHJ5IHtcbiAgICAgIHN0YXRzID0gYXdhaXQgdGhpcy5nZXRTZW5kZXJTdGF0cygpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRoaXMubG9nLmVycm9yKCdjb3VsZCBub3QgZ2V0IGF1ZGlvIHNlbmRlciBzdGF0cycsIHsgLi4udGhpcy5sb2dDb250ZXh0LCBlcnJvcjogZSB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoc3RhdHMgJiYgdGhpcy5wcmV2U3RhdHMpIHtcbiAgICAgIHRoaXMuX2N1cnJlbnRCaXRyYXRlID0gY29tcHV0ZUJpdHJhdGUoc3RhdHMsIHRoaXMucHJldlN0YXRzKTtcbiAgICB9XG5cbiAgICB0aGlzLnByZXZTdGF0cyA9IHN0YXRzO1xuICB9O1xuXG4gIGFzeW5jIHNldFByb2Nlc3Nvcihwcm9jZXNzb3I6IFRyYWNrUHJvY2Vzc29yPHRoaXNbJ2tpbmQnXT4pIHtcbiAgICBjb25zdCB1bmxvY2sgPSBhd2FpdCB0aGlzLnByb2Nlc3NvckxvY2subG9jaygpO1xuICAgIHRyeSB7XG4gICAgICBpZiAoIXRoaXMuYXVkaW9Db250ZXh0KSB7XG4gICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICdBdWRpbyBjb250ZXh0IG5lZWRzIHRvIGJlIHNldCBvbiBMb2NhbEF1ZGlvVHJhY2sgaW4gb3JkZXIgdG8gZW5hYmxlIHByb2Nlc3NvcnMnLFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMucHJvY2Vzc29yKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuc3RvcFByb2Nlc3NvcigpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMua2luZCA9PT0gJ3Vua25vd24nKSB7XG4gICAgICAgIHRocm93IFR5cGVFcnJvcignY2Fubm90IHNldCBwcm9jZXNzb3Igb24gdHJhY2sgb2YgdW5rbm93biBraW5kJyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHByb2Nlc3Nvck9wdGlvbnMgPSB7XG4gICAgICAgIGtpbmQ6IHRoaXMua2luZCxcbiAgICAgICAgdHJhY2s6IHRoaXMuX21lZGlhU3RyZWFtVHJhY2ssXG4gICAgICAgIGF1ZGlvQ29udGV4dDogdGhpcy5hdWRpb0NvbnRleHQsXG4gICAgICB9O1xuICAgICAgdGhpcy5sb2cuZGVidWcoYHNldHRpbmcgdXAgYXVkaW8gcHJvY2Vzc29yICR7cHJvY2Vzc29yLm5hbWV9YCwgdGhpcy5sb2dDb250ZXh0KTtcblxuICAgICAgYXdhaXQgcHJvY2Vzc29yLmluaXQocHJvY2Vzc29yT3B0aW9ucyk7XG4gICAgICB0aGlzLnByb2Nlc3NvciA9IHByb2Nlc3NvcjtcbiAgICAgIGlmICh0aGlzLnByb2Nlc3Nvci5wcm9jZXNzZWRUcmFjaykge1xuICAgICAgICBhd2FpdCB0aGlzLnNlbmRlcj8ucmVwbGFjZVRyYWNrKHRoaXMucHJvY2Vzc29yLnByb2Nlc3NlZFRyYWNrKTtcbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgdW5sb2NrKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBAZXhwZXJpbWVudGFsXG4gICAqL1xuICBzZXRBdWRpb0NvbnRleHQoYXVkaW9Db250ZXh0OiBBdWRpb0NvbnRleHQgfCB1bmRlZmluZWQpIHtcbiAgICB0aGlzLmF1ZGlvQ29udGV4dCA9IGF1ZGlvQ29udGV4dDtcbiAgfVxuXG4gIGFzeW5jIGdldFNlbmRlclN0YXRzKCk6IFByb21pc2U8QXVkaW9TZW5kZXJTdGF0cyB8IHVuZGVmaW5lZD4ge1xuICAgIGlmICghdGhpcy5zZW5kZXI/LmdldFN0YXRzKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGNvbnN0IHN0YXRzID0gYXdhaXQgdGhpcy5zZW5kZXIuZ2V0U3RhdHMoKTtcbiAgICBsZXQgYXVkaW9TdGF0czogQXVkaW9TZW5kZXJTdGF0cyB8IHVuZGVmaW5lZDtcbiAgICBzdGF0cy5mb3JFYWNoKCh2KSA9PiB7XG4gICAgICBpZiAodi50eXBlID09PSAnb3V0Ym91bmQtcnRwJykge1xuICAgICAgICBhdWRpb1N0YXRzID0ge1xuICAgICAgICAgIHR5cGU6ICdhdWRpbycsXG4gICAgICAgICAgc3RyZWFtSWQ6IHYuaWQsXG4gICAgICAgICAgcGFja2V0c1NlbnQ6IHYucGFja2V0c1NlbnQsXG4gICAgICAgICAgcGFja2V0c0xvc3Q6IHYucGFja2V0c0xvc3QsXG4gICAgICAgICAgYnl0ZXNTZW50OiB2LmJ5dGVzU2VudCxcbiAgICAgICAgICB0aW1lc3RhbXA6IHYudGltZXN0YW1wLFxuICAgICAgICAgIHJvdW5kVHJpcFRpbWU6IHYucm91bmRUcmlwVGltZSxcbiAgICAgICAgICBqaXR0ZXI6IHYuaml0dGVyLFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGF1ZGlvU3RhdHM7XG4gIH1cblxuICBhc3luYyBjaGVja0ZvclNpbGVuY2UoKSB7XG4gICAgY29uc3QgdHJhY2tJc1NpbGVudCA9IGF3YWl0IGRldGVjdFNpbGVuY2UodGhpcyk7XG4gICAgaWYgKHRyYWNrSXNTaWxlbnQpIHtcbiAgICAgIGlmICghdGhpcy5pc011dGVkKSB7XG4gICAgICAgIHRoaXMubG9nLndhcm4oJ3NpbGVuY2UgZGV0ZWN0ZWQgb24gbG9jYWwgYXVkaW8gdHJhY2snLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgfVxuICAgICAgdGhpcy5lbWl0KFRyYWNrRXZlbnQuQXVkaW9TaWxlbmNlRGV0ZWN0ZWQpO1xuICAgIH1cbiAgICByZXR1cm4gdHJhY2tJc1NpbGVudDtcbiAgfVxufVxuIiwiaW1wb3J0IGxvZyBmcm9tICcuLi8uLi9sb2dnZXInO1xuaW1wb3J0IHsgVHJhY2tJbnZhbGlkRXJyb3IgfSBmcm9tICcuLi9lcnJvcnMnO1xuaW1wb3J0IExvY2FsQXVkaW9UcmFjayBmcm9tICcuLi90cmFjay9Mb2NhbEF1ZGlvVHJhY2snO1xuaW1wb3J0IExvY2FsVmlkZW9UcmFjayBmcm9tICcuLi90cmFjay9Mb2NhbFZpZGVvVHJhY2snO1xuaW1wb3J0IHsgVHJhY2sgfSBmcm9tICcuLi90cmFjay9UcmFjayc7XG5pbXBvcnQgdHlwZSB7XG4gIEJhY2t1cFZpZGVvQ29kZWMsXG4gIFRyYWNrUHVibGlzaE9wdGlvbnMsXG4gIFZpZGVvQ29kZWMsXG4gIFZpZGVvRW5jb2RpbmcsXG59IGZyb20gJy4uL3RyYWNrL29wdGlvbnMnO1xuaW1wb3J0IHsgU2NyZWVuU2hhcmVQcmVzZXRzLCBWaWRlb1ByZXNldCwgVmlkZW9QcmVzZXRzLCBWaWRlb1ByZXNldHM0MyB9IGZyb20gJy4uL3RyYWNrL29wdGlvbnMnO1xuaW1wb3J0IHR5cGUgeyBMb2dnZXJPcHRpb25zIH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgZ2V0UmVhY3ROYXRpdmVPcywgaXNGaXJlRm94LCBpc1JlYWN0TmF0aXZlLCBpc1NWQ0NvZGVjIH0gZnJvbSAnLi4vdXRpbHMnO1xuXG4vKiogQGludGVybmFsICovXG5leHBvcnQgZnVuY3Rpb24gbWVkaWFUcmFja1RvTG9jYWxUcmFjayhcbiAgbWVkaWFTdHJlYW1UcmFjazogTWVkaWFTdHJlYW1UcmFjayxcbiAgY29uc3RyYWludHM/OiBNZWRpYVRyYWNrQ29uc3RyYWludHMsXG4gIGxvZ2dlck9wdGlvbnM/OiBMb2dnZXJPcHRpb25zLFxuKTogTG9jYWxWaWRlb1RyYWNrIHwgTG9jYWxBdWRpb1RyYWNrIHtcbiAgc3dpdGNoIChtZWRpYVN0cmVhbVRyYWNrLmtpbmQpIHtcbiAgICBjYXNlICdhdWRpbyc6XG4gICAgICByZXR1cm4gbmV3IExvY2FsQXVkaW9UcmFjayhtZWRpYVN0cmVhbVRyYWNrLCBjb25zdHJhaW50cywgZmFsc2UsIHVuZGVmaW5lZCwgbG9nZ2VyT3B0aW9ucyk7XG4gICAgY2FzZSAndmlkZW8nOlxuICAgICAgcmV0dXJuIG5ldyBMb2NhbFZpZGVvVHJhY2sobWVkaWFTdHJlYW1UcmFjaywgY29uc3RyYWludHMsIGZhbHNlLCBsb2dnZXJPcHRpb25zKTtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IFRyYWNrSW52YWxpZEVycm9yKGB1bnN1cHBvcnRlZCB0cmFjayB0eXBlOiAke21lZGlhU3RyZWFtVHJhY2sua2luZH1gKTtcbiAgfVxufVxuXG4vKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBjb25zdCBwcmVzZXRzMTY5ID0gT2JqZWN0LnZhbHVlcyhWaWRlb1ByZXNldHMpO1xuXG4vKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBjb25zdCBwcmVzZXRzNDMgPSBPYmplY3QudmFsdWVzKFZpZGVvUHJlc2V0czQzKTtcblxuLyogQGludGVybmFsICovXG5leHBvcnQgY29uc3QgcHJlc2V0c1NjcmVlblNoYXJlID0gT2JqZWN0LnZhbHVlcyhTY3JlZW5TaGFyZVByZXNldHMpO1xuXG4vKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBjb25zdCBkZWZhdWx0U2ltdWxjYXN0UHJlc2V0czE2OSA9IFtWaWRlb1ByZXNldHMuaDE4MCwgVmlkZW9QcmVzZXRzLmgzNjBdO1xuXG4vKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBjb25zdCBkZWZhdWx0U2ltdWxjYXN0UHJlc2V0czQzID0gW1ZpZGVvUHJlc2V0czQzLmgxODAsIFZpZGVvUHJlc2V0czQzLmgzNjBdO1xuXG4vKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBjb25zdCBjb21wdXRlRGVmYXVsdFNjcmVlblNoYXJlU2ltdWxjYXN0UHJlc2V0cyA9IChmcm9tUHJlc2V0OiBWaWRlb1ByZXNldCkgPT4ge1xuICBjb25zdCBsYXllcnMgPSBbeyBzY2FsZVJlc29sdXRpb25Eb3duQnk6IDIsIGZwczogZnJvbVByZXNldC5lbmNvZGluZy5tYXhGcmFtZXJhdGUgfV07XG4gIHJldHVybiBsYXllcnMubWFwKFxuICAgICh0KSA9PlxuICAgICAgbmV3IFZpZGVvUHJlc2V0KFxuICAgICAgICBNYXRoLmZsb29yKGZyb21QcmVzZXQud2lkdGggLyB0LnNjYWxlUmVzb2x1dGlvbkRvd25CeSksXG4gICAgICAgIE1hdGguZmxvb3IoZnJvbVByZXNldC5oZWlnaHQgLyB0LnNjYWxlUmVzb2x1dGlvbkRvd25CeSksXG4gICAgICAgIE1hdGgubWF4KFxuICAgICAgICAgIDE1MF8wMDAsXG4gICAgICAgICAgTWF0aC5mbG9vcihcbiAgICAgICAgICAgIGZyb21QcmVzZXQuZW5jb2RpbmcubWF4Qml0cmF0ZSAvXG4gICAgICAgICAgICAgICh0LnNjYWxlUmVzb2x1dGlvbkRvd25CeSAqKiAyICpcbiAgICAgICAgICAgICAgICAoKGZyb21QcmVzZXQuZW5jb2RpbmcubWF4RnJhbWVyYXRlID8/IDMwKSAvICh0LmZwcyA/PyAzMCkpKSxcbiAgICAgICAgICApLFxuICAgICAgICApLFxuICAgICAgICB0LmZwcyxcbiAgICAgICAgZnJvbVByZXNldC5lbmNvZGluZy5wcmlvcml0eSxcbiAgICAgICksXG4gICk7XG59O1xuXG4vLyAvKipcbi8vICAqXG4vLyAgKiBAaW50ZXJuYWxcbi8vICAqIEBleHBlcmltZW50YWxcbi8vICAqL1xuLy8gY29uc3QgY29tcHV0ZURlZmF1bHRNdWx0aUNvZGVjU2ltdWxjYXN0RW5jb2RpbmdzID0gKHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyKSA9PiB7XG4vLyAgIC8vIHVzZSB2cDggYXMgYSBkZWZhdWx0XG4vLyAgIGNvbnN0IHZwOCA9IGRldGVybWluZUFwcHJvcHJpYXRlRW5jb2RpbmcoZmFsc2UsIHdpZHRoLCBoZWlnaHQpO1xuLy8gICBjb25zdCB2cDkgPSB7IC4uLnZwOCwgbWF4Qml0cmF0ZTogdnA4Lm1heEJpdHJhdGUgKiAwLjkgfTtcbi8vICAgY29uc3QgaDI2NCA9IHsgLi4udnA4LCBtYXhCaXRyYXRlOiB2cDgubWF4Qml0cmF0ZSAqIDEuMSB9O1xuLy8gICBjb25zdCBhdjEgPSB7IC4uLnZwOCwgbWF4Qml0cmF0ZTogdnA4Lm1heEJpdHJhdGUgKiAwLjcgfTtcbi8vICAgcmV0dXJuIHtcbi8vICAgICB2cDgsXG4vLyAgICAgdnA5LFxuLy8gICAgIGgyNjQsXG4vLyAgICAgYXYxLFxuLy8gICB9O1xuLy8gfTtcblxuY29uc3QgdmlkZW9SaWRzID0gWydxJywgJ2gnLCAnZiddO1xuXG4vKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBmdW5jdGlvbiBjb21wdXRlVmlkZW9FbmNvZGluZ3MoXG4gIGlzU2NyZWVuU2hhcmU6IGJvb2xlYW4sXG4gIHdpZHRoPzogbnVtYmVyLFxuICBoZWlnaHQ/OiBudW1iZXIsXG4gIG9wdGlvbnM/OiBUcmFja1B1Ymxpc2hPcHRpb25zLFxuKTogUlRDUnRwRW5jb2RpbmdQYXJhbWV0ZXJzW10ge1xuICBsZXQgdmlkZW9FbmNvZGluZzogVmlkZW9FbmNvZGluZyB8IHVuZGVmaW5lZCA9IG9wdGlvbnM/LnZpZGVvRW5jb2Rpbmc7XG5cbiAgaWYgKGlzU2NyZWVuU2hhcmUpIHtcbiAgICB2aWRlb0VuY29kaW5nID0gb3B0aW9ucz8uc2NyZWVuU2hhcmVFbmNvZGluZztcbiAgfVxuXG4gIGNvbnN0IHVzZVNpbXVsY2FzdCA9IG9wdGlvbnM/LnNpbXVsY2FzdDtcbiAgY29uc3Qgc2NhbGFiaWxpdHlNb2RlID0gb3B0aW9ucz8uc2NhbGFiaWxpdHlNb2RlO1xuICBjb25zdCB2aWRlb0NvZGVjID0gb3B0aW9ucz8udmlkZW9Db2RlYztcblxuICBpZiAoKCF2aWRlb0VuY29kaW5nICYmICF1c2VTaW11bGNhc3QgJiYgIXNjYWxhYmlsaXR5TW9kZSkgfHwgIXdpZHRoIHx8ICFoZWlnaHQpIHtcbiAgICAvLyB3aGVuIHdlIGFyZW4ndCBzaW11bGNhc3Rpbmcgb3Igc3ZjLCB3aWxsIG5lZWQgdG8gcmV0dXJuIGEgc2luZ2xlIGVuY29kaW5nIHdpdGhvdXRcbiAgICAvLyBjYXBwaW5nIGJhbmR3aWR0aC4gd2UgYWx3YXlzIHJlcXVpcmUgYSBlbmNvZGluZyBmb3IgZHluYWNhc3RcbiAgICByZXR1cm4gW3t9XTtcbiAgfVxuXG4gIGlmICghdmlkZW9FbmNvZGluZykge1xuICAgIC8vIGZpbmQgdGhlIHJpZ2h0IGVuY29kaW5nIGJhc2VkIG9uIHdpZHRoL2hlaWdodFxuICAgIHZpZGVvRW5jb2RpbmcgPSBkZXRlcm1pbmVBcHByb3ByaWF0ZUVuY29kaW5nKGlzU2NyZWVuU2hhcmUsIHdpZHRoLCBoZWlnaHQsIHZpZGVvQ29kZWMpO1xuICAgIGxvZy5kZWJ1ZygndXNpbmcgdmlkZW8gZW5jb2RpbmcnLCB2aWRlb0VuY29kaW5nKTtcbiAgfVxuXG4gIGNvbnN0IG9yaWdpbmFsID0gbmV3IFZpZGVvUHJlc2V0KFxuICAgIHdpZHRoLFxuICAgIGhlaWdodCxcbiAgICB2aWRlb0VuY29kaW5nLm1heEJpdHJhdGUsXG4gICAgdmlkZW9FbmNvZGluZy5tYXhGcmFtZXJhdGUsXG4gICAgdmlkZW9FbmNvZGluZy5wcmlvcml0eSxcbiAgKTtcblxuICBpZiAoc2NhbGFiaWxpdHlNb2RlICYmIGlzU1ZDQ29kZWModmlkZW9Db2RlYykpIHtcbiAgICBsb2cuZGVidWcoYHVzaW5nIHN2YyB3aXRoIHNjYWxhYmlsaXR5TW9kZSAke3NjYWxhYmlsaXR5TW9kZX1gKTtcblxuICAgIGNvbnN0IHNtID0gbmV3IFNjYWxhYmlsaXR5TW9kZShzY2FsYWJpbGl0eU1vZGUpO1xuXG4gICAgY29uc3QgZW5jb2RpbmdzOiBSVENSdHBFbmNvZGluZ1BhcmFtZXRlcnNbXSA9IFtdO1xuXG4gICAgaWYgKHNtLnNwYXRpYWwgPiAzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIHNjYWxhYmlsaXR5TW9kZTogJHtzY2FsYWJpbGl0eU1vZGV9YCk7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc20uc3BhdGlhbDsgaSArPSAxKSB7XG4gICAgICBlbmNvZGluZ3MucHVzaCh7XG4gICAgICAgIHJpZDogdmlkZW9SaWRzWzIgLSBpXSxcbiAgICAgICAgbWF4Qml0cmF0ZTogdmlkZW9FbmNvZGluZy5tYXhCaXRyYXRlIC8gMyAqKiBpLFxuICAgICAgICAvKiBAdHMtaWdub3JlICovXG4gICAgICAgIG1heEZyYW1lcmF0ZTogb3JpZ2luYWwuZW5jb2RpbmcubWF4RnJhbWVyYXRlLFxuICAgICAgfSk7XG4gICAgfVxuICAgIC8qIEB0cy1pZ25vcmUgKi9cbiAgICBlbmNvZGluZ3NbMF0uc2NhbGFiaWxpdHlNb2RlID0gc2NhbGFiaWxpdHlNb2RlO1xuICAgIGxvZy5kZWJ1ZygnZW5jb2RpbmdzJywgZW5jb2RpbmdzKTtcbiAgICByZXR1cm4gZW5jb2RpbmdzO1xuICB9XG5cbiAgaWYgKCF1c2VTaW11bGNhc3QpIHtcbiAgICByZXR1cm4gW3ZpZGVvRW5jb2RpbmddO1xuICB9XG5cbiAgbGV0IHByZXNldHM6IEFycmF5PFZpZGVvUHJlc2V0PiA9IFtdO1xuICBpZiAoaXNTY3JlZW5TaGFyZSkge1xuICAgIHByZXNldHMgPVxuICAgICAgc29ydFByZXNldHMob3B0aW9ucz8uc2NyZWVuU2hhcmVTaW11bGNhc3RMYXllcnMpID8/XG4gICAgICBkZWZhdWx0U2ltdWxjYXN0TGF5ZXJzKGlzU2NyZWVuU2hhcmUsIG9yaWdpbmFsKTtcbiAgfSBlbHNlIHtcbiAgICBwcmVzZXRzID1cbiAgICAgIHNvcnRQcmVzZXRzKG9wdGlvbnM/LnZpZGVvU2ltdWxjYXN0TGF5ZXJzKSA/PyBkZWZhdWx0U2ltdWxjYXN0TGF5ZXJzKGlzU2NyZWVuU2hhcmUsIG9yaWdpbmFsKTtcbiAgfVxuICBsZXQgbWlkUHJlc2V0OiBWaWRlb1ByZXNldCB8IHVuZGVmaW5lZDtcbiAgaWYgKHByZXNldHMubGVuZ3RoID4gMCkge1xuICAgIGNvbnN0IGxvd1ByZXNldCA9IHByZXNldHNbMF07XG4gICAgaWYgKHByZXNldHMubGVuZ3RoID4gMSkge1xuICAgICAgWywgbWlkUHJlc2V0XSA9IHByZXNldHM7XG4gICAgfVxuXG4gICAgLy8gTk9URTpcbiAgICAvLyAgIDEuIE9yZGVyaW5nIG9mIHRoZXNlIGVuY29kaW5ncyBpcyBpbXBvcnRhbnQuIENocm9tZSBzZWVtc1xuICAgIC8vICAgICAgdG8gdXNlIHRoZSBpbmRleCBpbnRvIGVuY29kaW5ncyB0byBkZWNpZGUgd2hpY2ggbGF5ZXJcbiAgICAvLyAgICAgIHRvIGRpc2FibGUgd2hlbiBDUFUgY29uc3RyYWluZWQuXG4gICAgLy8gICAgICBTbyBlbmNvZGluZ3Mgc2hvdWxkIGJlIG9yZGVyZWQgaW4gaW5jcmVhc2luZyBzcGF0aWFsXG4gICAgLy8gICAgICByZXNvbHV0aW9uIG9yZGVyLlxuICAgIC8vICAgMi4gaW9uLXNmdSB0cmFuc2xhdGVzIHJpZHMgaW50byBsYXllcnMuIFNvLCBhbGwgZW5jb2RpbmdzXG4gICAgLy8gICAgICBzaG91bGQgaGF2ZSB0aGUgYmFzZSBsYXllciBgcWAgYW5kIHRoZW4gbW9yZSBhZGRlZFxuICAgIC8vICAgICAgYmFzZWQgb24gb3RoZXIgY29uZGl0aW9ucy5cbiAgICBjb25zdCBzaXplID0gTWF0aC5tYXgod2lkdGgsIGhlaWdodCk7XG4gICAgaWYgKHNpemUgPj0gOTYwICYmIG1pZFByZXNldCkge1xuICAgICAgcmV0dXJuIGVuY29kaW5nc0Zyb21QcmVzZXRzKHdpZHRoLCBoZWlnaHQsIFtsb3dQcmVzZXQsIG1pZFByZXNldCwgb3JpZ2luYWxdKTtcbiAgICB9XG4gICAgaWYgKHNpemUgPj0gNDgwKSB7XG4gICAgICByZXR1cm4gZW5jb2RpbmdzRnJvbVByZXNldHMod2lkdGgsIGhlaWdodCwgW2xvd1ByZXNldCwgb3JpZ2luYWxdKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGVuY29kaW5nc0Zyb21QcmVzZXRzKHdpZHRoLCBoZWlnaHQsIFtvcmlnaW5hbF0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY29tcHV0ZVRyYWNrQmFja3VwRW5jb2RpbmdzKFxuICB0cmFjazogTG9jYWxWaWRlb1RyYWNrLFxuICB2aWRlb0NvZGVjOiBCYWNrdXBWaWRlb0NvZGVjLFxuICBvcHRzOiBUcmFja1B1Ymxpc2hPcHRpb25zLFxuKSB7XG4gIC8vIGJhY2t1cENvZGVjIHNob3VsZCBub3QgYmUgdHJ1ZSBhbnltb3JlLCBkZWZhdWx0IGNvZGVjIGlzIHNldCBpbiBMb2NhbFBhcnRpY2lwYW50LnB1Ymxpc2hcbiAgaWYgKFxuICAgICFvcHRzLmJhY2t1cENvZGVjIHx8XG4gICAgb3B0cy5iYWNrdXBDb2RlYyA9PT0gdHJ1ZSB8fFxuICAgIG9wdHMuYmFja3VwQ29kZWMuY29kZWMgPT09IG9wdHMudmlkZW9Db2RlY1xuICApIHtcbiAgICAvLyBiYWNrdXAgY29kZWMgcHVibGlzaGluZyBpcyBkaXNhYmxlZFxuICAgIHJldHVybjtcbiAgfVxuICBpZiAodmlkZW9Db2RlYyAhPT0gb3B0cy5iYWNrdXBDb2RlYy5jb2RlYykge1xuICAgIGxvZy53YXJuKCdyZXF1ZXN0ZWQgYSBkaWZmZXJlbnQgY29kZWMgdGhhbiBzcGVjaWZpZWQgYXMgYmFja3VwJywge1xuICAgICAgc2VydmVyUmVxdWVzdGVkOiB2aWRlb0NvZGVjLFxuICAgICAgYmFja3VwOiBvcHRzLmJhY2t1cENvZGVjLmNvZGVjLFxuICAgIH0pO1xuICB9XG5cbiAgb3B0cy52aWRlb0NvZGVjID0gdmlkZW9Db2RlYztcbiAgLy8gdXNlIGJhY2t1cCBlbmNvZGluZyBzZXR0aW5nIGFzIHZpZGVvRW5jb2RpbmcgZm9yIGJhY2t1cCBjb2RlYyBwdWJsaXNoaW5nXG4gIG9wdHMudmlkZW9FbmNvZGluZyA9IG9wdHMuYmFja3VwQ29kZWMuZW5jb2Rpbmc7XG5cbiAgY29uc3Qgc2V0dGluZ3MgPSB0cmFjay5tZWRpYVN0cmVhbVRyYWNrLmdldFNldHRpbmdzKCk7XG4gIGNvbnN0IHdpZHRoID0gc2V0dGluZ3Mud2lkdGggPz8gdHJhY2suZGltZW5zaW9ucz8ud2lkdGg7XG4gIGNvbnN0IGhlaWdodCA9IHNldHRpbmdzLmhlaWdodCA/PyB0cmFjay5kaW1lbnNpb25zPy5oZWlnaHQ7XG5cbiAgY29uc3QgZW5jb2RpbmdzID0gY29tcHV0ZVZpZGVvRW5jb2RpbmdzKFxuICAgIHRyYWNrLnNvdXJjZSA9PT0gVHJhY2suU291cmNlLlNjcmVlblNoYXJlLFxuICAgIHdpZHRoLFxuICAgIGhlaWdodCxcbiAgICBvcHRzLFxuICApO1xuICByZXR1cm4gZW5jb2RpbmdzO1xufVxuXG4vKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBmdW5jdGlvbiBkZXRlcm1pbmVBcHByb3ByaWF0ZUVuY29kaW5nKFxuICBpc1NjcmVlblNoYXJlOiBib29sZWFuLFxuICB3aWR0aDogbnVtYmVyLFxuICBoZWlnaHQ6IG51bWJlcixcbiAgY29kZWM/OiBWaWRlb0NvZGVjLFxuKTogVmlkZW9FbmNvZGluZyB7XG4gIGNvbnN0IHByZXNldHMgPSBwcmVzZXRzRm9yUmVzb2x1dGlvbihpc1NjcmVlblNoYXJlLCB3aWR0aCwgaGVpZ2h0KTtcbiAgbGV0IHsgZW5jb2RpbmcgfSA9IHByZXNldHNbMF07XG5cbiAgLy8gaGFuZGxlIHBvcnRyYWl0IGJ5IHN3YXBwaW5nIGRpbWVuc2lvbnNcbiAgY29uc3Qgc2l6ZSA9IE1hdGgubWF4KHdpZHRoLCBoZWlnaHQpO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcHJlc2V0cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgIGNvbnN0IHByZXNldCA9IHByZXNldHNbaV07XG4gICAgZW5jb2RpbmcgPSBwcmVzZXQuZW5jb2Rpbmc7XG4gICAgaWYgKHByZXNldC53aWR0aCA+PSBzaXplKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgLy8gcHJlc2V0cyBhcmUgYmFzZWQgb24gdGhlIGFzc3VtcHRpb24gb2YgdnA4IGFzIGEgY29kZWNcbiAgLy8gZm9yIG90aGVyIGNvZGVjcyB3ZSBhZGp1c3QgdGhlIG1heEJpdHJhdGUgaWYgbm8gc3BlY2lmaWMgdmlkZW9FbmNvZGluZyBoYXMgYmVlbiBwcm92aWRlZFxuICAvLyB1c2VycyBzaG91bGQgb3ZlcnJpZGUgdGhlc2Ugd2l0aCBvbmVzIHRoYXQgYXJlIG9wdGltaXplZCBmb3IgdGhlaXIgdXNlIGNhc2VcbiAgLy8gTk9URTogU1ZDIGNvZGVjIGJpdHJhdGVzIGFyZSBpbmNsdXNpdmUgb2YgYWxsIHNjYWxhYmlsaXR5IGxheWVycy4gd2hpbGVcbiAgLy8gYml0cmF0ZSBmb3Igbm9uLVNWQyBjb2RlY3MgZG9lcyBub3QgaW5jbHVkZSBvdGhlciBzaW11bGNhc3QgbGF5ZXJzLlxuICBpZiAoY29kZWMpIHtcbiAgICBzd2l0Y2ggKGNvZGVjKSB7XG4gICAgICBjYXNlICdhdjEnOlxuICAgICAgICBlbmNvZGluZyA9IHsgLi4uZW5jb2RpbmcgfTtcbiAgICAgICAgZW5jb2RpbmcubWF4Qml0cmF0ZSA9IGVuY29kaW5nLm1heEJpdHJhdGUgKiAwLjc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndnA5JzpcbiAgICAgICAgZW5jb2RpbmcgPSB7IC4uLmVuY29kaW5nIH07XG4gICAgICAgIGVuY29kaW5nLm1heEJpdHJhdGUgPSBlbmNvZGluZy5tYXhCaXRyYXRlICogMC44NTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZW5jb2Rpbmc7XG59XG5cbi8qIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGZ1bmN0aW9uIHByZXNldHNGb3JSZXNvbHV0aW9uKFxuICBpc1NjcmVlblNoYXJlOiBib29sZWFuLFxuICB3aWR0aDogbnVtYmVyLFxuICBoZWlnaHQ6IG51bWJlcixcbik6IFZpZGVvUHJlc2V0W10ge1xuICBpZiAoaXNTY3JlZW5TaGFyZSkge1xuICAgIHJldHVybiBwcmVzZXRzU2NyZWVuU2hhcmU7XG4gIH1cbiAgY29uc3QgYXNwZWN0ID0gd2lkdGggPiBoZWlnaHQgPyB3aWR0aCAvIGhlaWdodCA6IGhlaWdodCAvIHdpZHRoO1xuICBpZiAoTWF0aC5hYnMoYXNwZWN0IC0gMTYuMCAvIDkpIDwgTWF0aC5hYnMoYXNwZWN0IC0gNC4wIC8gMykpIHtcbiAgICByZXR1cm4gcHJlc2V0czE2OTtcbiAgfVxuICByZXR1cm4gcHJlc2V0czQzO1xufVxuXG4vKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWZhdWx0U2ltdWxjYXN0TGF5ZXJzKFxuICBpc1NjcmVlblNoYXJlOiBib29sZWFuLFxuICBvcmlnaW5hbDogVmlkZW9QcmVzZXQsXG4pOiBWaWRlb1ByZXNldFtdIHtcbiAgaWYgKGlzU2NyZWVuU2hhcmUpIHtcbiAgICByZXR1cm4gY29tcHV0ZURlZmF1bHRTY3JlZW5TaGFyZVNpbXVsY2FzdFByZXNldHMob3JpZ2luYWwpO1xuICB9XG4gIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gb3JpZ2luYWw7XG4gIGNvbnN0IGFzcGVjdCA9IHdpZHRoID4gaGVpZ2h0ID8gd2lkdGggLyBoZWlnaHQgOiBoZWlnaHQgLyB3aWR0aDtcbiAgaWYgKE1hdGguYWJzKGFzcGVjdCAtIDE2LjAgLyA5KSA8IE1hdGguYWJzKGFzcGVjdCAtIDQuMCAvIDMpKSB7XG4gICAgcmV0dXJuIGRlZmF1bHRTaW11bGNhc3RQcmVzZXRzMTY5O1xuICB9XG4gIHJldHVybiBkZWZhdWx0U2ltdWxjYXN0UHJlc2V0czQzO1xufVxuXG4vLyBwcmVzZXRzIHNob3VsZCBiZSBvcmRlcmVkIGJ5IGxvdywgbWVkaXVtLCBoaWdoXG5mdW5jdGlvbiBlbmNvZGluZ3NGcm9tUHJlc2V0cyhcbiAgd2lkdGg6IG51bWJlcixcbiAgaGVpZ2h0OiBudW1iZXIsXG4gIHByZXNldHM6IFZpZGVvUHJlc2V0W10sXG4pOiBSVENSdHBFbmNvZGluZ1BhcmFtZXRlcnNbXSB7XG4gIGNvbnN0IGVuY29kaW5nczogUlRDUnRwRW5jb2RpbmdQYXJhbWV0ZXJzW10gPSBbXTtcbiAgcHJlc2V0cy5mb3JFYWNoKChwcmVzZXQsIGlkeCkgPT4ge1xuICAgIGlmIChpZHggPj0gdmlkZW9SaWRzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzaXplID0gTWF0aC5taW4od2lkdGgsIGhlaWdodCk7XG4gICAgY29uc3QgcmlkID0gdmlkZW9SaWRzW2lkeF07XG4gICAgY29uc3QgZW5jb2Rpbmc6IFJUQ1J0cEVuY29kaW5nUGFyYW1ldGVycyA9IHtcbiAgICAgIHJpZCxcbiAgICAgIHNjYWxlUmVzb2x1dGlvbkRvd25CeTogTWF0aC5tYXgoMSwgc2l6ZSAvIE1hdGgubWluKHByZXNldC53aWR0aCwgcHJlc2V0LmhlaWdodCkpLFxuICAgICAgbWF4Qml0cmF0ZTogcHJlc2V0LmVuY29kaW5nLm1heEJpdHJhdGUsXG4gICAgfTtcbiAgICBpZiAocHJlc2V0LmVuY29kaW5nLm1heEZyYW1lcmF0ZSkge1xuICAgICAgZW5jb2RpbmcubWF4RnJhbWVyYXRlID0gcHJlc2V0LmVuY29kaW5nLm1heEZyYW1lcmF0ZTtcbiAgICB9XG4gICAgY29uc3QgY2FuU2V0UHJpb3JpdHkgPSBpc0ZpcmVGb3goKSB8fCBpZHggPT09IDA7XG4gICAgaWYgKHByZXNldC5lbmNvZGluZy5wcmlvcml0eSAmJiBjYW5TZXRQcmlvcml0eSkge1xuICAgICAgZW5jb2RpbmcucHJpb3JpdHkgPSBwcmVzZXQuZW5jb2RpbmcucHJpb3JpdHk7XG4gICAgICBlbmNvZGluZy5uZXR3b3JrUHJpb3JpdHkgPSBwcmVzZXQuZW5jb2RpbmcucHJpb3JpdHk7XG4gICAgfVxuICAgIGVuY29kaW5ncy5wdXNoKGVuY29kaW5nKTtcbiAgfSk7XG5cbiAgLy8gUk4gaW9zIHNpbXVsY2FzdCByZXF1aXJlcyBhbGwgc2FtZSBmcmFtZXJhdGVzLlxuICBpZiAoaXNSZWFjdE5hdGl2ZSgpICYmIGdldFJlYWN0TmF0aXZlT3MoKSA9PT0gJ2lvcycpIHtcbiAgICBsZXQgdG9wRnJhbWVyYXRlOiBudW1iZXIgfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG4gICAgZW5jb2RpbmdzLmZvckVhY2goKGVuY29kaW5nKSA9PiB7XG4gICAgICBpZiAoIXRvcEZyYW1lcmF0ZSkge1xuICAgICAgICB0b3BGcmFtZXJhdGUgPSBlbmNvZGluZy5tYXhGcmFtZXJhdGU7XG4gICAgICB9IGVsc2UgaWYgKGVuY29kaW5nLm1heEZyYW1lcmF0ZSAmJiBlbmNvZGluZy5tYXhGcmFtZXJhdGUgPiB0b3BGcmFtZXJhdGUpIHtcbiAgICAgICAgdG9wRnJhbWVyYXRlID0gZW5jb2RpbmcubWF4RnJhbWVyYXRlO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgbGV0IG5vdGlmeU9uY2UgPSB0cnVlO1xuICAgIGVuY29kaW5ncy5mb3JFYWNoKChlbmNvZGluZykgPT4ge1xuICAgICAgaWYgKGVuY29kaW5nLm1heEZyYW1lcmF0ZSAhPSB0b3BGcmFtZXJhdGUpIHtcbiAgICAgICAgaWYgKG5vdGlmeU9uY2UpIHtcbiAgICAgICAgICBub3RpZnlPbmNlID0gZmFsc2U7XG4gICAgICAgICAgbG9nLmluZm8oXG4gICAgICAgICAgICBgU2ltdWxjYXN0IG9uIGlPUyBSZWFjdC1OYXRpdmUgcmVxdWlyZXMgYWxsIGVuY29kaW5ncyB0byBzaGFyZSB0aGUgc2FtZSBmcmFtZXJhdGUuYCxcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGxvZy5pbmZvKGBTZXR0aW5nIGZyYW1lcmF0ZSBvZiBlbmNvZGluZyBcXFwiJHtlbmNvZGluZy5yaWQgPz8gJyd9XFxcIiB0byAke3RvcEZyYW1lcmF0ZX1gKTtcbiAgICAgICAgZW5jb2RpbmcubWF4RnJhbWVyYXRlID0gdG9wRnJhbWVyYXRlO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIGVuY29kaW5ncztcbn1cblxuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNvcnRQcmVzZXRzKHByZXNldHM6IEFycmF5PFZpZGVvUHJlc2V0PiB8IHVuZGVmaW5lZCkge1xuICBpZiAoIXByZXNldHMpIHJldHVybjtcbiAgcmV0dXJuIHByZXNldHMuc29ydCgoYSwgYikgPT4ge1xuICAgIGNvbnN0IHsgZW5jb2Rpbmc6IGFFbmMgfSA9IGE7XG4gICAgY29uc3QgeyBlbmNvZGluZzogYkVuYyB9ID0gYjtcblxuICAgIGlmIChhRW5jLm1heEJpdHJhdGUgPiBiRW5jLm1heEJpdHJhdGUpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICBpZiAoYUVuYy5tYXhCaXRyYXRlIDwgYkVuYy5tYXhCaXRyYXRlKSByZXR1cm4gLTE7XG4gICAgaWYgKGFFbmMubWF4Qml0cmF0ZSA9PT0gYkVuYy5tYXhCaXRyYXRlICYmIGFFbmMubWF4RnJhbWVyYXRlICYmIGJFbmMubWF4RnJhbWVyYXRlKSB7XG4gICAgICByZXR1cm4gYUVuYy5tYXhGcmFtZXJhdGUgPiBiRW5jLm1heEZyYW1lcmF0ZSA/IDEgOiAtMTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH0pO1xufVxuXG4vKiogQGludGVybmFsICovXG5leHBvcnQgY2xhc3MgU2NhbGFiaWxpdHlNb2RlIHtcbiAgc3BhdGlhbDogbnVtYmVyO1xuXG4gIHRlbXBvcmFsOiBudW1iZXI7XG5cbiAgc3VmZml4OiB1bmRlZmluZWQgfCAnaCcgfCAnX0tFWScgfCAnX0tFWV9TSElGVCc7XG5cbiAgY29uc3RydWN0b3Ioc2NhbGFiaWxpdHlNb2RlOiBzdHJpbmcpIHtcbiAgICBjb25zdCByZXN1bHRzID0gc2NhbGFiaWxpdHlNb2RlLm1hdGNoKC9eTChcXGQpVChcXGQpKGh8X0tFWXxfS0VZX1NISUZUKXswLDF9JC8pO1xuICAgIGlmICghcmVzdWx0cykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHNjYWxhYmlsaXR5IG1vZGUnKTtcbiAgICB9XG5cbiAgICB0aGlzLnNwYXRpYWwgPSBwYXJzZUludChyZXN1bHRzWzFdKTtcbiAgICB0aGlzLnRlbXBvcmFsID0gcGFyc2VJbnQocmVzdWx0c1syXSk7XG4gICAgaWYgKHJlc3VsdHMubGVuZ3RoID4gMykge1xuICAgICAgc3dpdGNoIChyZXN1bHRzWzNdKSB7XG4gICAgICAgIGNhc2UgJ2gnOlxuICAgICAgICBjYXNlICdfS0VZJzpcbiAgICAgICAgY2FzZSAnX0tFWV9TSElGVCc6XG4gICAgICAgICAgdGhpcy5zdWZmaXggPSByZXN1bHRzWzNdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHRvU3RyaW5nKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIGBMJHt0aGlzLnNwYXRpYWx9VCR7dGhpcy50ZW1wb3JhbH0ke3RoaXMuc3VmZml4ID8/ICcnfWA7XG4gIH1cbn1cbiIsImltcG9ydCB0eXBlIHsgU2lnbmFsQ2xpZW50IH0gZnJvbSAnLi4vLi4vYXBpL1NpZ25hbENsaWVudCc7XG5pbXBvcnQgdHlwZSB7IFN0cnVjdHVyZWRMb2dnZXIgfSBmcm9tICcuLi8uLi9sb2dnZXInO1xuaW1wb3J0IHsgVmlkZW9MYXllciwgVmlkZW9RdWFsaXR5IH0gZnJvbSAnLi4vLi4vcHJvdG8vbGl2ZWtpdF9tb2RlbHNfcGInO1xuaW1wb3J0IHsgU3Vic2NyaWJlZENvZGVjLCBTdWJzY3JpYmVkUXVhbGl0eSB9IGZyb20gJy4uLy4uL3Byb3RvL2xpdmVraXRfcnRjX3BiJztcbmltcG9ydCB7IFNjYWxhYmlsaXR5TW9kZSB9IGZyb20gJy4uL3BhcnRpY2lwYW50L3B1Ymxpc2hVdGlscyc7XG5pbXBvcnQgdHlwZSB7IFZpZGVvU2VuZGVyU3RhdHMgfSBmcm9tICcuLi9zdGF0cyc7XG5pbXBvcnQgeyBjb21wdXRlQml0cmF0ZSwgbW9uaXRvckZyZXF1ZW5jeSB9IGZyb20gJy4uL3N0YXRzJztcbmltcG9ydCB0eXBlIHsgTG9nZ2VyT3B0aW9ucyB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7IE11dGV4LCBpc0ZpcmVGb3gsIGlzTW9iaWxlLCBpc1dlYiwgdW53cmFwQ29uc3RyYWludCB9IGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCBMb2NhbFRyYWNrIGZyb20gJy4vTG9jYWxUcmFjayc7XG5pbXBvcnQgeyBUcmFjayB9IGZyb20gJy4vVHJhY2snO1xuaW1wb3J0IHR5cGUgeyBWaWRlb0NhcHR1cmVPcHRpb25zLCBWaWRlb0NvZGVjIH0gZnJvbSAnLi9vcHRpb25zJztcbmltcG9ydCB0eXBlIHsgVHJhY2tQcm9jZXNzb3IgfSBmcm9tICcuL3Byb2Nlc3Nvci90eXBlcyc7XG5pbXBvcnQgeyBjb25zdHJhaW50c0Zvck9wdGlvbnMgfSBmcm9tICcuL3V0aWxzJztcblxuZXhwb3J0IGNsYXNzIFNpbXVsY2FzdFRyYWNrSW5mbyB7XG4gIGNvZGVjOiBWaWRlb0NvZGVjO1xuXG4gIG1lZGlhU3RyZWFtVHJhY2s6IE1lZGlhU3RyZWFtVHJhY2s7XG5cbiAgc2VuZGVyPzogUlRDUnRwU2VuZGVyO1xuXG4gIGVuY29kaW5ncz86IFJUQ1J0cEVuY29kaW5nUGFyYW1ldGVyc1tdO1xuXG4gIGNvbnN0cnVjdG9yKGNvZGVjOiBWaWRlb0NvZGVjLCBtZWRpYVN0cmVhbVRyYWNrOiBNZWRpYVN0cmVhbVRyYWNrKSB7XG4gICAgdGhpcy5jb2RlYyA9IGNvZGVjO1xuICAgIHRoaXMubWVkaWFTdHJlYW1UcmFjayA9IG1lZGlhU3RyZWFtVHJhY2s7XG4gIH1cbn1cblxuY29uc3QgcmVmcmVzaFN1YnNjcmliZWRDb2RlY0FmdGVyTmV3Q29kZWMgPSA1MDAwO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMb2NhbFZpZGVvVHJhY2sgZXh0ZW5kcyBMb2NhbFRyYWNrIHtcbiAgLyogQGludGVybmFsICovXG4gIHNpZ25hbENsaWVudD86IFNpZ25hbENsaWVudDtcblxuICBwcml2YXRlIHByZXZTdGF0cz86IE1hcDxzdHJpbmcsIFZpZGVvU2VuZGVyU3RhdHM+O1xuXG4gIHByaXZhdGUgZW5jb2RpbmdzPzogUlRDUnRwRW5jb2RpbmdQYXJhbWV0ZXJzW107XG5cbiAgLyogQGludGVybmFsICovXG4gIHNpbXVsY2FzdENvZGVjczogTWFwPFZpZGVvQ29kZWMsIFNpbXVsY2FzdFRyYWNrSW5mbz4gPSBuZXcgTWFwPFZpZGVvQ29kZWMsIFNpbXVsY2FzdFRyYWNrSW5mbz4oKTtcblxuICBwcml2YXRlIHN1YnNjcmliZWRDb2RlY3M/OiBTdWJzY3JpYmVkQ29kZWNbXTtcblxuICAvLyBwcmV2ZW50cyBjb25jdXJyZW50IG1hbmlwdWxhdGlvbnMgdG8gdHJhY2sgc2VuZGVyXG4gIC8vIGlmIG11bHRpcGxlIGdldC9zZXRQYXJhbWV0ZXIgYXJlIGNhbGxlZCBjb25jdXJyZW50bHksIGNlcnRhaW4gdGltaW5nIG9mIGV2ZW50c1xuICAvLyBjb3VsZCBsZWFkIHRvIHRoZSBicm93c2VyIHRocm93aW5nIGFuIGV4Y2VwdGlvbiBpbiBgc2V0UGFyYW1ldGVyYCwgZHVlIHRvXG4gIC8vIGEgbWlzc2luZyBgZ2V0UGFyYW1ldGVyYCBjYWxsLlxuICBwcml2YXRlIHNlbmRlckxvY2s6IE11dGV4O1xuXG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0gbWVkaWFUcmFja1xuICAgKiBAcGFyYW0gY29uc3RyYWludHMgTWVkaWFUcmFja0NvbnN0cmFpbnRzIHRoYXQgYXJlIGJlaW5nIHVzZWQgd2hlbiByZXN0YXJ0aW5nIG9yIHJlYWNxdWlyaW5nIHRyYWNrc1xuICAgKiBAcGFyYW0gdXNlclByb3ZpZGVkVHJhY2sgU2lnbmFscyB0byB0aGUgU0RLIHdoZXRoZXIgb3Igbm90IHRoZSBtZWRpYVRyYWNrIHNob3VsZCBiZSBtYW5hZ2VkIChpLmUuIHJlbGVhc2VkIGFuZCByZWFjcXVpcmVkKSBpbnRlcm5hbGx5IGJ5IHRoZSBTREtcbiAgICovXG4gIGNvbnN0cnVjdG9yKFxuICAgIG1lZGlhVHJhY2s6IE1lZGlhU3RyZWFtVHJhY2ssXG4gICAgY29uc3RyYWludHM/OiBNZWRpYVRyYWNrQ29uc3RyYWludHMsXG4gICAgdXNlclByb3ZpZGVkVHJhY2sgPSB0cnVlLFxuICAgIGxvZ2dlck9wdGlvbnM/OiBMb2dnZXJPcHRpb25zLFxuICApIHtcbiAgICBzdXBlcihtZWRpYVRyYWNrLCBUcmFjay5LaW5kLlZpZGVvLCBjb25zdHJhaW50cywgdXNlclByb3ZpZGVkVHJhY2ssIGxvZ2dlck9wdGlvbnMpO1xuICAgIHRoaXMuc2VuZGVyTG9jayA9IG5ldyBNdXRleCgpO1xuICB9XG5cbiAgZ2V0IGlzU2ltdWxjYXN0KCk6IGJvb2xlYW4ge1xuICAgIGlmICh0aGlzLnNlbmRlciAmJiB0aGlzLnNlbmRlci5nZXRQYXJhbWV0ZXJzKCkuZW5jb2RpbmdzLmxlbmd0aCA+IDEpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKiBAaW50ZXJuYWwgKi9cbiAgc3RhcnRNb25pdG9yKHNpZ25hbENsaWVudDogU2lnbmFsQ2xpZW50KSB7XG4gICAgdGhpcy5zaWduYWxDbGllbnQgPSBzaWduYWxDbGllbnQ7XG4gICAgaWYgKCFpc1dlYigpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIHNhdmUgb3JpZ2luYWwgZW5jb2RpbmdzXG4gICAgLy8gVE9ETyA6IG1lcmdlIHNpbXVsY2FzdCB0cmFja3Mgc3RhdHNcbiAgICBjb25zdCBwYXJhbXMgPSB0aGlzLnNlbmRlcj8uZ2V0UGFyYW1ldGVycygpO1xuICAgIGlmIChwYXJhbXMpIHtcbiAgICAgIHRoaXMuZW5jb2RpbmdzID0gcGFyYW1zLmVuY29kaW5ncztcbiAgICB9XG5cbiAgICBpZiAodGhpcy5tb25pdG9ySW50ZXJ2YWwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5tb25pdG9ySW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICB0aGlzLm1vbml0b3JTZW5kZXIoKTtcbiAgICB9LCBtb25pdG9yRnJlcXVlbmN5KTtcbiAgfVxuXG4gIHN0b3AoKSB7XG4gICAgdGhpcy5fbWVkaWFTdHJlYW1UcmFjay5nZXRDb25zdHJhaW50cygpO1xuICAgIHRoaXMuc2ltdWxjYXN0Q29kZWNzLmZvckVhY2goKHRyYWNrSW5mbykgPT4ge1xuICAgICAgdHJhY2tJbmZvLm1lZGlhU3RyZWFtVHJhY2suc3RvcCgpO1xuICAgIH0pO1xuICAgIHN1cGVyLnN0b3AoKTtcbiAgfVxuXG4gIGFzeW5jIHBhdXNlVXBzdHJlYW0oKSB7XG4gICAgYXdhaXQgc3VwZXIucGF1c2VVcHN0cmVhbSgpO1xuICAgIGZvciBhd2FpdCAoY29uc3Qgc2Mgb2YgdGhpcy5zaW11bGNhc3RDb2RlY3MudmFsdWVzKCkpIHtcbiAgICAgIGF3YWl0IHNjLnNlbmRlcj8ucmVwbGFjZVRyYWNrKG51bGwpO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIHJlc3VtZVVwc3RyZWFtKCkge1xuICAgIGF3YWl0IHN1cGVyLnJlc3VtZVVwc3RyZWFtKCk7XG4gICAgZm9yIGF3YWl0IChjb25zdCBzYyBvZiB0aGlzLnNpbXVsY2FzdENvZGVjcy52YWx1ZXMoKSkge1xuICAgICAgYXdhaXQgc2Muc2VuZGVyPy5yZXBsYWNlVHJhY2soc2MubWVkaWFTdHJlYW1UcmFjayk7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgbXV0ZSgpOiBQcm9taXNlPExvY2FsVmlkZW9UcmFjaz4ge1xuICAgIGNvbnN0IHVubG9jayA9IGF3YWl0IHRoaXMubXV0ZUxvY2subG9jaygpO1xuICAgIHRyeSB7XG4gICAgICBpZiAodGhpcy5zb3VyY2UgPT09IFRyYWNrLlNvdXJjZS5DYW1lcmEgJiYgIXRoaXMuaXNVc2VyUHJvdmlkZWQpIHtcbiAgICAgICAgdGhpcy5sb2cuZGVidWcoJ3N0b3BwaW5nIGNhbWVyYSB0cmFjaycsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICAgIC8vIGFsc28gc3RvcCB0aGUgdHJhY2ssIHNvIHRoYXQgY2FtZXJhIGluZGljYXRvciBpcyB0dXJuZWQgb2ZmXG4gICAgICAgIHRoaXMuX21lZGlhU3RyZWFtVHJhY2suc3RvcCgpO1xuICAgICAgfVxuICAgICAgYXdhaXQgc3VwZXIubXV0ZSgpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHVubG9jaygpO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIHVubXV0ZSgpOiBQcm9taXNlPExvY2FsVmlkZW9UcmFjaz4ge1xuICAgIGNvbnN0IHVubG9jayA9IGF3YWl0IHRoaXMubXV0ZUxvY2subG9jaygpO1xuICAgIHRyeSB7XG4gICAgICBpZiAodGhpcy5zb3VyY2UgPT09IFRyYWNrLlNvdXJjZS5DYW1lcmEgJiYgIXRoaXMuaXNVc2VyUHJvdmlkZWQpIHtcbiAgICAgICAgdGhpcy5sb2cuZGVidWcoJ3JlYWNxdWlyaW5nIGNhbWVyYSB0cmFjaycsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICAgIGF3YWl0IHRoaXMucmVzdGFydFRyYWNrKCk7XG4gICAgICB9XG4gICAgICBhd2FpdCBzdXBlci51bm11dGUoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0gZmluYWxseSB7XG4gICAgICB1bmxvY2soKTtcbiAgICB9XG4gIH1cblxuICBwcm90ZWN0ZWQgc2V0VHJhY2tNdXRlZChtdXRlZDogYm9vbGVhbikge1xuICAgIHN1cGVyLnNldFRyYWNrTXV0ZWQobXV0ZWQpO1xuICAgIGZvciAoY29uc3Qgc2Mgb2YgdGhpcy5zaW11bGNhc3RDb2RlY3MudmFsdWVzKCkpIHtcbiAgICAgIHNjLm1lZGlhU3RyZWFtVHJhY2suZW5hYmxlZCA9ICFtdXRlZDtcbiAgICB9XG4gIH1cblxuICBhc3luYyBnZXRTZW5kZXJTdGF0cygpOiBQcm9taXNlPFZpZGVvU2VuZGVyU3RhdHNbXT4ge1xuICAgIGlmICghdGhpcy5zZW5kZXI/LmdldFN0YXRzKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgY29uc3QgaXRlbXM6IFZpZGVvU2VuZGVyU3RhdHNbXSA9IFtdO1xuXG4gICAgY29uc3Qgc3RhdHMgPSBhd2FpdCB0aGlzLnNlbmRlci5nZXRTdGF0cygpO1xuICAgIHN0YXRzLmZvckVhY2goKHYpID0+IHtcbiAgICAgIGlmICh2LnR5cGUgPT09ICdvdXRib3VuZC1ydHAnKSB7XG4gICAgICAgIGNvbnN0IHZzOiBWaWRlb1NlbmRlclN0YXRzID0ge1xuICAgICAgICAgIHR5cGU6ICd2aWRlbycsXG4gICAgICAgICAgc3RyZWFtSWQ6IHYuaWQsXG4gICAgICAgICAgZnJhbWVIZWlnaHQ6IHYuZnJhbWVIZWlnaHQsXG4gICAgICAgICAgZnJhbWVXaWR0aDogdi5mcmFtZVdpZHRoLFxuICAgICAgICAgIGZpckNvdW50OiB2LmZpckNvdW50LFxuICAgICAgICAgIHBsaUNvdW50OiB2LnBsaUNvdW50LFxuICAgICAgICAgIG5hY2tDb3VudDogdi5uYWNrQ291bnQsXG4gICAgICAgICAgcGFja2V0c1NlbnQ6IHYucGFja2V0c1NlbnQsXG4gICAgICAgICAgYnl0ZXNTZW50OiB2LmJ5dGVzU2VudCxcbiAgICAgICAgICBmcmFtZXNTZW50OiB2LmZyYW1lc1NlbnQsXG4gICAgICAgICAgdGltZXN0YW1wOiB2LnRpbWVzdGFtcCxcbiAgICAgICAgICByaWQ6IHYucmlkID8/IHYuaWQsXG4gICAgICAgICAgcmV0cmFuc21pdHRlZFBhY2tldHNTZW50OiB2LnJldHJhbnNtaXR0ZWRQYWNrZXRzU2VudCxcbiAgICAgICAgICBxdWFsaXR5TGltaXRhdGlvblJlYXNvbjogdi5xdWFsaXR5TGltaXRhdGlvblJlYXNvbixcbiAgICAgICAgICBxdWFsaXR5TGltaXRhdGlvblJlc29sdXRpb25DaGFuZ2VzOiB2LnF1YWxpdHlMaW1pdGF0aW9uUmVzb2x1dGlvbkNoYW5nZXMsXG4gICAgICAgIH07XG5cbiAgICAgICAgLy/CoGxvY2F0ZSB0aGUgYXBwcm9wcmlhdGUgcmVtb3RlLWluYm91bmQtcnRwIGl0ZW1cbiAgICAgICAgY29uc3QgciA9IHN0YXRzLmdldCh2LnJlbW90ZUlkKTtcbiAgICAgICAgaWYgKHIpIHtcbiAgICAgICAgICB2cy5qaXR0ZXIgPSByLmppdHRlcjtcbiAgICAgICAgICB2cy5wYWNrZXRzTG9zdCA9IHIucGFja2V0c0xvc3Q7XG4gICAgICAgICAgdnMucm91bmRUcmlwVGltZSA9IHIucm91bmRUcmlwVGltZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGl0ZW1zLnB1c2godnMpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGl0ZW1zO1xuICB9XG5cbiAgc2V0UHVibGlzaGluZ1F1YWxpdHkobWF4UXVhbGl0eTogVmlkZW9RdWFsaXR5KSB7XG4gICAgY29uc3QgcXVhbGl0aWVzOiBTdWJzY3JpYmVkUXVhbGl0eVtdID0gW107XG4gICAgZm9yIChsZXQgcSA9IFZpZGVvUXVhbGl0eS5MT1c7IHEgPD0gVmlkZW9RdWFsaXR5LkhJR0g7IHEgKz0gMSkge1xuICAgICAgcXVhbGl0aWVzLnB1c2goXG4gICAgICAgIG5ldyBTdWJzY3JpYmVkUXVhbGl0eSh7XG4gICAgICAgICAgcXVhbGl0eTogcSxcbiAgICAgICAgICBlbmFibGVkOiBxIDw9IG1heFF1YWxpdHksXG4gICAgICAgIH0pLFxuICAgICAgKTtcbiAgICB9XG4gICAgdGhpcy5sb2cuZGVidWcoYHNldHRpbmcgcHVibGlzaGluZyBxdWFsaXR5LiBtYXggcXVhbGl0eSAke21heFF1YWxpdHl9YCwgdGhpcy5sb2dDb250ZXh0KTtcbiAgICB0aGlzLnNldFB1Ymxpc2hpbmdMYXllcnMocXVhbGl0aWVzKTtcbiAgfVxuXG4gIGFzeW5jIHNldERldmljZUlkKGRldmljZUlkOiBDb25zdHJhaW5ET01TdHJpbmcpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICBpZiAoXG4gICAgICB0aGlzLl9jb25zdHJhaW50cy5kZXZpY2VJZCA9PT0gZGV2aWNlSWQgJiZcbiAgICAgIHRoaXMuX21lZGlhU3RyZWFtVHJhY2suZ2V0U2V0dGluZ3MoKS5kZXZpY2VJZCA9PT0gdW53cmFwQ29uc3RyYWludChkZXZpY2VJZClcbiAgICApIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICB0aGlzLl9jb25zdHJhaW50cy5kZXZpY2VJZCA9IGRldmljZUlkO1xuICAgIC8vIHdoZW4gdmlkZW8gaXMgbXV0ZWQsIHVuZGVybHlpbmcgbWVkaWEgc3RyZWFtIHRyYWNrIGlzIHN0b3BwZWQgYW5kXG4gICAgLy8gd2lsbCBiZSByZXN0YXJ0ZWQgbGF0ZXJcbiAgICBpZiAoIXRoaXMuaXNNdXRlZCkge1xuICAgICAgYXdhaXQgdGhpcy5yZXN0YXJ0VHJhY2soKTtcbiAgICB9XG4gICAgcmV0dXJuIChcbiAgICAgIHRoaXMuaXNNdXRlZCB8fCB1bndyYXBDb25zdHJhaW50KGRldmljZUlkKSA9PT0gdGhpcy5fbWVkaWFTdHJlYW1UcmFjay5nZXRTZXR0aW5ncygpLmRldmljZUlkXG4gICAgKTtcbiAgfVxuXG4gIGFzeW5jIHJlc3RhcnRUcmFjayhvcHRpb25zPzogVmlkZW9DYXB0dXJlT3B0aW9ucykge1xuICAgIGxldCBjb25zdHJhaW50czogTWVkaWFUcmFja0NvbnN0cmFpbnRzIHwgdW5kZWZpbmVkO1xuICAgIGlmIChvcHRpb25zKSB7XG4gICAgICBjb25zdCBzdHJlYW1Db25zdHJhaW50cyA9IGNvbnN0cmFpbnRzRm9yT3B0aW9ucyh7IHZpZGVvOiBvcHRpb25zIH0pO1xuICAgICAgaWYgKHR5cGVvZiBzdHJlYW1Db25zdHJhaW50cy52aWRlbyAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIGNvbnN0cmFpbnRzID0gc3RyZWFtQ29uc3RyYWludHMudmlkZW87XG4gICAgICB9XG4gICAgfVxuICAgIGF3YWl0IHRoaXMucmVzdGFydChjb25zdHJhaW50cyk7XG5cbiAgICBmb3IgYXdhaXQgKGNvbnN0IHNjIG9mIHRoaXMuc2ltdWxjYXN0Q29kZWNzLnZhbHVlcygpKSB7XG4gICAgICBpZiAoc2Muc2VuZGVyKSB7XG4gICAgICAgIHNjLm1lZGlhU3RyZWFtVHJhY2sgPSB0aGlzLm1lZGlhU3RyZWFtVHJhY2suY2xvbmUoKTtcbiAgICAgICAgYXdhaXQgc2Muc2VuZGVyLnJlcGxhY2VUcmFjayhzYy5tZWRpYVN0cmVhbVRyYWNrKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBhc3luYyBzZXRQcm9jZXNzb3IocHJvY2Vzc29yOiBUcmFja1Byb2Nlc3NvcjxUcmFjay5LaW5kPiwgc2hvd1Byb2Nlc3NlZFN0cmVhbUxvY2FsbHkgPSB0cnVlKSB7XG4gICAgYXdhaXQgc3VwZXIuc2V0UHJvY2Vzc29yKHByb2Nlc3Nvciwgc2hvd1Byb2Nlc3NlZFN0cmVhbUxvY2FsbHkpO1xuXG4gICAgaWYgKHRoaXMucHJvY2Vzc29yPy5wcm9jZXNzZWRUcmFjaykge1xuICAgICAgZm9yIGF3YWl0IChjb25zdCBzYyBvZiB0aGlzLnNpbXVsY2FzdENvZGVjcy52YWx1ZXMoKSkge1xuICAgICAgICBhd2FpdCBzYy5zZW5kZXI/LnJlcGxhY2VUcmFjayh0aGlzLnByb2Nlc3Nvci5wcm9jZXNzZWRUcmFjayk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgYWRkU2ltdWxjYXN0VHJhY2soY29kZWM6IFZpZGVvQ29kZWMsIGVuY29kaW5ncz86IFJUQ1J0cEVuY29kaW5nUGFyYW1ldGVyc1tdKTogU2ltdWxjYXN0VHJhY2tJbmZvIHtcbiAgICBpZiAodGhpcy5zaW11bGNhc3RDb2RlY3MuaGFzKGNvZGVjKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2NvZGVjfSBhbHJlYWR5IGFkZGVkYCk7XG4gICAgfVxuICAgIGNvbnN0IHNpbXVsY2FzdENvZGVjSW5mbzogU2ltdWxjYXN0VHJhY2tJbmZvID0ge1xuICAgICAgY29kZWMsXG4gICAgICBtZWRpYVN0cmVhbVRyYWNrOiB0aGlzLm1lZGlhU3RyZWFtVHJhY2suY2xvbmUoKSxcbiAgICAgIHNlbmRlcjogdW5kZWZpbmVkLFxuICAgICAgZW5jb2RpbmdzLFxuICAgIH07XG4gICAgdGhpcy5zaW11bGNhc3RDb2RlY3Muc2V0KGNvZGVjLCBzaW11bGNhc3RDb2RlY0luZm8pO1xuICAgIHJldHVybiBzaW11bGNhc3RDb2RlY0luZm87XG4gIH1cblxuICBzZXRTaW11bGNhc3RUcmFja1NlbmRlcihjb2RlYzogVmlkZW9Db2RlYywgc2VuZGVyOiBSVENSdHBTZW5kZXIpIHtcbiAgICBjb25zdCBzaW11bGNhc3RDb2RlY0luZm8gPSB0aGlzLnNpbXVsY2FzdENvZGVjcy5nZXQoY29kZWMpO1xuICAgIGlmICghc2ltdWxjYXN0Q29kZWNJbmZvKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHNpbXVsY2FzdENvZGVjSW5mby5zZW5kZXIgPSBzZW5kZXI7XG5cbiAgICAvLyBicm93c2VyIHdpbGwgcmVlbmFibGUgZGlzYWJsZWQgY29kZWMvbGF5ZXJzIGFmdGVyIG5ldyBjb2RlYyBoYXMgYmVlbiBwdWJsaXNoZWQsXG4gICAgLy8gc28gcmVmcmVzaCBzdWJzY3JpYmVkQ29kZWNzIGFmdGVyIHB1Ymxpc2ggYSBuZXcgY29kZWNcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGlmICh0aGlzLnN1YnNjcmliZWRDb2RlY3MpIHtcbiAgICAgICAgdGhpcy5zZXRQdWJsaXNoaW5nQ29kZWNzKHRoaXMuc3Vic2NyaWJlZENvZGVjcyk7XG4gICAgICB9XG4gICAgfSwgcmVmcmVzaFN1YnNjcmliZWRDb2RlY0FmdGVyTmV3Q29kZWMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBTZXRzIGNvZGVjcyB0aGF0IHNob3VsZCBiZSBwdWJsaXNoaW5nLCByZXR1cm5zIG5ldyBjb2RlY3MgdGhhdCBoYXZlIG5vdCB5ZXRcbiAgICogYmVlbiBwdWJsaXNoZWRcbiAgICovXG4gIGFzeW5jIHNldFB1Ymxpc2hpbmdDb2RlY3MoY29kZWNzOiBTdWJzY3JpYmVkQ29kZWNbXSk6IFByb21pc2U8VmlkZW9Db2RlY1tdPiB7XG4gICAgdGhpcy5sb2cuZGVidWcoJ3NldHRpbmcgcHVibGlzaGluZyBjb2RlY3MnLCB7XG4gICAgICAuLi50aGlzLmxvZ0NvbnRleHQsXG4gICAgICBjb2RlY3MsXG4gICAgICBjdXJyZW50Q29kZWM6IHRoaXMuY29kZWMsXG4gICAgfSk7XG4gICAgLy8gb25seSBlbmFibGUgc2ltdWxjYXN0IGNvZGVjIGZvciBwcmVmZXJlbmNlIGNvZGVjIHNldHRlZFxuICAgIGlmICghdGhpcy5jb2RlYyAmJiBjb2RlY3MubGVuZ3RoID4gMCkge1xuICAgICAgYXdhaXQgdGhpcy5zZXRQdWJsaXNoaW5nTGF5ZXJzKGNvZGVjc1swXS5xdWFsaXRpZXMpO1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIHRoaXMuc3Vic2NyaWJlZENvZGVjcyA9IGNvZGVjcztcblxuICAgIGNvbnN0IG5ld0NvZGVjczogVmlkZW9Db2RlY1tdID0gW107XG4gICAgZm9yIGF3YWl0IChjb25zdCBjb2RlYyBvZiBjb2RlY3MpIHtcbiAgICAgIGlmICghdGhpcy5jb2RlYyB8fCB0aGlzLmNvZGVjID09PSBjb2RlYy5jb2RlYykge1xuICAgICAgICBhd2FpdCB0aGlzLnNldFB1Ymxpc2hpbmdMYXllcnMoY29kZWMucXVhbGl0aWVzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHNpbXVsY2FzdENvZGVjSW5mbyA9IHRoaXMuc2ltdWxjYXN0Q29kZWNzLmdldChjb2RlYy5jb2RlYyBhcyBWaWRlb0NvZGVjKTtcbiAgICAgICAgdGhpcy5sb2cuZGVidWcoYHRyeSBzZXRQdWJsaXNoaW5nQ29kZWMgZm9yICR7Y29kZWMuY29kZWN9YCwge1xuICAgICAgICAgIC4uLnRoaXMubG9nQ29udGV4dCxcbiAgICAgICAgICBzaW11bGNhc3RDb2RlY0luZm8sXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIXNpbXVsY2FzdENvZGVjSW5mbyB8fCAhc2ltdWxjYXN0Q29kZWNJbmZvLnNlbmRlcikge1xuICAgICAgICAgIGZvciAoY29uc3QgcSBvZiBjb2RlYy5xdWFsaXRpZXMpIHtcbiAgICAgICAgICAgIGlmIChxLmVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgbmV3Q29kZWNzLnB1c2goY29kZWMuY29kZWMgYXMgVmlkZW9Db2RlYyk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChzaW11bGNhc3RDb2RlY0luZm8uZW5jb2RpbmdzKSB7XG4gICAgICAgICAgdGhpcy5sb2cuZGVidWcoYHRyeSBzZXRQdWJsaXNoaW5nTGF5ZXJzRm9yU2VuZGVyICR7Y29kZWMuY29kZWN9YCwgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgICAgICBhd2FpdCBzZXRQdWJsaXNoaW5nTGF5ZXJzRm9yU2VuZGVyKFxuICAgICAgICAgICAgc2ltdWxjYXN0Q29kZWNJbmZvLnNlbmRlcixcbiAgICAgICAgICAgIHNpbXVsY2FzdENvZGVjSW5mby5lbmNvZGluZ3MhLFxuICAgICAgICAgICAgY29kZWMucXVhbGl0aWVzLFxuICAgICAgICAgICAgdGhpcy5zZW5kZXJMb2NrLFxuICAgICAgICAgICAgdGhpcy5sb2csXG4gICAgICAgICAgICB0aGlzLmxvZ0NvbnRleHQsXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3Q29kZWNzO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBTZXRzIGxheWVycyB0aGF0IHNob3VsZCBiZSBwdWJsaXNoaW5nXG4gICAqL1xuICBhc3luYyBzZXRQdWJsaXNoaW5nTGF5ZXJzKHF1YWxpdGllczogU3Vic2NyaWJlZFF1YWxpdHlbXSkge1xuICAgIHRoaXMubG9nLmRlYnVnKCdzZXR0aW5nIHB1Ymxpc2hpbmcgbGF5ZXJzJywgeyAuLi50aGlzLmxvZ0NvbnRleHQsIHF1YWxpdGllcyB9KTtcbiAgICBpZiAoIXRoaXMuc2VuZGVyIHx8ICF0aGlzLmVuY29kaW5ncykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGF3YWl0IHNldFB1Ymxpc2hpbmdMYXllcnNGb3JTZW5kZXIoXG4gICAgICB0aGlzLnNlbmRlcixcbiAgICAgIHRoaXMuZW5jb2RpbmdzLFxuICAgICAgcXVhbGl0aWVzLFxuICAgICAgdGhpcy5zZW5kZXJMb2NrLFxuICAgICAgdGhpcy5sb2csXG4gICAgICB0aGlzLmxvZ0NvbnRleHQsXG4gICAgKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBtb25pdG9yU2VuZGVyID0gYXN5bmMgKCkgPT4ge1xuICAgIGlmICghdGhpcy5zZW5kZXIpIHtcbiAgICAgIHRoaXMuX2N1cnJlbnRCaXRyYXRlID0gMDtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsZXQgc3RhdHM6IFZpZGVvU2VuZGVyU3RhdHNbXSB8IHVuZGVmaW5lZDtcbiAgICB0cnkge1xuICAgICAgc3RhdHMgPSBhd2FpdCB0aGlzLmdldFNlbmRlclN0YXRzKCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhpcy5sb2cuZXJyb3IoJ2NvdWxkIG5vdCBnZXQgYXVkaW8gc2VuZGVyIHN0YXRzJywgeyAuLi50aGlzLmxvZ0NvbnRleHQsIGVycm9yOiBlIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzdGF0c01hcCA9IG5ldyBNYXA8c3RyaW5nLCBWaWRlb1NlbmRlclN0YXRzPihzdGF0cy5tYXAoKHMpID0+IFtzLnJpZCwgc10pKTtcblxuICAgIGlmICh0aGlzLnByZXZTdGF0cykge1xuICAgICAgbGV0IHRvdGFsQml0cmF0ZSA9IDA7XG4gICAgICBzdGF0c01hcC5mb3JFYWNoKChzLCBrZXkpID0+IHtcbiAgICAgICAgY29uc3QgcHJldiA9IHRoaXMucHJldlN0YXRzPy5nZXQoa2V5KTtcbiAgICAgICAgdG90YWxCaXRyYXRlICs9IGNvbXB1dGVCaXRyYXRlKHMsIHByZXYpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLl9jdXJyZW50Qml0cmF0ZSA9IHRvdGFsQml0cmF0ZTtcbiAgICB9XG5cbiAgICB0aGlzLnByZXZTdGF0cyA9IHN0YXRzTWFwO1xuICB9O1xuXG4gIHByb3RlY3RlZCBhc3luYyBoYW5kbGVBcHBWaXNpYmlsaXR5Q2hhbmdlZCgpIHtcbiAgICBhd2FpdCBzdXBlci5oYW5kbGVBcHBWaXNpYmlsaXR5Q2hhbmdlZCgpO1xuICAgIGlmICghaXNNb2JpbGUoKSkgcmV0dXJuO1xuICAgIGlmICh0aGlzLmlzSW5CYWNrZ3JvdW5kICYmIHRoaXMuc291cmNlID09PSBUcmFjay5Tb3VyY2UuQ2FtZXJhKSB7XG4gICAgICB0aGlzLl9tZWRpYVN0cmVhbVRyYWNrLmVuYWJsZWQgPSBmYWxzZTtcbiAgICB9XG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gc2V0UHVibGlzaGluZ0xheWVyc0ZvclNlbmRlcihcbiAgc2VuZGVyOiBSVENSdHBTZW5kZXIsXG4gIHNlbmRlckVuY29kaW5nczogUlRDUnRwRW5jb2RpbmdQYXJhbWV0ZXJzW10sXG4gIHF1YWxpdGllczogU3Vic2NyaWJlZFF1YWxpdHlbXSxcbiAgc2VuZGVyTG9jazogTXV0ZXgsXG4gIGxvZzogU3RydWN0dXJlZExvZ2dlcixcbiAgbG9nQ29udGV4dDogUmVjb3JkPHN0cmluZywgdW5rbm93bj4sXG4pIHtcbiAgY29uc3QgdW5sb2NrID0gYXdhaXQgc2VuZGVyTG9jay5sb2NrKCk7XG4gIGxvZy5kZWJ1Zygnc2V0UHVibGlzaGluZ0xheWVyc0ZvclNlbmRlcicsIHsgLi4ubG9nQ29udGV4dCwgc2VuZGVyLCBxdWFsaXRpZXMsIHNlbmRlckVuY29kaW5ncyB9KTtcbiAgdHJ5IHtcbiAgICBjb25zdCBwYXJhbXMgPSBzZW5kZXIuZ2V0UGFyYW1ldGVycygpO1xuICAgIGNvbnN0IHsgZW5jb2RpbmdzIH0gPSBwYXJhbXM7XG4gICAgaWYgKCFlbmNvZGluZ3MpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZW5jb2RpbmdzLmxlbmd0aCAhPT0gc2VuZGVyRW5jb2RpbmdzLmxlbmd0aCkge1xuICAgICAgbG9nLndhcm4oJ2Nhbm5vdCBzZXQgcHVibGlzaGluZyBsYXllcnMsIGVuY29kaW5ncyBtaXNtYXRjaCcpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxldCBoYXNDaGFuZ2VkID0gZmFsc2U7XG5cbiAgICAvKiBkaXNhYmxlIGNsb3NhYmxlIHNwYXRpYWwgbGF5ZXIgYXMgaXQgaGFzIHZpZGVvIGJsdXIgLyBmcm96ZW4gaXNzdWUgd2l0aCBjdXJyZW50IHNlcnZlciAvIGNsaWVudFxuICAgIDEuIGNocm9tZSAxMTM6IHdoZW4gc3dpdGNoaW5nIHRvIHVwIGxheWVyIHdpdGggc2NhbGFiaWxpdHkgTW9kZSBjaGFuZ2UsIGl0IHdpbGwgZ2VuZXJhdGUgYVxuICAgICAgICAgIGxvdyByZXNvbHV0aW9uIGZyYW1lIGFuZCByZWNvdmVyIHZlcnkgcXVpY2tseSwgYnV0IG5vdGljYWJsZVxuICAgIDIuIGxpdmVraXQgc2Z1OiBhZGRpdGlvbmFsIHBsaSByZXF1ZXN0IGNhdXNlIHZpZGVvIGZyb3plbiBmb3IgYSBmZXcgZnJhbWVzLCBhbHNvIG5vdGljYWJsZSAqL1xuICAgIGNvbnN0IGNsb3NhYmxlU3BhdGlhbCA9IGZhbHNlO1xuICAgIC8qIEB0cy1pZ25vcmUgKi9cbiAgICBpZiAoY2xvc2FibGVTcGF0aWFsICYmIGVuY29kaW5nc1swXS5zY2FsYWJpbGl0eU1vZGUpIHtcbiAgICAgIC8vIHN2YyBkeW5hY2FzdCBlbmNvZGluZ3NcbiAgICAgIGNvbnN0IGVuY29kaW5nID0gZW5jb2RpbmdzWzBdO1xuICAgICAgLyogQHRzLWlnbm9yZSAqL1xuICAgICAgLy8gY29uc3QgbW9kZSA9IG5ldyBTY2FsYWJpbGl0eU1vZGUoZW5jb2Rpbmcuc2NhbGFiaWxpdHlNb2RlKTtcbiAgICAgIGxldCBtYXhRdWFsaXR5ID0gVmlkZW9RdWFsaXR5Lk9GRjtcbiAgICAgIHF1YWxpdGllcy5mb3JFYWNoKChxKSA9PiB7XG4gICAgICAgIGlmIChxLmVuYWJsZWQgJiYgKG1heFF1YWxpdHkgPT09IFZpZGVvUXVhbGl0eS5PRkYgfHwgcS5xdWFsaXR5ID4gbWF4UXVhbGl0eSkpIHtcbiAgICAgICAgICBtYXhRdWFsaXR5ID0gcS5xdWFsaXR5O1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgaWYgKG1heFF1YWxpdHkgPT09IFZpZGVvUXVhbGl0eS5PRkYpIHtcbiAgICAgICAgaWYgKGVuY29kaW5nLmFjdGl2ZSkge1xuICAgICAgICAgIGVuY29kaW5nLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgIGhhc0NoYW5nZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKCFlbmNvZGluZy5hY3RpdmUgLyogfHwgbW9kZS5zcGF0aWFsICE9PSBtYXhRdWFsaXR5ICsgMSovKSB7XG4gICAgICAgIGhhc0NoYW5nZWQgPSB0cnVlO1xuICAgICAgICBlbmNvZGluZy5hY3RpdmUgPSB0cnVlO1xuICAgICAgICAvKlxuICAgICAgICBAdHMtaWdub3JlXG4gICAgICAgIGNvbnN0IG9yaWdpbmFsTW9kZSA9IG5ldyBTY2FsYWJpbGl0eU1vZGUoc2VuZGVyRW5jb2RpbmdzWzBdLnNjYWxhYmlsaXR5TW9kZSlcbiAgICAgICAgbW9kZS5zcGF0aWFsID0gbWF4UXVhbGl0eSArIDE7XG4gICAgICAgIG1vZGUuc3VmZml4ID0gb3JpZ2luYWxNb2RlLnN1ZmZpeDtcbiAgICAgICAgaWYgKG1vZGUuc3BhdGlhbCA9PT0gMSkge1xuICAgICAgICAgIC8vIG5vIHN1ZmZpeCBmb3IgTDFUeFxuICAgICAgICAgIG1vZGUuc3VmZml4ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIEB0cy1pZ25vcmVcbiAgICAgICAgZW5jb2Rpbmcuc2NhbGFiaWxpdHlNb2RlID0gbW9kZS50b1N0cmluZygpO1xuICAgICAgICBlbmNvZGluZy5zY2FsZVJlc29sdXRpb25Eb3duQnkgPSAyICoqICgyIC0gbWF4UXVhbGl0eSk7XG4gICAgICAqL1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBzaW11bGNhc3QgZHluYWNhc3QgZW5jb2RpbmdzXG4gICAgICBlbmNvZGluZ3MuZm9yRWFjaCgoZW5jb2RpbmcsIGlkeCkgPT4ge1xuICAgICAgICBsZXQgcmlkID0gZW5jb2RpbmcucmlkID8/ICcnO1xuICAgICAgICBpZiAocmlkID09PSAnJykge1xuICAgICAgICAgIHJpZCA9ICdxJztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBxdWFsaXR5ID0gdmlkZW9RdWFsaXR5Rm9yUmlkKHJpZCk7XG4gICAgICAgIGNvbnN0IHN1YnNjcmliZWRRdWFsaXR5ID0gcXVhbGl0aWVzLmZpbmQoKHEpID0+IHEucXVhbGl0eSA9PT0gcXVhbGl0eSk7XG4gICAgICAgIGlmICghc3Vic2NyaWJlZFF1YWxpdHkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVuY29kaW5nLmFjdGl2ZSAhPT0gc3Vic2NyaWJlZFF1YWxpdHkuZW5hYmxlZCkge1xuICAgICAgICAgIGhhc0NoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgIGVuY29kaW5nLmFjdGl2ZSA9IHN1YnNjcmliZWRRdWFsaXR5LmVuYWJsZWQ7XG4gICAgICAgICAgbG9nLmRlYnVnKFxuICAgICAgICAgICAgYHNldHRpbmcgbGF5ZXIgJHtzdWJzY3JpYmVkUXVhbGl0eS5xdWFsaXR5fSB0byAke1xuICAgICAgICAgICAgICBlbmNvZGluZy5hY3RpdmUgPyAnZW5hYmxlZCcgOiAnZGlzYWJsZWQnXG4gICAgICAgICAgICB9YCxcbiAgICAgICAgICAgIGxvZ0NvbnRleHQsXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIC8vIEZpcmVGb3ggZG9lcyBub3Qgc3VwcG9ydCBzZXR0aW5nIGVuY29kaW5nLmFjdGl2ZSB0byBmYWxzZSwgc28gd2VcbiAgICAgICAgICAvLyBoYXZlIGEgd29ya2Fyb3VuZCBvZiBsb3dlcmluZyBpdHMgYml0cmF0ZSBhbmQgcmVzb2x1dGlvbiB0byB0aGUgbWluLlxuICAgICAgICAgIGlmIChpc0ZpcmVGb3goKSkge1xuICAgICAgICAgICAgaWYgKHN1YnNjcmliZWRRdWFsaXR5LmVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgZW5jb2Rpbmcuc2NhbGVSZXNvbHV0aW9uRG93bkJ5ID0gc2VuZGVyRW5jb2RpbmdzW2lkeF0uc2NhbGVSZXNvbHV0aW9uRG93bkJ5O1xuICAgICAgICAgICAgICBlbmNvZGluZy5tYXhCaXRyYXRlID0gc2VuZGVyRW5jb2RpbmdzW2lkeF0ubWF4Qml0cmF0ZTtcbiAgICAgICAgICAgICAgLyogQHRzLWlnbm9yZSAqL1xuICAgICAgICAgICAgICBlbmNvZGluZy5tYXhGcmFtZVJhdGUgPSBzZW5kZXJFbmNvZGluZ3NbaWR4XS5tYXhGcmFtZVJhdGU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBlbmNvZGluZy5zY2FsZVJlc29sdXRpb25Eb3duQnkgPSA0O1xuICAgICAgICAgICAgICBlbmNvZGluZy5tYXhCaXRyYXRlID0gMTA7XG4gICAgICAgICAgICAgIC8qIEB0cy1pZ25vcmUgKi9cbiAgICAgICAgICAgICAgZW5jb2RpbmcubWF4RnJhbWVSYXRlID0gMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChoYXNDaGFuZ2VkKSB7XG4gICAgICBwYXJhbXMuZW5jb2RpbmdzID0gZW5jb2RpbmdzO1xuICAgICAgbG9nLmRlYnVnKGBzZXR0aW5nIGVuY29kaW5nc2AsIHsgLi4ubG9nQ29udGV4dCwgZW5jb2RpbmdzOiBwYXJhbXMuZW5jb2RpbmdzIH0pO1xuICAgICAgYXdhaXQgc2VuZGVyLnNldFBhcmFtZXRlcnMocGFyYW1zKTtcbiAgICB9XG4gIH0gZmluYWxseSB7XG4gICAgdW5sb2NrKCk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHZpZGVvUXVhbGl0eUZvclJpZChyaWQ6IHN0cmluZyk6IFZpZGVvUXVhbGl0eSB7XG4gIHN3aXRjaCAocmlkKSB7XG4gICAgY2FzZSAnZic6XG4gICAgICByZXR1cm4gVmlkZW9RdWFsaXR5LkhJR0g7XG4gICAgY2FzZSAnaCc6XG4gICAgICByZXR1cm4gVmlkZW9RdWFsaXR5Lk1FRElVTTtcbiAgICBjYXNlICdxJzpcbiAgICAgIHJldHVybiBWaWRlb1F1YWxpdHkuTE9XO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gVmlkZW9RdWFsaXR5LkhJR0g7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHZpZGVvTGF5ZXJzRnJvbUVuY29kaW5ncyhcbiAgd2lkdGg6IG51bWJlcixcbiAgaGVpZ2h0OiBudW1iZXIsXG4gIGVuY29kaW5ncz86IFJUQ1J0cEVuY29kaW5nUGFyYW1ldGVyc1tdLFxuICBzdmM/OiBib29sZWFuLFxuKTogVmlkZW9MYXllcltdIHtcbiAgLy8gZGVmYXVsdCB0byBhIHNpbmdsZSBsYXllciwgSFFcbiAgaWYgKCFlbmNvZGluZ3MpIHtcbiAgICByZXR1cm4gW1xuICAgICAgbmV3IFZpZGVvTGF5ZXIoe1xuICAgICAgICBxdWFsaXR5OiBWaWRlb1F1YWxpdHkuSElHSCxcbiAgICAgICAgd2lkdGgsXG4gICAgICAgIGhlaWdodCxcbiAgICAgICAgYml0cmF0ZTogMCxcbiAgICAgICAgc3NyYzogMCxcbiAgICAgIH0pLFxuICAgIF07XG4gIH1cblxuICBpZiAoc3ZjKSB7XG4gICAgLy8gc3ZjIGxheWVyc1xuICAgIC8qIEB0cy1pZ25vcmUgKi9cbiAgICBjb25zdCBlbmNvZGluZ1NNID0gZW5jb2RpbmdzWzBdLnNjYWxhYmlsaXR5TW9kZSBhcyBzdHJpbmc7XG4gICAgY29uc3Qgc20gPSBuZXcgU2NhbGFiaWxpdHlNb2RlKGVuY29kaW5nU00pO1xuICAgIGNvbnN0IGxheWVycyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc20uc3BhdGlhbDsgaSArPSAxKSB7XG4gICAgICBsYXllcnMucHVzaChcbiAgICAgICAgbmV3IFZpZGVvTGF5ZXIoe1xuICAgICAgICAgIHF1YWxpdHk6IFZpZGVvUXVhbGl0eS5ISUdIIC0gaSxcbiAgICAgICAgICB3aWR0aDogTWF0aC5jZWlsKHdpZHRoIC8gMiAqKiBpKSxcbiAgICAgICAgICBoZWlnaHQ6IE1hdGguY2VpbChoZWlnaHQgLyAyICoqIGkpLFxuICAgICAgICAgIGJpdHJhdGU6IGVuY29kaW5nc1swXS5tYXhCaXRyYXRlID8gTWF0aC5jZWlsKGVuY29kaW5nc1swXS5tYXhCaXRyYXRlIC8gMyAqKiBpKSA6IDAsXG4gICAgICAgICAgc3NyYzogMCxcbiAgICAgICAgfSksXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gbGF5ZXJzO1xuICB9XG5cbiAgcmV0dXJuIGVuY29kaW5ncy5tYXAoKGVuY29kaW5nKSA9PiB7XG4gICAgY29uc3Qgc2NhbGUgPSBlbmNvZGluZy5zY2FsZVJlc29sdXRpb25Eb3duQnkgPz8gMTtcbiAgICBsZXQgcXVhbGl0eSA9IHZpZGVvUXVhbGl0eUZvclJpZChlbmNvZGluZy5yaWQgPz8gJycpO1xuICAgIHJldHVybiBuZXcgVmlkZW9MYXllcih7XG4gICAgICBxdWFsaXR5LFxuICAgICAgd2lkdGg6IE1hdGguY2VpbCh3aWR0aCAvIHNjYWxlKSxcbiAgICAgIGhlaWdodDogTWF0aC5jZWlsKGhlaWdodCAvIHNjYWxlKSxcbiAgICAgIGJpdHJhdGU6IGVuY29kaW5nLm1heEJpdHJhdGUgPz8gMCxcbiAgICAgIHNzcmM6IDAsXG4gICAgfSk7XG4gIH0pO1xufVxuIiwiaW1wb3J0IHsgVHJhY2tFdmVudCB9IGZyb20gJy4uL2V2ZW50cyc7XG5pbXBvcnQgeyBtb25pdG9yRnJlcXVlbmN5IH0gZnJvbSAnLi4vc3RhdHMnO1xuaW1wb3J0IHR5cGUgeyBMb2dnZXJPcHRpb25zIH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgVHJhY2sgfSBmcm9tICcuL1RyYWNrJztcblxuZXhwb3J0IGRlZmF1bHQgYWJzdHJhY3QgY2xhc3MgUmVtb3RlVHJhY2sgZXh0ZW5kcyBUcmFjayB7XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgcmVjZWl2ZXI/OiBSVENSdHBSZWNlaXZlcjtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBtZWRpYVRyYWNrOiBNZWRpYVN0cmVhbVRyYWNrLFxuICAgIHNpZDogc3RyaW5nLFxuICAgIGtpbmQ6IFRyYWNrLktpbmQsXG4gICAgcmVjZWl2ZXI/OiBSVENSdHBSZWNlaXZlcixcbiAgICBsb2dnZXJPcHRpb25zPzogTG9nZ2VyT3B0aW9ucyxcbiAgKSB7XG4gICAgc3VwZXIobWVkaWFUcmFjaywga2luZCwgbG9nZ2VyT3B0aW9ucyk7XG5cbiAgICB0aGlzLnNpZCA9IHNpZDtcbiAgICB0aGlzLnJlY2VpdmVyID0gcmVjZWl2ZXI7XG4gIH1cblxuICAvKiogQGludGVybmFsICovXG4gIHNldE11dGVkKG11dGVkOiBib29sZWFuKSB7XG4gICAgaWYgKHRoaXMuaXNNdXRlZCAhPT0gbXV0ZWQpIHtcbiAgICAgIHRoaXMuaXNNdXRlZCA9IG11dGVkO1xuICAgICAgdGhpcy5fbWVkaWFTdHJlYW1UcmFjay5lbmFibGVkID0gIW11dGVkO1xuICAgICAgdGhpcy5lbWl0KG11dGVkID8gVHJhY2tFdmVudC5NdXRlZCA6IFRyYWNrRXZlbnQuVW5tdXRlZCwgdGhpcyk7XG4gICAgfVxuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBzZXRNZWRpYVN0cmVhbShzdHJlYW06IE1lZGlhU3RyZWFtKSB7XG4gICAgLy8gdGhpcyBpcyBuZWVkZWQgdG8gZGV0ZXJtaW5lIHdoZW4gdGhlIHRyYWNrIGlzIGZpbmlzaGVkXG4gICAgdGhpcy5tZWRpYVN0cmVhbSA9IHN0cmVhbTtcbiAgICBjb25zdCBvblJlbW92ZVRyYWNrID0gKGV2ZW50OiBNZWRpYVN0cmVhbVRyYWNrRXZlbnQpID0+IHtcbiAgICAgIGlmIChldmVudC50cmFjayA9PT0gdGhpcy5fbWVkaWFTdHJlYW1UcmFjaykge1xuICAgICAgICBzdHJlYW0ucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVtb3ZldHJhY2snLCBvblJlbW92ZVRyYWNrKTtcbiAgICAgICAgdGhpcy5yZWNlaXZlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fY3VycmVudEJpdHJhdGUgPSAwO1xuICAgICAgICB0aGlzLmVtaXQoVHJhY2tFdmVudC5FbmRlZCwgdGhpcyk7XG4gICAgICB9XG4gICAgfTtcbiAgICBzdHJlYW0uYWRkRXZlbnRMaXN0ZW5lcigncmVtb3ZldHJhY2snLCBvblJlbW92ZVRyYWNrKTtcbiAgfVxuXG4gIHN0YXJ0KCkge1xuICAgIHRoaXMuc3RhcnRNb25pdG9yKCk7XG4gICAgLy8gdXNlIGBlbmFibGVkYCBvZiB0cmFjayB0byBlbmFibGUgcmUtdXNlIG9mIHRyYW5zY2VpdmVyXG4gICAgc3VwZXIuZW5hYmxlKCk7XG4gIH1cblxuICBzdG9wKCkge1xuICAgIHRoaXMuc3RvcE1vbml0b3IoKTtcbiAgICAvLyB1c2UgYGVuYWJsZWRgIG9mIHRyYWNrIHRvIGVuYWJsZSByZS11c2Ugb2YgdHJhbnNjZWl2ZXJcbiAgICBzdXBlci5kaXNhYmxlKCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgUlRDU3RhdHNSZXBvcnQgZm9yIHRoZSBSZW1vdGVUcmFjaydzIHVuZGVybHlpbmcgUlRDUnRwUmVjZWl2ZXJcbiAgICogU2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9SVENTdGF0c1JlcG9ydFxuICAgKlxuICAgKiBAcmV0dXJucyBQcm9taXNlPFJUQ1N0YXRzUmVwb3J0PiB8IHVuZGVmaW5lZFxuICAgKi9cbiAgYXN5bmMgZ2V0UlRDU3RhdHNSZXBvcnQoKTogUHJvbWlzZTxSVENTdGF0c1JlcG9ydCB8IHVuZGVmaW5lZD4ge1xuICAgIGlmICghdGhpcy5yZWNlaXZlcj8uZ2V0U3RhdHMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc3RhdHNSZXBvcnQgPSBhd2FpdCB0aGlzLnJlY2VpdmVyLmdldFN0YXRzKCk7XG4gICAgcmV0dXJuIHN0YXRzUmVwb3J0O1xuICB9XG5cbiAgLyogQGludGVybmFsICovXG4gIHN0YXJ0TW9uaXRvcigpIHtcbiAgICBpZiAoIXRoaXMubW9uaXRvckludGVydmFsKSB7XG4gICAgICB0aGlzLm1vbml0b3JJbnRlcnZhbCA9IHNldEludGVydmFsKCgpID0+IHRoaXMubW9uaXRvclJlY2VpdmVyKCksIG1vbml0b3JGcmVxdWVuY3kpO1xuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCBhYnN0cmFjdCBtb25pdG9yUmVjZWl2ZXIoKTogdm9pZDtcbn1cbiIsImltcG9ydCB7IFRyYWNrRXZlbnQgfSBmcm9tICcuLi9ldmVudHMnO1xuaW1wb3J0IHsgY29tcHV0ZUJpdHJhdGUgfSBmcm9tICcuLi9zdGF0cyc7XG5pbXBvcnQgdHlwZSB7IEF1ZGlvUmVjZWl2ZXJTdGF0cyB9IGZyb20gJy4uL3N0YXRzJztcbmltcG9ydCB0eXBlIHsgTG9nZ2VyT3B0aW9ucyB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7IGlzUmVhY3ROYXRpdmUsIHN1cHBvcnRzU2V0U2lua0lkIH0gZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0IFJlbW90ZVRyYWNrIGZyb20gJy4vUmVtb3RlVHJhY2snO1xuaW1wb3J0IHsgVHJhY2sgfSBmcm9tICcuL1RyYWNrJztcbmltcG9ydCB0eXBlIHsgQXVkaW9PdXRwdXRPcHRpb25zIH0gZnJvbSAnLi9vcHRpb25zJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmVtb3RlQXVkaW9UcmFjayBleHRlbmRzIFJlbW90ZVRyYWNrIHtcbiAgcHJpdmF0ZSBwcmV2U3RhdHM/OiBBdWRpb1JlY2VpdmVyU3RhdHM7XG5cbiAgcHJpdmF0ZSBlbGVtZW50Vm9sdW1lOiBudW1iZXIgfCB1bmRlZmluZWQ7XG5cbiAgcHJpdmF0ZSBhdWRpb0NvbnRleHQ/OiBBdWRpb0NvbnRleHQ7XG5cbiAgcHJpdmF0ZSBnYWluTm9kZT86IEdhaW5Ob2RlO1xuXG4gIHByaXZhdGUgc291cmNlTm9kZT86IE1lZGlhU3RyZWFtQXVkaW9Tb3VyY2VOb2RlO1xuXG4gIHByaXZhdGUgd2ViQXVkaW9QbHVnaW5Ob2RlczogQXVkaW9Ob2RlW107XG5cbiAgcHJpdmF0ZSBzaW5rSWQ/OiBzdHJpbmc7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgbWVkaWFUcmFjazogTWVkaWFTdHJlYW1UcmFjayxcbiAgICBzaWQ6IHN0cmluZyxcbiAgICByZWNlaXZlcj86IFJUQ1J0cFJlY2VpdmVyLFxuICAgIGF1ZGlvQ29udGV4dD86IEF1ZGlvQ29udGV4dCxcbiAgICBhdWRpb091dHB1dD86IEF1ZGlvT3V0cHV0T3B0aW9ucyxcbiAgICBsb2dnZXJPcHRpb25zPzogTG9nZ2VyT3B0aW9ucyxcbiAgKSB7XG4gICAgc3VwZXIobWVkaWFUcmFjaywgc2lkLCBUcmFjay5LaW5kLkF1ZGlvLCByZWNlaXZlciwgbG9nZ2VyT3B0aW9ucyk7XG4gICAgdGhpcy5hdWRpb0NvbnRleHQgPSBhdWRpb0NvbnRleHQ7XG4gICAgdGhpcy53ZWJBdWRpb1BsdWdpbk5vZGVzID0gW107XG4gICAgaWYgKGF1ZGlvT3V0cHV0KSB7XG4gICAgICB0aGlzLnNpbmtJZCA9IGF1ZGlvT3V0cHV0LmRldmljZUlkO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBzZXRzIHRoZSB2b2x1bWUgZm9yIGFsbCBhdHRhY2hlZCBhdWRpbyBlbGVtZW50c1xuICAgKi9cbiAgc2V0Vm9sdW1lKHZvbHVtZTogbnVtYmVyKSB7XG4gICAgZm9yIChjb25zdCBlbCBvZiB0aGlzLmF0dGFjaGVkRWxlbWVudHMpIHtcbiAgICAgIGlmICh0aGlzLmF1ZGlvQ29udGV4dCkge1xuICAgICAgICB0aGlzLmdhaW5Ob2RlPy5nYWluLnNldFRhcmdldEF0VGltZSh2b2x1bWUsIDAsIDAuMSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbC52b2x1bWUgPSB2b2x1bWU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpc1JlYWN0TmF0aXZlKCkpIHtcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIHRoaXMuX21lZGlhU3RyZWFtVHJhY2suX3NldFZvbHVtZSh2b2x1bWUpO1xuICAgIH1cbiAgICB0aGlzLmVsZW1lbnRWb2x1bWUgPSB2b2x1bWU7XG4gIH1cblxuICAvKipcbiAgICogZ2V0cyB0aGUgdm9sdW1lIG9mIGF0dGFjaGVkIGF1ZGlvIGVsZW1lbnRzIChsb3VkZXN0KVxuICAgKi9cbiAgZ2V0Vm9sdW1lKCk6IG51bWJlciB7XG4gICAgaWYgKHRoaXMuZWxlbWVudFZvbHVtZSkge1xuICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudFZvbHVtZTtcbiAgICB9XG4gICAgaWYgKGlzUmVhY3ROYXRpdmUoKSkge1xuICAgICAgLy8gUk4gdm9sdW1lIHZhbHVlIGRlZmF1bHRzIHRvIDEuMCBpZiBoYXNuJ3QgYmVlbiBjaGFuZ2VkLlxuICAgICAgcmV0dXJuIDEuMDtcbiAgICB9XG4gICAgbGV0IGhpZ2hlc3RWb2x1bWUgPSAwO1xuICAgIHRoaXMuYXR0YWNoZWRFbGVtZW50cy5mb3JFYWNoKChlbGVtZW50KSA9PiB7XG4gICAgICBpZiAoZWxlbWVudC52b2x1bWUgPiBoaWdoZXN0Vm9sdW1lKSB7XG4gICAgICAgIGhpZ2hlc3RWb2x1bWUgPSBlbGVtZW50LnZvbHVtZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gaGlnaGVzdFZvbHVtZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBjYWxscyBzZXRTaW5rSWQgb24gYWxsIGF0dGFjaGVkIGVsZW1lbnRzLCBpZiBzdXBwb3J0ZWRcbiAgICogQHBhcmFtIGRldmljZUlkIGF1ZGlvIG91dHB1dCBkZXZpY2VcbiAgICovXG4gIGFzeW5jIHNldFNpbmtJZChkZXZpY2VJZDogc3RyaW5nKSB7XG4gICAgdGhpcy5zaW5rSWQgPSBkZXZpY2VJZDtcbiAgICBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgIHRoaXMuYXR0YWNoZWRFbGVtZW50cy5tYXAoKGVsbSkgPT4ge1xuICAgICAgICBpZiAoIXN1cHBvcnRzU2V0U2lua0lkKGVsbSkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLyogQHRzLWlnbm9yZSAqL1xuICAgICAgICByZXR1cm4gZWxtLnNldFNpbmtJZChkZXZpY2VJZCkgYXMgUHJvbWlzZTx2b2lkPjtcbiAgICAgIH0pLFxuICAgICk7XG4gIH1cblxuICBhdHRhY2goKTogSFRNTE1lZGlhRWxlbWVudDtcbiAgYXR0YWNoKGVsZW1lbnQ6IEhUTUxNZWRpYUVsZW1lbnQpOiBIVE1MTWVkaWFFbGVtZW50O1xuICBhdHRhY2goZWxlbWVudD86IEhUTUxNZWRpYUVsZW1lbnQpOiBIVE1MTWVkaWFFbGVtZW50IHtcbiAgICBjb25zdCBuZWVkc05ld1dlYkF1ZGlvQ29ubmVjdGlvbiA9IHRoaXMuYXR0YWNoZWRFbGVtZW50cy5sZW5ndGggPT09IDA7XG4gICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICBlbGVtZW50ID0gc3VwZXIuYXR0YWNoKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN1cGVyLmF0dGFjaChlbGVtZW50KTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5zaW5rSWQgJiYgc3VwcG9ydHNTZXRTaW5rSWQoZWxlbWVudCkpIHtcbiAgICAgIC8qIEB0cy1pZ25vcmUgKi9cbiAgICAgIGVsZW1lbnQuc2V0U2lua0lkKHRoaXMuc2lua0lkKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuYXVkaW9Db250ZXh0ICYmIG5lZWRzTmV3V2ViQXVkaW9Db25uZWN0aW9uKSB7XG4gICAgICB0aGlzLmxvZy5kZWJ1ZygndXNpbmcgYXVkaW8gY29udGV4dCBtYXBwaW5nJywgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgIHRoaXMuY29ubmVjdFdlYkF1ZGlvKHRoaXMuYXVkaW9Db250ZXh0LCBlbGVtZW50KTtcbiAgICAgIGVsZW1lbnQudm9sdW1lID0gMDtcbiAgICAgIGVsZW1lbnQubXV0ZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmVsZW1lbnRWb2x1bWUpIHtcbiAgICAgIC8vIG1ha2Ugc3VyZSB2b2x1bWUgc2V0dGluZyBpcyBiZWluZyBhcHBsaWVkIHRvIHRoZSBuZXdseSBhdHRhY2hlZCBlbGVtZW50XG4gICAgICB0aGlzLnNldFZvbHVtZSh0aGlzLmVsZW1lbnRWb2x1bWUpO1xuICAgIH1cblxuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG5cbiAgLyoqXG4gICAqIERldGFjaGVzIGZyb20gYWxsIGF0dGFjaGVkIGVsZW1lbnRzXG4gICAqL1xuICBkZXRhY2goKTogSFRNTE1lZGlhRWxlbWVudFtdO1xuXG4gIC8qKlxuICAgKiBEZXRhY2ggZnJvbSBhIHNpbmdsZSBlbGVtZW50XG4gICAqIEBwYXJhbSBlbGVtZW50XG4gICAqL1xuICBkZXRhY2goZWxlbWVudDogSFRNTE1lZGlhRWxlbWVudCk6IEhUTUxNZWRpYUVsZW1lbnQ7XG4gIGRldGFjaChlbGVtZW50PzogSFRNTE1lZGlhRWxlbWVudCk6IEhUTUxNZWRpYUVsZW1lbnQgfCBIVE1MTWVkaWFFbGVtZW50W10ge1xuICAgIGxldCBkZXRhY2hlZDogSFRNTE1lZGlhRWxlbWVudCB8IEhUTUxNZWRpYUVsZW1lbnRbXTtcbiAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgIGRldGFjaGVkID0gc3VwZXIuZGV0YWNoKCk7XG4gICAgICB0aGlzLmRpc2Nvbm5lY3RXZWJBdWRpbygpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZXRhY2hlZCA9IHN1cGVyLmRldGFjaChlbGVtZW50KTtcbiAgICAgIC8vIGlmIHRoZXJlIGFyZSBzdGlsbCBhbnkgYXR0YWNoZWQgZWxlbWVudHMgYWZ0ZXIgZGV0YWNoaW5nLCBjb25uZWN0IHdlYmF1ZGlvIHRvIHRoZSBmaXJzdCBlbGVtZW50IHRoYXQncyBsZWZ0XG4gICAgICAvLyBkaXNjb25uZWN0IHdlYmF1ZGlvIG90aGVyd2lzZVxuICAgICAgaWYgKHRoaXMuYXVkaW9Db250ZXh0KSB7XG4gICAgICAgIGlmICh0aGlzLmF0dGFjaGVkRWxlbWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHRoaXMuY29ubmVjdFdlYkF1ZGlvKHRoaXMuYXVkaW9Db250ZXh0LCB0aGlzLmF0dGFjaGVkRWxlbWVudHNbMF0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuZGlzY29ubmVjdFdlYkF1ZGlvKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRldGFjaGVkO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBAZXhwZXJpbWVudGFsXG4gICAqL1xuICBzZXRBdWRpb0NvbnRleHQoYXVkaW9Db250ZXh0OiBBdWRpb0NvbnRleHQgfCB1bmRlZmluZWQpIHtcbiAgICB0aGlzLmF1ZGlvQ29udGV4dCA9IGF1ZGlvQ29udGV4dDtcbiAgICBpZiAoYXVkaW9Db250ZXh0ICYmIHRoaXMuYXR0YWNoZWRFbGVtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICB0aGlzLmNvbm5lY3RXZWJBdWRpbyhhdWRpb0NvbnRleHQsIHRoaXMuYXR0YWNoZWRFbGVtZW50c1swXSk7XG4gICAgfSBlbHNlIGlmICghYXVkaW9Db250ZXh0KSB7XG4gICAgICB0aGlzLmRpc2Nvbm5lY3RXZWJBdWRpbygpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogQGV4cGVyaW1lbnRhbFxuICAgKiBAcGFyYW0ge0F1ZGlvTm9kZVtdfSBub2RlcyAtIEFuIGFycmF5IG9mIFdlYkF1ZGlvIG5vZGVzLiBUaGVzZSBub2RlcyBzaG91bGQgbm90IGJlIGNvbm5lY3RlZCB0byBlYWNoIG90aGVyIHdoZW4gcGFzc2VkLCBhcyB0aGUgc2RrIHdpbGwgdGFrZSBjYXJlIG9mIGNvbm5lY3RpbmcgdGhlbSBpbiB0aGUgb3JkZXIgb2YgdGhlIGFycmF5LlxuICAgKi9cbiAgc2V0V2ViQXVkaW9QbHVnaW5zKG5vZGVzOiBBdWRpb05vZGVbXSkge1xuICAgIHRoaXMud2ViQXVkaW9QbHVnaW5Ob2RlcyA9IG5vZGVzO1xuICAgIGlmICh0aGlzLmF0dGFjaGVkRWxlbWVudHMubGVuZ3RoID4gMCAmJiB0aGlzLmF1ZGlvQ29udGV4dCkge1xuICAgICAgdGhpcy5jb25uZWN0V2ViQXVkaW8odGhpcy5hdWRpb0NvbnRleHQsIHRoaXMuYXR0YWNoZWRFbGVtZW50c1swXSk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBjb25uZWN0V2ViQXVkaW8oY29udGV4dDogQXVkaW9Db250ZXh0LCBlbGVtZW50OiBIVE1MTWVkaWFFbGVtZW50KSB7XG4gICAgdGhpcy5kaXNjb25uZWN0V2ViQXVkaW8oKTtcbiAgICAvLyBAdHMtaWdub3JlIGF0dGFjaGVkIGVsZW1lbnRzIGFsd2F5cyBoYXZlIGEgc3JjT2JqZWN0IHNldFxuICAgIHRoaXMuc291cmNlTm9kZSA9IGNvbnRleHQuY3JlYXRlTWVkaWFTdHJlYW1Tb3VyY2UoZWxlbWVudC5zcmNPYmplY3QpO1xuICAgIGxldCBsYXN0Tm9kZTogQXVkaW9Ob2RlID0gdGhpcy5zb3VyY2VOb2RlO1xuICAgIHRoaXMud2ViQXVkaW9QbHVnaW5Ob2Rlcy5mb3JFYWNoKChub2RlKSA9PiB7XG4gICAgICBsYXN0Tm9kZS5jb25uZWN0KG5vZGUpO1xuICAgICAgbGFzdE5vZGUgPSBub2RlO1xuICAgIH0pO1xuICAgIHRoaXMuZ2Fpbk5vZGUgPSBjb250ZXh0LmNyZWF0ZUdhaW4oKTtcbiAgICBsYXN0Tm9kZS5jb25uZWN0KHRoaXMuZ2Fpbk5vZGUpO1xuICAgIHRoaXMuZ2Fpbk5vZGUuY29ubmVjdChjb250ZXh0LmRlc3RpbmF0aW9uKTtcblxuICAgIGlmICh0aGlzLmVsZW1lbnRWb2x1bWUpIHtcbiAgICAgIHRoaXMuZ2Fpbk5vZGUuZ2Fpbi5zZXRUYXJnZXRBdFRpbWUodGhpcy5lbGVtZW50Vm9sdW1lLCAwLCAwLjEpO1xuICAgIH1cblxuICAgIC8vIHRyeSB0byByZXN1bWUgdGhlIGNvbnRleHQgaWYgaXQgaXNuJ3QgcnVubmluZyBhbHJlYWR5XG4gICAgaWYgKGNvbnRleHQuc3RhdGUgIT09ICdydW5uaW5nJykge1xuICAgICAgY29udGV4dFxuICAgICAgICAucmVzdW1lKClcbiAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgIGlmIChjb250ZXh0LnN0YXRlICE9PSAncnVubmluZycpIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdChcbiAgICAgICAgICAgICAgVHJhY2tFdmVudC5BdWRpb1BsYXliYWNrRmFpbGVkLFxuICAgICAgICAgICAgICBuZXcgRXJyb3IoXCJBdWRpbyBDb250ZXh0IGNvdWxkbid0IGJlIHN0YXJ0ZWQgYXV0b21hdGljYWxseVwiKSxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICAuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICB0aGlzLmVtaXQoVHJhY2tFdmVudC5BdWRpb1BsYXliYWNrRmFpbGVkLCBlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBkaXNjb25uZWN0V2ViQXVkaW8oKSB7XG4gICAgdGhpcy5nYWluTm9kZT8uZGlzY29ubmVjdCgpO1xuICAgIHRoaXMuc291cmNlTm9kZT8uZGlzY29ubmVjdCgpO1xuICAgIHRoaXMuZ2Fpbk5vZGUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5zb3VyY2VOb2RlID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgcHJvdGVjdGVkIG1vbml0b3JSZWNlaXZlciA9IGFzeW5jICgpID0+IHtcbiAgICBpZiAoIXRoaXMucmVjZWl2ZXIpIHtcbiAgICAgIHRoaXMuX2N1cnJlbnRCaXRyYXRlID0gMDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc3RhdHMgPSBhd2FpdCB0aGlzLmdldFJlY2VpdmVyU3RhdHMoKTtcblxuICAgIGlmIChzdGF0cyAmJiB0aGlzLnByZXZTdGF0cyAmJiB0aGlzLnJlY2VpdmVyKSB7XG4gICAgICB0aGlzLl9jdXJyZW50Qml0cmF0ZSA9IGNvbXB1dGVCaXRyYXRlKHN0YXRzLCB0aGlzLnByZXZTdGF0cyk7XG4gICAgfVxuXG4gICAgdGhpcy5wcmV2U3RhdHMgPSBzdGF0cztcbiAgfTtcblxuICBwcm90ZWN0ZWQgYXN5bmMgZ2V0UmVjZWl2ZXJTdGF0cygpOiBQcm9taXNlPEF1ZGlvUmVjZWl2ZXJTdGF0cyB8IHVuZGVmaW5lZD4ge1xuICAgIGlmICghdGhpcy5yZWNlaXZlciB8fCAhdGhpcy5yZWNlaXZlci5nZXRTdGF0cykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHN0YXRzID0gYXdhaXQgdGhpcy5yZWNlaXZlci5nZXRTdGF0cygpO1xuICAgIGxldCByZWNlaXZlclN0YXRzOiBBdWRpb1JlY2VpdmVyU3RhdHMgfCB1bmRlZmluZWQ7XG4gICAgc3RhdHMuZm9yRWFjaCgodikgPT4ge1xuICAgICAgaWYgKHYudHlwZSA9PT0gJ2luYm91bmQtcnRwJykge1xuICAgICAgICByZWNlaXZlclN0YXRzID0ge1xuICAgICAgICAgIHR5cGU6ICdhdWRpbycsXG4gICAgICAgICAgdGltZXN0YW1wOiB2LnRpbWVzdGFtcCxcbiAgICAgICAgICBqaXR0ZXI6IHYuaml0dGVyLFxuICAgICAgICAgIGJ5dGVzUmVjZWl2ZWQ6IHYuYnl0ZXNSZWNlaXZlZCxcbiAgICAgICAgICBjb25jZWFsZWRTYW1wbGVzOiB2LmNvbmNlYWxlZFNhbXBsZXMsXG4gICAgICAgICAgY29uY2VhbG1lbnRFdmVudHM6IHYuY29uY2VhbG1lbnRFdmVudHMsXG4gICAgICAgICAgc2lsZW50Q29uY2VhbGVkU2FtcGxlczogdi5zaWxlbnRDb25jZWFsZWRTYW1wbGVzLFxuICAgICAgICAgIHNpbGVudENvbmNlYWxtZW50RXZlbnRzOiB2LnNpbGVudENvbmNlYWxtZW50RXZlbnRzLFxuICAgICAgICAgIHRvdGFsQXVkaW9FbmVyZ3k6IHYudG90YWxBdWRpb0VuZXJneSxcbiAgICAgICAgICB0b3RhbFNhbXBsZXNEdXJhdGlvbjogdi50b3RhbFNhbXBsZXNEdXJhdGlvbixcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmVjZWl2ZXJTdGF0cztcbiAgfVxufVxuIiwiaW1wb3J0IHsgZGVib3VuY2UgfSBmcm9tICd0cy1kZWJvdW5jZSc7XG5pbXBvcnQgeyBUcmFja0V2ZW50IH0gZnJvbSAnLi4vZXZlbnRzJztcbmltcG9ydCB0eXBlIHsgVmlkZW9SZWNlaXZlclN0YXRzIH0gZnJvbSAnLi4vc3RhdHMnO1xuaW1wb3J0IHsgY29tcHV0ZUJpdHJhdGUgfSBmcm9tICcuLi9zdGF0cyc7XG5pbXBvcnQgQ3JpdGljYWxUaW1lcnMgZnJvbSAnLi4vdGltZXJzJztcbmltcG9ydCB0eXBlIHsgTG9nZ2VyT3B0aW9ucyB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB0eXBlIHsgT2JzZXJ2YWJsZU1lZGlhRWxlbWVudCB9IGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCB7IGdldERldmljZVBpeGVsUmF0aW8sIGdldEludGVyc2VjdGlvbk9ic2VydmVyLCBnZXRSZXNpemVPYnNlcnZlciwgaXNXZWIgfSBmcm9tICcuLi91dGlscyc7XG5pbXBvcnQgUmVtb3RlVHJhY2sgZnJvbSAnLi9SZW1vdGVUcmFjayc7XG5pbXBvcnQgeyBUcmFjaywgYXR0YWNoVG9FbGVtZW50LCBkZXRhY2hUcmFjayB9IGZyb20gJy4vVHJhY2snO1xuaW1wb3J0IHR5cGUgeyBBZGFwdGl2ZVN0cmVhbVNldHRpbmdzIH0gZnJvbSAnLi90eXBlcyc7XG5cbmNvbnN0IFJFQUNUSU9OX0RFTEFZID0gMTAwO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZW1vdGVWaWRlb1RyYWNrIGV4dGVuZHMgUmVtb3RlVHJhY2sge1xuICBwcml2YXRlIHByZXZTdGF0cz86IFZpZGVvUmVjZWl2ZXJTdGF0cztcblxuICBwcml2YXRlIGVsZW1lbnRJbmZvczogRWxlbWVudEluZm9bXSA9IFtdO1xuXG4gIHByaXZhdGUgYWRhcHRpdmVTdHJlYW1TZXR0aW5ncz86IEFkYXB0aXZlU3RyZWFtU2V0dGluZ3M7XG5cbiAgcHJpdmF0ZSBsYXN0VmlzaWJsZT86IGJvb2xlYW47XG5cbiAgcHJpdmF0ZSBsYXN0RGltZW5zaW9ucz86IFRyYWNrLkRpbWVuc2lvbnM7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgbWVkaWFUcmFjazogTWVkaWFTdHJlYW1UcmFjayxcbiAgICBzaWQ6IHN0cmluZyxcbiAgICByZWNlaXZlcj86IFJUQ1J0cFJlY2VpdmVyLFxuICAgIGFkYXB0aXZlU3RyZWFtU2V0dGluZ3M/OiBBZGFwdGl2ZVN0cmVhbVNldHRpbmdzLFxuICAgIGxvZ2dlck9wdGlvbnM/OiBMb2dnZXJPcHRpb25zLFxuICApIHtcbiAgICBzdXBlcihtZWRpYVRyYWNrLCBzaWQsIFRyYWNrLktpbmQuVmlkZW8sIHJlY2VpdmVyLCBsb2dnZXJPcHRpb25zKTtcbiAgICB0aGlzLmFkYXB0aXZlU3RyZWFtU2V0dGluZ3MgPSBhZGFwdGl2ZVN0cmVhbVNldHRpbmdzO1xuICB9XG5cbiAgZ2V0IGlzQWRhcHRpdmVTdHJlYW0oKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuYWRhcHRpdmVTdHJlYW1TZXR0aW5ncyAhPT0gdW5kZWZpbmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIE5vdGU6IFdoZW4gdXNpbmcgYWRhcHRpdmVTdHJlYW0sIHlvdSBuZWVkIHRvIHVzZSByZW1vdGVWaWRlb1RyYWNrLmF0dGFjaCgpIHRvIGFkZCB0aGUgdHJhY2sgdG8gYSBIVE1MVmlkZW9FbGVtZW50LCBvdGhlcndpc2UgeW91ciB2aWRlbyB0cmFja3MgbWlnaHQgbmV2ZXIgc3RhcnRcbiAgICovXG4gIGdldCBtZWRpYVN0cmVhbVRyYWNrKCkge1xuICAgIHJldHVybiB0aGlzLl9tZWRpYVN0cmVhbVRyYWNrO1xuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBzZXRNdXRlZChtdXRlZDogYm9vbGVhbikge1xuICAgIHN1cGVyLnNldE11dGVkKG11dGVkKTtcblxuICAgIHRoaXMuYXR0YWNoZWRFbGVtZW50cy5mb3JFYWNoKChlbGVtZW50KSA9PiB7XG4gICAgICAvLyBkZXRhY2ggb3IgYXR0YWNoXG4gICAgICBpZiAobXV0ZWQpIHtcbiAgICAgICAgZGV0YWNoVHJhY2sodGhpcy5fbWVkaWFTdHJlYW1UcmFjaywgZWxlbWVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhdHRhY2hUb0VsZW1lbnQodGhpcy5fbWVkaWFTdHJlYW1UcmFjaywgZWxlbWVudCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBhdHRhY2goKTogSFRNTE1lZGlhRWxlbWVudDtcbiAgYXR0YWNoKGVsZW1lbnQ6IEhUTUxNZWRpYUVsZW1lbnQpOiBIVE1MTWVkaWFFbGVtZW50O1xuICBhdHRhY2goZWxlbWVudD86IEhUTUxNZWRpYUVsZW1lbnQpOiBIVE1MTWVkaWFFbGVtZW50IHtcbiAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgIGVsZW1lbnQgPSBzdXBlci5hdHRhY2goKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3VwZXIuYXR0YWNoKGVsZW1lbnQpO1xuICAgIH1cblxuICAgIC8vIEl0J3MgcG9zc2libGUgYXR0YWNoIGlzIGNhbGxlZCBtdWx0aXBsZSB0aW1lcyBvbiBhbiBlbGVtZW50LiBXaGVuIHRoYXQnc1xuICAgIC8vIHRoZSBjYXNlLCB3ZSdkIHdhbnQgdG8gYXZvaWQgYWRkaW5nIGR1cGxpY2F0ZSBlbGVtZW50SW5mb3NcbiAgICBpZiAoXG4gICAgICB0aGlzLmFkYXB0aXZlU3RyZWFtU2V0dGluZ3MgJiZcbiAgICAgIHRoaXMuZWxlbWVudEluZm9zLmZpbmQoKGluZm8pID0+IGluZm8uZWxlbWVudCA9PT0gZWxlbWVudCkgPT09IHVuZGVmaW5lZFxuICAgICkge1xuICAgICAgY29uc3QgZWxlbWVudEluZm8gPSBuZXcgSFRNTEVsZW1lbnRJbmZvKGVsZW1lbnQpO1xuICAgICAgdGhpcy5vYnNlcnZlRWxlbWVudEluZm8oZWxlbWVudEluZm8pO1xuICAgIH1cbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuXG4gIC8qKlxuICAgKiBPYnNlcnZlIGFuIEVsZW1lbnRJbmZvIGZvciBjaGFuZ2VzIHdoZW4gYWRhcHRpdmUgc3RyZWFtaW5nLlxuICAgKiBAcGFyYW0gZWxlbWVudEluZm9cbiAgICogQGludGVybmFsXG4gICAqL1xuICBvYnNlcnZlRWxlbWVudEluZm8oZWxlbWVudEluZm86IEVsZW1lbnRJbmZvKSB7XG4gICAgaWYgKFxuICAgICAgdGhpcy5hZGFwdGl2ZVN0cmVhbVNldHRpbmdzICYmXG4gICAgICB0aGlzLmVsZW1lbnRJbmZvcy5maW5kKChpbmZvKSA9PiBpbmZvID09PSBlbGVtZW50SW5mbykgPT09IHVuZGVmaW5lZFxuICAgICkge1xuICAgICAgZWxlbWVudEluZm8uaGFuZGxlUmVzaXplID0gKCkgPT4ge1xuICAgICAgICB0aGlzLmRlYm91bmNlZEhhbmRsZVJlc2l6ZSgpO1xuICAgICAgfTtcbiAgICAgIGVsZW1lbnRJbmZvLmhhbmRsZVZpc2liaWxpdHlDaGFuZ2VkID0gKCkgPT4ge1xuICAgICAgICB0aGlzLnVwZGF0ZVZpc2liaWxpdHkoKTtcbiAgICAgIH07XG4gICAgICB0aGlzLmVsZW1lbnRJbmZvcy5wdXNoKGVsZW1lbnRJbmZvKTtcbiAgICAgIGVsZW1lbnRJbmZvLm9ic2VydmUoKTtcbiAgICAgIC8vIHRyaWdnZXIgdGhlIGZpcnN0IHJlc2l6ZSB1cGRhdGUgY3ljbGVcbiAgICAgIC8vIGlmIHRoZSB0YWIgaXMgYmFja2dyb3VuZGVkLCB0aGUgaW5pdGlhbCByZXNpemUgZXZlbnQgZG9lcyBub3QgZmlyZSB1bnRpbFxuICAgICAgLy8gdGhlIHRhYiBjb21lcyBpbnRvIGZvY3VzIGZvciB0aGUgZmlyc3QgdGltZS5cbiAgICAgIHRoaXMuZGVib3VuY2VkSGFuZGxlUmVzaXplKCk7XG4gICAgICB0aGlzLnVwZGF0ZVZpc2liaWxpdHkoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5sb2cud2FybigndmlzaWJpbGl0eSByZXNpemUgb2JzZXJ2ZXIgbm90IHRyaWdnZXJlZCcsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFN0b3Agb2JzZXJ2aW5nIGFuIEVsZW1lbnRJbmZvIGZvciBjaGFuZ2VzLlxuICAgKiBAcGFyYW0gZWxlbWVudEluZm9cbiAgICogQGludGVybmFsXG4gICAqL1xuICBzdG9wT2JzZXJ2aW5nRWxlbWVudEluZm8oZWxlbWVudEluZm86IEVsZW1lbnRJbmZvKSB7XG4gICAgaWYgKCF0aGlzLmlzQWRhcHRpdmVTdHJlYW0pIHtcbiAgICAgIHRoaXMubG9nLndhcm4oJ3N0b3BPYnNlcnZpbmdFbGVtZW50SW5mbyBpZ25vcmVkJywgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc3RvcEVsZW1lbnRJbmZvcyA9IHRoaXMuZWxlbWVudEluZm9zLmZpbHRlcigoaW5mbykgPT4gaW5mbyA9PT0gZWxlbWVudEluZm8pO1xuICAgIGZvciAoY29uc3QgaW5mbyBvZiBzdG9wRWxlbWVudEluZm9zKSB7XG4gICAgICBpbmZvLnN0b3BPYnNlcnZpbmcoKTtcbiAgICB9XG4gICAgdGhpcy5lbGVtZW50SW5mb3MgPSB0aGlzLmVsZW1lbnRJbmZvcy5maWx0ZXIoKGluZm8pID0+IGluZm8gIT09IGVsZW1lbnRJbmZvKTtcbiAgICB0aGlzLnVwZGF0ZVZpc2liaWxpdHkoKTtcbiAgICB0aGlzLmRlYm91bmNlZEhhbmRsZVJlc2l6ZSgpO1xuICB9XG5cbiAgZGV0YWNoKCk6IEhUTUxNZWRpYUVsZW1lbnRbXTtcbiAgZGV0YWNoKGVsZW1lbnQ6IEhUTUxNZWRpYUVsZW1lbnQpOiBIVE1MTWVkaWFFbGVtZW50O1xuICBkZXRhY2goZWxlbWVudD86IEhUTUxNZWRpYUVsZW1lbnQpOiBIVE1MTWVkaWFFbGVtZW50IHwgSFRNTE1lZGlhRWxlbWVudFtdIHtcbiAgICBsZXQgZGV0YWNoZWRFbGVtZW50czogSFRNTE1lZGlhRWxlbWVudFtdID0gW107XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHRoaXMuc3RvcE9ic2VydmluZ0VsZW1lbnQoZWxlbWVudCk7XG4gICAgICByZXR1cm4gc3VwZXIuZGV0YWNoKGVsZW1lbnQpO1xuICAgIH1cbiAgICBkZXRhY2hlZEVsZW1lbnRzID0gc3VwZXIuZGV0YWNoKCk7XG5cbiAgICBmb3IgKGNvbnN0IGUgb2YgZGV0YWNoZWRFbGVtZW50cykge1xuICAgICAgdGhpcy5zdG9wT2JzZXJ2aW5nRWxlbWVudChlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGV0YWNoZWRFbGVtZW50cztcbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgZ2V0RGVjb2RlckltcGxlbWVudGF0aW9uKCk6IHN0cmluZyB8IHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIHRoaXMucHJldlN0YXRzPy5kZWNvZGVySW1wbGVtZW50YXRpb247XG4gIH1cblxuICBwcm90ZWN0ZWQgbW9uaXRvclJlY2VpdmVyID0gYXN5bmMgKCkgPT4ge1xuICAgIGlmICghdGhpcy5yZWNlaXZlcikge1xuICAgICAgdGhpcy5fY3VycmVudEJpdHJhdGUgPSAwO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzdGF0cyA9IGF3YWl0IHRoaXMuZ2V0UmVjZWl2ZXJTdGF0cygpO1xuXG4gICAgaWYgKHN0YXRzICYmIHRoaXMucHJldlN0YXRzICYmIHRoaXMucmVjZWl2ZXIpIHtcbiAgICAgIHRoaXMuX2N1cnJlbnRCaXRyYXRlID0gY29tcHV0ZUJpdHJhdGUoc3RhdHMsIHRoaXMucHJldlN0YXRzKTtcbiAgICB9XG5cbiAgICB0aGlzLnByZXZTdGF0cyA9IHN0YXRzO1xuICB9O1xuXG4gIHByaXZhdGUgYXN5bmMgZ2V0UmVjZWl2ZXJTdGF0cygpOiBQcm9taXNlPFZpZGVvUmVjZWl2ZXJTdGF0cyB8IHVuZGVmaW5lZD4ge1xuICAgIGlmICghdGhpcy5yZWNlaXZlciB8fCAhdGhpcy5yZWNlaXZlci5nZXRTdGF0cykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHN0YXRzID0gYXdhaXQgdGhpcy5yZWNlaXZlci5nZXRTdGF0cygpO1xuICAgIGxldCByZWNlaXZlclN0YXRzOiBWaWRlb1JlY2VpdmVyU3RhdHMgfCB1bmRlZmluZWQ7XG4gICAgbGV0IGNvZGVjSUQgPSAnJztcbiAgICBsZXQgY29kZWNzID0gbmV3IE1hcDxzdHJpbmcsIGFueT4oKTtcbiAgICBzdGF0cy5mb3JFYWNoKCh2KSA9PiB7XG4gICAgICBpZiAodi50eXBlID09PSAnaW5ib3VuZC1ydHAnKSB7XG4gICAgICAgIGNvZGVjSUQgPSB2LmNvZGVjSWQ7XG4gICAgICAgIHJlY2VpdmVyU3RhdHMgPSB7XG4gICAgICAgICAgdHlwZTogJ3ZpZGVvJyxcbiAgICAgICAgICBmcmFtZXNEZWNvZGVkOiB2LmZyYW1lc0RlY29kZWQsXG4gICAgICAgICAgZnJhbWVzRHJvcHBlZDogdi5mcmFtZXNEcm9wcGVkLFxuICAgICAgICAgIGZyYW1lc1JlY2VpdmVkOiB2LmZyYW1lc1JlY2VpdmVkLFxuICAgICAgICAgIHBhY2tldHNSZWNlaXZlZDogdi5wYWNrZXRzUmVjZWl2ZWQsXG4gICAgICAgICAgcGFja2V0c0xvc3Q6IHYucGFja2V0c0xvc3QsXG4gICAgICAgICAgZnJhbWVXaWR0aDogdi5mcmFtZVdpZHRoLFxuICAgICAgICAgIGZyYW1lSGVpZ2h0OiB2LmZyYW1lSGVpZ2h0LFxuICAgICAgICAgIHBsaUNvdW50OiB2LnBsaUNvdW50LFxuICAgICAgICAgIGZpckNvdW50OiB2LmZpckNvdW50LFxuICAgICAgICAgIG5hY2tDb3VudDogdi5uYWNrQ291bnQsXG4gICAgICAgICAgaml0dGVyOiB2LmppdHRlcixcbiAgICAgICAgICB0aW1lc3RhbXA6IHYudGltZXN0YW1wLFxuICAgICAgICAgIGJ5dGVzUmVjZWl2ZWQ6IHYuYnl0ZXNSZWNlaXZlZCxcbiAgICAgICAgICBkZWNvZGVySW1wbGVtZW50YXRpb246IHYuZGVjb2RlckltcGxlbWVudGF0aW9uLFxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmICh2LnR5cGUgPT09ICdjb2RlYycpIHtcbiAgICAgICAgY29kZWNzLnNldCh2LmlkLCB2KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAocmVjZWl2ZXJTdGF0cyAmJiBjb2RlY0lEICE9PSAnJyAmJiBjb2RlY3MuZ2V0KGNvZGVjSUQpKSB7XG4gICAgICByZWNlaXZlclN0YXRzLm1pbWVUeXBlID0gY29kZWNzLmdldChjb2RlY0lEKS5taW1lVHlwZTtcbiAgICB9XG4gICAgcmV0dXJuIHJlY2VpdmVyU3RhdHM7XG4gIH1cblxuICBwcml2YXRlIHN0b3BPYnNlcnZpbmdFbGVtZW50KGVsZW1lbnQ6IEhUTUxNZWRpYUVsZW1lbnQpIHtcbiAgICBjb25zdCBzdG9wRWxlbWVudEluZm9zID0gdGhpcy5lbGVtZW50SW5mb3MuZmlsdGVyKChpbmZvKSA9PiBpbmZvLmVsZW1lbnQgPT09IGVsZW1lbnQpO1xuICAgIGZvciAoY29uc3QgaW5mbyBvZiBzdG9wRWxlbWVudEluZm9zKSB7XG4gICAgICB0aGlzLnN0b3BPYnNlcnZpbmdFbGVtZW50SW5mbyhpbmZvKTtcbiAgICB9XG4gIH1cblxuICBwcm90ZWN0ZWQgYXN5bmMgaGFuZGxlQXBwVmlzaWJpbGl0eUNoYW5nZWQoKSB7XG4gICAgYXdhaXQgc3VwZXIuaGFuZGxlQXBwVmlzaWJpbGl0eUNoYW5nZWQoKTtcbiAgICBpZiAoIXRoaXMuaXNBZGFwdGl2ZVN0cmVhbSkgcmV0dXJuO1xuICAgIHRoaXMudXBkYXRlVmlzaWJpbGl0eSgpO1xuICB9XG5cbiAgcHJpdmF0ZSByZWFkb25seSBkZWJvdW5jZWRIYW5kbGVSZXNpemUgPSBkZWJvdW5jZSgoKSA9PiB7XG4gICAgdGhpcy51cGRhdGVEaW1lbnNpb25zKCk7XG4gIH0sIFJFQUNUSU9OX0RFTEFZKTtcblxuICBwcml2YXRlIHVwZGF0ZVZpc2liaWxpdHkoKSB7XG4gICAgY29uc3QgbGFzdFZpc2liaWxpdHlDaGFuZ2UgPSB0aGlzLmVsZW1lbnRJbmZvcy5yZWR1Y2UoXG4gICAgICAocHJldiwgaW5mbykgPT4gTWF0aC5tYXgocHJldiwgaW5mby52aXNpYmlsaXR5Q2hhbmdlZEF0IHx8IDApLFxuICAgICAgMCxcbiAgICApO1xuXG4gICAgY29uc3QgYmFja2dyb3VuZFBhdXNlID1cbiAgICAgIHRoaXMuYWRhcHRpdmVTdHJlYW1TZXR0aW5ncz8ucGF1c2VWaWRlb0luQmFja2dyb3VuZCA/PyB0cnVlIC8vIGRlZmF1bHQgdG8gdHJ1ZVxuICAgICAgICA/IHRoaXMuaXNJbkJhY2tncm91bmRcbiAgICAgICAgOiBmYWxzZTtcbiAgICBjb25zdCBpc1BpUE1vZGUgPSB0aGlzLmVsZW1lbnRJbmZvcy5zb21lKChpbmZvKSA9PiBpbmZvLnBpY3R1cmVJblBpY3R1cmUpO1xuICAgIGNvbnN0IGlzVmlzaWJsZSA9XG4gICAgICAodGhpcy5lbGVtZW50SW5mb3Muc29tZSgoaW5mbykgPT4gaW5mby52aXNpYmxlKSAmJiAhYmFja2dyb3VuZFBhdXNlKSB8fCBpc1BpUE1vZGU7XG5cbiAgICBpZiAodGhpcy5sYXN0VmlzaWJsZSA9PT0gaXNWaXNpYmxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCFpc1Zpc2libGUgJiYgRGF0ZS5ub3coKSAtIGxhc3RWaXNpYmlsaXR5Q2hhbmdlIDwgUkVBQ1RJT05fREVMQVkpIHtcbiAgICAgIC8vIGRlbGF5IGhpZGRlbiBldmVudHNcbiAgICAgIENyaXRpY2FsVGltZXJzLnNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0aGlzLnVwZGF0ZVZpc2liaWxpdHkoKTtcbiAgICAgIH0sIFJFQUNUSU9OX0RFTEFZKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmxhc3RWaXNpYmxlID0gaXNWaXNpYmxlO1xuICAgIHRoaXMuZW1pdChUcmFja0V2ZW50LlZpc2liaWxpdHlDaGFuZ2VkLCBpc1Zpc2libGUsIHRoaXMpO1xuICB9XG5cbiAgcHJpdmF0ZSB1cGRhdGVEaW1lbnNpb25zKCkge1xuICAgIGxldCBtYXhXaWR0aCA9IDA7XG4gICAgbGV0IG1heEhlaWdodCA9IDA7XG4gICAgY29uc3QgcGl4ZWxEZW5zaXR5ID0gdGhpcy5nZXRQaXhlbERlbnNpdHkoKTtcbiAgICBmb3IgKGNvbnN0IGluZm8gb2YgdGhpcy5lbGVtZW50SW5mb3MpIHtcbiAgICAgIGNvbnN0IGN1cnJlbnRFbGVtZW50V2lkdGggPSBpbmZvLndpZHRoKCkgKiBwaXhlbERlbnNpdHk7XG4gICAgICBjb25zdCBjdXJyZW50RWxlbWVudEhlaWdodCA9IGluZm8uaGVpZ2h0KCkgKiBwaXhlbERlbnNpdHk7XG4gICAgICBpZiAoY3VycmVudEVsZW1lbnRXaWR0aCArIGN1cnJlbnRFbGVtZW50SGVpZ2h0ID4gbWF4V2lkdGggKyBtYXhIZWlnaHQpIHtcbiAgICAgICAgbWF4V2lkdGggPSBjdXJyZW50RWxlbWVudFdpZHRoO1xuICAgICAgICBtYXhIZWlnaHQgPSBjdXJyZW50RWxlbWVudEhlaWdodDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5sYXN0RGltZW5zaW9ucz8ud2lkdGggPT09IG1heFdpZHRoICYmIHRoaXMubGFzdERpbWVuc2lvbnM/LmhlaWdodCA9PT0gbWF4SGVpZ2h0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5sYXN0RGltZW5zaW9ucyA9IHtcbiAgICAgIHdpZHRoOiBtYXhXaWR0aCxcbiAgICAgIGhlaWdodDogbWF4SGVpZ2h0LFxuICAgIH07XG5cbiAgICB0aGlzLmVtaXQoVHJhY2tFdmVudC5WaWRlb0RpbWVuc2lvbnNDaGFuZ2VkLCB0aGlzLmxhc3REaW1lbnNpb25zLCB0aGlzKTtcbiAgfVxuXG4gIHByaXZhdGUgZ2V0UGl4ZWxEZW5zaXR5KCk6IG51bWJlciB7XG4gICAgY29uc3QgcGl4ZWxEZW5zaXR5ID0gdGhpcy5hZGFwdGl2ZVN0cmVhbVNldHRpbmdzPy5waXhlbERlbnNpdHk7XG4gICAgaWYgKHBpeGVsRGVuc2l0eSA9PT0gJ3NjcmVlbicpIHtcbiAgICAgIHJldHVybiBnZXREZXZpY2VQaXhlbFJhdGlvKCk7XG4gICAgfSBlbHNlIGlmICghcGl4ZWxEZW5zaXR5KSB7XG4gICAgICAvLyB3aGVuIHVuc2V0LCB3ZSdsbCBwaWNrIGEgc2FuZSBkZWZhdWx0IGhlcmUuXG4gICAgICAvLyBmb3IgaGlnaGVyIHBpeGVsIGRlbnNpdHkgZGV2aWNlcyAobW9iaWxlIHBob25lcywgZXRjKSwgd2UnbGwgdXNlIDJcbiAgICAgIC8vIG90aGVyd2lzZSBpdCBkZWZhdWx0cyB0byAxXG4gICAgICBjb25zdCBkZXZpY2VQaXhlbFJhdGlvID0gZ2V0RGV2aWNlUGl4ZWxSYXRpbygpO1xuICAgICAgaWYgKGRldmljZVBpeGVsUmF0aW8gPiAyKSB7XG4gICAgICAgIHJldHVybiAyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwaXhlbERlbnNpdHk7XG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBFbGVtZW50SW5mbyB7XG4gIGVsZW1lbnQ6IG9iamVjdDtcbiAgd2lkdGgoKTogbnVtYmVyO1xuICBoZWlnaHQoKTogbnVtYmVyO1xuICB2aXNpYmxlOiBib29sZWFuO1xuICBwaWN0dXJlSW5QaWN0dXJlOiBib29sZWFuO1xuICB2aXNpYmlsaXR5Q2hhbmdlZEF0OiBudW1iZXIgfCB1bmRlZmluZWQ7XG5cbiAgaGFuZGxlUmVzaXplPzogKCkgPT4gdm9pZDtcbiAgaGFuZGxlVmlzaWJpbGl0eUNoYW5nZWQ/OiAoKSA9PiB2b2lkO1xuICBvYnNlcnZlKCk6IHZvaWQ7XG4gIHN0b3BPYnNlcnZpbmcoKTogdm9pZDtcbn1cblxuY2xhc3MgSFRNTEVsZW1lbnRJbmZvIGltcGxlbWVudHMgRWxlbWVudEluZm8ge1xuICBlbGVtZW50OiBIVE1MTWVkaWFFbGVtZW50O1xuXG4gIGdldCB2aXNpYmxlKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmlzUGlQIHx8IHRoaXMuaXNJbnRlcnNlY3Rpbmc7XG4gIH1cblxuICBnZXQgcGljdHVyZUluUGljdHVyZSgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5pc1BpUDtcbiAgfVxuXG4gIHZpc2liaWxpdHlDaGFuZ2VkQXQ6IG51bWJlciB8IHVuZGVmaW5lZDtcblxuICBoYW5kbGVSZXNpemU/OiAoKSA9PiB2b2lkO1xuXG4gIGhhbmRsZVZpc2liaWxpdHlDaGFuZ2VkPzogKCkgPT4gdm9pZDtcblxuICBwcml2YXRlIGlzUGlQOiBib29sZWFuO1xuXG4gIHByaXZhdGUgaXNJbnRlcnNlY3Rpbmc6IGJvb2xlYW47XG5cbiAgY29uc3RydWN0b3IoZWxlbWVudDogSFRNTE1lZGlhRWxlbWVudCwgdmlzaWJsZT86IGJvb2xlYW4pIHtcbiAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgIHRoaXMuaXNJbnRlcnNlY3RpbmcgPSB2aXNpYmxlID8/IGlzRWxlbWVudEluVmlld3BvcnQoZWxlbWVudCk7XG4gICAgdGhpcy5pc1BpUCA9IGlzV2ViKCkgJiYgZG9jdW1lbnQucGljdHVyZUluUGljdHVyZUVsZW1lbnQgPT09IGVsZW1lbnQ7XG4gICAgdGhpcy52aXNpYmlsaXR5Q2hhbmdlZEF0ID0gMDtcbiAgfVxuXG4gIHdpZHRoKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuZWxlbWVudC5jbGllbnRXaWR0aDtcbiAgfVxuXG4gIGhlaWdodCgpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLmVsZW1lbnQuY2xpZW50SGVpZ2h0O1xuICB9XG5cbiAgb2JzZXJ2ZSgpIHtcbiAgICAvLyBtYWtlIHN1cmUgd2UgdXBkYXRlIHRoZSBjdXJyZW50IHZpc2libGUgc3RhdGUgb25jZSB3ZSBzdGFydCB0byBvYnNlcnZlXG4gICAgdGhpcy5pc0ludGVyc2VjdGluZyA9IGlzRWxlbWVudEluVmlld3BvcnQodGhpcy5lbGVtZW50KTtcbiAgICB0aGlzLmlzUGlQID0gZG9jdW1lbnQucGljdHVyZUluUGljdHVyZUVsZW1lbnQgPT09IHRoaXMuZWxlbWVudDtcblxuICAgICh0aGlzLmVsZW1lbnQgYXMgT2JzZXJ2YWJsZU1lZGlhRWxlbWVudCkuaGFuZGxlUmVzaXplID0gKCkgPT4ge1xuICAgICAgdGhpcy5oYW5kbGVSZXNpemU/LigpO1xuICAgIH07XG4gICAgKHRoaXMuZWxlbWVudCBhcyBPYnNlcnZhYmxlTWVkaWFFbGVtZW50KS5oYW5kbGVWaXNpYmlsaXR5Q2hhbmdlZCA9IHRoaXMub25WaXNpYmlsaXR5Q2hhbmdlZDtcblxuICAgIGdldEludGVyc2VjdGlvbk9ic2VydmVyKCkub2JzZXJ2ZSh0aGlzLmVsZW1lbnQpO1xuICAgIGdldFJlc2l6ZU9ic2VydmVyKCkub2JzZXJ2ZSh0aGlzLmVsZW1lbnQpO1xuICAgICh0aGlzLmVsZW1lbnQgYXMgSFRNTFZpZGVvRWxlbWVudCkuYWRkRXZlbnRMaXN0ZW5lcignZW50ZXJwaWN0dXJlaW5waWN0dXJlJywgdGhpcy5vbkVudGVyUGlQKTtcbiAgICAodGhpcy5lbGVtZW50IGFzIEhUTUxWaWRlb0VsZW1lbnQpLmFkZEV2ZW50TGlzdGVuZXIoJ2xlYXZlcGljdHVyZWlucGljdHVyZScsIHRoaXMub25MZWF2ZVBpUCk7XG4gIH1cblxuICBwcml2YXRlIG9uVmlzaWJpbGl0eUNoYW5nZWQgPSAoZW50cnk6IEludGVyc2VjdGlvbk9ic2VydmVyRW50cnkpID0+IHtcbiAgICBjb25zdCB7IHRhcmdldCwgaXNJbnRlcnNlY3RpbmcgfSA9IGVudHJ5O1xuICAgIGlmICh0YXJnZXQgPT09IHRoaXMuZWxlbWVudCkge1xuICAgICAgdGhpcy5pc0ludGVyc2VjdGluZyA9IGlzSW50ZXJzZWN0aW5nO1xuICAgICAgdGhpcy52aXNpYmlsaXR5Q2hhbmdlZEF0ID0gRGF0ZS5ub3coKTtcbiAgICAgIHRoaXMuaGFuZGxlVmlzaWJpbGl0eUNoYW5nZWQ/LigpO1xuICAgIH1cbiAgfTtcblxuICBwcml2YXRlIG9uRW50ZXJQaVAgPSAoKSA9PiB7XG4gICAgdGhpcy5pc1BpUCA9IHRydWU7XG4gICAgdGhpcy5oYW5kbGVWaXNpYmlsaXR5Q2hhbmdlZD8uKCk7XG4gIH07XG5cbiAgcHJpdmF0ZSBvbkxlYXZlUGlQID0gKCkgPT4ge1xuICAgIHRoaXMuaXNQaVAgPSBmYWxzZTtcbiAgICB0aGlzLmhhbmRsZVZpc2liaWxpdHlDaGFuZ2VkPy4oKTtcbiAgfTtcblxuICBzdG9wT2JzZXJ2aW5nKCkge1xuICAgIGdldEludGVyc2VjdGlvbk9ic2VydmVyKCk/LnVub2JzZXJ2ZSh0aGlzLmVsZW1lbnQpO1xuICAgIGdldFJlc2l6ZU9ic2VydmVyKCk/LnVub2JzZXJ2ZSh0aGlzLmVsZW1lbnQpO1xuICAgICh0aGlzLmVsZW1lbnQgYXMgSFRNTFZpZGVvRWxlbWVudCkucmVtb3ZlRXZlbnRMaXN0ZW5lcihcbiAgICAgICdlbnRlcnBpY3R1cmVpbnBpY3R1cmUnLFxuICAgICAgdGhpcy5vbkVudGVyUGlQLFxuICAgICk7XG4gICAgKHRoaXMuZWxlbWVudCBhcyBIVE1MVmlkZW9FbGVtZW50KS5yZW1vdmVFdmVudExpc3RlbmVyKFxuICAgICAgJ2xlYXZlcGljdHVyZWlucGljdHVyZScsXG4gICAgICB0aGlzLm9uTGVhdmVQaVAsXG4gICAgKTtcbiAgfVxufVxuXG4vLyBkb2VzIG5vdCBhY2NvdW50IGZvciBvY2NsdXNpb24gYnkgb3RoZXIgZWxlbWVudHNcbmZ1bmN0aW9uIGlzRWxlbWVudEluVmlld3BvcnQoZWw6IEhUTUxFbGVtZW50KSB7XG4gIGxldCB0b3AgPSBlbC5vZmZzZXRUb3A7XG4gIGxldCBsZWZ0ID0gZWwub2Zmc2V0TGVmdDtcbiAgY29uc3Qgd2lkdGggPSBlbC5vZmZzZXRXaWR0aDtcbiAgY29uc3QgaGVpZ2h0ID0gZWwub2Zmc2V0SGVpZ2h0O1xuICBjb25zdCB7IGhpZGRlbiB9ID0gZWw7XG4gIGNvbnN0IHsgb3BhY2l0eSwgZGlzcGxheSB9ID0gZ2V0Q29tcHV0ZWRTdHlsZShlbCk7XG5cbiAgd2hpbGUgKGVsLm9mZnNldFBhcmVudCkge1xuICAgIGVsID0gZWwub2Zmc2V0UGFyZW50IGFzIEhUTUxFbGVtZW50O1xuICAgIHRvcCArPSBlbC5vZmZzZXRUb3A7XG4gICAgbGVmdCArPSBlbC5vZmZzZXRMZWZ0O1xuICB9XG5cbiAgcmV0dXJuIChcbiAgICB0b3AgPCB3aW5kb3cucGFnZVlPZmZzZXQgKyB3aW5kb3cuaW5uZXJIZWlnaHQgJiZcbiAgICBsZWZ0IDwgd2luZG93LnBhZ2VYT2Zmc2V0ICsgd2luZG93LmlubmVyV2lkdGggJiZcbiAgICB0b3AgKyBoZWlnaHQgPiB3aW5kb3cucGFnZVlPZmZzZXQgJiZcbiAgICBsZWZ0ICsgd2lkdGggPiB3aW5kb3cucGFnZVhPZmZzZXQgJiZcbiAgICAhaGlkZGVuICYmXG4gICAgKG9wYWNpdHkgIT09ICcnID8gcGFyc2VGbG9hdChvcGFjaXR5KSA+IDAgOiB0cnVlKSAmJlxuICAgIGRpc3BsYXkgIT09ICdub25lJ1xuICApO1xufVxuIiwiaW1wb3J0IHsgRXZlbnRFbWl0dGVyIH0gZnJvbSAnZXZlbnRzJztcbmltcG9ydCB0eXBlIFR5cGVkRXZlbnRFbWl0dGVyIGZyb20gJ3R5cGVkLWVtaXR0ZXInO1xuaW1wb3J0IGxvZywgeyBMb2dnZXJOYW1lcywgZ2V0TG9nZ2VyIH0gZnJvbSAnLi4vLi4vbG9nZ2VyJztcbmltcG9ydCB7IEVuY3J5cHRpb25fVHlwZSB9IGZyb20gJy4uLy4uL3Byb3RvL2xpdmVraXRfbW9kZWxzX3BiJztcbmltcG9ydCB0eXBlIHsgU3Vic2NyaXB0aW9uRXJyb3IsIFRyYWNrSW5mbyB9IGZyb20gJy4uLy4uL3Byb3RvL2xpdmVraXRfbW9kZWxzX3BiJztcbmltcG9ydCB0eXBlIHsgVXBkYXRlU3Vic2NyaXB0aW9uLCBVcGRhdGVUcmFja1NldHRpbmdzIH0gZnJvbSAnLi4vLi4vcHJvdG8vbGl2ZWtpdF9ydGNfcGInO1xuaW1wb3J0IHsgVHJhY2tFdmVudCB9IGZyb20gJy4uL2V2ZW50cyc7XG5pbXBvcnQgdHlwZSB7IExvZ2dlck9wdGlvbnMgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgTG9jYWxBdWRpb1RyYWNrIGZyb20gJy4vTG9jYWxBdWRpb1RyYWNrJztcbmltcG9ydCBMb2NhbFZpZGVvVHJhY2sgZnJvbSAnLi9Mb2NhbFZpZGVvVHJhY2snO1xuaW1wb3J0IFJlbW90ZUF1ZGlvVHJhY2sgZnJvbSAnLi9SZW1vdGVBdWRpb1RyYWNrJztcbmltcG9ydCB0eXBlIFJlbW90ZVRyYWNrIGZyb20gJy4vUmVtb3RlVHJhY2snO1xuaW1wb3J0IFJlbW90ZVZpZGVvVHJhY2sgZnJvbSAnLi9SZW1vdGVWaWRlb1RyYWNrJztcbmltcG9ydCB7IFRyYWNrIH0gZnJvbSAnLi9UcmFjayc7XG5pbXBvcnQgeyBnZXRMb2dDb250ZXh0RnJvbVRyYWNrIH0gZnJvbSAnLi91dGlscyc7XG5cbmV4cG9ydCBjbGFzcyBUcmFja1B1YmxpY2F0aW9uIGV4dGVuZHMgKEV2ZW50RW1pdHRlciBhcyBuZXcgKCkgPT4gVHlwZWRFdmVudEVtaXR0ZXI8UHVibGljYXRpb25FdmVudENhbGxiYWNrcz4pIHtcbiAga2luZDogVHJhY2suS2luZDtcblxuICB0cmFja05hbWU6IHN0cmluZztcblxuICB0cmFja1NpZDogVHJhY2suU0lEO1xuXG4gIHRyYWNrPzogVHJhY2s7XG5cbiAgc291cmNlOiBUcmFjay5Tb3VyY2U7XG5cbiAgLyoqIE1pbWVUeXBlIG9mIHRoZSBwdWJsaXNoZWQgdHJhY2sgKi9cbiAgbWltZVR5cGU/OiBzdHJpbmc7XG5cbiAgLyoqIGRpbWVuc2lvbiBvZiB0aGUgb3JpZ2luYWwgcHVibGlzaGVkIHN0cmVhbSwgdmlkZW8tb25seSAqL1xuICBkaW1lbnNpb25zPzogVHJhY2suRGltZW5zaW9ucztcblxuICAvKiogdHJ1ZSBpZiB0cmFjayB3YXMgc2ltdWxjYXN0ZWQgdG8gc2VydmVyLCB2aWRlby1vbmx5ICovXG4gIHNpbXVsY2FzdGVkPzogYm9vbGVhbjtcblxuICAvKiogQGludGVybmFsICovXG4gIHRyYWNrSW5mbz86IFRyYWNrSW5mbztcblxuICBwcm90ZWN0ZWQgbWV0YWRhdGFNdXRlZDogYm9vbGVhbiA9IGZhbHNlO1xuXG4gIHByb3RlY3RlZCBlbmNyeXB0aW9uOiBFbmNyeXB0aW9uX1R5cGUgPSBFbmNyeXB0aW9uX1R5cGUuTk9ORTtcblxuICBwcm90ZWN0ZWQgbG9nID0gbG9nO1xuXG4gIHByaXZhdGUgbG9nZ2VyQ29udGV4dENiPzogTG9nZ2VyT3B0aW9uc1snbG9nZ2VyQ29udGV4dENiJ107XG5cbiAgY29uc3RydWN0b3Ioa2luZDogVHJhY2suS2luZCwgaWQ6IHN0cmluZywgbmFtZTogc3RyaW5nLCBsb2dnZXJPcHRpb25zPzogTG9nZ2VyT3B0aW9ucykge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5sb2cgPSBnZXRMb2dnZXIobG9nZ2VyT3B0aW9ucz8ubG9nZ2VyTmFtZSA/PyBMb2dnZXJOYW1lcy5QdWJsaWNhdGlvbik7XG4gICAgdGhpcy5sb2dnZXJDb250ZXh0Q2IgPSB0aGlzLmxvZ2dlckNvbnRleHRDYjtcbiAgICB0aGlzLnNldE1heExpc3RlbmVycygxMDApO1xuICAgIHRoaXMua2luZCA9IGtpbmQ7XG4gICAgdGhpcy50cmFja1NpZCA9IGlkO1xuICAgIHRoaXMudHJhY2tOYW1lID0gbmFtZTtcbiAgICB0aGlzLnNvdXJjZSA9IFRyYWNrLlNvdXJjZS5Vbmtub3duO1xuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBzZXRUcmFjayh0cmFjaz86IFRyYWNrKSB7XG4gICAgaWYgKHRoaXMudHJhY2spIHtcbiAgICAgIHRoaXMudHJhY2sub2ZmKFRyYWNrRXZlbnQuTXV0ZWQsIHRoaXMuaGFuZGxlTXV0ZWQpO1xuICAgICAgdGhpcy50cmFjay5vZmYoVHJhY2tFdmVudC5Vbm11dGVkLCB0aGlzLmhhbmRsZVVubXV0ZWQpO1xuICAgIH1cblxuICAgIHRoaXMudHJhY2sgPSB0cmFjaztcblxuICAgIGlmICh0cmFjaykge1xuICAgICAgLy8gZm9yd2FyZCBldmVudHNcbiAgICAgIHRyYWNrLm9uKFRyYWNrRXZlbnQuTXV0ZWQsIHRoaXMuaGFuZGxlTXV0ZWQpO1xuICAgICAgdHJhY2sub24oVHJhY2tFdmVudC5Vbm11dGVkLCB0aGlzLmhhbmRsZVVubXV0ZWQpO1xuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCBnZXQgbG9nQ29udGV4dCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4udGhpcy5sb2dnZXJDb250ZXh0Q2I/LigpLFxuICAgICAgLi4uZ2V0TG9nQ29udGV4dEZyb21UcmFjayh0aGlzKSxcbiAgICB9O1xuICB9XG5cbiAgZ2V0IGlzTXV0ZWQoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMubWV0YWRhdGFNdXRlZDtcbiAgfVxuXG4gIGdldCBpc0VuYWJsZWQoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBnZXQgaXNTdWJzY3JpYmVkKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLnRyYWNrICE9PSB1bmRlZmluZWQ7XG4gIH1cblxuICBnZXQgaXNFbmNyeXB0ZWQoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuZW5jcnlwdGlvbiAhPT0gRW5jcnlwdGlvbl9UeXBlLk5PTkU7XG4gIH1cblxuICAvKipcbiAgICogYW4gW0F1ZGlvVHJhY2tdIGlmIHRoaXMgcHVibGljYXRpb24gaG9sZHMgYW4gYXVkaW8gdHJhY2tcbiAgICovXG4gIGdldCBhdWRpb1RyYWNrKCk6IExvY2FsQXVkaW9UcmFjayB8IFJlbW90ZUF1ZGlvVHJhY2sgfCB1bmRlZmluZWQge1xuICAgIGlmICh0aGlzLnRyYWNrIGluc3RhbmNlb2YgTG9jYWxBdWRpb1RyYWNrIHx8IHRoaXMudHJhY2sgaW5zdGFuY2VvZiBSZW1vdGVBdWRpb1RyYWNrKSB7XG4gICAgICByZXR1cm4gdGhpcy50cmFjaztcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogYW4gW1ZpZGVvVHJhY2tdIGlmIHRoaXMgcHVibGljYXRpb24gaG9sZHMgYSB2aWRlbyB0cmFja1xuICAgKi9cbiAgZ2V0IHZpZGVvVHJhY2soKTogTG9jYWxWaWRlb1RyYWNrIHwgUmVtb3RlVmlkZW9UcmFjayB8IHVuZGVmaW5lZCB7XG4gICAgaWYgKHRoaXMudHJhY2sgaW5zdGFuY2VvZiBMb2NhbFZpZGVvVHJhY2sgfHwgdGhpcy50cmFjayBpbnN0YW5jZW9mIFJlbW90ZVZpZGVvVHJhY2spIHtcbiAgICAgIHJldHVybiB0aGlzLnRyYWNrO1xuICAgIH1cbiAgfVxuXG4gIGhhbmRsZU11dGVkID0gKCkgPT4ge1xuICAgIHRoaXMuZW1pdChUcmFja0V2ZW50Lk11dGVkKTtcbiAgfTtcblxuICBoYW5kbGVVbm11dGVkID0gKCkgPT4ge1xuICAgIHRoaXMuZW1pdChUcmFja0V2ZW50LlVubXV0ZWQpO1xuICB9O1xuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgdXBkYXRlSW5mbyhpbmZvOiBUcmFja0luZm8pIHtcbiAgICB0aGlzLnRyYWNrU2lkID0gaW5mby5zaWQ7XG4gICAgdGhpcy50cmFja05hbWUgPSBpbmZvLm5hbWU7XG4gICAgdGhpcy5zb3VyY2UgPSBUcmFjay5zb3VyY2VGcm9tUHJvdG8oaW5mby5zb3VyY2UpO1xuICAgIHRoaXMubWltZVR5cGUgPSBpbmZvLm1pbWVUeXBlO1xuICAgIGlmICh0aGlzLmtpbmQgPT09IFRyYWNrLktpbmQuVmlkZW8gJiYgaW5mby53aWR0aCA+IDApIHtcbiAgICAgIHRoaXMuZGltZW5zaW9ucyA9IHtcbiAgICAgICAgd2lkdGg6IGluZm8ud2lkdGgsXG4gICAgICAgIGhlaWdodDogaW5mby5oZWlnaHQsXG4gICAgICB9O1xuICAgICAgdGhpcy5zaW11bGNhc3RlZCA9IGluZm8uc2ltdWxjYXN0O1xuICAgIH1cbiAgICB0aGlzLmVuY3J5cHRpb24gPSBpbmZvLmVuY3J5cHRpb247XG4gICAgdGhpcy50cmFja0luZm8gPSBpbmZvO1xuICAgIHRoaXMubG9nLmRlYnVnKCd1cGRhdGUgcHVibGljYXRpb24gaW5mbycsIHsgLi4udGhpcy5sb2dDb250ZXh0LCBpbmZvIH0pO1xuICB9XG59XG5cbmV4cG9ydCBuYW1lc3BhY2UgVHJhY2tQdWJsaWNhdGlvbiB7XG4gIGV4cG9ydCBlbnVtIFN1YnNjcmlwdGlvblN0YXR1cyB7XG4gICAgRGVzaXJlZCA9ICdkZXNpcmVkJyxcbiAgICBTdWJzY3JpYmVkID0gJ3N1YnNjcmliZWQnLFxuICAgIFVuc3Vic2NyaWJlZCA9ICd1bnN1YnNjcmliZWQnLFxuICB9XG5cbiAgZXhwb3J0IGVudW0gUGVybWlzc2lvblN0YXR1cyB7XG4gICAgQWxsb3dlZCA9ICdhbGxvd2VkJyxcbiAgICBOb3RBbGxvd2VkID0gJ25vdF9hbGxvd2VkJyxcbiAgfVxufVxuXG5leHBvcnQgdHlwZSBQdWJsaWNhdGlvbkV2ZW50Q2FsbGJhY2tzID0ge1xuICBtdXRlZDogKCkgPT4gdm9pZDtcbiAgdW5tdXRlZDogKCkgPT4gdm9pZDtcbiAgZW5kZWQ6ICh0cmFjaz86IFRyYWNrKSA9PiB2b2lkO1xuICB1cGRhdGVTZXR0aW5nczogKHNldHRpbmdzOiBVcGRhdGVUcmFja1NldHRpbmdzKSA9PiB2b2lkO1xuICBzdWJzY3JpcHRpb25QZXJtaXNzaW9uQ2hhbmdlZDogKFxuICAgIHN0YXR1czogVHJhY2tQdWJsaWNhdGlvbi5QZXJtaXNzaW9uU3RhdHVzLFxuICAgIHByZXZTdGF0dXM6IFRyYWNrUHVibGljYXRpb24uUGVybWlzc2lvblN0YXR1cyxcbiAgKSA9PiB2b2lkO1xuICB1cGRhdGVTdWJzY3JpcHRpb246IChzdWI6IFVwZGF0ZVN1YnNjcmlwdGlvbikgPT4gdm9pZDtcbiAgc3Vic2NyaWJlZDogKHRyYWNrOiBSZW1vdGVUcmFjaykgPT4gdm9pZDtcbiAgdW5zdWJzY3JpYmVkOiAodHJhY2s6IFJlbW90ZVRyYWNrKSA9PiB2b2lkO1xuICBzdWJzY3JpcHRpb25TdGF0dXNDaGFuZ2VkOiAoXG4gICAgc3RhdHVzOiBUcmFja1B1YmxpY2F0aW9uLlN1YnNjcmlwdGlvblN0YXR1cyxcbiAgICBwcmV2U3RhdHVzOiBUcmFja1B1YmxpY2F0aW9uLlN1YnNjcmlwdGlvblN0YXR1cyxcbiAgKSA9PiB2b2lkO1xuICBzdWJzY3JpcHRpb25GYWlsZWQ6IChlcnJvcjogU3Vic2NyaXB0aW9uRXJyb3IpID0+IHZvaWQ7XG59O1xuIiwiaW1wb3J0IHR5cGUgeyBUcmFja0luZm8gfSBmcm9tICcuLi8uLi9wcm90by9saXZla2l0X21vZGVsc19wYic7XG5pbXBvcnQgeyBUcmFja0V2ZW50IH0gZnJvbSAnLi4vZXZlbnRzJztcbmltcG9ydCB0eXBlIHsgTG9nZ2VyT3B0aW9ucyB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB0eXBlIExvY2FsQXVkaW9UcmFjayBmcm9tICcuL0xvY2FsQXVkaW9UcmFjayc7XG5pbXBvcnQgdHlwZSBMb2NhbFRyYWNrIGZyb20gJy4vTG9jYWxUcmFjayc7XG5pbXBvcnQgdHlwZSBMb2NhbFZpZGVvVHJhY2sgZnJvbSAnLi9Mb2NhbFZpZGVvVHJhY2snO1xuaW1wb3J0IHR5cGUgeyBUcmFjayB9IGZyb20gJy4vVHJhY2snO1xuaW1wb3J0IHsgVHJhY2tQdWJsaWNhdGlvbiB9IGZyb20gJy4vVHJhY2tQdWJsaWNhdGlvbic7XG5pbXBvcnQgdHlwZSB7IFRyYWNrUHVibGlzaE9wdGlvbnMgfSBmcm9tICcuL29wdGlvbnMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMb2NhbFRyYWNrUHVibGljYXRpb24gZXh0ZW5kcyBUcmFja1B1YmxpY2F0aW9uIHtcbiAgdHJhY2s/OiBMb2NhbFRyYWNrID0gdW5kZWZpbmVkO1xuXG4gIG9wdGlvbnM/OiBUcmFja1B1Ymxpc2hPcHRpb25zO1xuXG4gIGdldCBpc1Vwc3RyZWFtUGF1c2VkKCkge1xuICAgIHJldHVybiB0aGlzLnRyYWNrPy5pc1Vwc3RyZWFtUGF1c2VkO1xuICB9XG5cbiAgY29uc3RydWN0b3Ioa2luZDogVHJhY2suS2luZCwgdGk6IFRyYWNrSW5mbywgdHJhY2s/OiBMb2NhbFRyYWNrLCBsb2dnZXJPcHRpb25zPzogTG9nZ2VyT3B0aW9ucykge1xuICAgIHN1cGVyKGtpbmQsIHRpLnNpZCwgdGkubmFtZSwgbG9nZ2VyT3B0aW9ucyk7XG5cbiAgICB0aGlzLnVwZGF0ZUluZm8odGkpO1xuICAgIHRoaXMuc2V0VHJhY2sodHJhY2spO1xuICB9XG5cbiAgc2V0VHJhY2sodHJhY2s/OiBUcmFjaykge1xuICAgIGlmICh0aGlzLnRyYWNrKSB7XG4gICAgICB0aGlzLnRyYWNrLm9mZihUcmFja0V2ZW50LkVuZGVkLCB0aGlzLmhhbmRsZVRyYWNrRW5kZWQpO1xuICAgIH1cblxuICAgIHN1cGVyLnNldFRyYWNrKHRyYWNrKTtcblxuICAgIGlmICh0cmFjaykge1xuICAgICAgdHJhY2sub24oVHJhY2tFdmVudC5FbmRlZCwgdGhpcy5oYW5kbGVUcmFja0VuZGVkKTtcbiAgICB9XG4gIH1cblxuICBnZXQgaXNNdXRlZCgpOiBib29sZWFuIHtcbiAgICBpZiAodGhpcy50cmFjaykge1xuICAgICAgcmV0dXJuIHRoaXMudHJhY2suaXNNdXRlZDtcbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLmlzTXV0ZWQ7XG4gIH1cblxuICBnZXQgYXVkaW9UcmFjaygpOiBMb2NhbEF1ZGlvVHJhY2sgfCB1bmRlZmluZWQge1xuICAgIHJldHVybiBzdXBlci5hdWRpb1RyYWNrIGFzIExvY2FsQXVkaW9UcmFjayB8IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGdldCB2aWRlb1RyYWNrKCk6IExvY2FsVmlkZW9UcmFjayB8IHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIHN1cGVyLnZpZGVvVHJhY2sgYXMgTG9jYWxWaWRlb1RyYWNrIHwgdW5kZWZpbmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIE11dGUgdGhlIHRyYWNrIGFzc29jaWF0ZWQgd2l0aCB0aGlzIHB1YmxpY2F0aW9uXG4gICAqL1xuICBhc3luYyBtdXRlKCkge1xuICAgIHJldHVybiB0aGlzLnRyYWNrPy5tdXRlKCk7XG4gIH1cblxuICAvKipcbiAgICogVW5tdXRlIHRyYWNrIGFzc29jaWF0ZWQgd2l0aCB0aGlzIHB1YmxpY2F0aW9uXG4gICAqL1xuICBhc3luYyB1bm11dGUoKSB7XG4gICAgcmV0dXJuIHRoaXMudHJhY2s/LnVubXV0ZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhdXNlcyB0aGUgbWVkaWEgc3RyZWFtIHRyYWNrIGFzc29jaWF0ZWQgd2l0aCB0aGlzIHB1YmxpY2F0aW9uIGZyb20gYmVpbmcgc2VudCB0byB0aGUgc2VydmVyXG4gICAqIGFuZCBzaWduYWxzIFwibXV0ZWRcIiBldmVudCB0byBvdGhlciBwYXJ0aWNpcGFudHNcbiAgICogVXNlZnVsIGlmIHlvdSB3YW50IHRvIHBhdXNlIHRoZSBzdHJlYW0gd2l0aG91dCBwYXVzaW5nIHRoZSBsb2NhbCBtZWRpYSBzdHJlYW0gdHJhY2tcbiAgICovXG4gIGFzeW5jIHBhdXNlVXBzdHJlYW0oKSB7XG4gICAgYXdhaXQgdGhpcy50cmFjaz8ucGF1c2VVcHN0cmVhbSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlc3VtZXMgc2VuZGluZyB0aGUgbWVkaWEgc3RyZWFtIHRyYWNrIGFzc29jaWF0ZWQgd2l0aCB0aGlzIHB1YmxpY2F0aW9uIHRvIHRoZSBzZXJ2ZXIgYWZ0ZXIgYSBjYWxsIHRvIFtbcGF1c2VVcHN0cmVhbSgpXV1cbiAgICogYW5kIHNpZ25hbHMgXCJ1bm11dGVkXCIgZXZlbnQgdG8gb3RoZXIgcGFydGljaXBhbnRzICh1bmxlc3MgdGhlIHRyYWNrIGlzIGV4cGxpY2l0bHkgbXV0ZWQpXG4gICAqL1xuICBhc3luYyByZXN1bWVVcHN0cmVhbSgpIHtcbiAgICBhd2FpdCB0aGlzLnRyYWNrPy5yZXN1bWVVcHN0cmVhbSgpO1xuICB9XG5cbiAgaGFuZGxlVHJhY2tFbmRlZCA9ICgpID0+IHtcbiAgICB0aGlzLmVtaXQoVHJhY2tFdmVudC5FbmRlZCk7XG4gIH07XG59XG4iLCJpbXBvcnQgeyBFdmVudEVtaXR0ZXIgfSBmcm9tICdldmVudHMnO1xuaW1wb3J0IHR5cGUgVHlwZWRFbWl0dGVyIGZyb20gJ3R5cGVkLWVtaXR0ZXInO1xuaW1wb3J0IGxvZywgeyBMb2dnZXJOYW1lcywgU3RydWN0dXJlZExvZ2dlciwgZ2V0TG9nZ2VyIH0gZnJvbSAnLi4vLi4vbG9nZ2VyJztcbmltcG9ydCB7XG4gIERhdGFQYWNrZXRfS2luZCxcbiAgUGFydGljaXBhbnRJbmZvLFxuICBQYXJ0aWNpcGFudFBlcm1pc3Npb24sXG4gIENvbm5lY3Rpb25RdWFsaXR5IGFzIFByb3RvUXVhbGl0eSxcbiAgU3Vic2NyaXB0aW9uRXJyb3IsXG59IGZyb20gJy4uLy4uL3Byb3RvL2xpdmVraXRfbW9kZWxzX3BiJztcbmltcG9ydCB7IFBhcnRpY2lwYW50RXZlbnQsIFRyYWNrRXZlbnQgfSBmcm9tICcuLi9ldmVudHMnO1xuaW1wb3J0IExvY2FsQXVkaW9UcmFjayBmcm9tICcuLi90cmFjay9Mb2NhbEF1ZGlvVHJhY2snO1xuaW1wb3J0IHR5cGUgTG9jYWxUcmFja1B1YmxpY2F0aW9uIGZyb20gJy4uL3RyYWNrL0xvY2FsVHJhY2tQdWJsaWNhdGlvbic7XG5pbXBvcnQgUmVtb3RlQXVkaW9UcmFjayBmcm9tICcuLi90cmFjay9SZW1vdGVBdWRpb1RyYWNrJztcbmltcG9ydCB0eXBlIFJlbW90ZVRyYWNrIGZyb20gJy4uL3RyYWNrL1JlbW90ZVRyYWNrJztcbmltcG9ydCB0eXBlIFJlbW90ZVRyYWNrUHVibGljYXRpb24gZnJvbSAnLi4vdHJhY2svUmVtb3RlVHJhY2tQdWJsaWNhdGlvbic7XG5pbXBvcnQgeyBUcmFjayB9IGZyb20gJy4uL3RyYWNrL1RyYWNrJztcbmltcG9ydCB0eXBlIHsgVHJhY2tQdWJsaWNhdGlvbiB9IGZyb20gJy4uL3RyYWNrL1RyYWNrUHVibGljYXRpb24nO1xuaW1wb3J0IHR5cGUgeyBMb2dnZXJPcHRpb25zIH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5leHBvcnQgZW51bSBDb25uZWN0aW9uUXVhbGl0eSB7XG4gIEV4Y2VsbGVudCA9ICdleGNlbGxlbnQnLFxuICBHb29kID0gJ2dvb2QnLFxuICBQb29yID0gJ3Bvb3InLFxuICAvKipcbiAgICogSW5kaWNhdGVzIHRoYXQgYSBwYXJ0aWNpcGFudCBoYXMgdGVtcG9yYXJpbHkgKG9yIHBlcm1hbmVudGx5KSBsb3N0IGNvbm5lY3Rpb24gdG8gTGl2ZUtpdC5cbiAgICogRm9yIHBlcm1hbmVudCBkaXNjb25uZWN0aW9uIGEgYFBhcnRpY2lwYW50RGlzY29ubmVjdGVkYCBldmVudCB3aWxsIGJlIGVtaXR0ZWQgYWZ0ZXIgYSB0aW1lb3V0XG4gICAqL1xuICBMb3N0ID0gJ2xvc3QnLFxuICBVbmtub3duID0gJ3Vua25vd24nLFxufVxuXG5mdW5jdGlvbiBxdWFsaXR5RnJvbVByb3RvKHE6IFByb3RvUXVhbGl0eSk6IENvbm5lY3Rpb25RdWFsaXR5IHtcbiAgc3dpdGNoIChxKSB7XG4gICAgY2FzZSBQcm90b1F1YWxpdHkuRVhDRUxMRU5UOlxuICAgICAgcmV0dXJuIENvbm5lY3Rpb25RdWFsaXR5LkV4Y2VsbGVudDtcbiAgICBjYXNlIFByb3RvUXVhbGl0eS5HT09EOlxuICAgICAgcmV0dXJuIENvbm5lY3Rpb25RdWFsaXR5Lkdvb2Q7XG4gICAgY2FzZSBQcm90b1F1YWxpdHkuUE9PUjpcbiAgICAgIHJldHVybiBDb25uZWN0aW9uUXVhbGl0eS5Qb29yO1xuICAgIGNhc2UgUHJvdG9RdWFsaXR5LkxPU1Q6XG4gICAgICByZXR1cm4gQ29ubmVjdGlvblF1YWxpdHkuTG9zdDtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIENvbm5lY3Rpb25RdWFsaXR5LlVua25vd247XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUGFydGljaXBhbnQgZXh0ZW5kcyAoRXZlbnRFbWl0dGVyIGFzIG5ldyAoKSA9PiBUeXBlZEVtaXR0ZXI8UGFydGljaXBhbnRFdmVudENhbGxiYWNrcz4pIHtcbiAgcHJvdGVjdGVkIHBhcnRpY2lwYW50SW5mbz86IFBhcnRpY2lwYW50SW5mbztcblxuICBhdWRpb1RyYWNrczogTWFwPHN0cmluZywgVHJhY2tQdWJsaWNhdGlvbj47XG5cbiAgdmlkZW9UcmFja3M6IE1hcDxzdHJpbmcsIFRyYWNrUHVibGljYXRpb24+O1xuXG4gIC8qKiBtYXAgb2YgdHJhY2sgc2lkID0+IGFsbCBwdWJsaXNoZWQgdHJhY2tzICovXG4gIHRyYWNrczogTWFwPHN0cmluZywgVHJhY2tQdWJsaWNhdGlvbj47XG5cbiAgLyoqIGF1ZGlvIGxldmVsIGJldHdlZW4gMC0xLjAsIDEgYmVpbmcgbG91ZGVzdCwgMCBiZWluZyBzb2Z0ZXN0ICovXG4gIGF1ZGlvTGV2ZWw6IG51bWJlciA9IDA7XG5cbiAgLyoqIGlmIHBhcnRpY2lwYW50IGlzIGN1cnJlbnRseSBzcGVha2luZyAqL1xuICBpc1NwZWFraW5nOiBib29sZWFuID0gZmFsc2U7XG5cbiAgLyoqIHNlcnZlciBhc3NpZ25lZCB1bmlxdWUgaWQgKi9cbiAgc2lkOiBzdHJpbmc7XG5cbiAgLyoqIGNsaWVudCBhc3NpZ25lZCBpZGVudGl0eSwgZW5jb2RlZCBpbiBKV1QgdG9rZW4gKi9cbiAgaWRlbnRpdHk6IHN0cmluZztcblxuICAvKiogY2xpZW50IGFzc2lnbmVkIGRpc3BsYXkgbmFtZSwgZW5jb2RlZCBpbiBKV1QgdG9rZW4gKi9cbiAgbmFtZT86IHN0cmluZztcblxuICAvKiogY2xpZW50IG1ldGFkYXRhLCBvcGFxdWUgdG8gbGl2ZWtpdCAqL1xuICBtZXRhZGF0YT86IHN0cmluZztcblxuICBsYXN0U3Bva2VBdD86IERhdGUgfCB1bmRlZmluZWQ7XG5cbiAgcGVybWlzc2lvbnM/OiBQYXJ0aWNpcGFudFBlcm1pc3Npb247XG5cbiAgcHJpdmF0ZSBfY29ubmVjdGlvblF1YWxpdHk6IENvbm5lY3Rpb25RdWFsaXR5ID0gQ29ubmVjdGlvblF1YWxpdHkuVW5rbm93bjtcblxuICBwcm90ZWN0ZWQgYXVkaW9Db250ZXh0PzogQXVkaW9Db250ZXh0O1xuXG4gIHByb3RlY3RlZCBsb2c6IFN0cnVjdHVyZWRMb2dnZXIgPSBsb2c7XG5cbiAgcHJvdGVjdGVkIGxvZ2dlck9wdGlvbnM/OiBMb2dnZXJPcHRpb25zO1xuXG4gIHByb3RlY3RlZCBnZXQgbG9nQ29udGV4dCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4udGhpcy5sb2dnZXJPcHRpb25zPy5sb2dnZXJDb250ZXh0Q2I/LigpLFxuICAgICAgcGFydGljaXBhbnRTaWQ6IHRoaXMuc2lkLFxuICAgICAgcGFydGljaXBhbnRJZDogdGhpcy5pZGVudGl0eSxcbiAgICB9O1xuICB9XG5cbiAgZ2V0IGlzRW5jcnlwdGVkKCkge1xuICAgIHJldHVybiB0aGlzLnRyYWNrcy5zaXplID4gMCAmJiBBcnJheS5mcm9tKHRoaXMudHJhY2tzLnZhbHVlcygpKS5ldmVyeSgodHIpID0+IHRyLmlzRW5jcnlwdGVkKTtcbiAgfVxuXG4gIGdldCBpc0FnZW50KCkge1xuICAgIHJldHVybiB0aGlzLnBlcm1pc3Npb25zPy5hZ2VudCA/PyBmYWxzZTtcbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgY29uc3RydWN0b3IoXG4gICAgc2lkOiBzdHJpbmcsXG4gICAgaWRlbnRpdHk6IHN0cmluZyxcbiAgICBuYW1lPzogc3RyaW5nLFxuICAgIG1ldGFkYXRhPzogc3RyaW5nLFxuICAgIGxvZ2dlck9wdGlvbnM/OiBMb2dnZXJPcHRpb25zLFxuICApIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5sb2cgPSBnZXRMb2dnZXIobG9nZ2VyT3B0aW9ucz8ubG9nZ2VyTmFtZSA/PyBMb2dnZXJOYW1lcy5QYXJ0aWNpcGFudCk7XG4gICAgdGhpcy5sb2dnZXJPcHRpb25zID0gbG9nZ2VyT3B0aW9ucztcblxuICAgIHRoaXMuc2V0TWF4TGlzdGVuZXJzKDEwMCk7XG4gICAgdGhpcy5zaWQgPSBzaWQ7XG4gICAgdGhpcy5pZGVudGl0eSA9IGlkZW50aXR5O1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgdGhpcy5tZXRhZGF0YSA9IG1ldGFkYXRhO1xuICAgIHRoaXMuYXVkaW9UcmFja3MgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy52aWRlb1RyYWNrcyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLnRyYWNrcyA9IG5ldyBNYXAoKTtcbiAgfVxuXG4gIGdldFRyYWNrcygpOiBUcmFja1B1YmxpY2F0aW9uW10ge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMudHJhY2tzLnZhbHVlcygpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGaW5kcyB0aGUgZmlyc3QgdHJhY2sgdGhhdCBtYXRjaGVzIHRoZSBzb3VyY2UgZmlsdGVyLCBmb3IgZXhhbXBsZSwgZ2V0dGluZ1xuICAgKiB0aGUgdXNlcidzIGNhbWVyYSB0cmFjayB3aXRoIGdldFRyYWNrQnlTb3VyY2UoVHJhY2suU291cmNlLkNhbWVyYSkuXG4gICAqIEBwYXJhbSBzb3VyY2VcbiAgICogQHJldHVybnNcbiAgICovXG4gIGdldFRyYWNrKHNvdXJjZTogVHJhY2suU291cmNlKTogVHJhY2tQdWJsaWNhdGlvbiB8IHVuZGVmaW5lZCB7XG4gICAgZm9yIChjb25zdCBbLCBwdWJdIG9mIHRoaXMudHJhY2tzKSB7XG4gICAgICBpZiAocHViLnNvdXJjZSA9PT0gc291cmNlKSB7XG4gICAgICAgIHJldHVybiBwdWI7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEZpbmRzIHRoZSBmaXJzdCB0cmFjayB0aGF0IG1hdGNoZXMgdGhlIHRyYWNrJ3MgbmFtZS5cbiAgICogQHBhcmFtIG5hbWVcbiAgICogQHJldHVybnNcbiAgICovXG4gIGdldFRyYWNrQnlOYW1lKG5hbWU6IHN0cmluZyk6IFRyYWNrUHVibGljYXRpb24gfCB1bmRlZmluZWQge1xuICAgIGZvciAoY29uc3QgWywgcHViXSBvZiB0aGlzLnRyYWNrcykge1xuICAgICAgaWYgKHB1Yi50cmFja05hbWUgPT09IG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHB1YjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBnZXQgY29ubmVjdGlvblF1YWxpdHkoKTogQ29ubmVjdGlvblF1YWxpdHkge1xuICAgIHJldHVybiB0aGlzLl9jb25uZWN0aW9uUXVhbGl0eTtcbiAgfVxuXG4gIGdldCBpc0NhbWVyYUVuYWJsZWQoKTogYm9vbGVhbiB7XG4gICAgY29uc3QgdHJhY2sgPSB0aGlzLmdldFRyYWNrKFRyYWNrLlNvdXJjZS5DYW1lcmEpO1xuICAgIHJldHVybiAhKHRyYWNrPy5pc011dGVkID8/IHRydWUpO1xuICB9XG5cbiAgZ2V0IGlzTWljcm9waG9uZUVuYWJsZWQoKTogYm9vbGVhbiB7XG4gICAgY29uc3QgdHJhY2sgPSB0aGlzLmdldFRyYWNrKFRyYWNrLlNvdXJjZS5NaWNyb3Bob25lKTtcbiAgICByZXR1cm4gISh0cmFjaz8uaXNNdXRlZCA/PyB0cnVlKTtcbiAgfVxuXG4gIGdldCBpc1NjcmVlblNoYXJlRW5hYmxlZCgpOiBib29sZWFuIHtcbiAgICBjb25zdCB0cmFjayA9IHRoaXMuZ2V0VHJhY2soVHJhY2suU291cmNlLlNjcmVlblNoYXJlKTtcbiAgICByZXR1cm4gISF0cmFjaztcbiAgfVxuXG4gIGdldCBpc0xvY2FsKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKiB3aGVuIHBhcnRpY2lwYW50IGpvaW5lZCB0aGUgcm9vbSAqL1xuICBnZXQgam9pbmVkQXQoKTogRGF0ZSB8IHVuZGVmaW5lZCB7XG4gICAgaWYgKHRoaXMucGFydGljaXBhbnRJbmZvKSB7XG4gICAgICByZXR1cm4gbmV3IERhdGUoTnVtYmVyLnBhcnNlSW50KHRoaXMucGFydGljaXBhbnRJbmZvLmpvaW5lZEF0LnRvU3RyaW5nKCkpICogMTAwMCk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgRGF0ZSgpO1xuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICB1cGRhdGVJbmZvKGluZm86IFBhcnRpY2lwYW50SW5mbyk6IGJvb2xlYW4ge1xuICAgIC8vIGl0J3MgcG9zc2libGUgdGhlIHVwZGF0ZSBjb3VsZCBiZSBhcHBsaWVkIG91dCBvZiBvcmRlciBkdWUgdG8gYXdhaXRcbiAgICAvLyBkdXJpbmcgcmVjb25uZWN0IHNlcXVlbmNlcy4gd2hlbiB0aGF0IGhhcHBlbnMsIGl0J3MgcG9zc2libGUgZm9yIHNlcnZlclxuICAgIC8vIHRvIGhhdmUgc2VudCBtb3JlIHJlY2VudCB2ZXJzaW9uIG9mIHBhcnRpY2lwYW50IGluZm8gd2hpbGUgSlMgaXMgd2FpdGluZ1xuICAgIC8vIHRvIHByb2Nlc3MgdGhlIGV4aXN0aW5nIHBheWxvYWQuXG4gICAgLy8gd2hlbiB0aGUgcGFydGljaXBhbnQgc2lkIHJlbWFpbnMgdGhlIHNhbWUsIGFuZCB3ZSBhbHJlYWR5IGhhdmUgYSBsYXRlciB2ZXJzaW9uXG4gICAgLy8gb2YgdGhlIHBheWxvYWQsIHRoZXkgY2FuIGJlIHNhZmVseSBza2lwcGVkXG4gICAgaWYgKFxuICAgICAgdGhpcy5wYXJ0aWNpcGFudEluZm8gJiZcbiAgICAgIHRoaXMucGFydGljaXBhbnRJbmZvLnNpZCA9PT0gaW5mby5zaWQgJiZcbiAgICAgIHRoaXMucGFydGljaXBhbnRJbmZvLnZlcnNpb24gPiBpbmZvLnZlcnNpb25cbiAgICApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy5pZGVudGl0eSA9IGluZm8uaWRlbnRpdHk7XG4gICAgdGhpcy5zaWQgPSBpbmZvLnNpZDtcbiAgICB0aGlzLl9zZXROYW1lKGluZm8ubmFtZSk7XG4gICAgdGhpcy5fc2V0TWV0YWRhdGEoaW5mby5tZXRhZGF0YSk7XG4gICAgaWYgKGluZm8ucGVybWlzc2lvbikge1xuICAgICAgdGhpcy5zZXRQZXJtaXNzaW9ucyhpbmZvLnBlcm1pc3Npb24pO1xuICAgIH1cbiAgICAvLyBzZXQgdGhpcyBsYXN0IHNvIHNldE1ldGFkYXRhIGNhbiBkZXRlY3QgY2hhbmdlc1xuICAgIHRoaXMucGFydGljaXBhbnRJbmZvID0gaW5mbztcbiAgICB0aGlzLmxvZy50cmFjZSgndXBkYXRlIHBhcnRpY2lwYW50IGluZm8nLCB7IC4uLnRoaXMubG9nQ29udGV4dCwgaW5mbyB9KTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIG1ldGFkYXRhIGZyb20gc2VydmVyXG4gICAqKi9cbiAgcHJpdmF0ZSBfc2V0TWV0YWRhdGEobWQ6IHN0cmluZykge1xuICAgIGNvbnN0IGNoYW5nZWQgPSB0aGlzLm1ldGFkYXRhICE9PSBtZDtcbiAgICBjb25zdCBwcmV2TWV0YWRhdGEgPSB0aGlzLm1ldGFkYXRhO1xuICAgIHRoaXMubWV0YWRhdGEgPSBtZDtcblxuICAgIGlmIChjaGFuZ2VkKSB7XG4gICAgICB0aGlzLmVtaXQoUGFydGljaXBhbnRFdmVudC5QYXJ0aWNpcGFudE1ldGFkYXRhQ2hhbmdlZCwgcHJldk1ldGFkYXRhKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIF9zZXROYW1lKG5hbWU6IHN0cmluZykge1xuICAgIGNvbnN0IGNoYW5nZWQgPSB0aGlzLm5hbWUgIT09IG5hbWU7XG4gICAgdGhpcy5uYW1lID0gbmFtZTtcblxuICAgIGlmIChjaGFuZ2VkKSB7XG4gICAgICB0aGlzLmVtaXQoUGFydGljaXBhbnRFdmVudC5QYXJ0aWNpcGFudE5hbWVDaGFuZ2VkLCBuYW1lKTtcbiAgICB9XG4gIH1cblxuICAvKiogQGludGVybmFsICovXG4gIHNldFBlcm1pc3Npb25zKHBlcm1pc3Npb25zOiBQYXJ0aWNpcGFudFBlcm1pc3Npb24pOiBib29sZWFuIHtcbiAgICBjb25zdCBwcmV2UGVybWlzc2lvbnMgPSB0aGlzLnBlcm1pc3Npb25zO1xuICAgIGNvbnN0IGNoYW5nZWQgPVxuICAgICAgcGVybWlzc2lvbnMuY2FuUHVibGlzaCAhPT0gdGhpcy5wZXJtaXNzaW9ucz8uY2FuUHVibGlzaCB8fFxuICAgICAgcGVybWlzc2lvbnMuY2FuU3Vic2NyaWJlICE9PSB0aGlzLnBlcm1pc3Npb25zPy5jYW5TdWJzY3JpYmUgfHxcbiAgICAgIHBlcm1pc3Npb25zLmNhblB1Ymxpc2hEYXRhICE9PSB0aGlzLnBlcm1pc3Npb25zPy5jYW5QdWJsaXNoRGF0YSB8fFxuICAgICAgcGVybWlzc2lvbnMuaGlkZGVuICE9PSB0aGlzLnBlcm1pc3Npb25zPy5oaWRkZW4gfHxcbiAgICAgIHBlcm1pc3Npb25zLnJlY29yZGVyICE9PSB0aGlzLnBlcm1pc3Npb25zPy5yZWNvcmRlciB8fFxuICAgICAgcGVybWlzc2lvbnMuY2FuUHVibGlzaFNvdXJjZXMubGVuZ3RoICE9PSB0aGlzLnBlcm1pc3Npb25zLmNhblB1Ymxpc2hTb3VyY2VzLmxlbmd0aCB8fFxuICAgICAgcGVybWlzc2lvbnMuY2FuUHVibGlzaFNvdXJjZXMuc29tZShcbiAgICAgICAgKHZhbHVlLCBpbmRleCkgPT4gdmFsdWUgIT09IHRoaXMucGVybWlzc2lvbnM/LmNhblB1Ymxpc2hTb3VyY2VzW2luZGV4XSxcbiAgICAgICk7XG4gICAgdGhpcy5wZXJtaXNzaW9ucyA9IHBlcm1pc3Npb25zO1xuXG4gICAgaWYgKGNoYW5nZWQpIHtcbiAgICAgIHRoaXMuZW1pdChQYXJ0aWNpcGFudEV2ZW50LlBhcnRpY2lwYW50UGVybWlzc2lvbnNDaGFuZ2VkLCBwcmV2UGVybWlzc2lvbnMpO1xuICAgIH1cbiAgICByZXR1cm4gY2hhbmdlZDtcbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgc2V0SXNTcGVha2luZyhzcGVha2luZzogYm9vbGVhbikge1xuICAgIGlmIChzcGVha2luZyA9PT0gdGhpcy5pc1NwZWFraW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuaXNTcGVha2luZyA9IHNwZWFraW5nO1xuICAgIGlmIChzcGVha2luZykge1xuICAgICAgdGhpcy5sYXN0U3Bva2VBdCA9IG5ldyBEYXRlKCk7XG4gICAgfVxuICAgIHRoaXMuZW1pdChQYXJ0aWNpcGFudEV2ZW50LklzU3BlYWtpbmdDaGFuZ2VkLCBzcGVha2luZyk7XG4gIH1cblxuICAvKiogQGludGVybmFsICovXG4gIHNldENvbm5lY3Rpb25RdWFsaXR5KHE6IFByb3RvUXVhbGl0eSkge1xuICAgIGNvbnN0IHByZXZRdWFsaXR5ID0gdGhpcy5fY29ubmVjdGlvblF1YWxpdHk7XG4gICAgdGhpcy5fY29ubmVjdGlvblF1YWxpdHkgPSBxdWFsaXR5RnJvbVByb3RvKHEpO1xuICAgIGlmIChwcmV2UXVhbGl0eSAhPT0gdGhpcy5fY29ubmVjdGlvblF1YWxpdHkpIHtcbiAgICAgIHRoaXMuZW1pdChQYXJ0aWNpcGFudEV2ZW50LkNvbm5lY3Rpb25RdWFsaXR5Q2hhbmdlZCwgdGhpcy5fY29ubmVjdGlvblF1YWxpdHkpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHNldEF1ZGlvQ29udGV4dChjdHg6IEF1ZGlvQ29udGV4dCB8IHVuZGVmaW5lZCkge1xuICAgIHRoaXMuYXVkaW9Db250ZXh0ID0gY3R4O1xuICAgIHRoaXMuYXVkaW9UcmFja3MuZm9yRWFjaChcbiAgICAgICh0cmFjaykgPT5cbiAgICAgICAgKHRyYWNrLnRyYWNrIGluc3RhbmNlb2YgUmVtb3RlQXVkaW9UcmFjayB8fCB0cmFjay50cmFjayBpbnN0YW5jZW9mIExvY2FsQXVkaW9UcmFjaykgJiZcbiAgICAgICAgdHJhY2sudHJhY2suc2V0QXVkaW9Db250ZXh0KGN0eCksXG4gICAgKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBhZGRUcmFja1B1YmxpY2F0aW9uKHB1YmxpY2F0aW9uOiBUcmFja1B1YmxpY2F0aW9uKSB7XG4gICAgLy8gZm9yd2FyZCBwdWJsaWNhdGlvbiBkcml2ZW4gZXZlbnRzXG4gICAgcHVibGljYXRpb24ub24oVHJhY2tFdmVudC5NdXRlZCwgKCkgPT4ge1xuICAgICAgdGhpcy5lbWl0KFBhcnRpY2lwYW50RXZlbnQuVHJhY2tNdXRlZCwgcHVibGljYXRpb24pO1xuICAgIH0pO1xuXG4gICAgcHVibGljYXRpb24ub24oVHJhY2tFdmVudC5Vbm11dGVkLCAoKSA9PiB7XG4gICAgICB0aGlzLmVtaXQoUGFydGljaXBhbnRFdmVudC5UcmFja1VubXV0ZWQsIHB1YmxpY2F0aW9uKTtcbiAgICB9KTtcblxuICAgIGNvbnN0IHB1YiA9IHB1YmxpY2F0aW9uO1xuICAgIGlmIChwdWIudHJhY2spIHtcbiAgICAgIHB1Yi50cmFjay5zaWQgPSBwdWJsaWNhdGlvbi50cmFja1NpZDtcbiAgICB9XG5cbiAgICB0aGlzLnRyYWNrcy5zZXQocHVibGljYXRpb24udHJhY2tTaWQsIHB1YmxpY2F0aW9uKTtcbiAgICBzd2l0Y2ggKHB1YmxpY2F0aW9uLmtpbmQpIHtcbiAgICAgIGNhc2UgVHJhY2suS2luZC5BdWRpbzpcbiAgICAgICAgdGhpcy5hdWRpb1RyYWNrcy5zZXQocHVibGljYXRpb24udHJhY2tTaWQsIHB1YmxpY2F0aW9uKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFRyYWNrLktpbmQuVmlkZW86XG4gICAgICAgIHRoaXMudmlkZW9UcmFja3Muc2V0KHB1YmxpY2F0aW9uLnRyYWNrU2lkLCBwdWJsaWNhdGlvbik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCB0eXBlIFBhcnRpY2lwYW50RXZlbnRDYWxsYmFja3MgPSB7XG4gIHRyYWNrUHVibGlzaGVkOiAocHVibGljYXRpb246IFJlbW90ZVRyYWNrUHVibGljYXRpb24pID0+IHZvaWQ7XG4gIHRyYWNrU3Vic2NyaWJlZDogKHRyYWNrOiBSZW1vdGVUcmFjaywgcHVibGljYXRpb246IFJlbW90ZVRyYWNrUHVibGljYXRpb24pID0+IHZvaWQ7XG4gIHRyYWNrU3Vic2NyaXB0aW9uRmFpbGVkOiAodHJhY2tTaWQ6IHN0cmluZywgcmVhc29uPzogU3Vic2NyaXB0aW9uRXJyb3IpID0+IHZvaWQ7XG4gIHRyYWNrVW5wdWJsaXNoZWQ6IChwdWJsaWNhdGlvbjogUmVtb3RlVHJhY2tQdWJsaWNhdGlvbikgPT4gdm9pZDtcbiAgdHJhY2tVbnN1YnNjcmliZWQ6ICh0cmFjazogUmVtb3RlVHJhY2ssIHB1YmxpY2F0aW9uOiBSZW1vdGVUcmFja1B1YmxpY2F0aW9uKSA9PiB2b2lkO1xuICB0cmFja011dGVkOiAocHVibGljYXRpb246IFRyYWNrUHVibGljYXRpb24pID0+IHZvaWQ7XG4gIHRyYWNrVW5tdXRlZDogKHB1YmxpY2F0aW9uOiBUcmFja1B1YmxpY2F0aW9uKSA9PiB2b2lkO1xuICBsb2NhbFRyYWNrUHVibGlzaGVkOiAocHVibGljYXRpb246IExvY2FsVHJhY2tQdWJsaWNhdGlvbikgPT4gdm9pZDtcbiAgbG9jYWxUcmFja1VucHVibGlzaGVkOiAocHVibGljYXRpb246IExvY2FsVHJhY2tQdWJsaWNhdGlvbikgPT4gdm9pZDtcbiAgcGFydGljaXBhbnRNZXRhZGF0YUNoYW5nZWQ6IChwcmV2TWV0YWRhdGE6IHN0cmluZyB8IHVuZGVmaW5lZCwgcGFydGljaXBhbnQ/OiBhbnkpID0+IHZvaWQ7XG4gIHBhcnRpY2lwYW50TmFtZUNoYW5nZWQ6IChuYW1lOiBzdHJpbmcpID0+IHZvaWQ7XG4gIGRhdGFSZWNlaXZlZDogKHBheWxvYWQ6IFVpbnQ4QXJyYXksIGtpbmQ6IERhdGFQYWNrZXRfS2luZCkgPT4gdm9pZDtcbiAgaXNTcGVha2luZ0NoYW5nZWQ6IChzcGVha2luZzogYm9vbGVhbikgPT4gdm9pZDtcbiAgY29ubmVjdGlvblF1YWxpdHlDaGFuZ2VkOiAoY29ubmVjdGlvblF1YWxpdHk6IENvbm5lY3Rpb25RdWFsaXR5KSA9PiB2b2lkO1xuICB0cmFja1N0cmVhbVN0YXRlQ2hhbmdlZDogKFxuICAgIHB1YmxpY2F0aW9uOiBSZW1vdGVUcmFja1B1YmxpY2F0aW9uLFxuICAgIHN0cmVhbVN0YXRlOiBUcmFjay5TdHJlYW1TdGF0ZSxcbiAgKSA9PiB2b2lkO1xuICB0cmFja1N1YnNjcmlwdGlvblBlcm1pc3Npb25DaGFuZ2VkOiAoXG4gICAgcHVibGljYXRpb246IFJlbW90ZVRyYWNrUHVibGljYXRpb24sXG4gICAgc3RhdHVzOiBUcmFja1B1YmxpY2F0aW9uLlBlcm1pc3Npb25TdGF0dXMsXG4gICkgPT4gdm9pZDtcbiAgbWVkaWFEZXZpY2VzRXJyb3I6IChlcnJvcjogRXJyb3IpID0+IHZvaWQ7XG4gIGF1ZGlvU3RyZWFtQWNxdWlyZWQ6ICgpID0+IHZvaWQ7XG4gIHBhcnRpY2lwYW50UGVybWlzc2lvbnNDaGFuZ2VkOiAocHJldlBlcm1pc3Npb25zPzogUGFydGljaXBhbnRQZXJtaXNzaW9uKSA9PiB2b2lkO1xuICB0cmFja1N1YnNjcmlwdGlvblN0YXR1c0NoYW5nZWQ6IChcbiAgICBwdWJsaWNhdGlvbjogUmVtb3RlVHJhY2tQdWJsaWNhdGlvbixcbiAgICBzdGF0dXM6IFRyYWNrUHVibGljYXRpb24uU3Vic2NyaXB0aW9uU3RhdHVzLFxuICApID0+IHZvaWQ7XG59O1xuIiwiaW1wb3J0IHsgVHJhY2tQZXJtaXNzaW9uIH0gZnJvbSAnLi4vLi4vcHJvdG8vbGl2ZWtpdF9ydGNfcGInO1xuXG5leHBvcnQgaW50ZXJmYWNlIFBhcnRpY2lwYW50VHJhY2tQZXJtaXNzaW9uIHtcbiAgLyoqXG4gICAqIFRoZSBwYXJ0aWNpcGFudCBpZGVudGl0eSB0aGlzIHBlcm1pc3Npb24gYXBwbGllcyB0by5cbiAgICogWW91IGNhbiBlaXRoZXIgcHJvdmlkZSB0aGlzIG9yIGBwYXJ0aWNpcGFudFNpZGBcbiAgICovXG4gIHBhcnRpY2lwYW50SWRlbnRpdHk/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBwYXJ0aWNpcGFudCBzZXJ2ZXIgaWQgdGhpcyBwZXJtaXNzaW9uIGFwcGxpZXMgdG8uXG4gICAqIFlvdSBjYW4gZWl0aGVyIHByb3ZpZGUgdGhpcyBvciBgcGFydGljaXBhbnRJZGVudGl0eWBcbiAgICovXG4gIHBhcnRpY2lwYW50U2lkPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBHcmFudCBwZXJtaXNzaW9uIHRvIGFsbCBhbGwgdHJhY2tzLiBUYWtlcyBwcmVjZWRlbmNlIG92ZXIgYWxsb3dlZFRyYWNrU2lkcy5cbiAgICogZmFsc2UgaWYgdW5zZXQuXG4gICAqL1xuICBhbGxvd0FsbD86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIFRoZSBsaXN0IG9mIHRyYWNrIGlkcyB0aGF0IHRoZSB0YXJnZXQgcGFydGljaXBhbnQgY2FuIHN1YnNjcmliZSB0by5cbiAgICogV2hlbiB1bnNldCwgaXQnbGwgYWxsb3cgYWxsIHRyYWNrcyB0byBiZSBzdWJzY3JpYmVkIGJ5IHRoZSBwYXJ0aWNpcGFudC5cbiAgICogV2hlbiBlbXB0eSwgdGhpcyBwYXJ0aWNpcGFudCBpcyBkaXNhbGxvd2VkIGZyb20gc3Vic2NyaWJpbmcgdG8gYW55IHRyYWNrcy5cbiAgICovXG4gIGFsbG93ZWRUcmFja1NpZHM/OiBzdHJpbmdbXTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRyYWNrUGVybWlzc2lvblRvUHJvdG8ocGVybXM6IFBhcnRpY2lwYW50VHJhY2tQZXJtaXNzaW9uKTogVHJhY2tQZXJtaXNzaW9uIHtcbiAgaWYgKCFwZXJtcy5wYXJ0aWNpcGFudFNpZCAmJiAhcGVybXMucGFydGljaXBhbnRJZGVudGl0eSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdJbnZhbGlkIHRyYWNrIHBlcm1pc3Npb24sIG11c3QgcHJvdmlkZSBhdCBsZWFzdCBvbmUgb2YgcGFydGljaXBhbnRJZGVudGl0eSBhbmQgcGFydGljaXBhbnRTaWQnLFxuICAgICk7XG4gIH1cbiAgcmV0dXJuIG5ldyBUcmFja1Blcm1pc3Npb24oe1xuICAgIHBhcnRpY2lwYW50SWRlbnRpdHk6IHBlcm1zLnBhcnRpY2lwYW50SWRlbnRpdHkgPz8gJycsXG4gICAgcGFydGljaXBhbnRTaWQ6IHBlcm1zLnBhcnRpY2lwYW50U2lkID8/ICcnLFxuICAgIGFsbFRyYWNrczogcGVybXMuYWxsb3dBbGwgPz8gZmFsc2UsXG4gICAgdHJhY2tTaWRzOiBwZXJtcy5hbGxvd2VkVHJhY2tTaWRzIHx8IFtdLFxuICB9KTtcbn1cbiIsImltcG9ydCB7XG4gIFBhcnRpY2lwYW50VHJhY2tzLFxuICBTdWJzY3JpcHRpb25FcnJvcixcbiAgVHJhY2tJbmZvLFxuICBWaWRlb1F1YWxpdHksXG59IGZyb20gJy4uLy4uL3Byb3RvL2xpdmVraXRfbW9kZWxzX3BiJztcbmltcG9ydCB7IFVwZGF0ZVN1YnNjcmlwdGlvbiwgVXBkYXRlVHJhY2tTZXR0aW5ncyB9IGZyb20gJy4uLy4uL3Byb3RvL2xpdmVraXRfcnRjX3BiJztcbmltcG9ydCB7IFRyYWNrRXZlbnQgfSBmcm9tICcuLi9ldmVudHMnO1xuaW1wb3J0IHR5cGUgeyBMb2dnZXJPcHRpb25zIH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHR5cGUgUmVtb3RlVHJhY2sgZnJvbSAnLi9SZW1vdGVUcmFjayc7XG5pbXBvcnQgUmVtb3RlVmlkZW9UcmFjayBmcm9tICcuL1JlbW90ZVZpZGVvVHJhY2snO1xuaW1wb3J0IHsgVHJhY2sgfSBmcm9tICcuL1RyYWNrJztcbmltcG9ydCB7IFRyYWNrUHVibGljYXRpb24gfSBmcm9tICcuL1RyYWNrUHVibGljYXRpb24nO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZW1vdGVUcmFja1B1YmxpY2F0aW9uIGV4dGVuZHMgVHJhY2tQdWJsaWNhdGlvbiB7XG4gIHRyYWNrPzogUmVtb3RlVHJhY2sgPSB1bmRlZmluZWQ7XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBwcm90ZWN0ZWQgYWxsb3dlZCA9IHRydWU7XG5cbiAgLy8ga2VlcHMgdHJhY2sgb2YgY2xpZW50J3MgZGVzaXJlIHRvIHN1YnNjcmliZSB0byBhIHRyYWNrLCBhbHNvIHRydWUgaWYgYXV0b1N1YnNjcmliZSBpcyBhY3RpdmVcbiAgcHJvdGVjdGVkIHN1YnNjcmliZWQ/OiBib29sZWFuO1xuXG4gIHByb3RlY3RlZCBkaXNhYmxlZDogYm9vbGVhbiA9IGZhbHNlO1xuXG4gIHByb3RlY3RlZCBjdXJyZW50VmlkZW9RdWFsaXR5PzogVmlkZW9RdWFsaXR5ID0gVmlkZW9RdWFsaXR5LkhJR0g7XG5cbiAgcHJvdGVjdGVkIHZpZGVvRGltZW5zaW9ucz86IFRyYWNrLkRpbWVuc2lvbnM7XG5cbiAgcHJvdGVjdGVkIGZwcz86IG51bWJlcjtcblxuICBwcm90ZWN0ZWQgc3Vic2NyaXB0aW9uRXJyb3I/OiBTdWJzY3JpcHRpb25FcnJvcjtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBraW5kOiBUcmFjay5LaW5kLFxuICAgIHRpOiBUcmFja0luZm8sXG4gICAgYXV0b1N1YnNjcmliZTogYm9vbGVhbiB8IHVuZGVmaW5lZCxcbiAgICBsb2dnZXJPcHRpb25zPzogTG9nZ2VyT3B0aW9ucyxcbiAgKSB7XG4gICAgc3VwZXIoa2luZCwgdGkuc2lkLCB0aS5uYW1lLCBsb2dnZXJPcHRpb25zKTtcbiAgICB0aGlzLnN1YnNjcmliZWQgPSBhdXRvU3Vic2NyaWJlO1xuICAgIHRoaXMudXBkYXRlSW5mbyh0aSk7XG4gIH1cblxuICAvKipcbiAgICogU3Vic2NyaWJlIG9yIHVuc3Vic2NyaWJlIHRvIHRoaXMgcmVtb3RlIHRyYWNrXG4gICAqIEBwYXJhbSBzdWJzY3JpYmVkIHRydWUgdG8gc3Vic2NyaWJlIHRvIGEgdHJhY2ssIGZhbHNlIHRvIHVuc3Vic2NyaWJlXG4gICAqL1xuICBzZXRTdWJzY3JpYmVkKHN1YnNjcmliZWQ6IGJvb2xlYW4pIHtcbiAgICBjb25zdCBwcmV2U3RhdHVzID0gdGhpcy5zdWJzY3JpcHRpb25TdGF0dXM7XG4gICAgY29uc3QgcHJldlBlcm1pc3Npb24gPSB0aGlzLnBlcm1pc3Npb25TdGF0dXM7XG4gICAgdGhpcy5zdWJzY3JpYmVkID0gc3Vic2NyaWJlZDtcbiAgICAvLyByZXNldCBhbGxvd2VkIHN0YXR1cyB3aGVuIGRlc2lyZWQgc3Vic2NyaXB0aW9uIHN0YXRlIGNoYW5nZXNcbiAgICAvLyBzZXJ2ZXIgd2lsbCBub3RpZnkgY2xpZW50IHZpYSBzaWduYWwgbWVzc2FnZSBpZiBpdCdzIG5vdCBhbGxvd2VkXG4gICAgaWYgKHN1YnNjcmliZWQpIHtcbiAgICAgIHRoaXMuYWxsb3dlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgY29uc3Qgc3ViID0gbmV3IFVwZGF0ZVN1YnNjcmlwdGlvbih7XG4gICAgICB0cmFja1NpZHM6IFt0aGlzLnRyYWNrU2lkXSxcbiAgICAgIHN1YnNjcmliZTogdGhpcy5zdWJzY3JpYmVkLFxuICAgICAgcGFydGljaXBhbnRUcmFja3M6IFtcbiAgICAgICAgbmV3IFBhcnRpY2lwYW50VHJhY2tzKHtcbiAgICAgICAgICAvLyBzZW5kaW5nIGFuIGVtcHR5IHBhcnRpY2lwYW50IGlkIHNpbmNlIFRyYWNrUHVibGljYXRpb24gZG9lc24ndCBrZWVwIGl0XG4gICAgICAgICAgLy8gdGhpcyBpcyBmaWxsZWQgaW4gYnkgdGhlIHBhcnRpY2lwYW50IHRoYXQgcmVjZWl2ZXMgdGhpcyBtZXNzYWdlXG4gICAgICAgICAgcGFydGljaXBhbnRTaWQ6ICcnLFxuICAgICAgICAgIHRyYWNrU2lkczogW3RoaXMudHJhY2tTaWRdLFxuICAgICAgICB9KSxcbiAgICAgIF0sXG4gICAgfSk7XG4gICAgdGhpcy5lbWl0KFRyYWNrRXZlbnQuVXBkYXRlU3Vic2NyaXB0aW9uLCBzdWIpO1xuICAgIHRoaXMuZW1pdFN1YnNjcmlwdGlvblVwZGF0ZUlmQ2hhbmdlZChwcmV2U3RhdHVzKTtcbiAgICB0aGlzLmVtaXRQZXJtaXNzaW9uVXBkYXRlSWZDaGFuZ2VkKHByZXZQZXJtaXNzaW9uKTtcbiAgfVxuXG4gIGdldCBzdWJzY3JpcHRpb25TdGF0dXMoKTogVHJhY2tQdWJsaWNhdGlvbi5TdWJzY3JpcHRpb25TdGF0dXMge1xuICAgIGlmICh0aGlzLnN1YnNjcmliZWQgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm4gVHJhY2tQdWJsaWNhdGlvbi5TdWJzY3JpcHRpb25TdGF0dXMuVW5zdWJzY3JpYmVkO1xuICAgIH1cbiAgICBpZiAoIXN1cGVyLmlzU3Vic2NyaWJlZCkge1xuICAgICAgcmV0dXJuIFRyYWNrUHVibGljYXRpb24uU3Vic2NyaXB0aW9uU3RhdHVzLkRlc2lyZWQ7XG4gICAgfVxuICAgIHJldHVybiBUcmFja1B1YmxpY2F0aW9uLlN1YnNjcmlwdGlvblN0YXR1cy5TdWJzY3JpYmVkO1xuICB9XG5cbiAgZ2V0IHBlcm1pc3Npb25TdGF0dXMoKTogVHJhY2tQdWJsaWNhdGlvbi5QZXJtaXNzaW9uU3RhdHVzIHtcbiAgICByZXR1cm4gdGhpcy5hbGxvd2VkXG4gICAgICA/IFRyYWNrUHVibGljYXRpb24uUGVybWlzc2lvblN0YXR1cy5BbGxvd2VkXG4gICAgICA6IFRyYWNrUHVibGljYXRpb24uUGVybWlzc2lvblN0YXR1cy5Ob3RBbGxvd2VkO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0cmFjayBpcyBzdWJzY3JpYmVkLCBhbmQgcmVhZHkgZm9yIHBsYXliYWNrXG4gICAqL1xuICBnZXQgaXNTdWJzY3JpYmVkKCk6IGJvb2xlYW4ge1xuICAgIGlmICh0aGlzLnN1YnNjcmliZWQgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBzdXBlci5pc1N1YnNjcmliZWQ7XG4gIH1cblxuICAvLyByZXR1cm5zIGNsaWVudCdzIGRlc2lyZSB0byBzdWJzY3JpYmUgdG8gYSB0cmFjaywgYWxzbyB0cnVlIGlmIGF1dG9TdWJzY3JpYmUgaXMgZW5hYmxlZFxuICBnZXQgaXNEZXNpcmVkKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLnN1YnNjcmliZWQgIT09IGZhbHNlO1xuICB9XG5cbiAgZ2V0IGlzRW5hYmxlZCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gIXRoaXMuZGlzYWJsZWQ7XG4gIH1cblxuICAvKipcbiAgICogZGlzYWJsZSBzZXJ2ZXIgZnJvbSBzZW5kaW5nIGRvd24gZGF0YSBmb3IgdGhpcyB0cmFjay4gdGhpcyBpcyB1c2VmdWwgd2hlblxuICAgKiB0aGUgcGFydGljaXBhbnQgaXMgb2ZmIHNjcmVlbiwgeW91IG1heSBkaXNhYmxlIHN0cmVhbWluZyBkb3duIHRoZWlyIHZpZGVvXG4gICAqIHRvIHJlZHVjZSBiYW5kd2lkdGggcmVxdWlyZW1lbnRzXG4gICAqIEBwYXJhbSBlbmFibGVkXG4gICAqL1xuICBzZXRFbmFibGVkKGVuYWJsZWQ6IGJvb2xlYW4pIHtcbiAgICBpZiAoIXRoaXMuaXNNYW51YWxPcGVyYXRpb25BbGxvd2VkKCkgfHwgdGhpcy5kaXNhYmxlZCA9PT0gIWVuYWJsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5kaXNhYmxlZCA9ICFlbmFibGVkO1xuXG4gICAgdGhpcy5lbWl0VHJhY2tVcGRhdGUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBmb3IgdHJhY2tzIHRoYXQgc3VwcG9ydCBzaW11bGNhc3RpbmcsIGFkanVzdCBzdWJzY3JpYmVkIHF1YWxpdHlcbiAgICpcbiAgICogVGhpcyBpbmRpY2F0ZXMgdGhlIGhpZ2hlc3QgcXVhbGl0eSB0aGUgY2xpZW50IGNhbiBhY2NlcHQuIGlmIG5ldHdvcmtcbiAgICogYmFuZHdpZHRoIGRvZXMgbm90IGFsbG93LCBzZXJ2ZXIgd2lsbCBhdXRvbWF0aWNhbGx5IHJlZHVjZSBxdWFsaXR5IHRvXG4gICAqIG9wdGltaXplIGZvciB1bmludGVycnVwdGVkIHZpZGVvXG4gICAqL1xuICBzZXRWaWRlb1F1YWxpdHkocXVhbGl0eTogVmlkZW9RdWFsaXR5KSB7XG4gICAgaWYgKCF0aGlzLmlzTWFudWFsT3BlcmF0aW9uQWxsb3dlZCgpIHx8IHRoaXMuY3VycmVudFZpZGVvUXVhbGl0eSA9PT0gcXVhbGl0eSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmN1cnJlbnRWaWRlb1F1YWxpdHkgPSBxdWFsaXR5O1xuICAgIHRoaXMudmlkZW9EaW1lbnNpb25zID0gdW5kZWZpbmVkO1xuXG4gICAgdGhpcy5lbWl0VHJhY2tVcGRhdGUoKTtcbiAgfVxuXG4gIHNldFZpZGVvRGltZW5zaW9ucyhkaW1lbnNpb25zOiBUcmFjay5EaW1lbnNpb25zKSB7XG4gICAgaWYgKCF0aGlzLmlzTWFudWFsT3BlcmF0aW9uQWxsb3dlZCgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChcbiAgICAgIHRoaXMudmlkZW9EaW1lbnNpb25zPy53aWR0aCA9PT0gZGltZW5zaW9ucy53aWR0aCAmJlxuICAgICAgdGhpcy52aWRlb0RpbWVuc2lvbnM/LmhlaWdodCA9PT0gZGltZW5zaW9ucy5oZWlnaHRcbiAgICApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMudHJhY2sgaW5zdGFuY2VvZiBSZW1vdGVWaWRlb1RyYWNrKSB7XG4gICAgICB0aGlzLnZpZGVvRGltZW5zaW9ucyA9IGRpbWVuc2lvbnM7XG4gICAgfVxuICAgIHRoaXMuY3VycmVudFZpZGVvUXVhbGl0eSA9IHVuZGVmaW5lZDtcblxuICAgIHRoaXMuZW1pdFRyYWNrVXBkYXRlKCk7XG4gIH1cblxuICBzZXRWaWRlb0ZQUyhmcHM6IG51bWJlcikge1xuICAgIGlmICghdGhpcy5pc01hbnVhbE9wZXJhdGlvbkFsbG93ZWQoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghKHRoaXMudHJhY2sgaW5zdGFuY2VvZiBSZW1vdGVWaWRlb1RyYWNrKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmZwcyA9PT0gZnBzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5mcHMgPSBmcHM7XG4gICAgdGhpcy5lbWl0VHJhY2tVcGRhdGUoKTtcbiAgfVxuXG4gIGdldCB2aWRlb1F1YWxpdHkoKTogVmlkZW9RdWFsaXR5IHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gdGhpcy5jdXJyZW50VmlkZW9RdWFsaXR5O1xuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBzZXRUcmFjayh0cmFjaz86IFJlbW90ZVRyYWNrKSB7XG4gICAgY29uc3QgcHJldlN0YXR1cyA9IHRoaXMuc3Vic2NyaXB0aW9uU3RhdHVzO1xuICAgIGNvbnN0IHByZXZQZXJtaXNzaW9uID0gdGhpcy5wZXJtaXNzaW9uU3RhdHVzO1xuICAgIGNvbnN0IHByZXZUcmFjayA9IHRoaXMudHJhY2s7XG4gICAgaWYgKHByZXZUcmFjayA9PT0gdHJhY2spIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHByZXZUcmFjaykge1xuICAgICAgLy8gdW5yZWdpc3RlciBsaXN0ZW5lclxuICAgICAgcHJldlRyYWNrLm9mZihUcmFja0V2ZW50LlZpZGVvRGltZW5zaW9uc0NoYW5nZWQsIHRoaXMuaGFuZGxlVmlkZW9EaW1lbnNpb25zQ2hhbmdlKTtcbiAgICAgIHByZXZUcmFjay5vZmYoVHJhY2tFdmVudC5WaXNpYmlsaXR5Q2hhbmdlZCwgdGhpcy5oYW5kbGVWaXNpYmlsaXR5Q2hhbmdlKTtcbiAgICAgIHByZXZUcmFjay5vZmYoVHJhY2tFdmVudC5FbmRlZCwgdGhpcy5oYW5kbGVFbmRlZCk7XG4gICAgICBwcmV2VHJhY2suZGV0YWNoKCk7XG4gICAgICBwcmV2VHJhY2suc3RvcE1vbml0b3IoKTtcbiAgICAgIHRoaXMuZW1pdChUcmFja0V2ZW50LlVuc3Vic2NyaWJlZCwgcHJldlRyYWNrKTtcbiAgICB9XG4gICAgc3VwZXIuc2V0VHJhY2sodHJhY2spO1xuICAgIGlmICh0cmFjaykge1xuICAgICAgdHJhY2suc2lkID0gdGhpcy50cmFja1NpZDtcbiAgICAgIHRyYWNrLm9uKFRyYWNrRXZlbnQuVmlkZW9EaW1lbnNpb25zQ2hhbmdlZCwgdGhpcy5oYW5kbGVWaWRlb0RpbWVuc2lvbnNDaGFuZ2UpO1xuICAgICAgdHJhY2sub24oVHJhY2tFdmVudC5WaXNpYmlsaXR5Q2hhbmdlZCwgdGhpcy5oYW5kbGVWaXNpYmlsaXR5Q2hhbmdlKTtcbiAgICAgIHRyYWNrLm9uKFRyYWNrRXZlbnQuRW5kZWQsIHRoaXMuaGFuZGxlRW5kZWQpO1xuICAgICAgdGhpcy5lbWl0KFRyYWNrRXZlbnQuU3Vic2NyaWJlZCwgdHJhY2spO1xuICAgIH1cbiAgICB0aGlzLmVtaXRQZXJtaXNzaW9uVXBkYXRlSWZDaGFuZ2VkKHByZXZQZXJtaXNzaW9uKTtcbiAgICB0aGlzLmVtaXRTdWJzY3JpcHRpb25VcGRhdGVJZkNoYW5nZWQocHJldlN0YXR1cyk7XG4gIH1cblxuICAvKiogQGludGVybmFsICovXG4gIHNldEFsbG93ZWQoYWxsb3dlZDogYm9vbGVhbikge1xuICAgIGNvbnN0IHByZXZTdGF0dXMgPSB0aGlzLnN1YnNjcmlwdGlvblN0YXR1cztcbiAgICBjb25zdCBwcmV2UGVybWlzc2lvbiA9IHRoaXMucGVybWlzc2lvblN0YXR1cztcbiAgICB0aGlzLmFsbG93ZWQgPSBhbGxvd2VkO1xuICAgIHRoaXMuZW1pdFBlcm1pc3Npb25VcGRhdGVJZkNoYW5nZWQocHJldlBlcm1pc3Npb24pO1xuICAgIHRoaXMuZW1pdFN1YnNjcmlwdGlvblVwZGF0ZUlmQ2hhbmdlZChwcmV2U3RhdHVzKTtcbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgc2V0U3Vic2NyaXB0aW9uRXJyb3IoZXJyb3I6IFN1YnNjcmlwdGlvbkVycm9yKSB7XG4gICAgdGhpcy5lbWl0KFRyYWNrRXZlbnQuU3Vic2NyaXB0aW9uRmFpbGVkLCBlcnJvcik7XG4gIH1cblxuICAvKiogQGludGVybmFsICovXG4gIHVwZGF0ZUluZm8oaW5mbzogVHJhY2tJbmZvKSB7XG4gICAgc3VwZXIudXBkYXRlSW5mbyhpbmZvKTtcbiAgICBjb25zdCBwcmV2TWV0YWRhdGFNdXRlZCA9IHRoaXMubWV0YWRhdGFNdXRlZDtcbiAgICB0aGlzLm1ldGFkYXRhTXV0ZWQgPSBpbmZvLm11dGVkO1xuICAgIGlmICh0aGlzLnRyYWNrKSB7XG4gICAgICB0aGlzLnRyYWNrLnNldE11dGVkKGluZm8ubXV0ZWQpO1xuICAgIH0gZWxzZSBpZiAocHJldk1ldGFkYXRhTXV0ZWQgIT09IGluZm8ubXV0ZWQpIHtcbiAgICAgIHRoaXMuZW1pdChpbmZvLm11dGVkID8gVHJhY2tFdmVudC5NdXRlZCA6IFRyYWNrRXZlbnQuVW5tdXRlZCk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBlbWl0U3Vic2NyaXB0aW9uVXBkYXRlSWZDaGFuZ2VkKHByZXZpb3VzU3RhdHVzOiBUcmFja1B1YmxpY2F0aW9uLlN1YnNjcmlwdGlvblN0YXR1cykge1xuICAgIGNvbnN0IGN1cnJlbnRTdGF0dXMgPSB0aGlzLnN1YnNjcmlwdGlvblN0YXR1cztcbiAgICBpZiAocHJldmlvdXNTdGF0dXMgPT09IGN1cnJlbnRTdGF0dXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5lbWl0KFRyYWNrRXZlbnQuU3Vic2NyaXB0aW9uU3RhdHVzQ2hhbmdlZCwgY3VycmVudFN0YXR1cywgcHJldmlvdXNTdGF0dXMpO1xuICB9XG5cbiAgcHJpdmF0ZSBlbWl0UGVybWlzc2lvblVwZGF0ZUlmQ2hhbmdlZChcbiAgICBwcmV2aW91c1Blcm1pc3Npb25TdGF0dXM6IFRyYWNrUHVibGljYXRpb24uUGVybWlzc2lvblN0YXR1cyxcbiAgKSB7XG4gICAgY29uc3QgY3VycmVudFBlcm1pc3Npb25TdGF0dXMgPSB0aGlzLnBlcm1pc3Npb25TdGF0dXM7XG4gICAgaWYgKGN1cnJlbnRQZXJtaXNzaW9uU3RhdHVzICE9PSBwcmV2aW91c1Blcm1pc3Npb25TdGF0dXMpIHtcbiAgICAgIHRoaXMuZW1pdChcbiAgICAgICAgVHJhY2tFdmVudC5TdWJzY3JpcHRpb25QZXJtaXNzaW9uQ2hhbmdlZCxcbiAgICAgICAgdGhpcy5wZXJtaXNzaW9uU3RhdHVzLFxuICAgICAgICBwcmV2aW91c1Blcm1pc3Npb25TdGF0dXMsXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgaXNNYW51YWxPcGVyYXRpb25BbGxvd2VkKCk6IGJvb2xlYW4ge1xuICAgIGlmICh0aGlzLmtpbmQgPT09IFRyYWNrLktpbmQuVmlkZW8gJiYgdGhpcy5pc0FkYXB0aXZlU3RyZWFtKSB7XG4gICAgICB0aGlzLmxvZy53YXJuKFxuICAgICAgICAnYWRhcHRpdmUgc3RyZWFtIGlzIGVuYWJsZWQsIGNhbm5vdCBjaGFuZ2UgdmlkZW8gdHJhY2sgc2V0dGluZ3MnLFxuICAgICAgICB0aGlzLmxvZ0NvbnRleHQsXG4gICAgICApO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuaXNEZXNpcmVkKSB7XG4gICAgICB0aGlzLmxvZy53YXJuKCdjYW5ub3QgdXBkYXRlIHRyYWNrIHNldHRpbmdzIHdoZW4gbm90IHN1YnNjcmliZWQnLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHByb3RlY3RlZCBoYW5kbGVFbmRlZCA9ICh0cmFjazogUmVtb3RlVHJhY2spID0+IHtcbiAgICB0aGlzLnNldFRyYWNrKHVuZGVmaW5lZCk7XG4gICAgdGhpcy5lbWl0KFRyYWNrRXZlbnQuRW5kZWQsIHRyYWNrKTtcbiAgfTtcblxuICBwcm90ZWN0ZWQgZ2V0IGlzQWRhcHRpdmVTdHJlYW0oKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMudHJhY2sgaW5zdGFuY2VvZiBSZW1vdGVWaWRlb1RyYWNrICYmIHRoaXMudHJhY2suaXNBZGFwdGl2ZVN0cmVhbTtcbiAgfVxuXG4gIHByb3RlY3RlZCBoYW5kbGVWaXNpYmlsaXR5Q2hhbmdlID0gKHZpc2libGU6IGJvb2xlYW4pID0+IHtcbiAgICB0aGlzLmxvZy5kZWJ1ZyhcbiAgICAgIGBhZGFwdGl2ZXN0cmVhbSB2aWRlbyB2aXNpYmlsaXR5ICR7dGhpcy50cmFja1NpZH0sIHZpc2libGU9JHt2aXNpYmxlfWAsXG4gICAgICB0aGlzLmxvZ0NvbnRleHQsXG4gICAgKTtcbiAgICB0aGlzLmRpc2FibGVkID0gIXZpc2libGU7XG4gICAgdGhpcy5lbWl0VHJhY2tVcGRhdGUoKTtcbiAgfTtcblxuICBwcm90ZWN0ZWQgaGFuZGxlVmlkZW9EaW1lbnNpb25zQ2hhbmdlID0gKGRpbWVuc2lvbnM6IFRyYWNrLkRpbWVuc2lvbnMpID0+IHtcbiAgICB0aGlzLmxvZy5kZWJ1ZyhcbiAgICAgIGBhZGFwdGl2ZXN0cmVhbSB2aWRlbyBkaW1lbnNpb25zICR7ZGltZW5zaW9ucy53aWR0aH14JHtkaW1lbnNpb25zLmhlaWdodH1gLFxuICAgICAgdGhpcy5sb2dDb250ZXh0LFxuICAgICk7XG4gICAgdGhpcy52aWRlb0RpbWVuc2lvbnMgPSBkaW1lbnNpb25zO1xuICAgIHRoaXMuZW1pdFRyYWNrVXBkYXRlKCk7XG4gIH07XG5cbiAgLyogQGludGVybmFsICovXG4gIGVtaXRUcmFja1VwZGF0ZSgpIHtcbiAgICBjb25zdCBzZXR0aW5nczogVXBkYXRlVHJhY2tTZXR0aW5ncyA9IG5ldyBVcGRhdGVUcmFja1NldHRpbmdzKHtcbiAgICAgIHRyYWNrU2lkczogW3RoaXMudHJhY2tTaWRdLFxuICAgICAgZGlzYWJsZWQ6IHRoaXMuZGlzYWJsZWQsXG4gICAgICBmcHM6IHRoaXMuZnBzLFxuICAgIH0pO1xuICAgIGlmICh0aGlzLnZpZGVvRGltZW5zaW9ucykge1xuICAgICAgc2V0dGluZ3Mud2lkdGggPSBNYXRoLmNlaWwodGhpcy52aWRlb0RpbWVuc2lvbnMud2lkdGgpO1xuICAgICAgc2V0dGluZ3MuaGVpZ2h0ID0gTWF0aC5jZWlsKHRoaXMudmlkZW9EaW1lbnNpb25zLmhlaWdodCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmN1cnJlbnRWaWRlb1F1YWxpdHkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgc2V0dGluZ3MucXVhbGl0eSA9IHRoaXMuY3VycmVudFZpZGVvUXVhbGl0eTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZGVmYXVsdHMgdG8gaGlnaCBxdWFsaXR5XG4gICAgICBzZXR0aW5ncy5xdWFsaXR5ID0gVmlkZW9RdWFsaXR5LkhJR0g7XG4gICAgfVxuXG4gICAgdGhpcy5lbWl0KFRyYWNrRXZlbnQuVXBkYXRlU2V0dGluZ3MsIHNldHRpbmdzKTtcbiAgfVxufVxuIiwiaW1wb3J0IHR5cGUgeyBTaWduYWxDbGllbnQgfSBmcm9tICcuLi8uLi9hcGkvU2lnbmFsQ2xpZW50JztcbmltcG9ydCB0eXBlIHsgUGFydGljaXBhbnRJbmZvLCBTdWJzY3JpcHRpb25FcnJvciB9IGZyb20gJy4uLy4uL3Byb3RvL2xpdmVraXRfbW9kZWxzX3BiJztcbmltcG9ydCB0eXBlIHsgVXBkYXRlU3Vic2NyaXB0aW9uLCBVcGRhdGVUcmFja1NldHRpbmdzIH0gZnJvbSAnLi4vLi4vcHJvdG8vbGl2ZWtpdF9ydGNfcGInO1xuaW1wb3J0IHsgUGFydGljaXBhbnRFdmVudCwgVHJhY2tFdmVudCB9IGZyb20gJy4uL2V2ZW50cyc7XG5pbXBvcnQgUmVtb3RlQXVkaW9UcmFjayBmcm9tICcuLi90cmFjay9SZW1vdGVBdWRpb1RyYWNrJztcbmltcG9ydCB0eXBlIFJlbW90ZVRyYWNrIGZyb20gJy4uL3RyYWNrL1JlbW90ZVRyYWNrJztcbmltcG9ydCBSZW1vdGVUcmFja1B1YmxpY2F0aW9uIGZyb20gJy4uL3RyYWNrL1JlbW90ZVRyYWNrUHVibGljYXRpb24nO1xuaW1wb3J0IFJlbW90ZVZpZGVvVHJhY2sgZnJvbSAnLi4vdHJhY2svUmVtb3RlVmlkZW9UcmFjayc7XG5pbXBvcnQgeyBUcmFjayB9IGZyb20gJy4uL3RyYWNrL1RyYWNrJztcbmltcG9ydCB0eXBlIHsgVHJhY2tQdWJsaWNhdGlvbiB9IGZyb20gJy4uL3RyYWNrL1RyYWNrUHVibGljYXRpb24nO1xuaW1wb3J0IHR5cGUgeyBBdWRpb091dHB1dE9wdGlvbnMgfSBmcm9tICcuLi90cmFjay9vcHRpb25zJztcbmltcG9ydCB0eXBlIHsgQWRhcHRpdmVTdHJlYW1TZXR0aW5ncyB9IGZyb20gJy4uL3RyYWNrL3R5cGVzJztcbmltcG9ydCB7IGdldExvZ0NvbnRleHRGcm9tVHJhY2sgfSBmcm9tICcuLi90cmFjay91dGlscyc7XG5pbXBvcnQgdHlwZSB7IExvZ2dlck9wdGlvbnMgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgUGFydGljaXBhbnQgZnJvbSAnLi9QYXJ0aWNpcGFudCc7XG5pbXBvcnQgdHlwZSB7IFBhcnRpY2lwYW50RXZlbnRDYWxsYmFja3MgfSBmcm9tICcuL1BhcnRpY2lwYW50JztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmVtb3RlUGFydGljaXBhbnQgZXh0ZW5kcyBQYXJ0aWNpcGFudCB7XG4gIGF1ZGlvVHJhY2tzOiBNYXA8c3RyaW5nLCBSZW1vdGVUcmFja1B1YmxpY2F0aW9uPjtcblxuICB2aWRlb1RyYWNrczogTWFwPHN0cmluZywgUmVtb3RlVHJhY2tQdWJsaWNhdGlvbj47XG5cbiAgdHJhY2tzOiBNYXA8c3RyaW5nLCBSZW1vdGVUcmFja1B1YmxpY2F0aW9uPjtcblxuICBzaWduYWxDbGllbnQ6IFNpZ25hbENsaWVudDtcblxuICBwcml2YXRlIHZvbHVtZU1hcDogTWFwPFRyYWNrLlNvdXJjZSwgbnVtYmVyPjtcblxuICBwcml2YXRlIGF1ZGlvT3V0cHV0PzogQXVkaW9PdXRwdXRPcHRpb25zO1xuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgc3RhdGljIGZyb21QYXJ0aWNpcGFudEluZm8oc2lnbmFsQ2xpZW50OiBTaWduYWxDbGllbnQsIHBpOiBQYXJ0aWNpcGFudEluZm8pOiBSZW1vdGVQYXJ0aWNpcGFudCB7XG4gICAgcmV0dXJuIG5ldyBSZW1vdGVQYXJ0aWNpcGFudChzaWduYWxDbGllbnQsIHBpLnNpZCwgcGkuaWRlbnRpdHksIHBpLm5hbWUsIHBpLm1ldGFkYXRhKTtcbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgY29uc3RydWN0b3IoXG4gICAgc2lnbmFsQ2xpZW50OiBTaWduYWxDbGllbnQsXG4gICAgc2lkOiBzdHJpbmcsXG4gICAgaWRlbnRpdHk/OiBzdHJpbmcsXG4gICAgbmFtZT86IHN0cmluZyxcbiAgICBtZXRhZGF0YT86IHN0cmluZyxcbiAgICBsb2dnZXJPcHRpb25zPzogTG9nZ2VyT3B0aW9ucyxcbiAgKSB7XG4gICAgc3VwZXIoc2lkLCBpZGVudGl0eSB8fCAnJywgbmFtZSwgbWV0YWRhdGEsIGxvZ2dlck9wdGlvbnMpO1xuICAgIHRoaXMuc2lnbmFsQ2xpZW50ID0gc2lnbmFsQ2xpZW50O1xuICAgIHRoaXMudHJhY2tzID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuYXVkaW9UcmFja3MgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy52aWRlb1RyYWNrcyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLnZvbHVtZU1hcCA9IG5ldyBNYXAoKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBhZGRUcmFja1B1YmxpY2F0aW9uKHB1YmxpY2F0aW9uOiBSZW1vdGVUcmFja1B1YmxpY2F0aW9uKSB7XG4gICAgc3VwZXIuYWRkVHJhY2tQdWJsaWNhdGlvbihwdWJsaWNhdGlvbik7XG5cbiAgICAvLyByZWdpc3RlciBhY3Rpb24gZXZlbnRzXG4gICAgcHVibGljYXRpb24ub24oVHJhY2tFdmVudC5VcGRhdGVTZXR0aW5ncywgKHNldHRpbmdzOiBVcGRhdGVUcmFja1NldHRpbmdzKSA9PiB7XG4gICAgICB0aGlzLmxvZy5kZWJ1Zygnc2VuZCB1cGRhdGUgc2V0dGluZ3MnLCB7XG4gICAgICAgIC4uLnRoaXMubG9nQ29udGV4dCxcbiAgICAgICAgLi4uZ2V0TG9nQ29udGV4dEZyb21UcmFjayhwdWJsaWNhdGlvbiksXG4gICAgICB9KTtcbiAgICAgIHRoaXMuc2lnbmFsQ2xpZW50LnNlbmRVcGRhdGVUcmFja1NldHRpbmdzKHNldHRpbmdzKTtcbiAgICB9KTtcbiAgICBwdWJsaWNhdGlvbi5vbihUcmFja0V2ZW50LlVwZGF0ZVN1YnNjcmlwdGlvbiwgKHN1YjogVXBkYXRlU3Vic2NyaXB0aW9uKSA9PiB7XG4gICAgICBzdWIucGFydGljaXBhbnRUcmFja3MuZm9yRWFjaCgocHQpID0+IHtcbiAgICAgICAgcHQucGFydGljaXBhbnRTaWQgPSB0aGlzLnNpZDtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5zaWduYWxDbGllbnQuc2VuZFVwZGF0ZVN1YnNjcmlwdGlvbihzdWIpO1xuICAgIH0pO1xuICAgIHB1YmxpY2F0aW9uLm9uKFxuICAgICAgVHJhY2tFdmVudC5TdWJzY3JpcHRpb25QZXJtaXNzaW9uQ2hhbmdlZCxcbiAgICAgIChzdGF0dXM6IFRyYWNrUHVibGljYXRpb24uUGVybWlzc2lvblN0YXR1cykgPT4ge1xuICAgICAgICB0aGlzLmVtaXQoUGFydGljaXBhbnRFdmVudC5UcmFja1N1YnNjcmlwdGlvblBlcm1pc3Npb25DaGFuZ2VkLCBwdWJsaWNhdGlvbiwgc3RhdHVzKTtcbiAgICAgIH0sXG4gICAgKTtcbiAgICBwdWJsaWNhdGlvbi5vbihcbiAgICAgIFRyYWNrRXZlbnQuU3Vic2NyaXB0aW9uU3RhdHVzQ2hhbmdlZCxcbiAgICAgIChzdGF0dXM6IFRyYWNrUHVibGljYXRpb24uU3Vic2NyaXB0aW9uU3RhdHVzKSA9PiB7XG4gICAgICAgIHRoaXMuZW1pdChQYXJ0aWNpcGFudEV2ZW50LlRyYWNrU3Vic2NyaXB0aW9uU3RhdHVzQ2hhbmdlZCwgcHVibGljYXRpb24sIHN0YXR1cyk7XG4gICAgICB9LFxuICAgICk7XG4gICAgcHVibGljYXRpb24ub24oVHJhY2tFdmVudC5TdWJzY3JpYmVkLCAodHJhY2s6IFJlbW90ZVRyYWNrKSA9PiB7XG4gICAgICB0aGlzLmVtaXQoUGFydGljaXBhbnRFdmVudC5UcmFja1N1YnNjcmliZWQsIHRyYWNrLCBwdWJsaWNhdGlvbik7XG4gICAgfSk7XG4gICAgcHVibGljYXRpb24ub24oVHJhY2tFdmVudC5VbnN1YnNjcmliZWQsIChwcmV2aW91c1RyYWNrOiBSZW1vdGVUcmFjaykgPT4ge1xuICAgICAgdGhpcy5lbWl0KFBhcnRpY2lwYW50RXZlbnQuVHJhY2tVbnN1YnNjcmliZWQsIHByZXZpb3VzVHJhY2ssIHB1YmxpY2F0aW9uKTtcbiAgICB9KTtcbiAgICBwdWJsaWNhdGlvbi5vbihUcmFja0V2ZW50LlN1YnNjcmlwdGlvbkZhaWxlZCwgKGVycm9yOiBTdWJzY3JpcHRpb25FcnJvcikgPT4ge1xuICAgICAgdGhpcy5lbWl0KFBhcnRpY2lwYW50RXZlbnQuVHJhY2tTdWJzY3JpcHRpb25GYWlsZWQsIHB1YmxpY2F0aW9uLnRyYWNrU2lkLCBlcnJvcik7XG4gICAgfSk7XG4gIH1cblxuICBnZXRUcmFjayhzb3VyY2U6IFRyYWNrLlNvdXJjZSk6IFJlbW90ZVRyYWNrUHVibGljYXRpb24gfCB1bmRlZmluZWQge1xuICAgIGNvbnN0IHRyYWNrID0gc3VwZXIuZ2V0VHJhY2soc291cmNlKTtcbiAgICBpZiAodHJhY2spIHtcbiAgICAgIHJldHVybiB0cmFjayBhcyBSZW1vdGVUcmFja1B1YmxpY2F0aW9uO1xuICAgIH1cbiAgfVxuXG4gIGdldFRyYWNrQnlOYW1lKG5hbWU6IHN0cmluZyk6IFJlbW90ZVRyYWNrUHVibGljYXRpb24gfCB1bmRlZmluZWQge1xuICAgIGNvbnN0IHRyYWNrID0gc3VwZXIuZ2V0VHJhY2tCeU5hbWUobmFtZSk7XG4gICAgaWYgKHRyYWNrKSB7XG4gICAgICByZXR1cm4gdHJhY2sgYXMgUmVtb3RlVHJhY2tQdWJsaWNhdGlvbjtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogc2V0cyB0aGUgdm9sdW1lIG9uIHRoZSBwYXJ0aWNpcGFudCdzIGF1ZGlvIHRyYWNrXG4gICAqIGJ5IGRlZmF1bHQsIHRoaXMgYWZmZWN0cyB0aGUgbWljcm9waG9uZSBwdWJsaWNhdGlvblxuICAgKiBhIGRpZmZlcmVudCBzb3VyY2UgY2FuIGJlIHBhc3NlZCBpbiBhcyBhIHNlY29uZCBhcmd1bWVudFxuICAgKiBpZiBubyB0cmFjayBleGlzdHMgdGhlIHZvbHVtZSB3aWxsIGJlIGFwcGxpZWQgd2hlbiB0aGUgbWljcm9waG9uZSB0cmFjayBpcyBhZGRlZFxuICAgKi9cbiAgc2V0Vm9sdW1lKFxuICAgIHZvbHVtZTogbnVtYmVyLFxuICAgIHNvdXJjZTogVHJhY2suU291cmNlLk1pY3JvcGhvbmUgfCBUcmFjay5Tb3VyY2UuU2NyZWVuU2hhcmVBdWRpbyA9IFRyYWNrLlNvdXJjZS5NaWNyb3Bob25lLFxuICApIHtcbiAgICB0aGlzLnZvbHVtZU1hcC5zZXQoc291cmNlLCB2b2x1bWUpO1xuICAgIGNvbnN0IGF1ZGlvUHVibGljYXRpb24gPSB0aGlzLmdldFRyYWNrKHNvdXJjZSk7XG4gICAgaWYgKGF1ZGlvUHVibGljYXRpb24gJiYgYXVkaW9QdWJsaWNhdGlvbi50cmFjaykge1xuICAgICAgKGF1ZGlvUHVibGljYXRpb24udHJhY2sgYXMgUmVtb3RlQXVkaW9UcmFjaykuc2V0Vm9sdW1lKHZvbHVtZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIGdldHMgdGhlIHZvbHVtZSBvbiB0aGUgcGFydGljaXBhbnQncyBtaWNyb3Bob25lIHRyYWNrXG4gICAqL1xuICBnZXRWb2x1bWUoXG4gICAgc291cmNlOiBUcmFjay5Tb3VyY2UuTWljcm9waG9uZSB8IFRyYWNrLlNvdXJjZS5TY3JlZW5TaGFyZUF1ZGlvID0gVHJhY2suU291cmNlLk1pY3JvcGhvbmUsXG4gICkge1xuICAgIGNvbnN0IGF1ZGlvUHVibGljYXRpb24gPSB0aGlzLmdldFRyYWNrKHNvdXJjZSk7XG4gICAgaWYgKGF1ZGlvUHVibGljYXRpb24gJiYgYXVkaW9QdWJsaWNhdGlvbi50cmFjaykge1xuICAgICAgcmV0dXJuIChhdWRpb1B1YmxpY2F0aW9uLnRyYWNrIGFzIFJlbW90ZUF1ZGlvVHJhY2spLmdldFZvbHVtZSgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy52b2x1bWVNYXAuZ2V0KHNvdXJjZSk7XG4gIH1cblxuICAvKiogQGludGVybmFsICovXG4gIGFkZFN1YnNjcmliZWRNZWRpYVRyYWNrKFxuICAgIG1lZGlhVHJhY2s6IE1lZGlhU3RyZWFtVHJhY2ssXG4gICAgc2lkOiBUcmFjay5TSUQsXG4gICAgbWVkaWFTdHJlYW06IE1lZGlhU3RyZWFtLFxuICAgIHJlY2VpdmVyPzogUlRDUnRwUmVjZWl2ZXIsXG4gICAgYWRhcHRpdmVTdHJlYW1TZXR0aW5ncz86IEFkYXB0aXZlU3RyZWFtU2V0dGluZ3MsXG4gICAgdHJpZXNMZWZ0PzogbnVtYmVyLFxuICApIHtcbiAgICAvLyBmaW5kIHRoZSB0cmFjayBwdWJsaWNhdGlvblxuICAgIC8vIGl0J3MgcG9zc2libGUgZm9yIHRoZSBtZWRpYSB0cmFjayB0byBhcnJpdmUgYmVmb3JlIHBhcnRpY2lwYW50IGluZm9cbiAgICBsZXQgcHVibGljYXRpb24gPSB0aGlzLmdldFRyYWNrUHVibGljYXRpb24oc2lkKTtcblxuICAgIC8vIGl0J3MgYWxzbyBwb3NzaWJsZSB0aGF0IHRoZSBicm93c2VyIGRpZG4ndCBob25vciBvdXIgb3JpZ2luYWwgdHJhY2sgaWRcbiAgICAvLyBGaXJlRm94IHdvdWxkIHVzZSBpdHMgb3duIGxvY2FsIHV1aWQgaW5zdGVhZCBvZiBzZXJ2ZXIgdHJhY2sgaWRcbiAgICBpZiAoIXB1YmxpY2F0aW9uKSB7XG4gICAgICBpZiAoIXNpZC5zdGFydHNXaXRoKCdUUicpKSB7XG4gICAgICAgIC8vIGZpbmQgdGhlIGZpcnN0IHRyYWNrIHRoYXQgbWF0Y2hlcyB0eXBlXG4gICAgICAgIHRoaXMudHJhY2tzLmZvckVhY2goKHApID0+IHtcbiAgICAgICAgICBpZiAoIXB1YmxpY2F0aW9uICYmIG1lZGlhVHJhY2sua2luZCA9PT0gcC5raW5kLnRvU3RyaW5nKCkpIHtcbiAgICAgICAgICAgIHB1YmxpY2F0aW9uID0gcDtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHdoZW4gd2UgY291bGRuJ3QgbG9jYXRlIHRoZSB0cmFjaywgaXQncyBwb3NzaWJsZSB0aGF0IHRoZSBtZXRhZGF0YSBoYXNuJ3RcbiAgICAvLyB5ZXQgYXJyaXZlZC4gV2FpdCBhIGJpdCBsb25nZXIgZm9yIGl0IHRvIGFycml2ZSwgb3IgZmlyZSBhbiBlcnJvclxuICAgIGlmICghcHVibGljYXRpb24pIHtcbiAgICAgIGlmICh0cmllc0xlZnQgPT09IDApIHtcbiAgICAgICAgdGhpcy5sb2cuZXJyb3IoJ2NvdWxkIG5vdCBmaW5kIHB1Ymxpc2hlZCB0cmFjaycsIHtcbiAgICAgICAgICAuLi50aGlzLmxvZ0NvbnRleHQsXG4gICAgICAgICAgdHJhY2tTaWQ6IHNpZCxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZW1pdChQYXJ0aWNpcGFudEV2ZW50LlRyYWNrU3Vic2NyaXB0aW9uRmFpbGVkLCBzaWQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICh0cmllc0xlZnQgPT09IHVuZGVmaW5lZCkgdHJpZXNMZWZ0ID0gMjA7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGhpcy5hZGRTdWJzY3JpYmVkTWVkaWFUcmFjayhcbiAgICAgICAgICBtZWRpYVRyYWNrLFxuICAgICAgICAgIHNpZCxcbiAgICAgICAgICBtZWRpYVN0cmVhbSxcbiAgICAgICAgICByZWNlaXZlcixcbiAgICAgICAgICBhZGFwdGl2ZVN0cmVhbVNldHRpbmdzLFxuICAgICAgICAgIHRyaWVzTGVmdCEgLSAxLFxuICAgICAgICApO1xuICAgICAgfSwgMTUwKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAobWVkaWFUcmFjay5yZWFkeVN0YXRlID09PSAnZW5kZWQnKSB7XG4gICAgICB0aGlzLmxvZy5lcnJvcihcbiAgICAgICAgJ3VuYWJsZSB0byBzdWJzY3JpYmUgYmVjYXVzZSBNZWRpYVN0cmVhbVRyYWNrIGlzIGVuZGVkLiBEbyBub3QgY2FsbCBNZWRpYVN0cmVhbVRyYWNrLnN0b3AoKScsXG4gICAgICAgIHsgLi4udGhpcy5sb2dDb250ZXh0LCAuLi5nZXRMb2dDb250ZXh0RnJvbVRyYWNrKHB1YmxpY2F0aW9uKSB9LFxuICAgICAgKTtcbiAgICAgIHRoaXMuZW1pdChQYXJ0aWNpcGFudEV2ZW50LlRyYWNrU3Vic2NyaXB0aW9uRmFpbGVkLCBzaWQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGlzVmlkZW8gPSBtZWRpYVRyYWNrLmtpbmQgPT09ICd2aWRlbyc7XG4gICAgbGV0IHRyYWNrOiBSZW1vdGVUcmFjaztcbiAgICBpZiAoaXNWaWRlbykge1xuICAgICAgdHJhY2sgPSBuZXcgUmVtb3RlVmlkZW9UcmFjayhtZWRpYVRyYWNrLCBzaWQsIHJlY2VpdmVyLCBhZGFwdGl2ZVN0cmVhbVNldHRpbmdzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdHJhY2sgPSBuZXcgUmVtb3RlQXVkaW9UcmFjayhtZWRpYVRyYWNrLCBzaWQsIHJlY2VpdmVyLCB0aGlzLmF1ZGlvQ29udGV4dCwgdGhpcy5hdWRpb091dHB1dCk7XG4gICAgfVxuXG4gICAgLy8gc2V0IHRyYWNrIGluZm9cbiAgICB0cmFjay5zb3VyY2UgPSBwdWJsaWNhdGlvbi5zb3VyY2U7XG4gICAgLy8ga2VlcCBwdWJsaWNhdGlvbidzIG11dGVkIHN0YXR1c1xuICAgIHRyYWNrLmlzTXV0ZWQgPSBwdWJsaWNhdGlvbi5pc011dGVkO1xuICAgIHRyYWNrLnNldE1lZGlhU3RyZWFtKG1lZGlhU3RyZWFtKTtcbiAgICB0cmFjay5zdGFydCgpO1xuXG4gICAgcHVibGljYXRpb24uc2V0VHJhY2sodHJhY2spO1xuICAgIC8vIHNldCBwYXJ0aWNpcGFudCB2b2x1bWVzIG9uIG5ldyBhdWRpbyB0cmFja3NcbiAgICBpZiAodGhpcy52b2x1bWVNYXAuaGFzKHB1YmxpY2F0aW9uLnNvdXJjZSkgJiYgdHJhY2sgaW5zdGFuY2VvZiBSZW1vdGVBdWRpb1RyYWNrKSB7XG4gICAgICB0cmFjay5zZXRWb2x1bWUodGhpcy52b2x1bWVNYXAuZ2V0KHB1YmxpY2F0aW9uLnNvdXJjZSkhKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcHVibGljYXRpb247XG4gIH1cblxuICAvKiogQGludGVybmFsICovXG4gIGdldCBoYXNNZXRhZGF0YSgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gISF0aGlzLnBhcnRpY2lwYW50SW5mbztcbiAgfVxuXG4gIGdldFRyYWNrUHVibGljYXRpb24oc2lkOiBUcmFjay5TSUQpOiBSZW1vdGVUcmFja1B1YmxpY2F0aW9uIHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gdGhpcy50cmFja3MuZ2V0KHNpZCk7XG4gIH1cblxuICAvKiogQGludGVybmFsICovXG4gIHVwZGF0ZUluZm8oaW5mbzogUGFydGljaXBhbnRJbmZvKTogYm9vbGVhbiB7XG4gICAgaWYgKCFzdXBlci51cGRhdGVJbmZvKGluZm8pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gd2UgYXJlIGdldHRpbmcgYSBsaXN0IG9mIGFsbCBhdmFpbGFibGUgdHJhY2tzLCByZWNvbmNpbGUgaW4gaGVyZVxuICAgIC8vIGFuZCBzZW5kIG91dCBldmVudHMgZm9yIGNoYW5nZXNcblxuICAgIC8vIHJlY29uY2lsZSB0cmFjayBwdWJsaWNhdGlvbnMsIHB1Ymxpc2ggZXZlbnRzIG9ubHkgaWYgbWV0YWRhdGEgaXMgYWxyZWFkeSB0aGVyZVxuICAgIC8vIGkuZS4gY2hhbmdlcyBzaW5jZSB0aGUgbG9jYWwgcGFydGljaXBhbnQgaGFzIGpvaW5lZFxuICAgIGNvbnN0IHZhbGlkVHJhY2tzID0gbmV3IE1hcDxzdHJpbmcsIFJlbW90ZVRyYWNrUHVibGljYXRpb24+KCk7XG4gICAgY29uc3QgbmV3VHJhY2tzID0gbmV3IE1hcDxzdHJpbmcsIFJlbW90ZVRyYWNrUHVibGljYXRpb24+KCk7XG5cbiAgICBpbmZvLnRyYWNrcy5mb3JFYWNoKCh0aSkgPT4ge1xuICAgICAgbGV0IHB1YmxpY2F0aW9uID0gdGhpcy5nZXRUcmFja1B1YmxpY2F0aW9uKHRpLnNpZCk7XG4gICAgICBpZiAoIXB1YmxpY2F0aW9uKSB7XG4gICAgICAgIC8vIG5ldyBwdWJsaWNhdGlvblxuICAgICAgICBjb25zdCBraW5kID0gVHJhY2sua2luZEZyb21Qcm90byh0aS50eXBlKTtcbiAgICAgICAgaWYgKCFraW5kKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHB1YmxpY2F0aW9uID0gbmV3IFJlbW90ZVRyYWNrUHVibGljYXRpb24oXG4gICAgICAgICAga2luZCxcbiAgICAgICAgICB0aSxcbiAgICAgICAgICB0aGlzLnNpZ25hbENsaWVudC5jb25uZWN0T3B0aW9ucz8uYXV0b1N1YnNjcmliZSxcbiAgICAgICAgICB7IGxvZ2dlckNvbnRleHRDYjogKCkgPT4gdGhpcy5sb2dDb250ZXh0LCBsb2dnZXJOYW1lOiB0aGlzLmxvZ2dlck9wdGlvbnM/LmxvZ2dlck5hbWUgfSxcbiAgICAgICAgKTtcbiAgICAgICAgcHVibGljYXRpb24udXBkYXRlSW5mbyh0aSk7XG4gICAgICAgIG5ld1RyYWNrcy5zZXQodGkuc2lkLCBwdWJsaWNhdGlvbik7XG4gICAgICAgIGNvbnN0IGV4aXN0aW5nVHJhY2tPZlNvdXJjZSA9IEFycmF5LmZyb20odGhpcy50cmFja3MudmFsdWVzKCkpLmZpbmQoXG4gICAgICAgICAgKHB1Ymxpc2hlZFRyYWNrKSA9PiBwdWJsaXNoZWRUcmFjay5zb3VyY2UgPT09IHB1YmxpY2F0aW9uPy5zb3VyY2UsXG4gICAgICAgICk7XG4gICAgICAgIGlmIChleGlzdGluZ1RyYWNrT2ZTb3VyY2UgJiYgcHVibGljYXRpb24uc291cmNlICE9PSBUcmFjay5Tb3VyY2UuVW5rbm93bikge1xuICAgICAgICAgIHRoaXMubG9nLmRlYnVnKFxuICAgICAgICAgICAgYHJlY2VpdmVkIGEgc2Vjb25kIHRyYWNrIHB1YmxpY2F0aW9uIGZvciAke3RoaXMuaWRlbnRpdHl9IHdpdGggdGhlIHNhbWUgc291cmNlOiAke3B1YmxpY2F0aW9uLnNvdXJjZX1gLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAuLi50aGlzLmxvZ0NvbnRleHQsXG4gICAgICAgICAgICAgIG9sZFRyYWNrOiBnZXRMb2dDb250ZXh0RnJvbVRyYWNrKGV4aXN0aW5nVHJhY2tPZlNvdXJjZSksXG4gICAgICAgICAgICAgIG5ld1RyYWNrOiBnZXRMb2dDb250ZXh0RnJvbVRyYWNrKHB1YmxpY2F0aW9uKSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFkZFRyYWNrUHVibGljYXRpb24ocHVibGljYXRpb24pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHVibGljYXRpb24udXBkYXRlSW5mbyh0aSk7XG4gICAgICB9XG4gICAgICB2YWxpZFRyYWNrcy5zZXQodGkuc2lkLCBwdWJsaWNhdGlvbik7XG4gICAgfSk7XG5cbiAgICAvLyBkZXRlY3QgcmVtb3ZlZCB0cmFja3NcbiAgICB0aGlzLnRyYWNrcy5mb3JFYWNoKChwdWJsaWNhdGlvbikgPT4ge1xuICAgICAgaWYgKCF2YWxpZFRyYWNrcy5oYXMocHVibGljYXRpb24udHJhY2tTaWQpKSB7XG4gICAgICAgIHRoaXMubG9nLnRyYWNlKCdkZXRlY3RlZCByZW1vdmVkIHRyYWNrIG9uIHJlbW90ZSBwYXJ0aWNpcGFudCwgdW5wdWJsaXNoaW5nJywge1xuICAgICAgICAgIC4uLnRoaXMubG9nQ29udGV4dCxcbiAgICAgICAgICAuLi5nZXRMb2dDb250ZXh0RnJvbVRyYWNrKHB1YmxpY2F0aW9uKSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudW5wdWJsaXNoVHJhY2socHVibGljYXRpb24udHJhY2tTaWQsIHRydWUpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gYWx3YXlzIGVtaXQgZXZlbnRzIGZvciBuZXcgcHVibGljYXRpb25zLCBSb29tIHdpbGwgbm90IGZvcndhcmQgdGhlbSB1bmxlc3MgaXQncyByZWFkeVxuICAgIG5ld1RyYWNrcy5mb3JFYWNoKChwdWJsaWNhdGlvbikgPT4ge1xuICAgICAgdGhpcy5lbWl0KFBhcnRpY2lwYW50RXZlbnQuVHJhY2tQdWJsaXNoZWQsIHB1YmxpY2F0aW9uKTtcbiAgICB9KTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgdW5wdWJsaXNoVHJhY2soc2lkOiBUcmFjay5TSUQsIHNlbmRVbnB1Ymxpc2g/OiBib29sZWFuKSB7XG4gICAgY29uc3QgcHVibGljYXRpb24gPSA8UmVtb3RlVHJhY2tQdWJsaWNhdGlvbj50aGlzLnRyYWNrcy5nZXQoc2lkKTtcbiAgICBpZiAoIXB1YmxpY2F0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gYWxzbyBzZW5kIHVuc3Vic2NyaWJlLCBpZiB0cmFjayBpcyBhY3RpdmVseSBzdWJzY3JpYmVkXG4gICAgY29uc3QgeyB0cmFjayB9ID0gcHVibGljYXRpb247XG4gICAgaWYgKHRyYWNrKSB7XG4gICAgICB0cmFjay5zdG9wKCk7XG4gICAgICBwdWJsaWNhdGlvbi5zZXRUcmFjayh1bmRlZmluZWQpO1xuICAgIH1cblxuICAgIC8vIHJlbW92ZSB0cmFjayBmcm9tIG1hcHMgb25seSBhZnRlciB1bnN1YnNjcmliZWQgaGFzIGJlZW4gZmlyZWRcbiAgICB0aGlzLnRyYWNrcy5kZWxldGUoc2lkKTtcblxuICAgIC8vIHJlbW92ZSBmcm9tIHRoZSByaWdodCB0eXBlIG1hcFxuICAgIHN3aXRjaCAocHVibGljYXRpb24ua2luZCkge1xuICAgICAgY2FzZSBUcmFjay5LaW5kLkF1ZGlvOlxuICAgICAgICB0aGlzLmF1ZGlvVHJhY2tzLmRlbGV0ZShzaWQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgVHJhY2suS2luZC5WaWRlbzpcbiAgICAgICAgdGhpcy52aWRlb1RyYWNrcy5kZWxldGUoc2lkKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICBpZiAoc2VuZFVucHVibGlzaCkge1xuICAgICAgdGhpcy5lbWl0KFBhcnRpY2lwYW50RXZlbnQuVHJhY2tVbnB1Ymxpc2hlZCwgcHVibGljYXRpb24pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGFzeW5jIHNldEF1ZGlvT3V0cHV0KG91dHB1dDogQXVkaW9PdXRwdXRPcHRpb25zKSB7XG4gICAgdGhpcy5hdWRpb091dHB1dCA9IG91dHB1dDtcbiAgICBjb25zdCBwcm9taXNlczogUHJvbWlzZTx2b2lkPltdID0gW107XG4gICAgdGhpcy5hdWRpb1RyYWNrcy5mb3JFYWNoKChwdWIpID0+IHtcbiAgICAgIGlmIChwdWIudHJhY2sgaW5zdGFuY2VvZiBSZW1vdGVBdWRpb1RyYWNrKSB7XG4gICAgICAgIHByb21pc2VzLnB1c2gocHViLnRyYWNrLnNldFNpbmtJZChvdXRwdXQuZGV2aWNlSWQgPz8gJ2RlZmF1bHQnKSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgYXdhaXQgUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBlbWl0PEUgZXh0ZW5kcyBrZXlvZiBQYXJ0aWNpcGFudEV2ZW50Q2FsbGJhY2tzPihcbiAgICBldmVudDogRSxcbiAgICAuLi5hcmdzOiBQYXJhbWV0ZXJzPFBhcnRpY2lwYW50RXZlbnRDYWxsYmFja3NbRV0+XG4gICk6IGJvb2xlYW4ge1xuICAgIHRoaXMubG9nLnRyYWNlKCdwYXJ0aWNpcGFudCBldmVudCcsIHsgLi4udGhpcy5sb2dDb250ZXh0LCBldmVudCwgYXJncyB9KTtcbiAgICByZXR1cm4gc3VwZXIuZW1pdChldmVudCwgLi4uYXJncyk7XG4gIH1cbn1cbiIsImltcG9ydCB0eXBlIHsgSW50ZXJuYWxSb29tT3B0aW9ucyB9IGZyb20gJy4uLy4uL29wdGlvbnMnO1xuaW1wb3J0IHtcbiAgRGF0YVBhY2tldCxcbiAgRGF0YVBhY2tldF9LaW5kLFxuICBFbmNyeXB0aW9uX1R5cGUsXG4gIFBhcnRpY2lwYW50SW5mbyxcbiAgUGFydGljaXBhbnRQZXJtaXNzaW9uLFxuICBVc2VyUGFja2V0LFxufSBmcm9tICcuLi8uLi9wcm90by9saXZla2l0X21vZGVsc19wYic7XG5pbXBvcnQge1xuICBBZGRUcmFja1JlcXVlc3QsXG4gIFNpbXVsY2FzdENvZGVjLFxuICBTdWJzY3JpYmVkUXVhbGl0eVVwZGF0ZSxcbiAgVHJhY2tVbnB1Ymxpc2hlZFJlc3BvbnNlLFxufSBmcm9tICcuLi8uLi9wcm90by9saXZla2l0X3J0Y19wYic7XG5pbXBvcnQgeyBQQ1RyYW5zcG9ydFN0YXRlIH0gZnJvbSAnLi4vUENUcmFuc3BvcnRNYW5hZ2VyJztcbmltcG9ydCB0eXBlIFJUQ0VuZ2luZSBmcm9tICcuLi9SVENFbmdpbmUnO1xuaW1wb3J0IHsgZGVmYXVsdFZpZGVvQ29kZWMgfSBmcm9tICcuLi9kZWZhdWx0cyc7XG5pbXBvcnQgeyBEZXZpY2VVbnN1cHBvcnRlZEVycm9yLCBUcmFja0ludmFsaWRFcnJvciwgVW5leHBlY3RlZENvbm5lY3Rpb25TdGF0ZSB9IGZyb20gJy4uL2Vycm9ycyc7XG5pbXBvcnQgeyBFbmdpbmVFdmVudCwgUGFydGljaXBhbnRFdmVudCwgVHJhY2tFdmVudCB9IGZyb20gJy4uL2V2ZW50cyc7XG5pbXBvcnQgTG9jYWxBdWRpb1RyYWNrIGZyb20gJy4uL3RyYWNrL0xvY2FsQXVkaW9UcmFjayc7XG5pbXBvcnQgTG9jYWxUcmFjayBmcm9tICcuLi90cmFjay9Mb2NhbFRyYWNrJztcbmltcG9ydCBMb2NhbFRyYWNrUHVibGljYXRpb24gZnJvbSAnLi4vdHJhY2svTG9jYWxUcmFja1B1YmxpY2F0aW9uJztcbmltcG9ydCBMb2NhbFZpZGVvVHJhY2ssIHsgdmlkZW9MYXllcnNGcm9tRW5jb2RpbmdzIH0gZnJvbSAnLi4vdHJhY2svTG9jYWxWaWRlb1RyYWNrJztcbmltcG9ydCB7IFRyYWNrIH0gZnJvbSAnLi4vdHJhY2svVHJhY2snO1xuaW1wb3J0IHR5cGUge1xuICBBdWRpb0NhcHR1cmVPcHRpb25zLFxuICBCYWNrdXBWaWRlb0NvZGVjLFxuICBDcmVhdGVMb2NhbFRyYWNrc09wdGlvbnMsXG4gIFNjcmVlblNoYXJlQ2FwdHVyZU9wdGlvbnMsXG4gIFRyYWNrUHVibGlzaE9wdGlvbnMsXG4gIFZpZGVvQ2FwdHVyZU9wdGlvbnMsXG59IGZyb20gJy4uL3RyYWNrL29wdGlvbnMnO1xuaW1wb3J0IHsgU2NyZWVuU2hhcmVQcmVzZXRzLCBWaWRlb1ByZXNldHMsIGlzQmFja3VwQ29kZWMgfSBmcm9tICcuLi90cmFjay9vcHRpb25zJztcbmltcG9ydCB7XG4gIGNvbnN0cmFpbnRzRm9yT3B0aW9ucyxcbiAgZ2V0TG9nQ29udGV4dEZyb21UcmFjayxcbiAgbWVyZ2VEZWZhdWx0T3B0aW9ucyxcbiAgbWltZVR5cGVUb1ZpZGVvQ29kZWNTdHJpbmcsXG4gIHNjcmVlbkNhcHR1cmVUb0Rpc3BsYXlNZWRpYVN0cmVhbU9wdGlvbnMsXG59IGZyb20gJy4uL3RyYWNrL3V0aWxzJztcbmltcG9ydCB0eXBlIHsgRGF0YVB1Ymxpc2hPcHRpb25zIH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHtcbiAgRnV0dXJlLFxuICBpc0ZpcmVGb3gsXG4gIGlzU1ZDQ29kZWMsXG4gIGlzU2FmYXJpLFxuICBpc1NhZmFyaTE3LFxuICBpc1dlYixcbiAgc3VwcG9ydHNBVjEsXG4gIHN1cHBvcnRzVlA5LFxufSBmcm9tICcuLi91dGlscyc7XG5pbXBvcnQgUGFydGljaXBhbnQgZnJvbSAnLi9QYXJ0aWNpcGFudCc7XG5pbXBvcnQgdHlwZSB7IFBhcnRpY2lwYW50VHJhY2tQZXJtaXNzaW9uIH0gZnJvbSAnLi9QYXJ0aWNpcGFudFRyYWNrUGVybWlzc2lvbic7XG5pbXBvcnQgeyB0cmFja1Blcm1pc3Npb25Ub1Byb3RvIH0gZnJvbSAnLi9QYXJ0aWNpcGFudFRyYWNrUGVybWlzc2lvbic7XG5pbXBvcnQgUmVtb3RlUGFydGljaXBhbnQgZnJvbSAnLi9SZW1vdGVQYXJ0aWNpcGFudCc7XG5pbXBvcnQge1xuICBjb21wdXRlVHJhY2tCYWNrdXBFbmNvZGluZ3MsXG4gIGNvbXB1dGVWaWRlb0VuY29kaW5ncyxcbiAgbWVkaWFUcmFja1RvTG9jYWxUcmFjayxcbn0gZnJvbSAnLi9wdWJsaXNoVXRpbHMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMb2NhbFBhcnRpY2lwYW50IGV4dGVuZHMgUGFydGljaXBhbnQge1xuICBhdWRpb1RyYWNrczogTWFwPHN0cmluZywgTG9jYWxUcmFja1B1YmxpY2F0aW9uPjtcblxuICB2aWRlb1RyYWNrczogTWFwPHN0cmluZywgTG9jYWxUcmFja1B1YmxpY2F0aW9uPjtcblxuICAvKiogbWFwIG9mIHRyYWNrIHNpZCA9PiBhbGwgcHVibGlzaGVkIHRyYWNrcyAqL1xuICB0cmFja3M6IE1hcDxzdHJpbmcsIExvY2FsVHJhY2tQdWJsaWNhdGlvbj47XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBlbmdpbmU6IFJUQ0VuZ2luZTtcblxuICAvKiogQGludGVybmFsICovXG4gIGFjdGl2ZURldmljZU1hcDogTWFwPE1lZGlhRGV2aWNlS2luZCwgc3RyaW5nPjtcblxuICBwcml2YXRlIHBlbmRpbmdQdWJsaXNoaW5nID0gbmV3IFNldDxUcmFjay5Tb3VyY2U+KCk7XG5cbiAgcHJpdmF0ZSBwZW5kaW5nUHVibGlzaFByb21pc2VzID0gbmV3IE1hcDxMb2NhbFRyYWNrLCBQcm9taXNlPExvY2FsVHJhY2tQdWJsaWNhdGlvbj4+KCk7XG5cbiAgcHJpdmF0ZSBjYW1lcmFFcnJvcjogRXJyb3IgfCB1bmRlZmluZWQ7XG5cbiAgcHJpdmF0ZSBtaWNyb3Bob25lRXJyb3I6IEVycm9yIHwgdW5kZWZpbmVkO1xuXG4gIHByaXZhdGUgcGFydGljaXBhbnRUcmFja1Blcm1pc3Npb25zOiBBcnJheTxQYXJ0aWNpcGFudFRyYWNrUGVybWlzc2lvbj4gPSBbXTtcblxuICBwcml2YXRlIGFsbFBhcnRpY2lwYW50c0FsbG93ZWRUb1N1YnNjcmliZTogYm9vbGVhbiA9IHRydWU7XG5cbiAgLy8ga2VlcCBhIHBvaW50ZXIgdG8gcm9vbSBvcHRpb25zXG4gIHByaXZhdGUgcm9vbU9wdGlvbnM6IEludGVybmFsUm9vbU9wdGlvbnM7XG5cbiAgcHJpdmF0ZSBlbmNyeXB0aW9uVHlwZTogRW5jcnlwdGlvbl9UeXBlID0gRW5jcnlwdGlvbl9UeXBlLk5PTkU7XG5cbiAgcHJpdmF0ZSByZWNvbm5lY3RGdXR1cmU/OiBGdXR1cmU8dm9pZD47XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBjb25zdHJ1Y3RvcihzaWQ6IHN0cmluZywgaWRlbnRpdHk6IHN0cmluZywgZW5naW5lOiBSVENFbmdpbmUsIG9wdGlvbnM6IEludGVybmFsUm9vbU9wdGlvbnMpIHtcbiAgICBzdXBlcihzaWQsIGlkZW50aXR5LCB1bmRlZmluZWQsIHVuZGVmaW5lZCwge1xuICAgICAgbG9nZ2VyTmFtZTogb3B0aW9ucy5sb2dnZXJOYW1lLFxuICAgICAgbG9nZ2VyQ29udGV4dENiOiAoKSA9PiB0aGlzLmVuZ2luZS5sb2dDb250ZXh0LFxuICAgIH0pO1xuICAgIHRoaXMuYXVkaW9UcmFja3MgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy52aWRlb1RyYWNrcyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLnRyYWNrcyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLmVuZ2luZSA9IGVuZ2luZTtcbiAgICB0aGlzLnJvb21PcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLnNldHVwRW5naW5lKGVuZ2luZSk7XG4gICAgdGhpcy5hY3RpdmVEZXZpY2VNYXAgPSBuZXcgTWFwKCk7XG4gIH1cblxuICBnZXQgbGFzdENhbWVyYUVycm9yKCk6IEVycm9yIHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gdGhpcy5jYW1lcmFFcnJvcjtcbiAgfVxuXG4gIGdldCBsYXN0TWljcm9waG9uZUVycm9yKCk6IEVycm9yIHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gdGhpcy5taWNyb3Bob25lRXJyb3I7XG4gIH1cblxuICBnZXQgaXNFMkVFRW5hYmxlZCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5lbmNyeXB0aW9uVHlwZSAhPT0gRW5jcnlwdGlvbl9UeXBlLk5PTkU7XG4gIH1cblxuICBnZXRUcmFjayhzb3VyY2U6IFRyYWNrLlNvdXJjZSk6IExvY2FsVHJhY2tQdWJsaWNhdGlvbiB8IHVuZGVmaW5lZCB7XG4gICAgY29uc3QgdHJhY2sgPSBzdXBlci5nZXRUcmFjayhzb3VyY2UpO1xuICAgIGlmICh0cmFjaykge1xuICAgICAgcmV0dXJuIHRyYWNrIGFzIExvY2FsVHJhY2tQdWJsaWNhdGlvbjtcbiAgICB9XG4gIH1cblxuICBnZXRUcmFja0J5TmFtZShuYW1lOiBzdHJpbmcpOiBMb2NhbFRyYWNrUHVibGljYXRpb24gfCB1bmRlZmluZWQge1xuICAgIGNvbnN0IHRyYWNrID0gc3VwZXIuZ2V0VHJhY2tCeU5hbWUobmFtZSk7XG4gICAgaWYgKHRyYWNrKSB7XG4gICAgICByZXR1cm4gdHJhY2sgYXMgTG9jYWxUcmFja1B1YmxpY2F0aW9uO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHNldHVwRW5naW5lKGVuZ2luZTogUlRDRW5naW5lKSB7XG4gICAgdGhpcy5lbmdpbmUgPSBlbmdpbmU7XG4gICAgdGhpcy5lbmdpbmUub24oRW5naW5lRXZlbnQuUmVtb3RlTXV0ZSwgKHRyYWNrU2lkOiBzdHJpbmcsIG11dGVkOiBib29sZWFuKSA9PiB7XG4gICAgICBjb25zdCBwdWIgPSB0aGlzLnRyYWNrcy5nZXQodHJhY2tTaWQpO1xuICAgICAgaWYgKCFwdWIgfHwgIXB1Yi50cmFjaykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAobXV0ZWQpIHtcbiAgICAgICAgcHViLm11dGUoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHB1Yi51bm11dGUoKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHRoaXMuZW5naW5lXG4gICAgICAub24oRW5naW5lRXZlbnQuQ29ubmVjdGVkLCB0aGlzLmhhbmRsZVJlY29ubmVjdGVkKVxuICAgICAgLm9uKEVuZ2luZUV2ZW50LlNpZ25hbFJlc3RhcnRlZCwgdGhpcy5oYW5kbGVSZWNvbm5lY3RlZClcbiAgICAgIC5vbihFbmdpbmVFdmVudC5TaWduYWxSZXN1bWVkLCB0aGlzLmhhbmRsZVJlY29ubmVjdGVkKVxuICAgICAgLm9uKEVuZ2luZUV2ZW50LlJlc3RhcnRpbmcsIHRoaXMuaGFuZGxlUmVjb25uZWN0aW5nKVxuICAgICAgLm9uKEVuZ2luZUV2ZW50LlJlc3VtaW5nLCB0aGlzLmhhbmRsZVJlY29ubmVjdGluZylcbiAgICAgIC5vbihFbmdpbmVFdmVudC5Mb2NhbFRyYWNrVW5wdWJsaXNoZWQsIHRoaXMuaGFuZGxlTG9jYWxUcmFja1VucHVibGlzaGVkKVxuICAgICAgLm9uKEVuZ2luZUV2ZW50LlN1YnNjcmliZWRRdWFsaXR5VXBkYXRlLCB0aGlzLmhhbmRsZVN1YnNjcmliZWRRdWFsaXR5VXBkYXRlKVxuICAgICAgLm9uKEVuZ2luZUV2ZW50LkRpc2Nvbm5lY3RlZCwgdGhpcy5oYW5kbGVEaXNjb25uZWN0ZWQpO1xuICB9XG5cbiAgcHJpdmF0ZSBoYW5kbGVSZWNvbm5lY3RpbmcgPSAoKSA9PiB7XG4gICAgaWYgKCF0aGlzLnJlY29ubmVjdEZ1dHVyZSkge1xuICAgICAgdGhpcy5yZWNvbm5lY3RGdXR1cmUgPSBuZXcgRnV0dXJlPHZvaWQ+KCk7XG4gICAgfVxuICB9O1xuXG4gIHByaXZhdGUgaGFuZGxlUmVjb25uZWN0ZWQgPSAoKSA9PiB7XG4gICAgdGhpcy5yZWNvbm5lY3RGdXR1cmU/LnJlc29sdmU/LigpO1xuICAgIHRoaXMucmVjb25uZWN0RnV0dXJlID0gdW5kZWZpbmVkO1xuICAgIHRoaXMudXBkYXRlVHJhY2tTdWJzY3JpcHRpb25QZXJtaXNzaW9ucygpO1xuICB9O1xuXG4gIHByaXZhdGUgaGFuZGxlRGlzY29ubmVjdGVkID0gKCkgPT4ge1xuICAgIGlmICh0aGlzLnJlY29ubmVjdEZ1dHVyZSkge1xuICAgICAgdGhpcy5yZWNvbm5lY3RGdXR1cmUucHJvbWlzZS5jYXRjaCgoZSkgPT4gdGhpcy5sb2cud2FybihlLm1lc3NhZ2UsIHRoaXMubG9nQ29udGV4dCkpO1xuICAgICAgdGhpcy5yZWNvbm5lY3RGdXR1cmU/LnJlamVjdD8uKCdHb3QgZGlzY29ubmVjdGVkIGR1cmluZyByZWNvbm5lY3Rpb24gYXR0ZW1wdCcpO1xuICAgICAgdGhpcy5yZWNvbm5lY3RGdXR1cmUgPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBTZXRzIGFuZCB1cGRhdGVzIHRoZSBtZXRhZGF0YSBvZiB0aGUgbG9jYWwgcGFydGljaXBhbnQuXG4gICAqIFRoZSBjaGFuZ2UgZG9lcyBub3QgdGFrZSBpbW1lZGlhdGUgZWZmZWN0LlxuICAgKiBJZiBzdWNjZXNzZnVsLCBhIGBQYXJ0aWNpcGFudEV2ZW50Lk1ldGFkYXRhQ2hhbmdlZGAgZXZlbnQgd2lsbCBiZSBlbWl0dGVkIG9uIHRoZSBsb2NhbCBwYXJ0aWNpcGFudC5cbiAgICogTm90ZTogdGhpcyByZXF1aXJlcyBgY2FuVXBkYXRlT3duTWV0YWRhdGFgIHBlcm1pc3Npb24uXG4gICAqIEBwYXJhbSBtZXRhZGF0YVxuICAgKi9cbiAgc2V0TWV0YWRhdGEobWV0YWRhdGE6IHN0cmluZyk6IHZvaWQge1xuICAgIHRoaXMuZW5naW5lLmNsaWVudC5zZW5kVXBkYXRlTG9jYWxNZXRhZGF0YShtZXRhZGF0YSwgdGhpcy5uYW1lID8/ICcnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIGFuZCB1cGRhdGVzIHRoZSBuYW1lIG9mIHRoZSBsb2NhbCBwYXJ0aWNpcGFudC5cbiAgICogVGhlIGNoYW5nZSBkb2VzIG5vdCB0YWtlIGltbWVkaWF0ZSBlZmZlY3QuXG4gICAqIElmIHN1Y2Nlc3NmdWwsIGEgYFBhcnRpY2lwYW50RXZlbnQuUGFydGljaXBhbnROYW1lQ2hhbmdlZGAgZXZlbnQgd2lsbCBiZSBlbWl0dGVkIG9uIHRoZSBsb2NhbCBwYXJ0aWNpcGFudC5cbiAgICogTm90ZTogdGhpcyByZXF1aXJlcyBgY2FuVXBkYXRlT3duTWV0YWRhdGFgIHBlcm1pc3Npb24uXG4gICAqIEBwYXJhbSBtZXRhZGF0YVxuICAgKi9cbiAgc2V0TmFtZShuYW1lOiBzdHJpbmcpOiB2b2lkIHtcbiAgICB0aGlzLmVuZ2luZS5jbGllbnQuc2VuZFVwZGF0ZUxvY2FsTWV0YWRhdGEodGhpcy5tZXRhZGF0YSA/PyAnJywgbmFtZSk7XG4gIH1cblxuICAvKipcbiAgICogRW5hYmxlIG9yIGRpc2FibGUgYSBwYXJ0aWNpcGFudCdzIGNhbWVyYSB0cmFjay5cbiAgICpcbiAgICogSWYgYSB0cmFjayBoYXMgYWxyZWFkeSBwdWJsaXNoZWQsIGl0J2xsIG11dGUgb3IgdW5tdXRlIHRoZSB0cmFjay5cbiAgICogUmVzb2x2ZXMgd2l0aCBhIGBMb2NhbFRyYWNrUHVibGljYXRpb25gIGluc3RhbmNlIGlmIHN1Y2Nlc3NmdWwgYW5kIGB1bmRlZmluZWRgIG90aGVyd2lzZVxuICAgKi9cbiAgc2V0Q2FtZXJhRW5hYmxlZChcbiAgICBlbmFibGVkOiBib29sZWFuLFxuICAgIG9wdGlvbnM/OiBWaWRlb0NhcHR1cmVPcHRpb25zLFxuICAgIHB1Ymxpc2hPcHRpb25zPzogVHJhY2tQdWJsaXNoT3B0aW9ucyxcbiAgKTogUHJvbWlzZTxMb2NhbFRyYWNrUHVibGljYXRpb24gfCB1bmRlZmluZWQ+IHtcbiAgICByZXR1cm4gdGhpcy5zZXRUcmFja0VuYWJsZWQoVHJhY2suU291cmNlLkNhbWVyYSwgZW5hYmxlZCwgb3B0aW9ucywgcHVibGlzaE9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEVuYWJsZSBvciBkaXNhYmxlIGEgcGFydGljaXBhbnQncyBtaWNyb3Bob25lIHRyYWNrLlxuICAgKlxuICAgKiBJZiBhIHRyYWNrIGhhcyBhbHJlYWR5IHB1Ymxpc2hlZCwgaXQnbGwgbXV0ZSBvciB1bm11dGUgdGhlIHRyYWNrLlxuICAgKiBSZXNvbHZlcyB3aXRoIGEgYExvY2FsVHJhY2tQdWJsaWNhdGlvbmAgaW5zdGFuY2UgaWYgc3VjY2Vzc2Z1bCBhbmQgYHVuZGVmaW5lZGAgb3RoZXJ3aXNlXG4gICAqL1xuICBzZXRNaWNyb3Bob25lRW5hYmxlZChcbiAgICBlbmFibGVkOiBib29sZWFuLFxuICAgIG9wdGlvbnM/OiBBdWRpb0NhcHR1cmVPcHRpb25zLFxuICAgIHB1Ymxpc2hPcHRpb25zPzogVHJhY2tQdWJsaXNoT3B0aW9ucyxcbiAgKTogUHJvbWlzZTxMb2NhbFRyYWNrUHVibGljYXRpb24gfCB1bmRlZmluZWQ+IHtcbiAgICByZXR1cm4gdGhpcy5zZXRUcmFja0VuYWJsZWQoVHJhY2suU291cmNlLk1pY3JvcGhvbmUsIGVuYWJsZWQsIG9wdGlvbnMsIHB1Ymxpc2hPcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdGFydCBvciBzdG9wIHNoYXJpbmcgYSBwYXJ0aWNpcGFudCdzIHNjcmVlblxuICAgKiBSZXNvbHZlcyB3aXRoIGEgYExvY2FsVHJhY2tQdWJsaWNhdGlvbmAgaW5zdGFuY2UgaWYgc3VjY2Vzc2Z1bCBhbmQgYHVuZGVmaW5lZGAgb3RoZXJ3aXNlXG4gICAqL1xuICBzZXRTY3JlZW5TaGFyZUVuYWJsZWQoXG4gICAgZW5hYmxlZDogYm9vbGVhbixcbiAgICBvcHRpb25zPzogU2NyZWVuU2hhcmVDYXB0dXJlT3B0aW9ucyxcbiAgICBwdWJsaXNoT3B0aW9ucz86IFRyYWNrUHVibGlzaE9wdGlvbnMsXG4gICk6IFByb21pc2U8TG9jYWxUcmFja1B1YmxpY2F0aW9uIHwgdW5kZWZpbmVkPiB7XG4gICAgcmV0dXJuIHRoaXMuc2V0VHJhY2tFbmFibGVkKFRyYWNrLlNvdXJjZS5TY3JlZW5TaGFyZSwgZW5hYmxlZCwgb3B0aW9ucywgcHVibGlzaE9wdGlvbnMpO1xuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBzZXRQZXJtaXNzaW9ucyhwZXJtaXNzaW9uczogUGFydGljaXBhbnRQZXJtaXNzaW9uKTogYm9vbGVhbiB7XG4gICAgY29uc3QgcHJldlBlcm1pc3Npb25zID0gdGhpcy5wZXJtaXNzaW9ucztcbiAgICBjb25zdCBjaGFuZ2VkID0gc3VwZXIuc2V0UGVybWlzc2lvbnMocGVybWlzc2lvbnMpO1xuICAgIGlmIChjaGFuZ2VkICYmIHByZXZQZXJtaXNzaW9ucykge1xuICAgICAgdGhpcy5lbWl0KFBhcnRpY2lwYW50RXZlbnQuUGFydGljaXBhbnRQZXJtaXNzaW9uc0NoYW5nZWQsIHByZXZQZXJtaXNzaW9ucyk7XG4gICAgfVxuICAgIHJldHVybiBjaGFuZ2VkO1xuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBhc3luYyBzZXRFMkVFRW5hYmxlZChlbmFibGVkOiBib29sZWFuKSB7XG4gICAgdGhpcy5lbmNyeXB0aW9uVHlwZSA9IGVuYWJsZWQgPyBFbmNyeXB0aW9uX1R5cGUuR0NNIDogRW5jcnlwdGlvbl9UeXBlLk5PTkU7XG4gICAgYXdhaXQgdGhpcy5yZXB1Ymxpc2hBbGxUcmFja3ModW5kZWZpbmVkLCBmYWxzZSk7XG4gIH1cblxuICAvKipcbiAgICogRW5hYmxlIG9yIGRpc2FibGUgcHVibGlzaGluZyBmb3IgYSB0cmFjayBieSBzb3VyY2UuIFRoaXMgc2VydmVzIGFzIGEgc2ltcGxlXG4gICAqIHdheSB0byBtYW5hZ2UgdGhlIGNvbW1vbiB0cmFja3MgKGNhbWVyYSwgbWljLCBvciBzY3JlZW4gc2hhcmUpLlxuICAgKiBSZXNvbHZlcyB3aXRoIExvY2FsVHJhY2tQdWJsaWNhdGlvbiBpZiBzdWNjZXNzZnVsIGFuZCB2b2lkIG90aGVyd2lzZVxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBzZXRUcmFja0VuYWJsZWQoXG4gICAgc291cmNlOiBFeHRyYWN0PFRyYWNrLlNvdXJjZSwgVHJhY2suU291cmNlLkNhbWVyYT4sXG4gICAgZW5hYmxlZDogYm9vbGVhbixcbiAgICBvcHRpb25zPzogVmlkZW9DYXB0dXJlT3B0aW9ucyxcbiAgICBwdWJsaXNoT3B0aW9ucz86IFRyYWNrUHVibGlzaE9wdGlvbnMsXG4gICk6IFByb21pc2U8TG9jYWxUcmFja1B1YmxpY2F0aW9uIHwgdW5kZWZpbmVkPjtcbiAgcHJpdmF0ZSBhc3luYyBzZXRUcmFja0VuYWJsZWQoXG4gICAgc291cmNlOiBFeHRyYWN0PFRyYWNrLlNvdXJjZSwgVHJhY2suU291cmNlLk1pY3JvcGhvbmU+LFxuICAgIGVuYWJsZWQ6IGJvb2xlYW4sXG4gICAgb3B0aW9ucz86IEF1ZGlvQ2FwdHVyZU9wdGlvbnMsXG4gICAgcHVibGlzaE9wdGlvbnM/OiBUcmFja1B1Ymxpc2hPcHRpb25zLFxuICApOiBQcm9taXNlPExvY2FsVHJhY2tQdWJsaWNhdGlvbiB8IHVuZGVmaW5lZD47XG4gIHByaXZhdGUgYXN5bmMgc2V0VHJhY2tFbmFibGVkKFxuICAgIHNvdXJjZTogRXh0cmFjdDxUcmFjay5Tb3VyY2UsIFRyYWNrLlNvdXJjZS5TY3JlZW5TaGFyZT4sXG4gICAgZW5hYmxlZDogYm9vbGVhbixcbiAgICBvcHRpb25zPzogU2NyZWVuU2hhcmVDYXB0dXJlT3B0aW9ucyxcbiAgICBwdWJsaXNoT3B0aW9ucz86IFRyYWNrUHVibGlzaE9wdGlvbnMsXG4gICk6IFByb21pc2U8TG9jYWxUcmFja1B1YmxpY2F0aW9uIHwgdW5kZWZpbmVkPjtcbiAgcHJpdmF0ZSBhc3luYyBzZXRUcmFja0VuYWJsZWQoXG4gICAgc291cmNlOiBUcmFjay5Tb3VyY2UsXG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICBvcHRpb25zPzogVmlkZW9DYXB0dXJlT3B0aW9ucyB8IEF1ZGlvQ2FwdHVyZU9wdGlvbnMgfCBTY3JlZW5TaGFyZUNhcHR1cmVPcHRpb25zLFxuICAgIHB1Ymxpc2hPcHRpb25zPzogVHJhY2tQdWJsaXNoT3B0aW9ucyxcbiAgKSB7XG4gICAgdGhpcy5sb2cuZGVidWcoJ3NldFRyYWNrRW5hYmxlZCcsIHsgLi4udGhpcy5sb2dDb250ZXh0LCBzb3VyY2UsIGVuYWJsZWQgfSk7XG4gICAgbGV0IHRyYWNrID0gdGhpcy5nZXRUcmFjayhzb3VyY2UpO1xuICAgIGlmIChlbmFibGVkKSB7XG4gICAgICBpZiAodHJhY2spIHtcbiAgICAgICAgYXdhaXQgdHJhY2sudW5tdXRlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgbG9jYWxUcmFja3M6IEFycmF5PExvY2FsVHJhY2s+IHwgdW5kZWZpbmVkO1xuICAgICAgICBpZiAodGhpcy5wZW5kaW5nUHVibGlzaGluZy5oYXMoc291cmNlKSkge1xuICAgICAgICAgIHRoaXMubG9nLmluZm8oJ3NraXBwaW5nIGR1cGxpY2F0ZSBwdWJsaXNoZWQgc291cmNlJywgeyAuLi50aGlzLmxvZ0NvbnRleHQsIHNvdXJjZSB9KTtcbiAgICAgICAgICAvLyBuby1vcCBpdCdzIGFscmVhZHkgYmVlbiByZXF1ZXN0ZWRcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wZW5kaW5nUHVibGlzaGluZy5hZGQoc291cmNlKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBzd2l0Y2ggKHNvdXJjZSkge1xuICAgICAgICAgICAgY2FzZSBUcmFjay5Tb3VyY2UuQ2FtZXJhOlxuICAgICAgICAgICAgICBsb2NhbFRyYWNrcyA9IGF3YWl0IHRoaXMuY3JlYXRlVHJhY2tzKHtcbiAgICAgICAgICAgICAgICB2aWRlbzogKG9wdGlvbnMgYXMgVmlkZW9DYXB0dXJlT3B0aW9ucyB8IHVuZGVmaW5lZCkgPz8gdHJ1ZSxcbiAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFRyYWNrLlNvdXJjZS5NaWNyb3Bob25lOlxuICAgICAgICAgICAgICBsb2NhbFRyYWNrcyA9IGF3YWl0IHRoaXMuY3JlYXRlVHJhY2tzKHtcbiAgICAgICAgICAgICAgICBhdWRpbzogKG9wdGlvbnMgYXMgQXVkaW9DYXB0dXJlT3B0aW9ucyB8IHVuZGVmaW5lZCkgPz8gdHJ1ZSxcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBUcmFjay5Tb3VyY2UuU2NyZWVuU2hhcmU6XG4gICAgICAgICAgICAgIGxvY2FsVHJhY2tzID0gYXdhaXQgdGhpcy5jcmVhdGVTY3JlZW5UcmFja3Moe1xuICAgICAgICAgICAgICAgIC4uLihvcHRpb25zIGFzIFNjcmVlblNoYXJlQ2FwdHVyZU9wdGlvbnMgfCB1bmRlZmluZWQpLFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICB0aHJvdyBuZXcgVHJhY2tJbnZhbGlkRXJyb3Ioc291cmNlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgcHVibGlzaFByb21pc2VzOiBBcnJheTxQcm9taXNlPExvY2FsVHJhY2tQdWJsaWNhdGlvbj4+ID0gW107XG4gICAgICAgICAgZm9yIChjb25zdCBsb2NhbFRyYWNrIG9mIGxvY2FsVHJhY2tzKSB7XG4gICAgICAgICAgICB0aGlzLmxvZy5pbmZvKCdwdWJsaXNoaW5nIHRyYWNrJywge1xuICAgICAgICAgICAgICAuLi50aGlzLmxvZ0NvbnRleHQsXG4gICAgICAgICAgICAgIC4uLmdldExvZ0NvbnRleHRGcm9tVHJhY2sobG9jYWxUcmFjayksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHB1Ymxpc2hQcm9taXNlcy5wdXNoKHRoaXMucHVibGlzaFRyYWNrKGxvY2FsVHJhY2ssIHB1Ymxpc2hPcHRpb25zKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHB1Ymxpc2hlZFRyYWNrcyA9IGF3YWl0IFByb21pc2UuYWxsKHB1Ymxpc2hQcm9taXNlcyk7XG4gICAgICAgICAgLy8gZm9yIHNjcmVlbiBzaGFyZSBwdWJsaWNhdGlvbnMgaW5jbHVkaW5nIGF1ZGlvLCB0aGlzIHdpbGwgb25seSByZXR1cm4gdGhlIHNjcmVlbiBzaGFyZSBwdWJsaWNhdGlvbiwgbm90IHRoZSBzY3JlZW4gc2hhcmUgYXVkaW8gb25lXG4gICAgICAgICAgLy8gcmV2aXNpdCBpZiB3ZSB3YW50IHRvIHJldHVybiBhbiBhcnJheSBvZiB0cmFja3MgaW5zdGVhZCBmb3IgdjJcbiAgICAgICAgICBbdHJhY2tdID0gcHVibGlzaGVkVHJhY2tzO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgbG9jYWxUcmFja3M/LmZvckVhY2goKHRyKSA9PiB7XG4gICAgICAgICAgICB0ci5zdG9wKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBFcnJvciAmJiAhKGUgaW5zdGFuY2VvZiBUcmFja0ludmFsaWRFcnJvcikpIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdChQYXJ0aWNpcGFudEV2ZW50Lk1lZGlhRGV2aWNlc0Vycm9yLCBlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICB0aGlzLnBlbmRpbmdQdWJsaXNoaW5nLmRlbGV0ZShzb3VyY2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0cmFjayAmJiB0cmFjay50cmFjaykge1xuICAgICAgLy8gc2NyZWVuc2hhcmUgY2Fubm90IGJlIG11dGVkLCB1bnB1Ymxpc2ggaW5zdGVhZFxuICAgICAgaWYgKHNvdXJjZSA9PT0gVHJhY2suU291cmNlLlNjcmVlblNoYXJlKSB7XG4gICAgICAgIHRyYWNrID0gYXdhaXQgdGhpcy51bnB1Ymxpc2hUcmFjayh0cmFjay50cmFjayk7XG4gICAgICAgIGNvbnN0IHNjcmVlbkF1ZGlvVHJhY2sgPSB0aGlzLmdldFRyYWNrKFRyYWNrLlNvdXJjZS5TY3JlZW5TaGFyZUF1ZGlvKTtcbiAgICAgICAgaWYgKHNjcmVlbkF1ZGlvVHJhY2sgJiYgc2NyZWVuQXVkaW9UcmFjay50cmFjaykge1xuICAgICAgICAgIHRoaXMudW5wdWJsaXNoVHJhY2soc2NyZWVuQXVkaW9UcmFjay50cmFjayk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGF3YWl0IHRyYWNrLm11dGUoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRyYWNrO1xuICB9XG5cbiAgLyoqXG4gICAqIFB1Ymxpc2ggYm90aCBjYW1lcmEgYW5kIG1pY3JvcGhvbmUgYXQgdGhlIHNhbWUgdGltZS4gVGhpcyBpcyB1c2VmdWwgZm9yXG4gICAqIGRpc3BsYXlpbmcgYSBzaW5nbGUgUGVybWlzc2lvbiBEaWFsb2cgYm94IHRvIHRoZSBlbmQgdXNlci5cbiAgICovXG4gIGFzeW5jIGVuYWJsZUNhbWVyYUFuZE1pY3JvcGhvbmUoKSB7XG4gICAgaWYgKFxuICAgICAgdGhpcy5wZW5kaW5nUHVibGlzaGluZy5oYXMoVHJhY2suU291cmNlLkNhbWVyYSkgfHxcbiAgICAgIHRoaXMucGVuZGluZ1B1Ymxpc2hpbmcuaGFzKFRyYWNrLlNvdXJjZS5NaWNyb3Bob25lKVxuICAgICkge1xuICAgICAgLy8gbm8tb3AgaXQncyBhbHJlYWR5IGJlZW4gcmVxdWVzdGVkXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5wZW5kaW5nUHVibGlzaGluZy5hZGQoVHJhY2suU291cmNlLkNhbWVyYSk7XG4gICAgdGhpcy5wZW5kaW5nUHVibGlzaGluZy5hZGQoVHJhY2suU291cmNlLk1pY3JvcGhvbmUpO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCB0cmFja3M6IExvY2FsVHJhY2tbXSA9IGF3YWl0IHRoaXMuY3JlYXRlVHJhY2tzKHtcbiAgICAgICAgYXVkaW86IHRydWUsXG4gICAgICAgIHZpZGVvOiB0cnVlLFxuICAgICAgfSk7XG5cbiAgICAgIGF3YWl0IFByb21pc2UuYWxsKHRyYWNrcy5tYXAoKHRyYWNrKSA9PiB0aGlzLnB1Ymxpc2hUcmFjayh0cmFjaykpKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdGhpcy5wZW5kaW5nUHVibGlzaGluZy5kZWxldGUoVHJhY2suU291cmNlLkNhbWVyYSk7XG4gICAgICB0aGlzLnBlbmRpbmdQdWJsaXNoaW5nLmRlbGV0ZShUcmFjay5Tb3VyY2UuTWljcm9waG9uZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBsb2NhbCBjYW1lcmEgYW5kL29yIG1pY3JvcGhvbmUgdHJhY2tzXG4gICAqIEBwYXJhbSBvcHRpb25zXG4gICAqIEByZXR1cm5zXG4gICAqL1xuICBhc3luYyBjcmVhdGVUcmFja3Mob3B0aW9ucz86IENyZWF0ZUxvY2FsVHJhY2tzT3B0aW9ucyk6IFByb21pc2U8TG9jYWxUcmFja1tdPiB7XG4gICAgY29uc3Qgb3B0cyA9IG1lcmdlRGVmYXVsdE9wdGlvbnMoXG4gICAgICBvcHRpb25zLFxuICAgICAgdGhpcy5yb29tT3B0aW9ucz8uYXVkaW9DYXB0dXJlRGVmYXVsdHMsXG4gICAgICB0aGlzLnJvb21PcHRpb25zPy52aWRlb0NhcHR1cmVEZWZhdWx0cyxcbiAgICApO1xuXG4gICAgY29uc3QgY29uc3RyYWludHMgPSBjb25zdHJhaW50c0Zvck9wdGlvbnMob3B0cyk7XG4gICAgbGV0IHN0cmVhbTogTWVkaWFTdHJlYW0gfCB1bmRlZmluZWQ7XG4gICAgdHJ5IHtcbiAgICAgIHN0cmVhbSA9IGF3YWl0IG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKGNvbnN0cmFpbnRzKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICBpZiAoY29uc3RyYWludHMuYXVkaW8pIHtcbiAgICAgICAgICB0aGlzLm1pY3JvcGhvbmVFcnJvciA9IGVycjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29uc3RyYWludHMudmlkZW8pIHtcbiAgICAgICAgICB0aGlzLmNhbWVyYUVycm9yID0gZXJyO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRocm93IGVycjtcbiAgICB9XG5cbiAgICBpZiAoY29uc3RyYWludHMuYXVkaW8pIHtcbiAgICAgIHRoaXMubWljcm9waG9uZUVycm9yID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5lbWl0KFBhcnRpY2lwYW50RXZlbnQuQXVkaW9TdHJlYW1BY3F1aXJlZCk7XG4gICAgfVxuICAgIGlmIChjb25zdHJhaW50cy52aWRlbykge1xuICAgICAgdGhpcy5jYW1lcmFFcnJvciA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICByZXR1cm4gc3RyZWFtLmdldFRyYWNrcygpLm1hcCgobWVkaWFTdHJlYW1UcmFjaykgPT4ge1xuICAgICAgY29uc3QgaXNBdWRpbyA9IG1lZGlhU3RyZWFtVHJhY2sua2luZCA9PT0gJ2F1ZGlvJztcbiAgICAgIGxldCB0cmFja09wdGlvbnMgPSBpc0F1ZGlvID8gb3B0aW9ucyEuYXVkaW8gOiBvcHRpb25zIS52aWRlbztcbiAgICAgIGlmICh0eXBlb2YgdHJhY2tPcHRpb25zID09PSAnYm9vbGVhbicgfHwgIXRyYWNrT3B0aW9ucykge1xuICAgICAgICB0cmFja09wdGlvbnMgPSB7fTtcbiAgICAgIH1cbiAgICAgIGxldCB0cmFja0NvbnN0cmFpbnRzOiBNZWRpYVRyYWNrQ29uc3RyYWludHMgfCB1bmRlZmluZWQ7XG4gICAgICBjb25zdCBjb25PckJvb2wgPSBpc0F1ZGlvID8gY29uc3RyYWludHMuYXVkaW8gOiBjb25zdHJhaW50cy52aWRlbztcbiAgICAgIGlmICh0eXBlb2YgY29uT3JCb29sICE9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgdHJhY2tDb25zdHJhaW50cyA9IGNvbk9yQm9vbDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHRyYWNrID0gbWVkaWFUcmFja1RvTG9jYWxUcmFjayhtZWRpYVN0cmVhbVRyYWNrLCB0cmFja0NvbnN0cmFpbnRzLCB7XG4gICAgICAgIGxvZ2dlck5hbWU6IHRoaXMucm9vbU9wdGlvbnMubG9nZ2VyTmFtZSxcbiAgICAgICAgbG9nZ2VyQ29udGV4dENiOiAoKSA9PiB0aGlzLmxvZ0NvbnRleHQsXG4gICAgICB9KTtcbiAgICAgIGlmICh0cmFjay5raW5kID09PSBUcmFjay5LaW5kLlZpZGVvKSB7XG4gICAgICAgIHRyYWNrLnNvdXJjZSA9IFRyYWNrLlNvdXJjZS5DYW1lcmE7XG4gICAgICB9IGVsc2UgaWYgKHRyYWNrLmtpbmQgPT09IFRyYWNrLktpbmQuQXVkaW8pIHtcbiAgICAgICAgdHJhY2suc291cmNlID0gVHJhY2suU291cmNlLk1pY3JvcGhvbmU7XG4gICAgICB9XG4gICAgICB0cmFjay5tZWRpYVN0cmVhbSA9IHN0cmVhbTtcbiAgICAgIHJldHVybiB0cmFjaztcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgc2NyZWVuIGNhcHR1cmUgdHJhY2tzIHdpdGggZ2V0RGlzcGxheU1lZGlhKCkuXG4gICAqIEEgTG9jYWxWaWRlb1RyYWNrIGlzIGFsd2F5cyBjcmVhdGVkIGFuZCByZXR1cm5lZC5cbiAgICogSWYgeyBhdWRpbzogdHJ1ZSB9LCBhbmQgdGhlIGJyb3dzZXIgc3VwcG9ydHMgYXVkaW8gY2FwdHVyZSwgYSBMb2NhbEF1ZGlvVHJhY2sgaXMgYWxzbyBjcmVhdGVkLlxuICAgKi9cbiAgYXN5bmMgY3JlYXRlU2NyZWVuVHJhY2tzKG9wdGlvbnM/OiBTY3JlZW5TaGFyZUNhcHR1cmVPcHRpb25zKTogUHJvbWlzZTxBcnJheTxMb2NhbFRyYWNrPj4ge1xuICAgIGlmIChvcHRpb25zID09PSB1bmRlZmluZWQpIHtcbiAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG5cbiAgICBpZiAobmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXREaXNwbGF5TWVkaWEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IERldmljZVVuc3VwcG9ydGVkRXJyb3IoJ2dldERpc3BsYXlNZWRpYSBub3Qgc3VwcG9ydGVkJyk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMucmVzb2x1dGlvbiA9PT0gdW5kZWZpbmVkICYmICFpc1NhZmFyaTE3KCkpIHtcbiAgICAgIC8vIHdlIG5lZWQgdG8gY29uc3RyYWluIHRoZSBkaW1lbnNpb25zLCBvdGhlcndpc2UgaXQgY291bGQgbGVhZCB0byBsb3cgYml0cmF0ZVxuICAgICAgLy8gZHVlIHRvIGVuY29kaW5nIGEgaHVnZSB2aWRlby4gRW5jb2Rpbmcgc3VjaCBsYXJnZSBzdXJmYWNlcyBpcyByZWFsbHkgZXhwZW5zaXZlXG4gICAgICAvLyB1bmZvcnR1bmF0ZWx5IFNhZmFyaSAxNyBoYXMgYSBidXQgYW5kIGNhbm5vdCBiZSBjb25zdHJhaW5lZCBieSBkZWZhdWx0XG4gICAgICBvcHRpb25zLnJlc29sdXRpb24gPSBTY3JlZW5TaGFyZVByZXNldHMuaDEwODBmcHMzMC5yZXNvbHV0aW9uO1xuICAgIH1cblxuICAgIGNvbnN0IGNvbnN0cmFpbnRzID0gc2NyZWVuQ2FwdHVyZVRvRGlzcGxheU1lZGlhU3RyZWFtT3B0aW9ucyhvcHRpb25zKTtcbiAgICBjb25zdCBzdHJlYW06IE1lZGlhU3RyZWFtID0gYXdhaXQgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXREaXNwbGF5TWVkaWEoY29uc3RyYWludHMpO1xuXG4gICAgY29uc3QgdHJhY2tzID0gc3RyZWFtLmdldFZpZGVvVHJhY2tzKCk7XG4gICAgaWYgKHRyYWNrcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBUcmFja0ludmFsaWRFcnJvcignbm8gdmlkZW8gdHJhY2sgZm91bmQnKTtcbiAgICB9XG4gICAgY29uc3Qgc2NyZWVuVmlkZW8gPSBuZXcgTG9jYWxWaWRlb1RyYWNrKHRyYWNrc1swXSwgdW5kZWZpbmVkLCBmYWxzZSwge1xuICAgICAgbG9nZ2VyTmFtZTogdGhpcy5yb29tT3B0aW9ucy5sb2dnZXJOYW1lLFxuICAgICAgbG9nZ2VyQ29udGV4dENiOiAoKSA9PiB0aGlzLmxvZ0NvbnRleHQsXG4gICAgfSk7XG4gICAgc2NyZWVuVmlkZW8uc291cmNlID0gVHJhY2suU291cmNlLlNjcmVlblNoYXJlO1xuICAgIGlmIChvcHRpb25zLmNvbnRlbnRIaW50KSB7XG4gICAgICBzY3JlZW5WaWRlby5tZWRpYVN0cmVhbVRyYWNrLmNvbnRlbnRIaW50ID0gb3B0aW9ucy5jb250ZW50SGludDtcbiAgICB9XG5cbiAgICBjb25zdCBsb2NhbFRyYWNrczogQXJyYXk8TG9jYWxUcmFjaz4gPSBbc2NyZWVuVmlkZW9dO1xuICAgIGlmIChzdHJlYW0uZ2V0QXVkaW9UcmFja3MoKS5sZW5ndGggPiAwKSB7XG4gICAgICB0aGlzLmVtaXQoUGFydGljaXBhbnRFdmVudC5BdWRpb1N0cmVhbUFjcXVpcmVkKTtcbiAgICAgIGNvbnN0IHNjcmVlbkF1ZGlvID0gbmV3IExvY2FsQXVkaW9UcmFjayhcbiAgICAgICAgc3RyZWFtLmdldEF1ZGlvVHJhY2tzKClbMF0sXG4gICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIHRoaXMuYXVkaW9Db250ZXh0LFxuICAgICAgICB7IGxvZ2dlck5hbWU6IHRoaXMucm9vbU9wdGlvbnMubG9nZ2VyTmFtZSwgbG9nZ2VyQ29udGV4dENiOiAoKSA9PiB0aGlzLmxvZ0NvbnRleHQgfSxcbiAgICAgICk7XG4gICAgICBzY3JlZW5BdWRpby5zb3VyY2UgPSBUcmFjay5Tb3VyY2UuU2NyZWVuU2hhcmVBdWRpbztcbiAgICAgIGxvY2FsVHJhY2tzLnB1c2goc2NyZWVuQXVkaW8pO1xuICAgIH1cbiAgICByZXR1cm4gbG9jYWxUcmFja3M7XG4gIH1cblxuICAvKipcbiAgICogUHVibGlzaCBhIG5ldyB0cmFjayB0byB0aGUgcm9vbVxuICAgKiBAcGFyYW0gdHJhY2tcbiAgICogQHBhcmFtIG9wdGlvbnNcbiAgICovXG4gIGFzeW5jIHB1Ymxpc2hUcmFjayhcbiAgICB0cmFjazogTG9jYWxUcmFjayB8IE1lZGlhU3RyZWFtVHJhY2ssXG4gICAgb3B0aW9ucz86IFRyYWNrUHVibGlzaE9wdGlvbnMsXG4gICk6IFByb21pc2U8TG9jYWxUcmFja1B1YmxpY2F0aW9uPiB7XG4gICAgYXdhaXQgdGhpcy5yZWNvbm5lY3RGdXR1cmU/LnByb21pc2U7XG4gICAgaWYgKHRyYWNrIGluc3RhbmNlb2YgTG9jYWxUcmFjayAmJiB0aGlzLnBlbmRpbmdQdWJsaXNoUHJvbWlzZXMuaGFzKHRyYWNrKSkge1xuICAgICAgYXdhaXQgdGhpcy5wZW5kaW5nUHVibGlzaFByb21pc2VzLmdldCh0cmFjayk7XG4gICAgfVxuICAgIGxldCBkZWZhdWx0Q29uc3RyYWludHM6IE1lZGlhVHJhY2tDb25zdHJhaW50cyB8IHVuZGVmaW5lZDtcbiAgICBpZiAodHJhY2sgaW5zdGFuY2VvZiBNZWRpYVN0cmVhbVRyYWNrKSB7XG4gICAgICBkZWZhdWx0Q29uc3RyYWludHMgPSB0cmFjay5nZXRDb25zdHJhaW50cygpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB3ZSB3YW50IHRvIGFjY2VzcyBjb25zdHJhaW50cyBkaXJlY3RseSBhcyBgdHJhY2subWVkaWFTdHJlYW1UcmFja2BcbiAgICAgIC8vIG1pZ2h0IGJlIHBvaW50aW5nIHRvIGEgbm9uLWRldmljZSB0cmFjayAoZS5nLiBwcm9jZXNzZWQgdHJhY2spIGFscmVhZHlcbiAgICAgIGRlZmF1bHRDb25zdHJhaW50cyA9IHRyYWNrLmNvbnN0cmFpbnRzO1xuICAgICAgbGV0IGRldmljZUtpbmQ6IE1lZGlhRGV2aWNlS2luZCB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcbiAgICAgIHN3aXRjaCAodHJhY2suc291cmNlKSB7XG4gICAgICAgIGNhc2UgVHJhY2suU291cmNlLk1pY3JvcGhvbmU6XG4gICAgICAgICAgZGV2aWNlS2luZCA9ICdhdWRpb2lucHV0JztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBUcmFjay5Tb3VyY2UuQ2FtZXJhOlxuICAgICAgICAgIGRldmljZUtpbmQgPSAndmlkZW9pbnB1dCc7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoZGV2aWNlS2luZCAmJiB0aGlzLmFjdGl2ZURldmljZU1hcC5oYXMoZGV2aWNlS2luZCkpIHtcbiAgICAgICAgZGVmYXVsdENvbnN0cmFpbnRzID0ge1xuICAgICAgICAgIC4uLmRlZmF1bHRDb25zdHJhaW50cyxcbiAgICAgICAgICBkZXZpY2VJZDogdGhpcy5hY3RpdmVEZXZpY2VNYXAuZ2V0KGRldmljZUtpbmQpLFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBjb252ZXJ0IHJhdyBtZWRpYSB0cmFjayBpbnRvIGF1ZGlvIG9yIHZpZGVvIHRyYWNrXG4gICAgaWYgKHRyYWNrIGluc3RhbmNlb2YgTWVkaWFTdHJlYW1UcmFjaykge1xuICAgICAgc3dpdGNoICh0cmFjay5raW5kKSB7XG4gICAgICAgIGNhc2UgJ2F1ZGlvJzpcbiAgICAgICAgICB0cmFjayA9IG5ldyBMb2NhbEF1ZGlvVHJhY2sodHJhY2ssIGRlZmF1bHRDb25zdHJhaW50cywgdHJ1ZSwgdGhpcy5hdWRpb0NvbnRleHQsIHtcbiAgICAgICAgICAgIGxvZ2dlck5hbWU6IHRoaXMucm9vbU9wdGlvbnMubG9nZ2VyTmFtZSxcbiAgICAgICAgICAgIGxvZ2dlckNvbnRleHRDYjogKCkgPT4gdGhpcy5sb2dDb250ZXh0LFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICd2aWRlbyc6XG4gICAgICAgICAgdHJhY2sgPSBuZXcgTG9jYWxWaWRlb1RyYWNrKHRyYWNrLCBkZWZhdWx0Q29uc3RyYWludHMsIHRydWUsIHtcbiAgICAgICAgICAgIGxvZ2dlck5hbWU6IHRoaXMucm9vbU9wdGlvbnMubG9nZ2VyTmFtZSxcbiAgICAgICAgICAgIGxvZ2dlckNvbnRleHRDYjogKCkgPT4gdGhpcy5sb2dDb250ZXh0LFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBUcmFja0ludmFsaWRFcnJvcihgdW5zdXBwb3J0ZWQgTWVkaWFTdHJlYW1UcmFjayBraW5kICR7dHJhY2sua2luZH1gKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdHJhY2sudXBkYXRlTG9nZ2VyT3B0aW9ucyh7XG4gICAgICAgIGxvZ2dlck5hbWU6IHRoaXMucm9vbU9wdGlvbnMubG9nZ2VyTmFtZSxcbiAgICAgICAgbG9nZ2VyQ29udGV4dENiOiAoKSA9PiB0aGlzLmxvZ0NvbnRleHQsXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAodHJhY2sgaW5zdGFuY2VvZiBMb2NhbEF1ZGlvVHJhY2spIHtcbiAgICAgIHRyYWNrLnNldEF1ZGlvQ29udGV4dCh0aGlzLmF1ZGlvQ29udGV4dCk7XG4gICAgfVxuXG4gICAgLy8gaXMgaXQgYWxyZWFkeSBwdWJsaXNoZWQ/IGlmIHNvIHNraXBcbiAgICBsZXQgZXhpc3RpbmdQdWJsaWNhdGlvbjogTG9jYWxUcmFja1B1YmxpY2F0aW9uIHwgdW5kZWZpbmVkO1xuICAgIHRoaXMudHJhY2tzLmZvckVhY2goKHB1YmxpY2F0aW9uKSA9PiB7XG4gICAgICBpZiAoIXB1YmxpY2F0aW9uLnRyYWNrKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChwdWJsaWNhdGlvbi50cmFjayA9PT0gdHJhY2spIHtcbiAgICAgICAgZXhpc3RpbmdQdWJsaWNhdGlvbiA9IDxMb2NhbFRyYWNrUHVibGljYXRpb24+cHVibGljYXRpb247XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAoZXhpc3RpbmdQdWJsaWNhdGlvbikge1xuICAgICAgdGhpcy5sb2cud2FybigndHJhY2sgaGFzIGFscmVhZHkgYmVlbiBwdWJsaXNoZWQsIHNraXBwaW5nJywge1xuICAgICAgICAuLi50aGlzLmxvZ0NvbnRleHQsXG4gICAgICAgIC4uLmdldExvZ0NvbnRleHRGcm9tVHJhY2soZXhpc3RpbmdQdWJsaWNhdGlvbiksXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBleGlzdGluZ1B1YmxpY2F0aW9uO1xuICAgIH1cblxuICAgIGNvbnN0IGlzU3RlcmVvSW5wdXQgPVxuICAgICAgKCdjaGFubmVsQ291bnQnIGluIHRyYWNrLm1lZGlhU3RyZWFtVHJhY2suZ2V0U2V0dGluZ3MoKSAmJlxuICAgICAgICAvLyBAdHMtaWdub3JlIGBjaGFubmVsQ291bnRgIG9uIGdldFNldHRpbmdzKCkgaXMgY3VycmVudGx5IG9ubHkgYXZhaWxhYmxlIGZvciBTYWZhcmksIGJ1dCBpcyBnZW5lcmFsbHkgdGhlIGJlc3Qgd2F5IHRvIGRldGVybWluZSBhIHN0ZXJlbyB0cmFjayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvTWVkaWFUcmFja1NldHRpbmdzL2NoYW5uZWxDb3VudFxuICAgICAgICB0cmFjay5tZWRpYVN0cmVhbVRyYWNrLmdldFNldHRpbmdzKCkuY2hhbm5lbENvdW50ID09PSAyKSB8fFxuICAgICAgdHJhY2subWVkaWFTdHJlYW1UcmFjay5nZXRDb25zdHJhaW50cygpLmNoYW5uZWxDb3VudCA9PT0gMjtcbiAgICBjb25zdCBpc1N0ZXJlbyA9IG9wdGlvbnM/LmZvcmNlU3RlcmVvID8/IGlzU3RlcmVvSW5wdXQ7XG5cbiAgICAvLyBkaXNhYmxlIGR0eCBmb3Igc3RlcmVvIHRyYWNrIGlmIG5vdCBlbmFibGVkIGV4cGxpY2l0bHlcbiAgICBpZiAoaXNTdGVyZW8pIHtcbiAgICAgIGlmICghb3B0aW9ucykge1xuICAgICAgICBvcHRpb25zID0ge307XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy5kdHggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLmxvZy5pbmZvKFxuICAgICAgICAgIGBPcHVzIERUWCB3aWxsIGJlIGRpc2FibGVkIGZvciBzdGVyZW8gdHJhY2tzIGJ5IGRlZmF1bHQuIEVuYWJsZSB0aGVtIGV4cGxpY2l0bHkgdG8gbWFrZSBpdCB3b3JrLmAsXG4gICAgICAgICAge1xuICAgICAgICAgICAgLi4udGhpcy5sb2dDb250ZXh0LFxuICAgICAgICAgICAgLi4uZ2V0TG9nQ29udGV4dEZyb21UcmFjayh0cmFjayksXG4gICAgICAgICAgfSxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLnJlZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMubG9nLmluZm8oXG4gICAgICAgICAgYE9wdXMgUkVEIHdpbGwgYmUgZGlzYWJsZWQgZm9yIHN0ZXJlbyB0cmFja3MgYnkgZGVmYXVsdC4gRW5hYmxlIHRoZW0gZXhwbGljaXRseSB0byBtYWtlIGl0IHdvcmsuYCxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIG9wdGlvbnMuZHR4ID8/PSBmYWxzZTtcbiAgICAgIG9wdGlvbnMucmVkID8/PSBmYWxzZTtcbiAgICB9XG4gICAgY29uc3Qgb3B0czogVHJhY2tQdWJsaXNoT3B0aW9ucyA9IHtcbiAgICAgIC4uLnRoaXMucm9vbU9wdGlvbnMucHVibGlzaERlZmF1bHRzLFxuICAgICAgLi4ub3B0aW9ucyxcbiAgICB9O1xuXG4gICAgLy8gZGlzYWJsZSBzaW11bGNhc3QgaWYgZTJlZSBpcyBzZXQgb24gc2FmYXJpXG4gICAgaWYgKGlzU2FmYXJpKCkgJiYgdGhpcy5yb29tT3B0aW9ucy5lMmVlKSB7XG4gICAgICB0aGlzLmxvZy5pbmZvKFxuICAgICAgICBgRW5kLXRvLWVuZCBlbmNyeXB0aW9uIGlzIHNldCB1cCwgc2ltdWxjYXN0IHB1Ymxpc2hpbmcgd2lsbCBiZSBkaXNhYmxlZCBvbiBTYWZhcmlgLFxuICAgICAgICB7XG4gICAgICAgICAgLi4udGhpcy5sb2dDb250ZXh0LFxuICAgICAgICB9LFxuICAgICAgKTtcbiAgICAgIG9wdHMuc2ltdWxjYXN0ID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKG9wdHMuc291cmNlKSB7XG4gICAgICB0cmFjay5zb3VyY2UgPSBvcHRzLnNvdXJjZTtcbiAgICB9XG4gICAgY29uc3QgcHVibGlzaFByb21pc2UgPSB0aGlzLnB1Ymxpc2godHJhY2ssIG9wdHMsIGlzU3RlcmVvKTtcbiAgICB0aGlzLnBlbmRpbmdQdWJsaXNoUHJvbWlzZXMuc2V0KHRyYWNrLCBwdWJsaXNoUHJvbWlzZSk7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHB1YmxpY2F0aW9uID0gYXdhaXQgcHVibGlzaFByb21pc2U7XG4gICAgICByZXR1cm4gcHVibGljYXRpb247XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhyb3cgZTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdGhpcy5wZW5kaW5nUHVibGlzaFByb21pc2VzLmRlbGV0ZSh0cmFjayk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBwdWJsaXNoKHRyYWNrOiBMb2NhbFRyYWNrLCBvcHRzOiBUcmFja1B1Ymxpc2hPcHRpb25zLCBpc1N0ZXJlbzogYm9vbGVhbikge1xuICAgIGNvbnN0IGV4aXN0aW5nVHJhY2tPZlNvdXJjZSA9IEFycmF5LmZyb20odGhpcy50cmFja3MudmFsdWVzKCkpLmZpbmQoXG4gICAgICAocHVibGlzaGVkVHJhY2spID0+IHRyYWNrIGluc3RhbmNlb2YgTG9jYWxUcmFjayAmJiBwdWJsaXNoZWRUcmFjay5zb3VyY2UgPT09IHRyYWNrLnNvdXJjZSxcbiAgICApO1xuICAgIGlmIChleGlzdGluZ1RyYWNrT2ZTb3VyY2UgJiYgdHJhY2suc291cmNlICE9PSBUcmFjay5Tb3VyY2UuVW5rbm93bikge1xuICAgICAgdGhpcy5sb2cuaW5mbyhgcHVibGlzaGluZyBhIHNlY29uZCB0cmFjayB3aXRoIHRoZSBzYW1lIHNvdXJjZTogJHt0cmFjay5zb3VyY2V9YCwge1xuICAgICAgICAuLi50aGlzLmxvZ0NvbnRleHQsXG4gICAgICAgIC4uLmdldExvZ0NvbnRleHRGcm9tVHJhY2sodHJhY2spLFxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChvcHRzLnN0b3BNaWNUcmFja09uTXV0ZSAmJiB0cmFjayBpbnN0YW5jZW9mIExvY2FsQXVkaW9UcmFjaykge1xuICAgICAgdHJhY2suc3RvcE9uTXV0ZSA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHRyYWNrLnNvdXJjZSA9PT0gVHJhY2suU291cmNlLlNjcmVlblNoYXJlICYmIGlzRmlyZUZveCgpKSB7XG4gICAgICAvLyBGaXJlZm94IGRvZXMgbm90IHdvcmsgd2VsbCB3aXRoIHNpbXVsY2FzdGVkIHNjcmVlbiBzaGFyZVxuICAgICAgLy8gd2UgZnJlcXVlbnRseSBnZXQgbm8gZGF0YSBvbiBsYXllciAwIHdoZW4gZW5hYmxlZFxuICAgICAgb3B0cy5zaW11bGNhc3QgPSBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyByZXF1aXJlIGZ1bGwgQVYxL1ZQOSBTVkMgc3VwcG9ydCBwcmlvciB0byB1c2luZyBpdFxuICAgIGlmIChvcHRzLnZpZGVvQ29kZWMgPT09ICdhdjEnICYmICFzdXBwb3J0c0FWMSgpKSB7XG4gICAgICBvcHRzLnZpZGVvQ29kZWMgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGlmIChvcHRzLnZpZGVvQ29kZWMgPT09ICd2cDknICYmICFzdXBwb3J0c1ZQOSgpKSB7XG4gICAgICBvcHRzLnZpZGVvQ29kZWMgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGlmIChvcHRzLnZpZGVvQ29kZWMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgb3B0cy52aWRlb0NvZGVjID0gZGVmYXVsdFZpZGVvQ29kZWM7XG4gICAgfVxuICAgIGNvbnN0IHZpZGVvQ29kZWMgPSBvcHRzLnZpZGVvQ29kZWM7XG5cbiAgICAvLyBoYW5kbGUgdHJhY2sgYWN0aW9uc1xuICAgIHRyYWNrLm9uKFRyYWNrRXZlbnQuTXV0ZWQsIHRoaXMub25UcmFja011dGVkKTtcbiAgICB0cmFjay5vbihUcmFja0V2ZW50LlVubXV0ZWQsIHRoaXMub25UcmFja1VubXV0ZWQpO1xuICAgIHRyYWNrLm9uKFRyYWNrRXZlbnQuRW5kZWQsIHRoaXMuaGFuZGxlVHJhY2tFbmRlZCk7XG4gICAgdHJhY2sub24oVHJhY2tFdmVudC5VcHN0cmVhbVBhdXNlZCwgdGhpcy5vblRyYWNrVXBzdHJlYW1QYXVzZWQpO1xuICAgIHRyYWNrLm9uKFRyYWNrRXZlbnQuVXBzdHJlYW1SZXN1bWVkLCB0aGlzLm9uVHJhY2tVcHN0cmVhbVJlc3VtZWQpO1xuXG4gICAgLy8gY3JlYXRlIHRyYWNrIHB1YmxpY2F0aW9uIGZyb20gdHJhY2tcbiAgICBjb25zdCByZXEgPSBuZXcgQWRkVHJhY2tSZXF1ZXN0KHtcbiAgICAgIC8vIGdldCBsb2NhbCB0cmFjayBpZCBmb3IgdXNlIGR1cmluZyBwdWJsaXNoaW5nXG4gICAgICBjaWQ6IHRyYWNrLm1lZGlhU3RyZWFtVHJhY2suaWQsXG4gICAgICBuYW1lOiBvcHRzLm5hbWUsXG4gICAgICB0eXBlOiBUcmFjay5raW5kVG9Qcm90byh0cmFjay5raW5kKSxcbiAgICAgIG11dGVkOiB0cmFjay5pc011dGVkLFxuICAgICAgc291cmNlOiBUcmFjay5zb3VyY2VUb1Byb3RvKHRyYWNrLnNvdXJjZSksXG4gICAgICBkaXNhYmxlRHR4OiAhKG9wdHMuZHR4ID8/IHRydWUpLFxuICAgICAgZW5jcnlwdGlvbjogdGhpcy5lbmNyeXB0aW9uVHlwZSxcbiAgICAgIHN0ZXJlbzogaXNTdGVyZW8sXG4gICAgICBkaXNhYmxlUmVkOiB0aGlzLmlzRTJFRUVuYWJsZWQgfHwgIShvcHRzLnJlZCA/PyB0cnVlKSxcbiAgICAgIHN0cmVhbTogb3B0cz8uc3RyZWFtLFxuICAgIH0pO1xuXG4gICAgLy8gY29tcHV0ZSBlbmNvZGluZ3MgYW5kIGxheWVycyBmb3IgdmlkZW9cbiAgICBsZXQgZW5jb2RpbmdzOiBSVENSdHBFbmNvZGluZ1BhcmFtZXRlcnNbXSB8IHVuZGVmaW5lZDtcbiAgICBpZiAodHJhY2sua2luZCA9PT0gVHJhY2suS2luZC5WaWRlbykge1xuICAgICAgbGV0IGRpbXM6IFRyYWNrLkRpbWVuc2lvbnMgPSB7XG4gICAgICAgIHdpZHRoOiAwLFxuICAgICAgICBoZWlnaHQ6IDAsXG4gICAgICB9O1xuICAgICAgdHJ5IHtcbiAgICAgICAgZGltcyA9IGF3YWl0IHRyYWNrLndhaXRGb3JEaW1lbnNpb25zKCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8vIHVzZSBkZWZhdWx0cywgaXQncyBxdWl0ZSBwYWluZnVsIGZvciBjb25nZXN0aW9uIGNvbnRyb2wgd2l0aG91dCBzaW11bGNhc3RcbiAgICAgICAgLy8gc28gdXNpbmcgZGVmYXVsdCBkaW1zIGFjY29yZGluZyB0byBwdWJsaXNoIHNldHRpbmdzXG4gICAgICAgIGNvbnN0IGRlZmF1bHRSZXMgPVxuICAgICAgICAgIHRoaXMucm9vbU9wdGlvbnMudmlkZW9DYXB0dXJlRGVmYXVsdHM/LnJlc29sdXRpb24gPz8gVmlkZW9QcmVzZXRzLmg3MjAucmVzb2x1dGlvbjtcbiAgICAgICAgZGltcyA9IHtcbiAgICAgICAgICB3aWR0aDogZGVmYXVsdFJlcy53aWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IGRlZmF1bHRSZXMuaGVpZ2h0LFxuICAgICAgICB9O1xuICAgICAgICAvLyBsb2cgZmFpbHVyZVxuICAgICAgICB0aGlzLmxvZy5lcnJvcignY291bGQgbm90IGRldGVybWluZSB0cmFjayBkaW1lbnNpb25zLCB1c2luZyBkZWZhdWx0cycsIHtcbiAgICAgICAgICAuLi50aGlzLmxvZ0NvbnRleHQsXG4gICAgICAgICAgLi4uZ2V0TG9nQ29udGV4dEZyb21UcmFjayh0cmFjayksXG4gICAgICAgICAgZGltcyxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICAvLyB3aWR0aCBhbmQgaGVpZ2h0IHNob3VsZCBiZSBkZWZpbmVkIGZvciB2aWRlb1xuICAgICAgcmVxLndpZHRoID0gZGltcy53aWR0aDtcbiAgICAgIHJlcS5oZWlnaHQgPSBkaW1zLmhlaWdodDtcbiAgICAgIC8vIGZvciBzdmMgY29kZWNzLCBkaXNhYmxlIHNpbXVsY2FzdCBhbmQgdXNlIHZwOCBmb3IgYmFja3VwIGNvZGVjXG4gICAgICBpZiAodHJhY2sgaW5zdGFuY2VvZiBMb2NhbFZpZGVvVHJhY2spIHtcbiAgICAgICAgaWYgKGlzU1ZDQ29kZWModmlkZW9Db2RlYykpIHtcbiAgICAgICAgICAvLyB2cDkgc3ZjIHdpdGggc2NyZWVuc2hhcmUgaGFzIHByb2JsZW0gdG8gZW5jb2RlLCBhbHdheXMgdXNlIEwxVDMgaGVyZVxuICAgICAgICAgIGlmICh0cmFjay5zb3VyY2UgPT09IFRyYWNrLlNvdXJjZS5TY3JlZW5TaGFyZSAmJiB2aWRlb0NvZGVjID09PSAndnA5Jykge1xuICAgICAgICAgICAgb3B0cy5zY2FsYWJpbGl0eU1vZGUgPSAnTDFUMyc7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIHNldCBzY2FsYWJpbGl0eU1vZGUgdG8gJ0wzVDNfS0VZJyBieSBkZWZhdWx0XG4gICAgICAgICAgb3B0cy5zY2FsYWJpbGl0eU1vZGUgPSBvcHRzLnNjYWxhYmlsaXR5TW9kZSA/PyAnTDNUM19LRVknO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVxLnNpbXVsY2FzdENvZGVjcyA9IFtcbiAgICAgICAgICBuZXcgU2ltdWxjYXN0Q29kZWMoe1xuICAgICAgICAgICAgY29kZWM6IHZpZGVvQ29kZWMsXG4gICAgICAgICAgICBjaWQ6IHRyYWNrLm1lZGlhU3RyZWFtVHJhY2suaWQsXG4gICAgICAgICAgfSksXG4gICAgICAgIF07XG5cbiAgICAgICAgLy8gc2V0IHVwIGJhY2t1cFxuICAgICAgICBpZiAob3B0cy5iYWNrdXBDb2RlYyA9PT0gdHJ1ZSkge1xuICAgICAgICAgIG9wdHMuYmFja3VwQ29kZWMgPSB7IGNvZGVjOiBkZWZhdWx0VmlkZW9Db2RlYyB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChcbiAgICAgICAgICBvcHRzLmJhY2t1cENvZGVjICYmXG4gICAgICAgICAgdmlkZW9Db2RlYyAhPT0gb3B0cy5iYWNrdXBDb2RlYy5jb2RlYyAmJlxuICAgICAgICAgIC8vIFRPRE8gcmVtb3ZlIHRoaXMgb25jZSBlMmVlIGlzIHN1cHBvcnRlZCBmb3IgYmFja3VwIGNvZGVjc1xuICAgICAgICAgIHJlcS5lbmNyeXB0aW9uID09PSBFbmNyeXB0aW9uX1R5cGUuTk9ORVxuICAgICAgICApIHtcbiAgICAgICAgICAvLyBtdWx0aS1jb2RlYyBzaW11bGNhc3QgcmVxdWlyZXMgZHluYWNhc3RcbiAgICAgICAgICBpZiAoIXRoaXMucm9vbU9wdGlvbnMuZHluYWNhc3QpIHtcbiAgICAgICAgICAgIHRoaXMucm9vbU9wdGlvbnMuZHluYWNhc3QgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXEuc2ltdWxjYXN0Q29kZWNzLnB1c2goXG4gICAgICAgICAgICBuZXcgU2ltdWxjYXN0Q29kZWMoe1xuICAgICAgICAgICAgICBjb2RlYzogb3B0cy5iYWNrdXBDb2RlYy5jb2RlYyxcbiAgICAgICAgICAgICAgY2lkOiAnJyxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZW5jb2RpbmdzID0gY29tcHV0ZVZpZGVvRW5jb2RpbmdzKFxuICAgICAgICB0cmFjay5zb3VyY2UgPT09IFRyYWNrLlNvdXJjZS5TY3JlZW5TaGFyZSxcbiAgICAgICAgcmVxLndpZHRoLFxuICAgICAgICByZXEuaGVpZ2h0LFxuICAgICAgICBvcHRzLFxuICAgICAgKTtcbiAgICAgIHJlcS5sYXllcnMgPSB2aWRlb0xheWVyc0Zyb21FbmNvZGluZ3MoXG4gICAgICAgIHJlcS53aWR0aCxcbiAgICAgICAgcmVxLmhlaWdodCxcbiAgICAgICAgZW5jb2RpbmdzLFxuICAgICAgICBpc1NWQ0NvZGVjKG9wdHMudmlkZW9Db2RlYyksXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAodHJhY2sua2luZCA9PT0gVHJhY2suS2luZC5BdWRpbykge1xuICAgICAgZW5jb2RpbmdzID0gW1xuICAgICAgICB7XG4gICAgICAgICAgbWF4Qml0cmF0ZTogb3B0cy5hdWRpb1ByZXNldD8ubWF4Qml0cmF0ZSA/PyBvcHRzLmF1ZGlvQml0cmF0ZSxcbiAgICAgICAgICBwcmlvcml0eTogb3B0cy5hdWRpb1ByZXNldD8ucHJpb3JpdHkgPz8gJ2hpZ2gnLFxuICAgICAgICAgIG5ldHdvcmtQcmlvcml0eTogb3B0cy5hdWRpb1ByZXNldD8ucHJpb3JpdHkgPz8gJ2hpZ2gnLFxuICAgICAgICB9LFxuICAgICAgXTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuZW5naW5lIHx8IHRoaXMuZW5naW5lLmlzQ2xvc2VkKSB7XG4gICAgICB0aHJvdyBuZXcgVW5leHBlY3RlZENvbm5lY3Rpb25TdGF0ZSgnY2Fubm90IHB1Ymxpc2ggdHJhY2sgd2hlbiBub3QgY29ubmVjdGVkJyk7XG4gICAgfVxuXG4gICAgY29uc3QgdGkgPSBhd2FpdCB0aGlzLmVuZ2luZS5hZGRUcmFjayhyZXEpO1xuICAgIC8vIHNlcnZlciBtaWdodCBub3Qgc3VwcG9ydCB0aGUgY29kZWMgdGhlIGNsaWVudCBoYXMgcmVxdWVzdGVkLCBpbiB0aGF0IGNhc2UsIGZhbGxiYWNrXG4gICAgLy8gdG8gYSBzdXBwb3J0ZWQgY29kZWNcbiAgICBsZXQgcHJpbWFyeUNvZGVjTWltZTogc3RyaW5nIHwgdW5kZWZpbmVkO1xuICAgIHRpLmNvZGVjcy5mb3JFYWNoKChjb2RlYykgPT4ge1xuICAgICAgaWYgKHByaW1hcnlDb2RlY01pbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwcmltYXJ5Q29kZWNNaW1lID0gY29kZWMubWltZVR5cGU7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKHByaW1hcnlDb2RlY01pbWUgJiYgdHJhY2sua2luZCA9PT0gVHJhY2suS2luZC5WaWRlbykge1xuICAgICAgY29uc3QgdXBkYXRlZENvZGVjID0gbWltZVR5cGVUb1ZpZGVvQ29kZWNTdHJpbmcocHJpbWFyeUNvZGVjTWltZSk7XG4gICAgICBpZiAodXBkYXRlZENvZGVjICE9PSB2aWRlb0NvZGVjKSB7XG4gICAgICAgIHRoaXMubG9nLmRlYnVnKCdmYWxsaW5nIGJhY2sgdG8gc2VydmVyIHNlbGVjdGVkIGNvZGVjJywge1xuICAgICAgICAgIC4uLnRoaXMubG9nQ29udGV4dCxcbiAgICAgICAgICAuLi5nZXRMb2dDb250ZXh0RnJvbVRyYWNrKHRyYWNrKSxcbiAgICAgICAgICBjb2RlYzogdXBkYXRlZENvZGVjLFxuICAgICAgICB9KTtcbiAgICAgICAgLyogQHRzLWlnbm9yZSAqL1xuICAgICAgICBvcHRzLnZpZGVvQ29kZWMgPSB1cGRhdGVkQ29kZWM7XG5cbiAgICAgICAgLy8gcmVjb21wdXRlIGVuY29kaW5ncyBzaW5jZSBiaXRyYXRlcy9ldGMgY291bGQgaGF2ZSBjaGFuZ2VkXG4gICAgICAgIGVuY29kaW5ncyA9IGNvbXB1dGVWaWRlb0VuY29kaW5ncyhcbiAgICAgICAgICB0cmFjay5zb3VyY2UgPT09IFRyYWNrLlNvdXJjZS5TY3JlZW5TaGFyZSxcbiAgICAgICAgICByZXEud2lkdGgsXG4gICAgICAgICAgcmVxLmhlaWdodCxcbiAgICAgICAgICBvcHRzLFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHB1YmxpY2F0aW9uID0gbmV3IExvY2FsVHJhY2tQdWJsaWNhdGlvbih0cmFjay5raW5kLCB0aSwgdHJhY2ssIHtcbiAgICAgIGxvZ2dlck5hbWU6IHRoaXMucm9vbU9wdGlvbnMubG9nZ2VyTmFtZSxcbiAgICAgIGxvZ2dlckNvbnRleHRDYjogKCkgPT4gdGhpcy5sb2dDb250ZXh0LFxuICAgIH0pO1xuICAgIC8vIHNhdmUgb3B0aW9ucyBmb3Igd2hlbiBpdCBuZWVkcyB0byBiZSByZXB1Ymxpc2hlZCBhZ2FpblxuICAgIHB1YmxpY2F0aW9uLm9wdGlvbnMgPSBvcHRzO1xuICAgIHRyYWNrLnNpZCA9IHRpLnNpZDtcblxuICAgIGlmICghdGhpcy5lbmdpbmUucGNNYW5hZ2VyKSB7XG4gICAgICB0aHJvdyBuZXcgVW5leHBlY3RlZENvbm5lY3Rpb25TdGF0ZSgncGNNYW5hZ2VyIGlzIG5vdCByZWFkeScpO1xuICAgIH1cbiAgICB0aGlzLmxvZy5kZWJ1ZyhgcHVibGlzaGluZyAke3RyYWNrLmtpbmR9IHdpdGggZW5jb2RpbmdzYCwge1xuICAgICAgLi4udGhpcy5sb2dDb250ZXh0LFxuICAgICAgZW5jb2RpbmdzLFxuICAgICAgdHJhY2tJbmZvOiB0aSxcbiAgICB9KTtcblxuICAgIHRyYWNrLnNlbmRlciA9IGF3YWl0IHRoaXMuZW5naW5lLmNyZWF0ZVNlbmRlcih0cmFjaywgb3B0cywgZW5jb2RpbmdzKTtcblxuICAgIGlmIChlbmNvZGluZ3MpIHtcbiAgICAgIGlmIChpc0ZpcmVGb3goKSAmJiB0cmFjay5raW5kID09PSBUcmFjay5LaW5kLkF1ZGlvKSB7XG4gICAgICAgIC8qIFJlZmVyIHRvIFJGQyBodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL3JmYzc1ODcjc2VjdGlvbi02LjEsXG4gICAgICAgICAgIGxpdmVraXQtc2VydmVyIHVzZXMgbWF4YXZlcmFnZWJpdHJhdGU9NTEwMDAwIGluIHRoZSBhbnN3ZXIgc2RwIHRvIHBlcm1pdCBjbGllbnQgdG9cbiAgICAgICAgICAgcHVibGlzaCBoaWdoIHF1YWxpdHkgYXVkaW8gdHJhY2suIEJ1dCBmaXJlZm94IGFsd2F5cyB1c2VzIHRoaXMgdmFsdWUgYXMgdGhlIGFjdHVhbFxuICAgICAgICAgICBiaXRyYXRlcywgY2F1c2luZyB0aGUgYXVkaW8gYml0cmF0ZXMgdG8gcmlzZSB0byA1MTBLYnBzIGluIGFueSBzdGVyZW8gY2FzZSB1bmV4cGVjdGVkbHkuXG4gICAgICAgICAgIFNvIHRoZSBjbGllbnQgbmVlZCB0byBtb2RpZnkgbWF4YXZlcnJhZ2ViaXRyYXRlcyBpbiBhbnN3ZXIgc2RwIHRvIHVzZXIgcHJvdmlkZWQgdmFsdWUgdG9cbiAgICAgICAgICAgZml4IHRoZSBpc3N1ZS5cbiAgICAgICAgICovXG4gICAgICAgIGxldCB0cmFja1RyYW5zY2VpdmVyOiBSVENSdHBUcmFuc2NlaXZlciB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgZm9yIChjb25zdCB0cmFuc2NlaXZlciBvZiB0aGlzLmVuZ2luZS5wY01hbmFnZXIucHVibGlzaGVyLmdldFRyYW5zY2VpdmVycygpKSB7XG4gICAgICAgICAgaWYgKHRyYW5zY2VpdmVyLnNlbmRlciA9PT0gdHJhY2suc2VuZGVyKSB7XG4gICAgICAgICAgICB0cmFja1RyYW5zY2VpdmVyID0gdHJhbnNjZWl2ZXI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRyYWNrVHJhbnNjZWl2ZXIpIHtcbiAgICAgICAgICB0aGlzLmVuZ2luZS5wY01hbmFnZXIucHVibGlzaGVyLnNldFRyYWNrQ29kZWNCaXRyYXRlKHtcbiAgICAgICAgICAgIHRyYW5zY2VpdmVyOiB0cmFja1RyYW5zY2VpdmVyLFxuICAgICAgICAgICAgY29kZWM6ICdvcHVzJyxcbiAgICAgICAgICAgIG1heGJyOiBlbmNvZGluZ3NbMF0/Lm1heEJpdHJhdGUgPyBlbmNvZGluZ3NbMF0ubWF4Qml0cmF0ZSAvIDEwMDAgOiAwLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHRyYWNrLmNvZGVjICYmIGlzU1ZDQ29kZWModHJhY2suY29kZWMpICYmIGVuY29kaW5nc1swXT8ubWF4Qml0cmF0ZSkge1xuICAgICAgICB0aGlzLmVuZ2luZS5wY01hbmFnZXIucHVibGlzaGVyLnNldFRyYWNrQ29kZWNCaXRyYXRlKHtcbiAgICAgICAgICBjaWQ6IHJlcS5jaWQsXG4gICAgICAgICAgY29kZWM6IHRyYWNrLmNvZGVjLFxuICAgICAgICAgIG1heGJyOiBlbmNvZGluZ3NbMF0ubWF4Qml0cmF0ZSAvIDEwMDAsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGF3YWl0IHRoaXMuZW5naW5lLm5lZ290aWF0ZSgpO1xuXG4gICAgaWYgKHRyYWNrIGluc3RhbmNlb2YgTG9jYWxWaWRlb1RyYWNrKSB7XG4gICAgICB0cmFjay5zdGFydE1vbml0b3IodGhpcy5lbmdpbmUuY2xpZW50KTtcbiAgICB9IGVsc2UgaWYgKHRyYWNrIGluc3RhbmNlb2YgTG9jYWxBdWRpb1RyYWNrKSB7XG4gICAgICB0cmFjay5zdGFydE1vbml0b3IoKTtcbiAgICB9XG5cbiAgICB0aGlzLmFkZFRyYWNrUHVibGljYXRpb24ocHVibGljYXRpb24pO1xuXG4gICAgLy8gc2VuZCBldmVudCBmb3IgcHVibGljYXRpb25cbiAgICB0aGlzLmVtaXQoUGFydGljaXBhbnRFdmVudC5Mb2NhbFRyYWNrUHVibGlzaGVkLCBwdWJsaWNhdGlvbik7XG4gICAgcmV0dXJuIHB1YmxpY2F0aW9uO1xuICB9XG5cbiAgb3ZlcnJpZGUgZ2V0IGlzTG9jYWwoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKiogQGludGVybmFsXG4gICAqIHB1Ymxpc2ggYWRkaXRpb25hbCBjb2RlYyB0byBleGlzdGluZyB0cmFja1xuICAgKi9cbiAgYXN5bmMgcHVibGlzaEFkZGl0aW9uYWxDb2RlY0ZvclRyYWNrKFxuICAgIHRyYWNrOiBMb2NhbFRyYWNrIHwgTWVkaWFTdHJlYW1UcmFjayxcbiAgICB2aWRlb0NvZGVjOiBCYWNrdXBWaWRlb0NvZGVjLFxuICAgIG9wdGlvbnM/OiBUcmFja1B1Ymxpc2hPcHRpb25zLFxuICApIHtcbiAgICAvLyBUT0RPIHJlbW92ZSBvbmNlIGUyZWUgaXMgc3VwcG9ydGVkIGZvciBiYWNrdXAgdHJhY2tzXG4gICAgaWYgKHRoaXMuZW5jcnlwdGlvblR5cGUgIT09IEVuY3J5cHRpb25fVHlwZS5OT05FKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gaXMgaXQgbm90IHB1Ymxpc2hlZD8gaWYgc28gc2tpcFxuICAgIGxldCBleGlzdGluZ1B1YmxpY2F0aW9uOiBMb2NhbFRyYWNrUHVibGljYXRpb24gfCB1bmRlZmluZWQ7XG4gICAgdGhpcy50cmFja3MuZm9yRWFjaCgocHVibGljYXRpb24pID0+IHtcbiAgICAgIGlmICghcHVibGljYXRpb24udHJhY2spIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHB1YmxpY2F0aW9uLnRyYWNrID09PSB0cmFjaykge1xuICAgICAgICBleGlzdGluZ1B1YmxpY2F0aW9uID0gPExvY2FsVHJhY2tQdWJsaWNhdGlvbj5wdWJsaWNhdGlvbjtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoIWV4aXN0aW5nUHVibGljYXRpb24pIHtcbiAgICAgIHRocm93IG5ldyBUcmFja0ludmFsaWRFcnJvcigndHJhY2sgaXMgbm90IHB1Ymxpc2hlZCcpO1xuICAgIH1cblxuICAgIGlmICghKHRyYWNrIGluc3RhbmNlb2YgTG9jYWxWaWRlb1RyYWNrKSkge1xuICAgICAgdGhyb3cgbmV3IFRyYWNrSW52YWxpZEVycm9yKCd0cmFjayBpcyBub3QgYSB2aWRlbyB0cmFjaycpO1xuICAgIH1cblxuICAgIGNvbnN0IG9wdHM6IFRyYWNrUHVibGlzaE9wdGlvbnMgPSB7XG4gICAgICAuLi50aGlzLnJvb21PcHRpb25zPy5wdWJsaXNoRGVmYXVsdHMsXG4gICAgICAuLi5vcHRpb25zLFxuICAgIH07XG5cbiAgICBjb25zdCBlbmNvZGluZ3MgPSBjb21wdXRlVHJhY2tCYWNrdXBFbmNvZGluZ3ModHJhY2ssIHZpZGVvQ29kZWMsIG9wdHMpO1xuICAgIGlmICghZW5jb2RpbmdzKSB7XG4gICAgICB0aGlzLmxvZy5pbmZvKFxuICAgICAgICBgYmFja3VwIGNvZGVjIGhhcyBiZWVuIGRpc2FibGVkLCBpZ25vcmluZyByZXF1ZXN0IHRvIGFkZCBhZGRpdGlvbmFsIGNvZGVjIGZvciB0cmFja2AsXG4gICAgICAgIHtcbiAgICAgICAgICAuLi50aGlzLmxvZ0NvbnRleHQsXG4gICAgICAgICAgLi4uZ2V0TG9nQ29udGV4dEZyb21UcmFjayh0cmFjayksXG4gICAgICAgIH0sXG4gICAgICApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzaW11bGNhc3RUcmFjayA9IHRyYWNrLmFkZFNpbXVsY2FzdFRyYWNrKHZpZGVvQ29kZWMsIGVuY29kaW5ncyk7XG4gICAgY29uc3QgcmVxID0gbmV3IEFkZFRyYWNrUmVxdWVzdCh7XG4gICAgICBjaWQ6IHNpbXVsY2FzdFRyYWNrLm1lZGlhU3RyZWFtVHJhY2suaWQsXG4gICAgICB0eXBlOiBUcmFjay5raW5kVG9Qcm90byh0cmFjay5raW5kKSxcbiAgICAgIG11dGVkOiB0cmFjay5pc011dGVkLFxuICAgICAgc291cmNlOiBUcmFjay5zb3VyY2VUb1Byb3RvKHRyYWNrLnNvdXJjZSksXG4gICAgICBzaWQ6IHRyYWNrLnNpZCxcbiAgICAgIHNpbXVsY2FzdENvZGVjczogW1xuICAgICAgICB7XG4gICAgICAgICAgY29kZWM6IG9wdHMudmlkZW9Db2RlYyxcbiAgICAgICAgICBjaWQ6IHNpbXVsY2FzdFRyYWNrLm1lZGlhU3RyZWFtVHJhY2suaWQsXG4gICAgICAgIH0sXG4gICAgICBdLFxuICAgIH0pO1xuICAgIHJlcS5sYXllcnMgPSB2aWRlb0xheWVyc0Zyb21FbmNvZGluZ3MocmVxLndpZHRoLCByZXEuaGVpZ2h0LCBlbmNvZGluZ3MpO1xuXG4gICAgaWYgKCF0aGlzLmVuZ2luZSB8fCB0aGlzLmVuZ2luZS5pc0Nsb3NlZCkge1xuICAgICAgdGhyb3cgbmV3IFVuZXhwZWN0ZWRDb25uZWN0aW9uU3RhdGUoJ2Nhbm5vdCBwdWJsaXNoIHRyYWNrIHdoZW4gbm90IGNvbm5lY3RlZCcpO1xuICAgIH1cblxuICAgIGNvbnN0IHRpID0gYXdhaXQgdGhpcy5lbmdpbmUuYWRkVHJhY2socmVxKTtcblxuICAgIGNvbnN0IHRyYW5zY2VpdmVySW5pdDogUlRDUnRwVHJhbnNjZWl2ZXJJbml0ID0geyBkaXJlY3Rpb246ICdzZW5kb25seScgfTtcbiAgICBpZiAoZW5jb2RpbmdzKSB7XG4gICAgICB0cmFuc2NlaXZlckluaXQuc2VuZEVuY29kaW5ncyA9IGVuY29kaW5ncztcbiAgICB9XG4gICAgYXdhaXQgdGhpcy5lbmdpbmUuY3JlYXRlU2ltdWxjYXN0U2VuZGVyKHRyYWNrLCBzaW11bGNhc3RUcmFjaywgb3B0cywgZW5jb2RpbmdzKTtcblxuICAgIGF3YWl0IHRoaXMuZW5naW5lLm5lZ290aWF0ZSgpO1xuICAgIHRoaXMubG9nLmRlYnVnKGBwdWJsaXNoZWQgJHt2aWRlb0NvZGVjfSBmb3IgdHJhY2sgJHt0cmFjay5zaWR9YCwge1xuICAgICAgLi4udGhpcy5sb2dDb250ZXh0LFxuICAgICAgZW5jb2RpbmdzLFxuICAgICAgdHJhY2tJbmZvOiB0aSxcbiAgICB9KTtcbiAgfVxuXG4gIGFzeW5jIHVucHVibGlzaFRyYWNrKFxuICAgIHRyYWNrOiBMb2NhbFRyYWNrIHwgTWVkaWFTdHJlYW1UcmFjayxcbiAgICBzdG9wT25VbnB1Ymxpc2g/OiBib29sZWFuLFxuICApOiBQcm9taXNlPExvY2FsVHJhY2tQdWJsaWNhdGlvbiB8IHVuZGVmaW5lZD4ge1xuICAgIC8vIGxvb2sgdGhyb3VnaCBhbGwgcHVibGlzaGVkIHRyYWNrcyB0byBmaW5kIHRoZSByaWdodCBvbmVzXG4gICAgY29uc3QgcHVibGljYXRpb24gPSB0aGlzLmdldFB1YmxpY2F0aW9uRm9yVHJhY2sodHJhY2spO1xuXG4gICAgY29uc3QgcHViTG9nQ29udGV4dCA9IHB1YmxpY2F0aW9uID8gZ2V0TG9nQ29udGV4dEZyb21UcmFjayhwdWJsaWNhdGlvbikgOiB1bmRlZmluZWQ7XG5cbiAgICB0aGlzLmxvZy5kZWJ1ZygndW5wdWJsaXNoaW5nIHRyYWNrJywge1xuICAgICAgLi4udGhpcy5sb2dDb250ZXh0LFxuICAgICAgLi4ucHViTG9nQ29udGV4dCxcbiAgICB9KTtcblxuICAgIGlmICghcHVibGljYXRpb24gfHwgIXB1YmxpY2F0aW9uLnRyYWNrKSB7XG4gICAgICB0aGlzLmxvZy53YXJuKCd0cmFjayB3YXMgbm90IHVucHVibGlzaGVkIGJlY2F1c2Ugbm8gcHVibGljYXRpb24gd2FzIGZvdW5kJywge1xuICAgICAgICAuLi50aGlzLmxvZ0NvbnRleHQsXG4gICAgICAgIC4uLnB1YkxvZ0NvbnRleHQsXG4gICAgICB9KTtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgdHJhY2sgPSBwdWJsaWNhdGlvbi50cmFjaztcbiAgICB0cmFjay5vZmYoVHJhY2tFdmVudC5NdXRlZCwgdGhpcy5vblRyYWNrTXV0ZWQpO1xuICAgIHRyYWNrLm9mZihUcmFja0V2ZW50LlVubXV0ZWQsIHRoaXMub25UcmFja1VubXV0ZWQpO1xuICAgIHRyYWNrLm9mZihUcmFja0V2ZW50LkVuZGVkLCB0aGlzLmhhbmRsZVRyYWNrRW5kZWQpO1xuICAgIHRyYWNrLm9mZihUcmFja0V2ZW50LlVwc3RyZWFtUGF1c2VkLCB0aGlzLm9uVHJhY2tVcHN0cmVhbVBhdXNlZCk7XG4gICAgdHJhY2sub2ZmKFRyYWNrRXZlbnQuVXBzdHJlYW1SZXN1bWVkLCB0aGlzLm9uVHJhY2tVcHN0cmVhbVJlc3VtZWQpO1xuXG4gICAgaWYgKHN0b3BPblVucHVibGlzaCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBzdG9wT25VbnB1Ymxpc2ggPSB0aGlzLnJvb21PcHRpb25zPy5zdG9wTG9jYWxUcmFja09uVW5wdWJsaXNoID8/IHRydWU7XG4gICAgfVxuICAgIGlmIChzdG9wT25VbnB1Ymxpc2gpIHtcbiAgICAgIHRyYWNrLnN0b3AoKTtcbiAgICB9XG5cbiAgICBsZXQgbmVnb3RpYXRpb25OZWVkZWQgPSBmYWxzZTtcbiAgICBjb25zdCB0cmFja1NlbmRlciA9IHRyYWNrLnNlbmRlcjtcbiAgICB0cmFjay5zZW5kZXIgPSB1bmRlZmluZWQ7XG4gICAgaWYgKFxuICAgICAgdGhpcy5lbmdpbmUucGNNYW5hZ2VyICYmXG4gICAgICB0aGlzLmVuZ2luZS5wY01hbmFnZXIuY3VycmVudFN0YXRlIDwgUENUcmFuc3BvcnRTdGF0ZS5GQUlMRUQgJiZcbiAgICAgIHRyYWNrU2VuZGVyXG4gICAgKSB7XG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKGNvbnN0IHRyYW5zY2VpdmVyIG9mIHRoaXMuZW5naW5lLnBjTWFuYWdlci5wdWJsaXNoZXIuZ2V0VHJhbnNjZWl2ZXJzKCkpIHtcbiAgICAgICAgICAvLyBpZiBzZW5kZXIgaXMgbm90IGN1cnJlbnRseSBzZW5kaW5nIChhZnRlciByZXBsYWNlVHJhY2sobnVsbCkpXG4gICAgICAgICAgLy8gcmVtb3ZlVHJhY2sgd291bGQgaGF2ZSBubyBlZmZlY3QuXG4gICAgICAgICAgLy8gdG8gZW5zdXJlIHdlIGVuZCB1cCBzdWNjZXNzZnVsbHkgcmVtb3ZpbmcgdGhlIHRyYWNrLCBtYW51YWxseSBzZXRcbiAgICAgICAgICAvLyB0aGUgdHJhbnNjZWl2ZXIgdG8gaW5hY3RpdmVcbiAgICAgICAgICBpZiAodHJhbnNjZWl2ZXIuc2VuZGVyID09PSB0cmFja1NlbmRlcikge1xuICAgICAgICAgICAgdHJhbnNjZWl2ZXIuZGlyZWN0aW9uID0gJ2luYWN0aXZlJztcbiAgICAgICAgICAgIG5lZ290aWF0aW9uTmVlZGVkID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZW5naW5lLnJlbW92ZVRyYWNrKHRyYWNrU2VuZGVyKSkge1xuICAgICAgICAgIG5lZ290aWF0aW9uTmVlZGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHJhY2sgaW5zdGFuY2VvZiBMb2NhbFZpZGVvVHJhY2spIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IFssIHRyYWNrSW5mb10gb2YgdHJhY2suc2ltdWxjYXN0Q29kZWNzKSB7XG4gICAgICAgICAgICBpZiAodHJhY2tJbmZvLnNlbmRlcikge1xuICAgICAgICAgICAgICBpZiAodGhpcy5lbmdpbmUucmVtb3ZlVHJhY2sodHJhY2tJbmZvLnNlbmRlcikpIHtcbiAgICAgICAgICAgICAgICBuZWdvdGlhdGlvbk5lZWRlZCA9IHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdHJhY2tJbmZvLnNlbmRlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdHJhY2suc2ltdWxjYXN0Q29kZWNzLmNsZWFyKCk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhpcy5sb2cud2FybignZmFpbGVkIHRvIHVucHVibGlzaCB0cmFjaycsIHtcbiAgICAgICAgICAuLi50aGlzLmxvZ0NvbnRleHQsXG4gICAgICAgICAgLi4ucHViTG9nQ29udGV4dCxcbiAgICAgICAgICBlcnJvcjogZSxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gcmVtb3ZlIGZyb20gb3VyIG1hcHNcbiAgICB0aGlzLnRyYWNrcy5kZWxldGUocHVibGljYXRpb24udHJhY2tTaWQpO1xuICAgIHN3aXRjaCAocHVibGljYXRpb24ua2luZCkge1xuICAgICAgY2FzZSBUcmFjay5LaW5kLkF1ZGlvOlxuICAgICAgICB0aGlzLmF1ZGlvVHJhY2tzLmRlbGV0ZShwdWJsaWNhdGlvbi50cmFja1NpZCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBUcmFjay5LaW5kLlZpZGVvOlxuICAgICAgICB0aGlzLnZpZGVvVHJhY2tzLmRlbGV0ZShwdWJsaWNhdGlvbi50cmFja1NpZCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgdGhpcy5lbWl0KFBhcnRpY2lwYW50RXZlbnQuTG9jYWxUcmFja1VucHVibGlzaGVkLCBwdWJsaWNhdGlvbik7XG4gICAgcHVibGljYXRpb24uc2V0VHJhY2sodW5kZWZpbmVkKTtcblxuICAgIGlmIChuZWdvdGlhdGlvbk5lZWRlZCkge1xuICAgICAgYXdhaXQgdGhpcy5lbmdpbmUubmVnb3RpYXRlKCk7XG4gICAgfVxuICAgIHJldHVybiBwdWJsaWNhdGlvbjtcbiAgfVxuXG4gIGFzeW5jIHVucHVibGlzaFRyYWNrcyhcbiAgICB0cmFja3M6IExvY2FsVHJhY2tbXSB8IE1lZGlhU3RyZWFtVHJhY2tbXSxcbiAgKTogUHJvbWlzZTxMb2NhbFRyYWNrUHVibGljYXRpb25bXT4ge1xuICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCBQcm9taXNlLmFsbCh0cmFja3MubWFwKCh0cmFjaykgPT4gdGhpcy51bnB1Ymxpc2hUcmFjayh0cmFjaykpKTtcbiAgICByZXR1cm4gcmVzdWx0cy5maWx0ZXIoXG4gICAgICAodHJhY2spID0+IHRyYWNrIGluc3RhbmNlb2YgTG9jYWxUcmFja1B1YmxpY2F0aW9uLFxuICAgICkgYXMgTG9jYWxUcmFja1B1YmxpY2F0aW9uW107XG4gIH1cblxuICBhc3luYyByZXB1Ymxpc2hBbGxUcmFja3Mob3B0aW9ucz86IFRyYWNrUHVibGlzaE9wdGlvbnMsIHJlc3RhcnRUcmFja3M6IGJvb2xlYW4gPSB0cnVlKSB7XG4gICAgY29uc3QgbG9jYWxQdWJzOiBMb2NhbFRyYWNrUHVibGljYXRpb25bXSA9IFtdO1xuICAgIHRoaXMudHJhY2tzLmZvckVhY2goKHB1YikgPT4ge1xuICAgICAgaWYgKHB1Yi50cmFjaykge1xuICAgICAgICBpZiAob3B0aW9ucykge1xuICAgICAgICAgIHB1Yi5vcHRpb25zID0geyAuLi5wdWIub3B0aW9ucywgLi4ub3B0aW9ucyB9O1xuICAgICAgICB9XG4gICAgICAgIGxvY2FsUHVicy5wdXNoKHB1Yik7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgIGxvY2FsUHVicy5tYXAoYXN5bmMgKHB1YikgPT4ge1xuICAgICAgICBjb25zdCB0cmFjayA9IHB1Yi50cmFjayE7XG4gICAgICAgIGF3YWl0IHRoaXMudW5wdWJsaXNoVHJhY2sodHJhY2ssIGZhbHNlKTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIHJlc3RhcnRUcmFja3MgJiZcbiAgICAgICAgICAhdHJhY2suaXNNdXRlZCAmJlxuICAgICAgICAgIHRyYWNrLnNvdXJjZSAhPT0gVHJhY2suU291cmNlLlNjcmVlblNoYXJlICYmXG4gICAgICAgICAgdHJhY2suc291cmNlICE9PSBUcmFjay5Tb3VyY2UuU2NyZWVuU2hhcmVBdWRpbyAmJlxuICAgICAgICAgICh0cmFjayBpbnN0YW5jZW9mIExvY2FsQXVkaW9UcmFjayB8fCB0cmFjayBpbnN0YW5jZW9mIExvY2FsVmlkZW9UcmFjaykgJiZcbiAgICAgICAgICAhdHJhY2suaXNVc2VyUHJvdmlkZWRcbiAgICAgICAgKSB7XG4gICAgICAgICAgLy8gZ2VuZXJhbGx5IHdlIG5lZWQgdG8gcmVzdGFydCB0aGUgdHJhY2sgYmVmb3JlIHB1Ymxpc2hpbmcsIG9mdGVuIGEgZnVsbCByZWNvbm5lY3RcbiAgICAgICAgICAvLyBpcyBuZWNlc3NhcnkgYmVjYXVzZSBjb21wdXRlciBoYWQgZ29uZSB0byBzbGVlcC5cbiAgICAgICAgICB0aGlzLmxvZy5kZWJ1ZygncmVzdGFydGluZyBleGlzdGluZyB0cmFjaycsIHtcbiAgICAgICAgICAgIC4uLnRoaXMubG9nQ29udGV4dCxcbiAgICAgICAgICAgIHRyYWNrOiBwdWIudHJhY2tTaWQsXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYXdhaXQgdHJhY2sucmVzdGFydFRyYWNrKCk7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgdGhpcy5wdWJsaXNoVHJhY2sodHJhY2ssIHB1Yi5vcHRpb25zKTtcbiAgICAgIH0pLFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogUHVibGlzaCBhIG5ldyBkYXRhIHBheWxvYWQgdG8gdGhlIHJvb20uIERhdGEgd2lsbCBiZSBmb3J3YXJkZWQgdG8gZWFjaFxuICAgKiBwYXJ0aWNpcGFudCBpbiB0aGUgcm9vbSBpZiB0aGUgZGVzdGluYXRpb24gZmllbGQgaW4gcHVibGlzaE9wdGlvbnMgaXMgZW1wdHlcbiAgICpcbiAgICogQHBhcmFtIGRhdGEgVWludDhBcnJheSBvZiB0aGUgcGF5bG9hZC4gVG8gc2VuZCBzdHJpbmcgZGF0YSwgdXNlIFRleHRFbmNvZGVyLmVuY29kZVxuICAgKiBAcGFyYW0ga2luZCB3aGV0aGVyIHRvIHNlbmQgdGhpcyBhcyByZWxpYWJsZSBvciBsb3NzeS5cbiAgICogRm9yIGRhdGEgdGhhdCB5b3UgbmVlZCBkZWxpdmVyeSBndWFyYW50ZWUgKHN1Y2ggYXMgY2hhdCBtZXNzYWdlcyksIHVzZSBSZWxpYWJsZS5cbiAgICogRm9yIGRhdGEgdGhhdCBzaG91bGQgYXJyaXZlIGFzIHF1aWNrbHkgYXMgcG9zc2libGUsIGJ1dCB5b3UgYXJlIG9rIHdpdGggZHJvcHBlZFxuICAgKiBwYWNrZXRzLCB1c2UgTG9zc3kuXG4gICAqIEBwYXJhbSBwdWJsaXNoT3B0aW9ucyBvcHRpb25hbGx5IHNwZWNpZnkgYSBgdG9waWNgIGFuZCBgZGVzdGluYXRpb25gXG4gICAqL1xuICBhc3luYyBwdWJsaXNoRGF0YShcbiAgICBkYXRhOiBVaW50OEFycmF5LFxuICAgIGtpbmQ6IERhdGFQYWNrZXRfS2luZCxcbiAgICBwdWJsaXNoT3B0aW9ucz86IERhdGFQdWJsaXNoT3B0aW9ucyxcbiAgKTogUHJvbWlzZTx2b2lkPjtcbiAgLyoqXG4gICAqIFB1Ymxpc2ggYSBuZXcgZGF0YSBwYXlsb2FkIHRvIHRoZSByb29tLiBEYXRhIHdpbGwgYmUgZm9yd2FyZGVkIHRvIGVhY2hcbiAgICogcGFydGljaXBhbnQgaW4gdGhlIHJvb20gaWYgdGhlIGRlc3RpbmF0aW9uIGFyZ3VtZW50IGlzIGVtcHR5XG4gICAqXG4gICAqIEBwYXJhbSBkYXRhIFVpbnQ4QXJyYXkgb2YgdGhlIHBheWxvYWQuIFRvIHNlbmQgc3RyaW5nIGRhdGEsIHVzZSBUZXh0RW5jb2Rlci5lbmNvZGVcbiAgICogQHBhcmFtIGtpbmQgd2hldGhlciB0byBzZW5kIHRoaXMgYXMgcmVsaWFibGUgb3IgbG9zc3kuXG4gICAqIEZvciBkYXRhIHRoYXQgeW91IG5lZWQgZGVsaXZlcnkgZ3VhcmFudGVlIChzdWNoIGFzIGNoYXQgbWVzc2FnZXMpLCB1c2UgUmVsaWFibGUuXG4gICAqIEZvciBkYXRhIHRoYXQgc2hvdWxkIGFycml2ZSBhcyBxdWlja2x5IGFzIHBvc3NpYmxlLCBidXQgeW91IGFyZSBvayB3aXRoIGRyb3BwZWRcbiAgICogcGFja2V0cywgdXNlIExvc3N5LlxuICAgKiBAcGFyYW0gZGVzdGluYXRpb24gdGhlIHBhcnRpY2lwYW50cyB3aG8gd2lsbCByZWNlaXZlIHRoZSBtZXNzYWdlXG4gICAqL1xuICBhc3luYyBwdWJsaXNoRGF0YShcbiAgICBkYXRhOiBVaW50OEFycmF5LFxuICAgIGtpbmQ6IERhdGFQYWNrZXRfS2luZCxcbiAgICBkZXN0aW5hdGlvbj86IFJlbW90ZVBhcnRpY2lwYW50W10gfCBzdHJpbmdbXSxcbiAgKTogUHJvbWlzZTx2b2lkPjtcblxuICBhc3luYyBwdWJsaXNoRGF0YShcbiAgICBkYXRhOiBVaW50OEFycmF5LFxuICAgIGtpbmQ6IERhdGFQYWNrZXRfS2luZCxcbiAgICBwdWJsaXNoT3B0aW9uczogRGF0YVB1Ymxpc2hPcHRpb25zIHwgUmVtb3RlUGFydGljaXBhbnRbXSB8IHN0cmluZ1tdID0ge30sXG4gICkge1xuICAgIGNvbnN0IGRlc3RpbmF0aW9uID0gQXJyYXkuaXNBcnJheShwdWJsaXNoT3B0aW9ucylcbiAgICAgID8gcHVibGlzaE9wdGlvbnNcbiAgICAgIDogcHVibGlzaE9wdGlvbnM/LmRlc3RpbmF0aW9uO1xuICAgIGNvbnN0IGRlc3RpbmF0aW9uU2lkczogc3RyaW5nW10gPSBbXTtcblxuICAgIGNvbnN0IHRvcGljID0gIUFycmF5LmlzQXJyYXkocHVibGlzaE9wdGlvbnMpID8gcHVibGlzaE9wdGlvbnMudG9waWMgOiB1bmRlZmluZWQ7XG5cbiAgICBpZiAoZGVzdGluYXRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgZGVzdGluYXRpb24uZm9yRWFjaCgodmFsOiBhbnkpID0+IHtcbiAgICAgICAgaWYgKHZhbCBpbnN0YW5jZW9mIFJlbW90ZVBhcnRpY2lwYW50KSB7XG4gICAgICAgICAgZGVzdGluYXRpb25TaWRzLnB1c2godmFsLnNpZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGVzdGluYXRpb25TaWRzLnB1c2godmFsKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgY29uc3QgcGFja2V0ID0gbmV3IERhdGFQYWNrZXQoe1xuICAgICAga2luZCxcbiAgICAgIHZhbHVlOiB7XG4gICAgICAgIGNhc2U6ICd1c2VyJyxcbiAgICAgICAgdmFsdWU6IG5ldyBVc2VyUGFja2V0KHtcbiAgICAgICAgICBwYXJ0aWNpcGFudFNpZDogdGhpcy5zaWQsXG4gICAgICAgICAgcGF5bG9hZDogZGF0YSxcbiAgICAgICAgICBkZXN0aW5hdGlvblNpZHM6IGRlc3RpbmF0aW9uU2lkcyxcbiAgICAgICAgICB0b3BpYyxcbiAgICAgICAgfSksXG4gICAgICB9LFxuICAgIH0pO1xuXG4gICAgYXdhaXQgdGhpcy5lbmdpbmUuc2VuZERhdGFQYWNrZXQocGFja2V0LCBraW5kKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb250cm9sIHdobyBjYW4gc3Vic2NyaWJlIHRvIExvY2FsUGFydGljaXBhbnQncyBwdWJsaXNoZWQgdHJhY2tzLlxuICAgKlxuICAgKiBCeSBkZWZhdWx0LCBhbGwgcGFydGljaXBhbnRzIGNhbiBzdWJzY3JpYmUuIFRoaXMgYWxsb3dzIGZpbmUtZ3JhaW5lZCBjb250cm9sIG92ZXJcbiAgICogd2hvIGlzIGFibGUgdG8gc3Vic2NyaWJlIGF0IGEgcGFydGljaXBhbnQgYW5kIHRyYWNrIGxldmVsLlxuICAgKlxuICAgKiBOb3RlOiBpZiBhY2Nlc3MgaXMgZ2l2ZW4gYXQgYSB0cmFjay1sZXZlbCAoaS5lLiBib3RoIFthbGxQYXJ0aWNpcGFudHNBbGxvd2VkXSBhbmRcbiAgICogW1BhcnRpY2lwYW50VHJhY2tQZXJtaXNzaW9uLmFsbFRyYWNrc0FsbG93ZWRdIGFyZSBmYWxzZSksIGFueSBuZXdlciBwdWJsaXNoZWQgdHJhY2tzXG4gICAqIHdpbGwgbm90IGdyYW50IHBlcm1pc3Npb25zIHRvIGFueSBwYXJ0aWNpcGFudHMgYW5kIHdpbGwgcmVxdWlyZSBhIHN1YnNlcXVlbnRcbiAgICogcGVybWlzc2lvbnMgdXBkYXRlIHRvIGFsbG93IHN1YnNjcmlwdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIGFsbFBhcnRpY2lwYW50c0FsbG93ZWQgQWxsb3dzIGFsbCBwYXJ0aWNpcGFudHMgdG8gc3Vic2NyaWJlIGFsbCB0cmFja3MuXG4gICAqICBUYWtlcyBwcmVjZWRlbmNlIG92ZXIgW1twYXJ0aWNpcGFudFRyYWNrUGVybWlzc2lvbnNdXSBpZiBzZXQgdG8gdHJ1ZS5cbiAgICogIEJ5IGRlZmF1bHQgdGhpcyBpcyBzZXQgdG8gdHJ1ZS5cbiAgICogQHBhcmFtIHBhcnRpY2lwYW50VHJhY2tQZXJtaXNzaW9ucyBGdWxsIGxpc3Qgb2YgaW5kaXZpZHVhbCBwZXJtaXNzaW9ucyBwZXJcbiAgICogIHBhcnRpY2lwYW50L3RyYWNrLiBBbnkgb21pdHRlZCBwYXJ0aWNpcGFudHMgd2lsbCBub3QgcmVjZWl2ZSBhbnkgcGVybWlzc2lvbnMuXG4gICAqL1xuICBzZXRUcmFja1N1YnNjcmlwdGlvblBlcm1pc3Npb25zKFxuICAgIGFsbFBhcnRpY2lwYW50c0FsbG93ZWQ6IGJvb2xlYW4sXG4gICAgcGFydGljaXBhbnRUcmFja1Blcm1pc3Npb25zOiBQYXJ0aWNpcGFudFRyYWNrUGVybWlzc2lvbltdID0gW10sXG4gICkge1xuICAgIHRoaXMucGFydGljaXBhbnRUcmFja1Blcm1pc3Npb25zID0gcGFydGljaXBhbnRUcmFja1Blcm1pc3Npb25zO1xuICAgIHRoaXMuYWxsUGFydGljaXBhbnRzQWxsb3dlZFRvU3Vic2NyaWJlID0gYWxsUGFydGljaXBhbnRzQWxsb3dlZDtcbiAgICBpZiAoIXRoaXMuZW5naW5lLmNsaWVudC5pc0Rpc2Nvbm5lY3RlZCkge1xuICAgICAgdGhpcy51cGRhdGVUcmFja1N1YnNjcmlwdGlvblBlcm1pc3Npb25zKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICB1cGRhdGVJbmZvKGluZm86IFBhcnRpY2lwYW50SW5mbyk6IGJvb2xlYW4ge1xuICAgIGlmIChpbmZvLnNpZCAhPT0gdGhpcy5zaWQpIHtcbiAgICAgIC8vIGRyb3AgdXBkYXRlcyB0aGF0IHNwZWNpZnkgYSB3cm9uZyBzaWQuXG4gICAgICAvLyB0aGUgc2lkIGZvciBsb2NhbCBwYXJ0aWNpcGFudCBpcyBvbmx5IGV4cGxpY2l0bHkgc2V0IG9uIGpvaW4gYW5kIGZ1bGwgcmVjb25uZWN0XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICghc3VwZXIudXBkYXRlSW5mbyhpbmZvKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIHJlY29uY2lsZSB0cmFjayBtdXRlIHN0YXR1cy5cbiAgICAvLyBpZiBzZXJ2ZXIncyB0cmFjayBtdXRlIHN0YXR1cyBkb2Vzbid0IG1hdGNoIGFjdHVhbCwgd2UnbGwgaGF2ZSB0byB1cGRhdGVcbiAgICAvLyB0aGUgc2VydmVyJ3MgY29weVxuICAgIGluZm8udHJhY2tzLmZvckVhY2goKHRpKSA9PiB7XG4gICAgICBjb25zdCBwdWIgPSB0aGlzLnRyYWNrcy5nZXQodGkuc2lkKTtcblxuICAgICAgaWYgKHB1Yikge1xuICAgICAgICBjb25zdCBtdXRlZE9uU2VydmVyID0gcHViLmlzTXV0ZWQgfHwgKHB1Yi50cmFjaz8uaXNVcHN0cmVhbVBhdXNlZCA/PyBmYWxzZSk7XG4gICAgICAgIGlmIChtdXRlZE9uU2VydmVyICE9PSB0aS5tdXRlZCkge1xuICAgICAgICAgIHRoaXMubG9nLmRlYnVnKCd1cGRhdGluZyBzZXJ2ZXIgbXV0ZSBzdGF0ZSBhZnRlciByZWNvbmNpbGUnLCB7XG4gICAgICAgICAgICAuLi50aGlzLmxvZ0NvbnRleHQsXG4gICAgICAgICAgICAuLi5nZXRMb2dDb250ZXh0RnJvbVRyYWNrKHB1YiksXG4gICAgICAgICAgICBtdXRlZE9uU2VydmVyLFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRoaXMuZW5naW5lLmNsaWVudC5zZW5kTXV0ZVRyYWNrKHRpLnNpZCwgbXV0ZWRPblNlcnZlcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHByaXZhdGUgdXBkYXRlVHJhY2tTdWJzY3JpcHRpb25QZXJtaXNzaW9ucyA9ICgpID0+IHtcbiAgICB0aGlzLmxvZy5kZWJ1ZygndXBkYXRpbmcgdHJhY2sgc3Vic2NyaXB0aW9uIHBlcm1pc3Npb25zJywge1xuICAgICAgLi4udGhpcy5sb2dDb250ZXh0LFxuICAgICAgYWxsUGFydGljaXBhbnRzQWxsb3dlZDogdGhpcy5hbGxQYXJ0aWNpcGFudHNBbGxvd2VkVG9TdWJzY3JpYmUsXG4gICAgICBwYXJ0aWNpcGFudFRyYWNrUGVybWlzc2lvbnM6IHRoaXMucGFydGljaXBhbnRUcmFja1Blcm1pc3Npb25zLFxuICAgIH0pO1xuICAgIHRoaXMuZW5naW5lLmNsaWVudC5zZW5kVXBkYXRlU3Vic2NyaXB0aW9uUGVybWlzc2lvbnMoXG4gICAgICB0aGlzLmFsbFBhcnRpY2lwYW50c0FsbG93ZWRUb1N1YnNjcmliZSxcbiAgICAgIHRoaXMucGFydGljaXBhbnRUcmFja1Blcm1pc3Npb25zLm1hcCgocCkgPT4gdHJhY2tQZXJtaXNzaW9uVG9Qcm90byhwKSksXG4gICAgKTtcbiAgfTtcblxuICAvKiogQGludGVybmFsICovXG4gIHByaXZhdGUgb25UcmFja1VubXV0ZWQgPSAodHJhY2s6IExvY2FsVHJhY2spID0+IHtcbiAgICB0aGlzLm9uVHJhY2tNdXRlZCh0cmFjaywgdHJhY2suaXNVcHN0cmVhbVBhdXNlZCk7XG4gIH07XG5cbiAgLy8gd2hlbiB0aGUgbG9jYWwgdHJhY2sgY2hhbmdlcyBpbiBtdXRlIHN0YXR1cywgd2UnbGwgbm90aWZ5IHNlcnZlciBhcyBzdWNoXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgcHJpdmF0ZSBvblRyYWNrTXV0ZWQgPSAodHJhY2s6IExvY2FsVHJhY2ssIG11dGVkPzogYm9vbGVhbikgPT4ge1xuICAgIGlmIChtdXRlZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBtdXRlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKCF0cmFjay5zaWQpIHtcbiAgICAgIHRoaXMubG9nLmVycm9yKCdjb3VsZCBub3QgdXBkYXRlIG11dGUgc3RhdHVzIGZvciB1bnB1Ymxpc2hlZCB0cmFjaycsIHtcbiAgICAgICAgLi4udGhpcy5sb2dDb250ZXh0LFxuICAgICAgICAuLi5nZXRMb2dDb250ZXh0RnJvbVRyYWNrKHRyYWNrKSxcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuZW5naW5lLnVwZGF0ZU11dGVTdGF0dXModHJhY2suc2lkLCBtdXRlZCk7XG4gIH07XG5cbiAgcHJpdmF0ZSBvblRyYWNrVXBzdHJlYW1QYXVzZWQgPSAodHJhY2s6IExvY2FsVHJhY2spID0+IHtcbiAgICB0aGlzLmxvZy5kZWJ1ZygndXBzdHJlYW0gcGF1c2VkJywge1xuICAgICAgLi4udGhpcy5sb2dDb250ZXh0LFxuICAgICAgLi4uZ2V0TG9nQ29udGV4dEZyb21UcmFjayh0cmFjayksXG4gICAgfSk7XG4gICAgdGhpcy5vblRyYWNrTXV0ZWQodHJhY2ssIHRydWUpO1xuICB9O1xuXG4gIHByaXZhdGUgb25UcmFja1Vwc3RyZWFtUmVzdW1lZCA9ICh0cmFjazogTG9jYWxUcmFjaykgPT4ge1xuICAgIHRoaXMubG9nLmRlYnVnKCd1cHN0cmVhbSByZXN1bWVkJywge1xuICAgICAgLi4udGhpcy5sb2dDb250ZXh0LFxuICAgICAgLi4uZ2V0TG9nQ29udGV4dEZyb21UcmFjayh0cmFjayksXG4gICAgfSk7XG4gICAgdGhpcy5vblRyYWNrTXV0ZWQodHJhY2ssIHRyYWNrLmlzTXV0ZWQpO1xuICB9O1xuXG4gIHByaXZhdGUgaGFuZGxlU3Vic2NyaWJlZFF1YWxpdHlVcGRhdGUgPSBhc3luYyAodXBkYXRlOiBTdWJzY3JpYmVkUXVhbGl0eVVwZGF0ZSkgPT4ge1xuICAgIGlmICghdGhpcy5yb29tT3B0aW9ucz8uZHluYWNhc3QpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgcHViID0gdGhpcy52aWRlb1RyYWNrcy5nZXQodXBkYXRlLnRyYWNrU2lkKTtcbiAgICBpZiAoIXB1Yikge1xuICAgICAgdGhpcy5sb2cud2FybigncmVjZWl2ZWQgc3Vic2NyaWJlZCBxdWFsaXR5IHVwZGF0ZSBmb3IgdW5rbm93biB0cmFjaycsIHtcbiAgICAgICAgLi4udGhpcy5sb2dDb250ZXh0LFxuICAgICAgICB0cmFja1NpZDogdXBkYXRlLnRyYWNrU2lkLFxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh1cGRhdGUuc3Vic2NyaWJlZENvZGVjcy5sZW5ndGggPiAwKSB7XG4gICAgICBpZiAoIXB1Yi52aWRlb1RyYWNrKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG5ld0NvZGVjcyA9IGF3YWl0IHB1Yi52aWRlb1RyYWNrLnNldFB1Ymxpc2hpbmdDb2RlY3ModXBkYXRlLnN1YnNjcmliZWRDb2RlY3MpO1xuICAgICAgZm9yIGF3YWl0IChjb25zdCBjb2RlYyBvZiBuZXdDb2RlY3MpIHtcbiAgICAgICAgaWYgKGlzQmFja3VwQ29kZWMoY29kZWMpKSB7XG4gICAgICAgICAgdGhpcy5sb2cuZGVidWcoYHB1Ymxpc2ggJHtjb2RlY30gZm9yICR7cHViLnZpZGVvVHJhY2suc2lkfWAsIHtcbiAgICAgICAgICAgIC4uLnRoaXMubG9nQ29udGV4dCxcbiAgICAgICAgICAgIC4uLmdldExvZ0NvbnRleHRGcm9tVHJhY2socHViKSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBhd2FpdCB0aGlzLnB1Ymxpc2hBZGRpdGlvbmFsQ29kZWNGb3JUcmFjayhwdWIudmlkZW9UcmFjaywgY29kZWMsIHB1Yi5vcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodXBkYXRlLnN1YnNjcmliZWRRdWFsaXRpZXMubGVuZ3RoID4gMCkge1xuICAgICAgYXdhaXQgcHViLnZpZGVvVHJhY2s/LnNldFB1Ymxpc2hpbmdMYXllcnModXBkYXRlLnN1YnNjcmliZWRRdWFsaXRpZXMpO1xuICAgIH1cbiAgfTtcblxuICBwcml2YXRlIGhhbmRsZUxvY2FsVHJhY2tVbnB1Ymxpc2hlZCA9ICh1bnB1Ymxpc2hlZDogVHJhY2tVbnB1Ymxpc2hlZFJlc3BvbnNlKSA9PiB7XG4gICAgY29uc3QgdHJhY2sgPSB0aGlzLnRyYWNrcy5nZXQodW5wdWJsaXNoZWQudHJhY2tTaWQpO1xuICAgIGlmICghdHJhY2spIHtcbiAgICAgIHRoaXMubG9nLndhcm4oJ3JlY2VpdmVkIHVucHVibGlzaGVkIGV2ZW50IGZvciB1bmtub3duIHRyYWNrJywge1xuICAgICAgICAuLi50aGlzLmxvZ0NvbnRleHQsXG4gICAgICAgIHRyYWNrU2lkOiB1bnB1Ymxpc2hlZC50cmFja1NpZCxcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnVucHVibGlzaFRyYWNrKHRyYWNrLnRyYWNrISk7XG4gIH07XG5cbiAgcHJpdmF0ZSBoYW5kbGVUcmFja0VuZGVkID0gYXN5bmMgKHRyYWNrOiBMb2NhbFRyYWNrKSA9PiB7XG4gICAgaWYgKFxuICAgICAgdHJhY2suc291cmNlID09PSBUcmFjay5Tb3VyY2UuU2NyZWVuU2hhcmUgfHxcbiAgICAgIHRyYWNrLnNvdXJjZSA9PT0gVHJhY2suU291cmNlLlNjcmVlblNoYXJlQXVkaW9cbiAgICApIHtcbiAgICAgIHRoaXMubG9nLmRlYnVnKCd1bnB1Ymxpc2hpbmcgbG9jYWwgdHJhY2sgZHVlIHRvIFRyYWNrRW5kZWQnLCB7XG4gICAgICAgIC4uLnRoaXMubG9nQ29udGV4dCxcbiAgICAgICAgLi4uZ2V0TG9nQ29udGV4dEZyb21UcmFjayh0cmFjayksXG4gICAgICB9KTtcbiAgICAgIHRoaXMudW5wdWJsaXNoVHJhY2sodHJhY2spO1xuICAgIH0gZWxzZSBpZiAodHJhY2suaXNVc2VyUHJvdmlkZWQpIHtcbiAgICAgIGF3YWl0IHRyYWNrLm11dGUoKTtcbiAgICB9IGVsc2UgaWYgKHRyYWNrIGluc3RhbmNlb2YgTG9jYWxBdWRpb1RyYWNrIHx8IHRyYWNrIGluc3RhbmNlb2YgTG9jYWxWaWRlb1RyYWNrKSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoaXNXZWIoKSkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50UGVybWlzc2lvbnMgPSBhd2FpdCBuYXZpZ2F0b3I/LnBlcm1pc3Npb25zLnF1ZXJ5KHtcbiAgICAgICAgICAgICAgLy8gdGhlIHBlcm1pc3Npb24gcXVlcnkgZm9yIGNhbWVyYSBhbmQgbWljcm9waG9uZSBjdXJyZW50bHkgbm90IHN1cHBvcnRlZCBpbiBTYWZhcmkgYW5kIEZpcmVmb3hcbiAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICBuYW1lOiB0cmFjay5zb3VyY2UgPT09IFRyYWNrLlNvdXJjZS5DYW1lcmEgPyAnY2FtZXJhJyA6ICdtaWNyb3Bob25lJyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRQZXJtaXNzaW9ucyAmJiBjdXJyZW50UGVybWlzc2lvbnMuc3RhdGUgPT09ICdkZW5pZWQnKSB7XG4gICAgICAgICAgICAgIHRoaXMubG9nLndhcm4oYHVzZXIgaGFzIHJldm9rZWQgYWNjZXNzIHRvICR7dHJhY2suc291cmNlfWAsIHtcbiAgICAgICAgICAgICAgICAuLi50aGlzLmxvZ0NvbnRleHQsXG4gICAgICAgICAgICAgICAgLi4uZ2V0TG9nQ29udGV4dEZyb21UcmFjayh0cmFjayksXG4gICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIC8vIGRldGVjdCBncmFudGVkIGNoYW5nZSBhZnRlciBwZXJtaXNzaW9ucyB3ZXJlIGRlbmllZCB0byB0cnkgYW5kIHJlc3VtZSB0aGVuXG4gICAgICAgICAgICAgIGN1cnJlbnRQZXJtaXNzaW9ucy5vbmNoYW5nZSA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudFBlcm1pc3Npb25zLnN0YXRlICE9PSAnZGVuaWVkJykge1xuICAgICAgICAgICAgICAgICAgaWYgKCF0cmFjay5pc011dGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyYWNrLnJlc3RhcnRUcmFjaygpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgY3VycmVudFBlcm1pc3Npb25zLm9uY2hhbmdlID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignR2V0VXNlck1lZGlhIFBlcm1pc3Npb24gZGVuaWVkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZTogYW55KSB7XG4gICAgICAgICAgICAvLyBwZXJtaXNzaW9ucyBxdWVyeSBmYWlscyBmb3IgZmlyZWZveCwgd2UgY29udGludWUgYW5kIHRyeSB0byByZXN0YXJ0IHRoZSB0cmFja1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRyYWNrLmlzTXV0ZWQpIHtcbiAgICAgICAgICB0aGlzLmxvZy5kZWJ1ZygndHJhY2sgZW5kZWQsIGF0dGVtcHRpbmcgdG8gdXNlIGEgZGlmZmVyZW50IGRldmljZScsIHtcbiAgICAgICAgICAgIC4uLnRoaXMubG9nQ29udGV4dCxcbiAgICAgICAgICAgIC4uLmdldExvZ0NvbnRleHRGcm9tVHJhY2sodHJhY2spLFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGF3YWl0IHRyYWNrLnJlc3RhcnRUcmFjaygpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHRoaXMubG9nLndhcm4oYGNvdWxkIG5vdCByZXN0YXJ0IHRyYWNrLCBtdXRpbmcgaW5zdGVhZGAsIHtcbiAgICAgICAgICAuLi50aGlzLmxvZ0NvbnRleHQsXG4gICAgICAgICAgLi4uZ2V0TG9nQ29udGV4dEZyb21UcmFjayh0cmFjayksXG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCB0cmFjay5tdXRlKCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHByaXZhdGUgZ2V0UHVibGljYXRpb25Gb3JUcmFjayhcbiAgICB0cmFjazogTG9jYWxUcmFjayB8IE1lZGlhU3RyZWFtVHJhY2ssXG4gICk6IExvY2FsVHJhY2tQdWJsaWNhdGlvbiB8IHVuZGVmaW5lZCB7XG4gICAgbGV0IHB1YmxpY2F0aW9uOiBMb2NhbFRyYWNrUHVibGljYXRpb24gfCB1bmRlZmluZWQ7XG4gICAgdGhpcy50cmFja3MuZm9yRWFjaCgocHViKSA9PiB7XG4gICAgICBjb25zdCBsb2NhbFRyYWNrID0gcHViLnRyYWNrO1xuICAgICAgaWYgKCFsb2NhbFRyYWNrKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gdGhpcyBsb29rcyBvdmVybHkgY29tcGxpY2F0ZWQgZHVlIHRvIHRoaXMgb2JqZWN0IHRyZWVcbiAgICAgIGlmICh0cmFjayBpbnN0YW5jZW9mIE1lZGlhU3RyZWFtVHJhY2spIHtcbiAgICAgICAgaWYgKGxvY2FsVHJhY2sgaW5zdGFuY2VvZiBMb2NhbEF1ZGlvVHJhY2sgfHwgbG9jYWxUcmFjayBpbnN0YW5jZW9mIExvY2FsVmlkZW9UcmFjaykge1xuICAgICAgICAgIGlmIChsb2NhbFRyYWNrLm1lZGlhU3RyZWFtVHJhY2sgPT09IHRyYWNrKSB7XG4gICAgICAgICAgICBwdWJsaWNhdGlvbiA9IDxMb2NhbFRyYWNrUHVibGljYXRpb24+cHViO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0cmFjayA9PT0gbG9jYWxUcmFjaykge1xuICAgICAgICBwdWJsaWNhdGlvbiA9IDxMb2NhbFRyYWNrUHVibGljYXRpb24+cHViO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBwdWJsaWNhdGlvbjtcbiAgfVxufVxuIiwiaW1wb3J0IHsgcHJvdG9JbnQ2NCB9IGZyb20gJ0BidWZidWlsZC9wcm90b2J1Zic7XG5pbXBvcnQgeyBFdmVudEVtaXR0ZXIgfSBmcm9tICdldmVudHMnO1xuaW1wb3J0IHR5cGUgVHlwZWRFbWl0dGVyIGZyb20gJ3R5cGVkLWVtaXR0ZXInO1xuaW1wb3J0ICd3ZWJydGMtYWRhcHRlcic7XG5pbXBvcnQgeyBFbmNyeXB0aW9uRXZlbnQgfSBmcm9tICcuLi9lMmVlJztcbmltcG9ydCB7IEUyRUVNYW5hZ2VyIH0gZnJvbSAnLi4vZTJlZS9FMmVlTWFuYWdlcic7XG5pbXBvcnQgbG9nLCB7IExvZ2dlck5hbWVzLCBnZXRMb2dnZXIgfSBmcm9tICcuLi9sb2dnZXInO1xuaW1wb3J0IHR5cGUge1xuICBJbnRlcm5hbFJvb21Db25uZWN0T3B0aW9ucyxcbiAgSW50ZXJuYWxSb29tT3B0aW9ucyxcbiAgUm9vbUNvbm5lY3RPcHRpb25zLFxuICBSb29tT3B0aW9ucyxcbn0gZnJvbSAnLi4vb3B0aW9ucyc7XG5pbXBvcnQge1xuICBEYXRhUGFja2V0X0tpbmQsXG4gIERpc2Nvbm5lY3RSZWFzb24sXG4gIFBhcnRpY2lwYW50SW5mbyxcbiAgUGFydGljaXBhbnRJbmZvX1N0YXRlLFxuICBQYXJ0aWNpcGFudFBlcm1pc3Npb24sXG4gIFJvb20gYXMgUm9vbU1vZGVsLFxuICBTZXJ2ZXJJbmZvLFxuICBTcGVha2VySW5mbyxcbiAgU3Vic2NyaXB0aW9uRXJyb3IsXG4gIFRyYWNrSW5mbyxcbiAgVHJhY2tTb3VyY2UsXG4gIFRyYWNrVHlwZSxcbiAgVXNlclBhY2tldCxcbn0gZnJvbSAnLi4vcHJvdG8vbGl2ZWtpdF9tb2RlbHNfcGInO1xuaW1wb3J0IHtcbiAgQ29ubmVjdGlvblF1YWxpdHlVcGRhdGUsXG4gIEpvaW5SZXNwb25zZSxcbiAgTGVhdmVSZXF1ZXN0LFxuICBTaW11bGF0ZVNjZW5hcmlvLFxuICBTdHJlYW1TdGF0ZVVwZGF0ZSxcbiAgU3Vic2NyaXB0aW9uUGVybWlzc2lvblVwZGF0ZSxcbiAgU3Vic2NyaXB0aW9uUmVzcG9uc2UsXG59IGZyb20gJy4uL3Byb3RvL2xpdmVraXRfcnRjX3BiJztcbmltcG9ydCB7IGdldEJyb3dzZXIgfSBmcm9tICcuLi91dGlscy9icm93c2VyUGFyc2VyJztcbmltcG9ydCBEZXZpY2VNYW5hZ2VyIGZyb20gJy4vRGV2aWNlTWFuYWdlcic7XG5pbXBvcnQgUlRDRW5naW5lIGZyb20gJy4vUlRDRW5naW5lJztcbmltcG9ydCB7IFJlZ2lvblVybFByb3ZpZGVyIH0gZnJvbSAnLi9SZWdpb25VcmxQcm92aWRlcic7XG5pbXBvcnQge1xuICBhdWRpb0RlZmF1bHRzLFxuICBwdWJsaXNoRGVmYXVsdHMsXG4gIHJvb21Db25uZWN0T3B0aW9uRGVmYXVsdHMsXG4gIHJvb21PcHRpb25EZWZhdWx0cyxcbiAgdmlkZW9EZWZhdWx0cyxcbn0gZnJvbSAnLi9kZWZhdWx0cyc7XG5pbXBvcnQgeyBDb25uZWN0aW9uRXJyb3IsIENvbm5lY3Rpb25FcnJvclJlYXNvbiwgVW5zdXBwb3J0ZWRTZXJ2ZXIgfSBmcm9tICcuL2Vycm9ycyc7XG5pbXBvcnQgeyBFbmdpbmVFdmVudCwgUGFydGljaXBhbnRFdmVudCwgUm9vbUV2ZW50LCBUcmFja0V2ZW50IH0gZnJvbSAnLi9ldmVudHMnO1xuaW1wb3J0IExvY2FsUGFydGljaXBhbnQgZnJvbSAnLi9wYXJ0aWNpcGFudC9Mb2NhbFBhcnRpY2lwYW50JztcbmltcG9ydCB0eXBlIFBhcnRpY2lwYW50IGZyb20gJy4vcGFydGljaXBhbnQvUGFydGljaXBhbnQnO1xuaW1wb3J0IHR5cGUgeyBDb25uZWN0aW9uUXVhbGl0eSB9IGZyb20gJy4vcGFydGljaXBhbnQvUGFydGljaXBhbnQnO1xuaW1wb3J0IFJlbW90ZVBhcnRpY2lwYW50IGZyb20gJy4vcGFydGljaXBhbnQvUmVtb3RlUGFydGljaXBhbnQnO1xuaW1wb3J0IENyaXRpY2FsVGltZXJzIGZyb20gJy4vdGltZXJzJztcbmltcG9ydCBMb2NhbEF1ZGlvVHJhY2sgZnJvbSAnLi90cmFjay9Mb2NhbEF1ZGlvVHJhY2snO1xuaW1wb3J0IExvY2FsVHJhY2tQdWJsaWNhdGlvbiBmcm9tICcuL3RyYWNrL0xvY2FsVHJhY2tQdWJsaWNhdGlvbic7XG5pbXBvcnQgTG9jYWxWaWRlb1RyYWNrIGZyb20gJy4vdHJhY2svTG9jYWxWaWRlb1RyYWNrJztcbmltcG9ydCB0eXBlIFJlbW90ZVRyYWNrIGZyb20gJy4vdHJhY2svUmVtb3RlVHJhY2snO1xuaW1wb3J0IFJlbW90ZVRyYWNrUHVibGljYXRpb24gZnJvbSAnLi90cmFjay9SZW1vdGVUcmFja1B1YmxpY2F0aW9uJztcbmltcG9ydCB7IFRyYWNrIH0gZnJvbSAnLi90cmFjay9UcmFjayc7XG5pbXBvcnQgdHlwZSB7IFRyYWNrUHVibGljYXRpb24gfSBmcm9tICcuL3RyYWNrL1RyYWNrUHVibGljYXRpb24nO1xuaW1wb3J0IHR5cGUgeyBBZGFwdGl2ZVN0cmVhbVNldHRpbmdzIH0gZnJvbSAnLi90cmFjay90eXBlcyc7XG5pbXBvcnQgeyBnZXROZXdBdWRpb0NvbnRleHQsIHNvdXJjZVRvS2luZCB9IGZyb20gJy4vdHJhY2svdXRpbHMnO1xuaW1wb3J0IHR5cGUgeyBTaW11bGF0aW9uT3B0aW9ucywgU2ltdWxhdGlvblNjZW5hcmlvIH0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQge1xuICBGdXR1cmUsXG4gIE11dGV4LFxuICBjcmVhdGVEdW1teVZpZGVvU3RyZWFtVHJhY2ssXG4gIGdldEVtcHR5QXVkaW9TdHJlYW1UcmFjayxcbiAgaXNDbG91ZCxcbiAgaXNXZWIsXG4gIHN1cHBvcnRzU2V0U2lua0lkLFxuICB0b0h0dHBVcmwsXG4gIHVucGFja1N0cmVhbUlkLFxuICB1bndyYXBDb25zdHJhaW50LFxufSBmcm9tICcuL3V0aWxzJztcblxuZXhwb3J0IGVudW0gQ29ubmVjdGlvblN0YXRlIHtcbiAgRGlzY29ubmVjdGVkID0gJ2Rpc2Nvbm5lY3RlZCcsXG4gIENvbm5lY3RpbmcgPSAnY29ubmVjdGluZycsXG4gIENvbm5lY3RlZCA9ICdjb25uZWN0ZWQnLFxuICBSZWNvbm5lY3RpbmcgPSAncmVjb25uZWN0aW5nJyxcbn1cblxuY29uc3QgY29ubmVjdGlvblJlY29uY2lsZUZyZXF1ZW5jeSA9IDIgKiAxMDAwO1xuXG4vKiogQGRlcHJlY2F0ZWQgUm9vbVN0YXRlIGhhcyBiZWVuIHJlbmFtZWQgdG8gW1tDb25uZWN0aW9uU3RhdGVdXSAqL1xuZXhwb3J0IGNvbnN0IFJvb21TdGF0ZSA9IENvbm5lY3Rpb25TdGF0ZTtcblxuLyoqXG4gKiBJbiBMaXZlS2l0LCBhIHJvb20gaXMgdGhlIGxvZ2ljYWwgZ3JvdXBpbmcgZm9yIGEgbGlzdCBvZiBwYXJ0aWNpcGFudHMuXG4gKiBQYXJ0aWNpcGFudHMgaW4gYSByb29tIGNhbiBwdWJsaXNoIHRyYWNrcywgYW5kIHN1YnNjcmliZSB0byBvdGhlcnMnIHRyYWNrcy5cbiAqXG4gKiBhIFJvb20gZmlyZXMgW1tSb29tRXZlbnQgfCBSb29tRXZlbnRzXV0uXG4gKlxuICogQG5vSW5oZXJpdERvY1xuICovXG5jbGFzcyBSb29tIGV4dGVuZHMgKEV2ZW50RW1pdHRlciBhcyBuZXcgKCkgPT4gVHlwZWRFbWl0dGVyPFJvb21FdmVudENhbGxiYWNrcz4pIHtcbiAgc3RhdGU6IENvbm5lY3Rpb25TdGF0ZSA9IENvbm5lY3Rpb25TdGF0ZS5EaXNjb25uZWN0ZWQ7XG5cbiAgLyoqIG1hcCBvZiBzaWQ6IFtbUmVtb3RlUGFydGljaXBhbnRdXSAqL1xuICBwYXJ0aWNpcGFudHM6IE1hcDxzdHJpbmcsIFJlbW90ZVBhcnRpY2lwYW50PjtcblxuICAvKipcbiAgICogbGlzdCBvZiBwYXJ0aWNpcGFudHMgdGhhdCBhcmUgYWN0aXZlbHkgc3BlYWtpbmcuIHdoZW4gdGhpcyBjaGFuZ2VzXG4gICAqIGEgW1tSb29tRXZlbnQuQWN0aXZlU3BlYWtlcnNDaGFuZ2VkXV0gZXZlbnQgaXMgZmlyZWRcbiAgICovXG4gIGFjdGl2ZVNwZWFrZXJzOiBQYXJ0aWNpcGFudFtdID0gW107XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBlbmdpbmUhOiBSVENFbmdpbmU7XG5cbiAgLyoqIHRoZSBjdXJyZW50IHBhcnRpY2lwYW50ICovXG4gIGxvY2FsUGFydGljaXBhbnQ6IExvY2FsUGFydGljaXBhbnQ7XG5cbiAgLyoqIG9wdGlvbnMgb2Ygcm9vbSAqL1xuICBvcHRpb25zOiBJbnRlcm5hbFJvb21PcHRpb25zO1xuXG4gIC8qKiByZWZsZWN0cyB0aGUgc2VuZGVyIGVuY3J5cHRpb24gc3RhdHVzIG9mIHRoZSBsb2NhbCBwYXJ0aWNpcGFudCAqL1xuICBpc0UyRUVFbmFibGVkOiBib29sZWFuID0gZmFsc2U7XG5cbiAgcHJpdmF0ZSByb29tSW5mbz86IFJvb21Nb2RlbDtcblxuICBwcml2YXRlIGlkZW50aXR5VG9TaWQ6IE1hcDxzdHJpbmcsIHN0cmluZz47XG5cbiAgLyoqIGNvbm5lY3Qgb3B0aW9ucyBvZiByb29tICovXG4gIHByaXZhdGUgY29ubk9wdGlvbnM/OiBJbnRlcm5hbFJvb21Db25uZWN0T3B0aW9ucztcblxuICBwcml2YXRlIGF1ZGlvRW5hYmxlZCA9IHRydWU7XG5cbiAgcHJpdmF0ZSBhdWRpb0NvbnRleHQ/OiBBdWRpb0NvbnRleHQ7XG5cbiAgLyoqIHVzZWQgZm9yIGFib3J0aW5nIHBlbmRpbmcgY29ubmVjdGlvbnMgdG8gYSBMaXZlS2l0IHNlcnZlciAqL1xuICBwcml2YXRlIGFib3J0Q29udHJvbGxlcj86IEFib3J0Q29udHJvbGxlcjtcblxuICAvKiogZnV0dXJlIGhvbGRpbmcgY2xpZW50IGluaXRpYXRlZCBjb25uZWN0aW9uIGF0dGVtcHQgKi9cbiAgcHJpdmF0ZSBjb25uZWN0RnV0dXJlPzogRnV0dXJlPHZvaWQ+O1xuXG4gIHByaXZhdGUgZGlzY29ubmVjdExvY2s6IE11dGV4O1xuXG4gIHByaXZhdGUgZTJlZU1hbmFnZXI6IEUyRUVNYW5hZ2VyIHwgdW5kZWZpbmVkO1xuXG4gIHByaXZhdGUgY29ubmVjdGlvblJlY29uY2lsZUludGVydmFsPzogUmV0dXJuVHlwZTx0eXBlb2Ygc2V0SW50ZXJ2YWw+O1xuXG4gIHByaXZhdGUgcmVnaW9uVXJsUHJvdmlkZXI/OiBSZWdpb25VcmxQcm92aWRlcjtcblxuICBwcml2YXRlIHJlZ2lvblVybD86IHN0cmluZztcblxuICBwcml2YXRlIGlzVmlkZW9QbGF5YmFja0Jsb2NrZWQ6IGJvb2xlYW4gPSBmYWxzZTtcblxuICBwcml2YXRlIGxvZyA9IGxvZztcblxuICBwcml2YXRlIGJ1ZmZlcmVkRXZlbnRzOiBBcnJheTxhbnk+ID0gW107XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgUm9vbSwgdGhlIHByaW1hcnkgY29uc3RydWN0IGZvciBhIExpdmVLaXQgc2Vzc2lvbi5cbiAgICogQHBhcmFtIG9wdGlvbnNcbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnM/OiBSb29tT3B0aW9ucykge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5zZXRNYXhMaXN0ZW5lcnMoMTAwKTtcbiAgICB0aGlzLnBhcnRpY2lwYW50cyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLmlkZW50aXR5VG9TaWQgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5vcHRpb25zID0geyAuLi5yb29tT3B0aW9uRGVmYXVsdHMsIC4uLm9wdGlvbnMgfTtcblxuICAgIHRoaXMubG9nID0gZ2V0TG9nZ2VyKHRoaXMub3B0aW9ucy5sb2dnZXJOYW1lID8/IExvZ2dlck5hbWVzLlJvb20pO1xuXG4gICAgdGhpcy5vcHRpb25zLmF1ZGlvQ2FwdHVyZURlZmF1bHRzID0ge1xuICAgICAgLi4uYXVkaW9EZWZhdWx0cyxcbiAgICAgIC4uLm9wdGlvbnM/LmF1ZGlvQ2FwdHVyZURlZmF1bHRzLFxuICAgIH07XG4gICAgdGhpcy5vcHRpb25zLnZpZGVvQ2FwdHVyZURlZmF1bHRzID0ge1xuICAgICAgLi4udmlkZW9EZWZhdWx0cyxcbiAgICAgIC4uLm9wdGlvbnM/LnZpZGVvQ2FwdHVyZURlZmF1bHRzLFxuICAgIH07XG4gICAgdGhpcy5vcHRpb25zLnB1Ymxpc2hEZWZhdWx0cyA9IHtcbiAgICAgIC4uLnB1Ymxpc2hEZWZhdWx0cyxcbiAgICAgIC4uLm9wdGlvbnM/LnB1Ymxpc2hEZWZhdWx0cyxcbiAgICB9O1xuXG4gICAgdGhpcy5tYXliZUNyZWF0ZUVuZ2luZSgpO1xuXG4gICAgdGhpcy5kaXNjb25uZWN0TG9jayA9IG5ldyBNdXRleCgpO1xuXG4gICAgdGhpcy5sb2NhbFBhcnRpY2lwYW50ID0gbmV3IExvY2FsUGFydGljaXBhbnQoJycsICcnLCB0aGlzLmVuZ2luZSwgdGhpcy5vcHRpb25zKTtcblxuICAgIGlmICh0aGlzLm9wdGlvbnMudmlkZW9DYXB0dXJlRGVmYXVsdHMuZGV2aWNlSWQpIHtcbiAgICAgIHRoaXMubG9jYWxQYXJ0aWNpcGFudC5hY3RpdmVEZXZpY2VNYXAuc2V0KFxuICAgICAgICAndmlkZW9pbnB1dCcsXG4gICAgICAgIHVud3JhcENvbnN0cmFpbnQodGhpcy5vcHRpb25zLnZpZGVvQ2FwdHVyZURlZmF1bHRzLmRldmljZUlkKSxcbiAgICAgICk7XG4gICAgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMuYXVkaW9DYXB0dXJlRGVmYXVsdHMuZGV2aWNlSWQpIHtcbiAgICAgIHRoaXMubG9jYWxQYXJ0aWNpcGFudC5hY3RpdmVEZXZpY2VNYXAuc2V0KFxuICAgICAgICAnYXVkaW9pbnB1dCcsXG4gICAgICAgIHVud3JhcENvbnN0cmFpbnQodGhpcy5vcHRpb25zLmF1ZGlvQ2FwdHVyZURlZmF1bHRzLmRldmljZUlkKSxcbiAgICAgICk7XG4gICAgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMuYXVkaW9PdXRwdXQ/LmRldmljZUlkKSB7XG4gICAgICB0aGlzLnN3aXRjaEFjdGl2ZURldmljZShcbiAgICAgICAgJ2F1ZGlvb3V0cHV0JyxcbiAgICAgICAgdW53cmFwQ29uc3RyYWludCh0aGlzLm9wdGlvbnMuYXVkaW9PdXRwdXQuZGV2aWNlSWQpLFxuICAgICAgKS5jYXRjaCgoZSkgPT4gdGhpcy5sb2cud2FybihgQ291bGQgbm90IHNldCBhdWRpbyBvdXRwdXQ6ICR7ZS5tZXNzYWdlfWAsIHRoaXMubG9nQ29udGV4dCkpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLm9wdGlvbnMuZTJlZSkge1xuICAgICAgdGhpcy5zZXR1cEUyRUUoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQGV4cGVyaW1lbnRhbFxuICAgKi9cbiAgYXN5bmMgc2V0RTJFRUVuYWJsZWQoZW5hYmxlZDogYm9vbGVhbikge1xuICAgIGlmICh0aGlzLmUyZWVNYW5hZ2VyKSB7XG4gICAgICBhd2FpdCBQcm9taXNlLmFsbChbdGhpcy5sb2NhbFBhcnRpY2lwYW50LnNldEUyRUVFbmFibGVkKGVuYWJsZWQpXSk7XG4gICAgICBpZiAodGhpcy5sb2NhbFBhcnRpY2lwYW50LmlkZW50aXR5ICE9PSAnJykge1xuICAgICAgICB0aGlzLmUyZWVNYW5hZ2VyLnNldFBhcnRpY2lwYW50Q3J5cHRvckVuYWJsZWQoZW5hYmxlZCwgdGhpcy5sb2NhbFBhcnRpY2lwYW50LmlkZW50aXR5KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgRXJyb3IoJ2UyZWUgbm90IGNvbmZpZ3VyZWQsIHBsZWFzZSBzZXQgZTJlZSBzZXR0aW5ncyB3aXRoaW4gdGhlIHJvb20gb3B0aW9ucycpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgc2V0dXBFMkVFKCkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZTJlZSkge1xuICAgICAgdGhpcy5lMmVlTWFuYWdlciA9IG5ldyBFMkVFTWFuYWdlcih0aGlzLm9wdGlvbnMuZTJlZSk7XG4gICAgICB0aGlzLmUyZWVNYW5hZ2VyLm9uKFxuICAgICAgICBFbmNyeXB0aW9uRXZlbnQuUGFydGljaXBhbnRFbmNyeXB0aW9uU3RhdHVzQ2hhbmdlZCxcbiAgICAgICAgKGVuYWJsZWQsIHBhcnRpY2lwYW50KSA9PiB7XG4gICAgICAgICAgaWYgKHBhcnRpY2lwYW50IGluc3RhbmNlb2YgTG9jYWxQYXJ0aWNpcGFudCkge1xuICAgICAgICAgICAgdGhpcy5pc0UyRUVFbmFibGVkID0gZW5hYmxlZDtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5lbWl0KFJvb21FdmVudC5QYXJ0aWNpcGFudEVuY3J5cHRpb25TdGF0dXNDaGFuZ2VkLCBlbmFibGVkLCBwYXJ0aWNpcGFudCk7XG4gICAgICAgIH0sXG4gICAgICApO1xuICAgICAgdGhpcy5lMmVlTWFuYWdlci5vbihFbmNyeXB0aW9uRXZlbnQuRW5jcnlwdGlvbkVycm9yLCAoZXJyb3IpID0+XG4gICAgICAgIHRoaXMuZW1pdChSb29tRXZlbnQuRW5jcnlwdGlvbkVycm9yLCBlcnJvciksXG4gICAgICApO1xuICAgICAgdGhpcy5lMmVlTWFuYWdlcj8uc2V0dXAodGhpcyk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBnZXQgbG9nQ29udGV4dCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcm9vbTogdGhpcy5uYW1lLFxuICAgICAgcm9vbVNpZDogdGhpcy5zaWQsXG4gICAgICBpZGVudGl0eTogdGhpcy5sb2NhbFBhcnRpY2lwYW50LmlkZW50aXR5LFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogaWYgdGhlIGN1cnJlbnQgcm9vbSBoYXMgYSBwYXJ0aWNpcGFudCB3aXRoIGByZWNvcmRlcjogdHJ1ZWAgaW4gaXRzIEpXVCBncmFudFxuICAgKiovXG4gIGdldCBpc1JlY29yZGluZygpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5yb29tSW5mbz8uYWN0aXZlUmVjb3JkaW5nID8/IGZhbHNlO1xuICB9XG5cbiAgLyoqIHNlcnZlciBhc3NpZ25lZCB1bmlxdWUgcm9vbSBpZCAqL1xuICBnZXQgc2lkKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMucm9vbUluZm8/LnNpZCA/PyAnJztcbiAgfVxuXG4gIC8qKiB1c2VyIGFzc2lnbmVkIG5hbWUsIGRlcml2ZWQgZnJvbSBKV1QgdG9rZW4gKi9cbiAgZ2V0IG5hbWUoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5yb29tSW5mbz8ubmFtZSA/PyAnJztcbiAgfVxuXG4gIC8qKiByb29tIG1ldGFkYXRhICovXG4gIGdldCBtZXRhZGF0YSgpOiBzdHJpbmcgfCB1bmRlZmluZWQge1xuICAgIHJldHVybiB0aGlzLnJvb21JbmZvPy5tZXRhZGF0YTtcbiAgfVxuXG4gIGdldCBudW1QYXJ0aWNpcGFudHMoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5yb29tSW5mbz8ubnVtUGFydGljaXBhbnRzID8/IDA7XG4gIH1cblxuICBnZXQgbnVtUHVibGlzaGVycygpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLnJvb21JbmZvPy5udW1QdWJsaXNoZXJzID8/IDA7XG4gIH1cblxuICBwcml2YXRlIG1heWJlQ3JlYXRlRW5naW5lKCkge1xuICAgIGlmICh0aGlzLmVuZ2luZSAmJiAhdGhpcy5lbmdpbmUuaXNDbG9zZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmVuZ2luZSA9IG5ldyBSVENFbmdpbmUodGhpcy5vcHRpb25zKTtcblxuICAgIHRoaXMuZW5naW5lXG4gICAgICAub24oRW5naW5lRXZlbnQuUGFydGljaXBhbnRVcGRhdGUsIHRoaXMuaGFuZGxlUGFydGljaXBhbnRVcGRhdGVzKVxuICAgICAgLm9uKEVuZ2luZUV2ZW50LlJvb21VcGRhdGUsIHRoaXMuaGFuZGxlUm9vbVVwZGF0ZSlcbiAgICAgIC5vbihFbmdpbmVFdmVudC5TcGVha2Vyc0NoYW5nZWQsIHRoaXMuaGFuZGxlU3BlYWtlcnNDaGFuZ2VkKVxuICAgICAgLm9uKEVuZ2luZUV2ZW50LlN0cmVhbVN0YXRlQ2hhbmdlZCwgdGhpcy5oYW5kbGVTdHJlYW1TdGF0ZVVwZGF0ZSlcbiAgICAgIC5vbihFbmdpbmVFdmVudC5Db25uZWN0aW9uUXVhbGl0eVVwZGF0ZSwgdGhpcy5oYW5kbGVDb25uZWN0aW9uUXVhbGl0eVVwZGF0ZSlcbiAgICAgIC5vbihFbmdpbmVFdmVudC5TdWJzY3JpcHRpb25FcnJvciwgdGhpcy5oYW5kbGVTdWJzY3JpcHRpb25FcnJvcilcbiAgICAgIC5vbihFbmdpbmVFdmVudC5TdWJzY3JpcHRpb25QZXJtaXNzaW9uVXBkYXRlLCB0aGlzLmhhbmRsZVN1YnNjcmlwdGlvblBlcm1pc3Npb25VcGRhdGUpXG4gICAgICAub24oXG4gICAgICAgIEVuZ2luZUV2ZW50Lk1lZGlhVHJhY2tBZGRlZCxcbiAgICAgICAgKG1lZGlhVHJhY2s6IE1lZGlhU3RyZWFtVHJhY2ssIHN0cmVhbTogTWVkaWFTdHJlYW0sIHJlY2VpdmVyPzogUlRDUnRwUmVjZWl2ZXIpID0+IHtcbiAgICAgICAgICB0aGlzLm9uVHJhY2tBZGRlZChtZWRpYVRyYWNrLCBzdHJlYW0sIHJlY2VpdmVyKTtcbiAgICAgICAgfSxcbiAgICAgIClcbiAgICAgIC5vbihFbmdpbmVFdmVudC5EaXNjb25uZWN0ZWQsIChyZWFzb24/OiBEaXNjb25uZWN0UmVhc29uKSA9PiB7XG4gICAgICAgIHRoaXMuaGFuZGxlRGlzY29ubmVjdCh0aGlzLm9wdGlvbnMuc3RvcExvY2FsVHJhY2tPblVucHVibGlzaCwgcmVhc29uKTtcbiAgICAgIH0pXG4gICAgICAub24oRW5naW5lRXZlbnQuQWN0aXZlU3BlYWtlcnNVcGRhdGUsIHRoaXMuaGFuZGxlQWN0aXZlU3BlYWtlcnNVcGRhdGUpXG4gICAgICAub24oRW5naW5lRXZlbnQuRGF0YVBhY2tldFJlY2VpdmVkLCB0aGlzLmhhbmRsZURhdGFQYWNrZXQpXG4gICAgICAub24oRW5naW5lRXZlbnQuUmVzdW1pbmcsICgpID0+IHtcbiAgICAgICAgdGhpcy5jbGVhckNvbm5lY3Rpb25SZWNvbmNpbGUoKTtcbiAgICAgICAgaWYgKHRoaXMuc2V0QW5kRW1pdENvbm5lY3Rpb25TdGF0ZShDb25uZWN0aW9uU3RhdGUuUmVjb25uZWN0aW5nKSkge1xuICAgICAgICAgIHRoaXMuZW1pdChSb29tRXZlbnQuUmVjb25uZWN0aW5nKTtcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIC5vbihFbmdpbmVFdmVudC5SZXN1bWVkLCAoKSA9PiB7XG4gICAgICAgIHRoaXMuc2V0QW5kRW1pdENvbm5lY3Rpb25TdGF0ZShDb25uZWN0aW9uU3RhdGUuQ29ubmVjdGVkKTtcbiAgICAgICAgdGhpcy5lbWl0KFJvb21FdmVudC5SZWNvbm5lY3RlZCk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXJDb25uZWN0aW9uUmVjb25jaWxlKCk7XG4gICAgICAgIHRoaXMudXBkYXRlU3Vic2NyaXB0aW9ucygpO1xuICAgICAgICB0aGlzLmVtaXRCdWZmZXJlZEV2ZW50cygpO1xuICAgICAgfSlcbiAgICAgIC5vbihFbmdpbmVFdmVudC5TaWduYWxSZXN1bWVkLCAoKSA9PiB7XG4gICAgICAgIHRoaXMuYnVmZmVyZWRFdmVudHMgPSBbXTtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IENvbm5lY3Rpb25TdGF0ZS5SZWNvbm5lY3RpbmcpIHtcbiAgICAgICAgICB0aGlzLnNlbmRTeW5jU3RhdGUoKTtcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIC5vbihFbmdpbmVFdmVudC5SZXN0YXJ0aW5nLCB0aGlzLmhhbmRsZVJlc3RhcnRpbmcpXG4gICAgICAub24oRW5naW5lRXZlbnQuU2lnbmFsUmVzdGFydGVkLCB0aGlzLmhhbmRsZVNpZ25hbFJlc3RhcnRlZClcbiAgICAgIC5vbihFbmdpbmVFdmVudC5EQ0J1ZmZlclN0YXR1c0NoYW5nZWQsIChzdGF0dXMsIGtpbmQpID0+IHtcbiAgICAgICAgdGhpcy5lbWl0KFJvb21FdmVudC5EQ0J1ZmZlclN0YXR1c0NoYW5nZWQsIHN0YXR1cywga2luZCk7XG4gICAgICB9KTtcblxuICAgIGlmICh0aGlzLmxvY2FsUGFydGljaXBhbnQpIHtcbiAgICAgIHRoaXMubG9jYWxQYXJ0aWNpcGFudC5zZXR1cEVuZ2luZSh0aGlzLmVuZ2luZSk7XG4gICAgfVxuICAgIGlmICh0aGlzLmUyZWVNYW5hZ2VyKSB7XG4gICAgICB0aGlzLmUyZWVNYW5hZ2VyLnNldHVwRW5naW5lKHRoaXMuZW5naW5lKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogZ2V0TG9jYWxEZXZpY2VzIGFic3RyYWN0cyBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmVudW1lcmF0ZURldmljZXMuXG4gICAqIEluIHBhcnRpY3VsYXIsIGl0IGhhbmRsZXMgQ2hyb21lJ3MgdW5pcXVlIGJlaGF2aW9yIG9mIGNyZWF0aW5nIGBkZWZhdWx0YFxuICAgKiBkZXZpY2VzLiBXaGVuIGVuY291bnRlcmVkLCBpdCdsbCBiZSByZW1vdmVkIGZyb20gdGhlIGxpc3Qgb2YgZGV2aWNlcy5cbiAgICogVGhlIGFjdHVhbCBkZWZhdWx0IGRldmljZSB3aWxsIGJlIHBsYWNlZCBhdCB0b3AuXG4gICAqIEBwYXJhbSBraW5kXG4gICAqIEByZXR1cm5zIGEgbGlzdCBvZiBhdmFpbGFibGUgbG9jYWwgZGV2aWNlc1xuICAgKi9cbiAgc3RhdGljIGdldExvY2FsRGV2aWNlcyhcbiAgICBraW5kPzogTWVkaWFEZXZpY2VLaW5kLFxuICAgIHJlcXVlc3RQZXJtaXNzaW9uczogYm9vbGVhbiA9IHRydWUsXG4gICk6IFByb21pc2U8TWVkaWFEZXZpY2VJbmZvW10+IHtcbiAgICByZXR1cm4gRGV2aWNlTWFuYWdlci5nZXRJbnN0YW5jZSgpLmdldERldmljZXMoa2luZCwgcmVxdWVzdFBlcm1pc3Npb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBwcmVwYXJlQ29ubmVjdGlvbiBzaG91bGQgYmUgY2FsbGVkIGFzIHNvb24gYXMgdGhlIHBhZ2UgaXMgbG9hZGVkLCBpbiBvcmRlclxuICAgKiB0byBzcGVlZCB1cCB0aGUgY29ubmVjdGlvbiBhdHRlbXB0LiBUaGlzIGZ1bmN0aW9uIHdpbGxcbiAgICogLSBwZXJmb3JtIEROUyByZXNvbHV0aW9uIGFuZCBwcmUtd2FybSB0aGUgRE5TIGNhY2hlXG4gICAqIC0gZXN0YWJsaXNoIFRMUyBjb25uZWN0aW9uIGFuZCBjYWNoZSBUTFMga2V5c1xuICAgKlxuICAgKiBXaXRoIExpdmVLaXQgQ2xvdWQsIGl0IHdpbGwgYWxzbyBkZXRlcm1pbmUgdGhlIGJlc3QgZWRnZSBkYXRhIGNlbnRlciBmb3JcbiAgICogdGhlIGN1cnJlbnQgY2xpZW50IHRvIGNvbm5lY3QgdG8gaWYgYSB0b2tlbiBpcyBwcm92aWRlZC5cbiAgICovXG4gIGFzeW5jIHByZXBhcmVDb25uZWN0aW9uKHVybDogc3RyaW5nLCB0b2tlbj86IHN0cmluZykge1xuICAgIGlmICh0aGlzLnN0YXRlICE9PSBDb25uZWN0aW9uU3RhdGUuRGlzY29ubmVjdGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMubG9nLmRlYnVnKGBwcmVwYXJlQ29ubmVjdGlvbiB0byAke3VybH1gLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgIHRyeSB7XG4gICAgICBpZiAoaXNDbG91ZChuZXcgVVJMKHVybCkpICYmIHRva2VuKSB7XG4gICAgICAgIHRoaXMucmVnaW9uVXJsUHJvdmlkZXIgPSBuZXcgUmVnaW9uVXJsUHJvdmlkZXIodXJsLCB0b2tlbik7XG4gICAgICAgIGNvbnN0IHJlZ2lvblVybCA9IGF3YWl0IHRoaXMucmVnaW9uVXJsUHJvdmlkZXIuZ2V0TmV4dEJlc3RSZWdpb25VcmwoKTtcbiAgICAgICAgLy8gd2Ugd2lsbCBub3QgcmVwbGFjZSB0aGUgcmVnaW9uVXJsIGlmIGFuIGF0dGVtcHQgaGFkIGFscmVhZHkgc3RhcnRlZFxuICAgICAgICAvLyB0byBhdm9pZCBvdmVycmlkaW5nIHJlZ2lvblVybCBhZnRlciBhIG5ldyBjb25uZWN0aW9uIGF0dGVtcHQgaGFkIHN0YXJ0ZWRcbiAgICAgICAgaWYgKHJlZ2lvblVybCAmJiB0aGlzLnN0YXRlID09PSBDb25uZWN0aW9uU3RhdGUuRGlzY29ubmVjdGVkKSB7XG4gICAgICAgICAgdGhpcy5yZWdpb25VcmwgPSByZWdpb25Vcmw7XG4gICAgICAgICAgYXdhaXQgZmV0Y2godG9IdHRwVXJsKHJlZ2lvblVybCksIHsgbWV0aG9kOiAnSEVBRCcgfSk7XG4gICAgICAgICAgdGhpcy5sb2cuZGVidWcoYHByZXBhcmVkIGNvbm5lY3Rpb24gdG8gJHtyZWdpb25Vcmx9YCwgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXdhaXQgZmV0Y2godG9IdHRwVXJsKHVybCksIHsgbWV0aG9kOiAnSEVBRCcgfSk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhpcy5sb2cud2FybignY291bGQgbm90IHByZXBhcmUgY29ubmVjdGlvbicsIHsgLi4udGhpcy5sb2dDb250ZXh0LCBlcnJvcjogZSB9KTtcbiAgICB9XG4gIH1cblxuICBjb25uZWN0ID0gYXN5bmMgKHVybDogc3RyaW5nLCB0b2tlbjogc3RyaW5nLCBvcHRzPzogUm9vbUNvbm5lY3RPcHRpb25zKTogUHJvbWlzZTx2b2lkPiA9PiB7XG4gICAgLy8gSW4gY2FzZSBhIGRpc2Nvbm5lY3QgY2FsbGVkIGhhcHBlbmVkIHJpZ2h0IGJlZm9yZSB0aGUgY29ubmVjdCBjYWxsLCBtYWtlIHN1cmUgdGhlIGRpc2Nvbm5lY3QgaXMgY29tcGxldGVkIGZpcnN0IGJ5IGF3YWl0aW5nIGl0cyBsb2NrXG4gICAgY29uc3QgdW5sb2NrRGlzY29ubmVjdCA9IGF3YWl0IHRoaXMuZGlzY29ubmVjdExvY2subG9jaygpO1xuXG4gICAgaWYgKHRoaXMuc3RhdGUgPT09IENvbm5lY3Rpb25TdGF0ZS5Db25uZWN0ZWQpIHtcbiAgICAgIC8vIHdoZW4gdGhlIHN0YXRlIGlzIHJlY29ubmVjdGluZyBvciBjb25uZWN0ZWQsIHRoaXMgZnVuY3Rpb24gcmV0dXJucyBpbW1lZGlhdGVseVxuICAgICAgdGhpcy5sb2cuaW5mbyhgYWxyZWFkeSBjb25uZWN0ZWQgdG8gcm9vbSAke3RoaXMubmFtZX1gLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgdW5sb2NrRGlzY29ubmVjdCgpO1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmNvbm5lY3RGdXR1cmUpIHtcbiAgICAgIHVubG9ja0Rpc2Nvbm5lY3QoKTtcbiAgICAgIHJldHVybiB0aGlzLmNvbm5lY3RGdXR1cmUucHJvbWlzZTtcbiAgICB9XG5cbiAgICB0aGlzLnNldEFuZEVtaXRDb25uZWN0aW9uU3RhdGUoQ29ubmVjdGlvblN0YXRlLkNvbm5lY3RpbmcpO1xuICAgIGlmICh0aGlzLnJlZ2lvblVybFByb3ZpZGVyPy5nZXRTZXJ2ZXJVcmwoKS50b1N0cmluZygpICE9PSB1cmwpIHtcbiAgICAgIHRoaXMucmVnaW9uVXJsID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5yZWdpb25VcmxQcm92aWRlciA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaWYgKGlzQ2xvdWQobmV3IFVSTCh1cmwpKSkge1xuICAgICAgaWYgKHRoaXMucmVnaW9uVXJsUHJvdmlkZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLnJlZ2lvblVybFByb3ZpZGVyID0gbmV3IFJlZ2lvblVybFByb3ZpZGVyKHVybCwgdG9rZW4pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5yZWdpb25VcmxQcm92aWRlci51cGRhdGVUb2tlbih0b2tlbik7XG4gICAgICB9XG4gICAgICAvLyB0cmlnZ2VyIHRoZSBmaXJzdCBmZXRjaCB3aXRob3V0IHdhaXRpbmcgZm9yIGEgcmVzcG9uc2VcbiAgICAgIC8vIGlmIGluaXRpYWwgY29ubmVjdGlvbiBmYWlscywgdGhpcyB3aWxsIHNwZWVkIHVwIHBpY2tpbmcgcmVnaW9uYWwgdXJsXG4gICAgICAvLyBvbiBzdWJzZXF1ZW50IHJ1bnNcbiAgICAgIHRoaXMucmVnaW9uVXJsUHJvdmlkZXIuZmV0Y2hSZWdpb25TZXR0aW5ncygpLmNhdGNoKChlKSA9PiB7XG4gICAgICAgIHRoaXMubG9nLndhcm4oJ2NvdWxkIG5vdCBmZXRjaCByZWdpb24gc2V0dGluZ3MnLCB7IC4uLnRoaXMubG9nQ29udGV4dCwgZXJyb3I6IGUgfSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBjb25zdCBjb25uZWN0Rm4gPSBhc3luYyAoXG4gICAgICByZXNvbHZlOiAoKSA9PiB2b2lkLFxuICAgICAgcmVqZWN0OiAocmVhc29uOiBhbnkpID0+IHZvaWQsXG4gICAgICByZWdpb25Vcmw/OiBzdHJpbmcsXG4gICAgKSA9PiB7XG4gICAgICBpZiAodGhpcy5hYm9ydENvbnRyb2xsZXIpIHtcbiAgICAgICAgdGhpcy5hYm9ydENvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICAgIH1cblxuICAgICAgLy8gZXhwbGljaXQgY3JlYXRpb24gYXMgbG9jYWwgdmFyIG5lZWRlZCB0byBzYXRpc2Z5IFRTIGNvbXBpbGVyIHdoZW4gcGFzc2luZyBpdCB0byBgYXR0ZW1wdENvbm5lY3Rpb25gIGZ1cnRoZXIgZG93blxuICAgICAgY29uc3QgYWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgICAgdGhpcy5hYm9ydENvbnRyb2xsZXIgPSBhYm9ydENvbnRyb2xsZXI7XG5cbiAgICAgIC8vIGF0IHRoaXMgcG9pbnQgdGhlIGludGVudGlvbiB0byBjb25uZWN0IGhhcyBiZWVuIHNpZ25hbGxlZCBzbyB3ZSBjYW4gYWxsb3cgY2FuY2VsbGluZyBvZiB0aGUgY29ubmVjdGlvbiB2aWEgZGlzY29ubmVjdCgpIGFnYWluXG4gICAgICB1bmxvY2tEaXNjb25uZWN0Py4oKTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgdGhpcy5hdHRlbXB0Q29ubmVjdGlvbihyZWdpb25VcmwgPz8gdXJsLCB0b2tlbiwgb3B0cywgYWJvcnRDb250cm9sbGVyKTtcbiAgICAgICAgdGhpcy5hYm9ydENvbnRyb2xsZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIHJlc29sdmUoKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIHRoaXMucmVnaW9uVXJsUHJvdmlkZXIgJiZcbiAgICAgICAgICBlIGluc3RhbmNlb2YgQ29ubmVjdGlvbkVycm9yICYmXG4gICAgICAgICAgZS5yZWFzb24gIT09IENvbm5lY3Rpb25FcnJvclJlYXNvbi5DYW5jZWxsZWQgJiZcbiAgICAgICAgICBlLnJlYXNvbiAhPT0gQ29ubmVjdGlvbkVycm9yUmVhc29uLk5vdEFsbG93ZWRcbiAgICAgICAgKSB7XG4gICAgICAgICAgbGV0IG5leHRVcmw6IHN0cmluZyB8IG51bGwgPSBudWxsO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBuZXh0VXJsID0gYXdhaXQgdGhpcy5yZWdpb25VcmxQcm92aWRlci5nZXROZXh0QmVzdFJlZ2lvblVybChcbiAgICAgICAgICAgICAgdGhpcy5hYm9ydENvbnRyb2xsZXI/LnNpZ25hbCxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgZXJyb3IgaW5zdGFuY2VvZiBDb25uZWN0aW9uRXJyb3IgJiZcbiAgICAgICAgICAgICAgKGVycm9yLnN0YXR1cyA9PT0gNDAxIHx8IGVycm9yLnJlYXNvbiA9PT0gQ29ubmVjdGlvbkVycm9yUmVhc29uLkNhbmNlbGxlZClcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICB0aGlzLmhhbmRsZURpc2Nvbm5lY3QodGhpcy5vcHRpb25zLnN0b3BMb2NhbFRyYWNrT25VbnB1Ymxpc2gpO1xuICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChuZXh0VXJsKSB7XG4gICAgICAgICAgICB0aGlzLmxvZy5pbmZvKFxuICAgICAgICAgICAgICBgSW5pdGlhbCBjb25uZWN0aW9uIGZhaWxlZCB3aXRoIENvbm5lY3Rpb25FcnJvcjogJHtlLm1lc3NhZ2V9LiBSZXRyeWluZyB3aXRoIGFub3RoZXIgcmVnaW9uOiAke25leHRVcmx9YCxcbiAgICAgICAgICAgICAgdGhpcy5sb2dDb250ZXh0LFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGF3YWl0IGNvbm5lY3RGbihyZXNvbHZlLCByZWplY3QsIG5leHRVcmwpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZURpc2Nvbm5lY3QodGhpcy5vcHRpb25zLnN0b3BMb2NhbFRyYWNrT25VbnB1Ymxpc2gpO1xuICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmhhbmRsZURpc2Nvbm5lY3QodGhpcy5vcHRpb25zLnN0b3BMb2NhbFRyYWNrT25VbnB1Ymxpc2gpO1xuICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICBjb25zdCByZWdpb25VcmwgPSB0aGlzLnJlZ2lvblVybDtcbiAgICB0aGlzLnJlZ2lvblVybCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmNvbm5lY3RGdXR1cmUgPSBuZXcgRnV0dXJlKFxuICAgICAgKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBjb25uZWN0Rm4ocmVzb2x2ZSwgcmVqZWN0LCByZWdpb25VcmwpO1xuICAgICAgfSxcbiAgICAgICgpID0+IHtcbiAgICAgICAgdGhpcy5jbGVhckNvbm5lY3Rpb25GdXR1cmVzKCk7XG4gICAgICB9LFxuICAgICk7XG5cbiAgICByZXR1cm4gdGhpcy5jb25uZWN0RnV0dXJlLnByb21pc2U7XG4gIH07XG5cbiAgcHJpdmF0ZSBjb25uZWN0U2lnbmFsID0gYXN5bmMgKFxuICAgIHVybDogc3RyaW5nLFxuICAgIHRva2VuOiBzdHJpbmcsXG4gICAgZW5naW5lOiBSVENFbmdpbmUsXG4gICAgY29ubmVjdE9wdGlvbnM6IEludGVybmFsUm9vbUNvbm5lY3RPcHRpb25zLFxuICAgIHJvb21PcHRpb25zOiBJbnRlcm5hbFJvb21PcHRpb25zLFxuICAgIGFib3J0Q29udHJvbGxlcjogQWJvcnRDb250cm9sbGVyLFxuICApOiBQcm9taXNlPEpvaW5SZXNwb25zZT4gPT4ge1xuICAgIGNvbnN0IGpvaW5SZXNwb25zZSA9IGF3YWl0IGVuZ2luZS5qb2luKFxuICAgICAgdXJsLFxuICAgICAgdG9rZW4sXG4gICAgICB7XG4gICAgICAgIGF1dG9TdWJzY3JpYmU6IGNvbm5lY3RPcHRpb25zLmF1dG9TdWJzY3JpYmUsXG4gICAgICAgIHB1Ymxpc2hPbmx5OiBjb25uZWN0T3B0aW9ucy5wdWJsaXNoT25seSxcbiAgICAgICAgYWRhcHRpdmVTdHJlYW06XG4gICAgICAgICAgdHlwZW9mIHJvb21PcHRpb25zLmFkYXB0aXZlU3RyZWFtID09PSAnb2JqZWN0JyA/IHRydWUgOiByb29tT3B0aW9ucy5hZGFwdGl2ZVN0cmVhbSxcbiAgICAgICAgbWF4UmV0cmllczogY29ubmVjdE9wdGlvbnMubWF4UmV0cmllcyxcbiAgICAgICAgZTJlZUVuYWJsZWQ6ICEhdGhpcy5lMmVlTWFuYWdlcixcbiAgICAgICAgd2Vic29ja2V0VGltZW91dDogY29ubmVjdE9wdGlvbnMud2Vic29ja2V0VGltZW91dCxcbiAgICAgIH0sXG4gICAgICBhYm9ydENvbnRyb2xsZXIuc2lnbmFsLFxuICAgICk7XG5cbiAgICBsZXQgc2VydmVySW5mbzogUGFydGlhbDxTZXJ2ZXJJbmZvPiB8IHVuZGVmaW5lZCA9IGpvaW5SZXNwb25zZS5zZXJ2ZXJJbmZvO1xuICAgIGlmICghc2VydmVySW5mbykge1xuICAgICAgc2VydmVySW5mbyA9IHsgdmVyc2lvbjogam9pblJlc3BvbnNlLnNlcnZlclZlcnNpb24sIHJlZ2lvbjogam9pblJlc3BvbnNlLnNlcnZlclJlZ2lvbiB9O1xuICAgIH1cblxuICAgIHRoaXMubG9nLmRlYnVnKFxuICAgICAgYGNvbm5lY3RlZCB0byBMaXZla2l0IFNlcnZlciAke09iamVjdC5lbnRyaWVzKHNlcnZlckluZm8pXG4gICAgICAgIC5tYXAoKFtrZXksIHZhbHVlXSkgPT4gYCR7a2V5fTogJHt2YWx1ZX1gKVxuICAgICAgICAuam9pbignLCAnKX1gLFxuICAgICAge1xuICAgICAgICByb29tOiBqb2luUmVzcG9uc2Uucm9vbT8ubmFtZSxcbiAgICAgICAgcm9vbVNpZDogam9pblJlc3BvbnNlLnJvb20/LnNpZCxcbiAgICAgICAgaWRlbnRpdHk6IGpvaW5SZXNwb25zZS5wYXJ0aWNpcGFudD8uaWRlbnRpdHksXG4gICAgICB9LFxuICAgICk7XG5cbiAgICBpZiAoIWpvaW5SZXNwb25zZS5zZXJ2ZXJWZXJzaW9uKSB7XG4gICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRTZXJ2ZXIoJ3Vua25vd24gc2VydmVyIHZlcnNpb24nKTtcbiAgICB9XG5cbiAgICBpZiAoam9pblJlc3BvbnNlLnNlcnZlclZlcnNpb24gPT09ICcwLjE1LjEnICYmIHRoaXMub3B0aW9ucy5keW5hY2FzdCkge1xuICAgICAgdGhpcy5sb2cuZGVidWcoJ2Rpc2FibGluZyBkeW5hY2FzdCBkdWUgdG8gc2VydmVyIHZlcnNpb24nLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgLy8gZHluYWNhc3QgaGFzIGEgYnVnIGluIDAuMTUuMSwgc28gd2UgY2Fubm90IHVzZSBpdCB0aGVuXG4gICAgICByb29tT3B0aW9ucy5keW5hY2FzdCA9IGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiBqb2luUmVzcG9uc2U7XG4gIH07XG5cbiAgcHJpdmF0ZSBhcHBseUpvaW5SZXNwb25zZSA9IChqb2luUmVzcG9uc2U6IEpvaW5SZXNwb25zZSkgPT4ge1xuICAgIGNvbnN0IHBpID0gam9pblJlc3BvbnNlLnBhcnRpY2lwYW50ITtcblxuICAgIHRoaXMubG9jYWxQYXJ0aWNpcGFudC5zaWQgPSBwaS5zaWQ7XG4gICAgdGhpcy5sb2NhbFBhcnRpY2lwYW50LmlkZW50aXR5ID0gcGkuaWRlbnRpdHk7XG5cbiAgICAvLyBwb3B1bGF0ZSByZW1vdGUgcGFydGljaXBhbnRzLCB0aGVzZSBzaG91bGQgbm90IHRyaWdnZXIgbmV3IGV2ZW50c1xuICAgIHRoaXMuaGFuZGxlUGFydGljaXBhbnRVcGRhdGVzKFtwaSwgLi4uam9pblJlc3BvbnNlLm90aGVyUGFydGljaXBhbnRzXSk7XG5cbiAgICBpZiAoam9pblJlc3BvbnNlLnJvb20pIHtcbiAgICAgIHRoaXMuaGFuZGxlUm9vbVVwZGF0ZShqb2luUmVzcG9uc2Uucm9vbSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5lMmVlICYmIHRoaXMuZTJlZU1hbmFnZXIpIHtcbiAgICAgIHRoaXMuZTJlZU1hbmFnZXIuc2V0U2lmVHJhaWxlcihqb2luUmVzcG9uc2Uuc2lmVHJhaWxlcik7XG4gICAgfVxuICB9O1xuXG4gIHByaXZhdGUgYXR0ZW1wdENvbm5lY3Rpb24gPSBhc3luYyAoXG4gICAgdXJsOiBzdHJpbmcsXG4gICAgdG9rZW46IHN0cmluZyxcbiAgICBvcHRzOiBSb29tQ29ubmVjdE9wdGlvbnMgfCB1bmRlZmluZWQsXG4gICAgYWJvcnRDb250cm9sbGVyOiBBYm9ydENvbnRyb2xsZXIsXG4gICkgPT4ge1xuICAgIGlmICh0aGlzLnN0YXRlID09PSBDb25uZWN0aW9uU3RhdGUuUmVjb25uZWN0aW5nKSB7XG4gICAgICB0aGlzLmxvZy5pbmZvKCdSZWNvbm5lY3Rpb24gYXR0ZW1wdCByZXBsYWNlZCBieSBuZXcgY29ubmVjdGlvbiBhdHRlbXB0JywgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgIC8vIG1ha2Ugc3VyZSB3ZSBjbG9zZSBhbmQgcmVjcmVhdGUgdGhlIGV4aXN0aW5nIGVuZ2luZSBpbiBvcmRlciB0byBnZXQgcmlkIG9mIGFueSBwb3RlbnRpYWxseSBvbmdvaW5nIHJlY29ubmVjdGlvbiBhdHRlbXB0c1xuICAgICAgdGhpcy5yZWNyZWF0ZUVuZ2luZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBjcmVhdGUgZW5naW5lIGlmIHByZXZpb3VzbHkgZGlzY29ubmVjdGVkXG4gICAgICB0aGlzLm1heWJlQ3JlYXRlRW5naW5lKCk7XG4gICAgfVxuICAgIGlmICh0aGlzLnJlZ2lvblVybFByb3ZpZGVyPy5pc0Nsb3VkKCkpIHtcbiAgICAgIHRoaXMuZW5naW5lLnNldFJlZ2lvblVybFByb3ZpZGVyKHRoaXMucmVnaW9uVXJsUHJvdmlkZXIpO1xuICAgIH1cblxuICAgIHRoaXMuYWNxdWlyZUF1ZGlvQ29udGV4dCgpO1xuXG4gICAgdGhpcy5jb25uT3B0aW9ucyA9IHsgLi4ucm9vbUNvbm5lY3RPcHRpb25EZWZhdWx0cywgLi4ub3B0cyB9IGFzIEludGVybmFsUm9vbUNvbm5lY3RPcHRpb25zO1xuXG4gICAgaWYgKHRoaXMuY29ubk9wdGlvbnMucnRjQ29uZmlnKSB7XG4gICAgICB0aGlzLmVuZ2luZS5ydGNDb25maWcgPSB0aGlzLmNvbm5PcHRpb25zLnJ0Y0NvbmZpZztcbiAgICB9XG4gICAgaWYgKHRoaXMuY29ubk9wdGlvbnMucGVlckNvbm5lY3Rpb25UaW1lb3V0KSB7XG4gICAgICB0aGlzLmVuZ2luZS5wZWVyQ29ubmVjdGlvblRpbWVvdXQgPSB0aGlzLmNvbm5PcHRpb25zLnBlZXJDb25uZWN0aW9uVGltZW91dDtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgY29uc3Qgam9pblJlc3BvbnNlID0gYXdhaXQgdGhpcy5jb25uZWN0U2lnbmFsKFxuICAgICAgICB1cmwsXG4gICAgICAgIHRva2VuLFxuICAgICAgICB0aGlzLmVuZ2luZSxcbiAgICAgICAgdGhpcy5jb25uT3B0aW9ucyxcbiAgICAgICAgdGhpcy5vcHRpb25zLFxuICAgICAgICBhYm9ydENvbnRyb2xsZXIsXG4gICAgICApO1xuXG4gICAgICB0aGlzLmFwcGx5Sm9pblJlc3BvbnNlKGpvaW5SZXNwb25zZSk7XG4gICAgICAvLyBmb3J3YXJkIG1ldGFkYXRhIGNoYW5nZWQgZm9yIHRoZSBsb2NhbCBwYXJ0aWNpcGFudFxuICAgICAgdGhpcy5zZXR1cExvY2FsUGFydGljaXBhbnRFdmVudHMoKTtcbiAgICAgIHRoaXMuZW1pdChSb29tRXZlbnQuU2lnbmFsQ29ubmVjdGVkKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGF3YWl0IHRoaXMuZW5naW5lLmNsb3NlKCk7XG4gICAgICB0aGlzLnJlY3JlYXRlRW5naW5lKCk7XG4gICAgICBjb25zdCByZXN1bHRpbmdFcnJvciA9IG5ldyBDb25uZWN0aW9uRXJyb3IoYGNvdWxkIG5vdCBlc3RhYmxpc2ggc2lnbmFsIGNvbm5lY3Rpb25gKTtcbiAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICByZXN1bHRpbmdFcnJvci5tZXNzYWdlID0gYCR7cmVzdWx0aW5nRXJyb3IubWVzc2FnZX06ICR7ZXJyLm1lc3NhZ2V9YDtcbiAgICAgIH1cbiAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBDb25uZWN0aW9uRXJyb3IpIHtcbiAgICAgICAgcmVzdWx0aW5nRXJyb3IucmVhc29uID0gZXJyLnJlYXNvbjtcbiAgICAgICAgcmVzdWx0aW5nRXJyb3Iuc3RhdHVzID0gZXJyLnN0YXR1cztcbiAgICAgIH1cbiAgICAgIHRoaXMubG9nLmRlYnVnKGBlcnJvciB0cnlpbmcgdG8gZXN0YWJsaXNoIHNpZ25hbCBjb25uZWN0aW9uYCwge1xuICAgICAgICAuLi50aGlzLmxvZ0NvbnRleHQsXG4gICAgICAgIGVycm9yOiBlcnIsXG4gICAgICB9KTtcbiAgICAgIHRocm93IHJlc3VsdGluZ0Vycm9yO1xuICAgIH1cblxuICAgIGlmIChhYm9ydENvbnRyb2xsZXIuc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgIGF3YWl0IHRoaXMuZW5naW5lLmNsb3NlKCk7XG4gICAgICB0aGlzLnJlY3JlYXRlRW5naW5lKCk7XG4gICAgICB0aHJvdyBuZXcgQ29ubmVjdGlvbkVycm9yKGBDb25uZWN0aW9uIGF0dGVtcHQgYWJvcnRlZGApO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBhd2FpdCB0aGlzLmVuZ2luZS53YWl0Rm9yUENJbml0aWFsQ29ubmVjdGlvbihcbiAgICAgICAgdGhpcy5jb25uT3B0aW9ucy5wZWVyQ29ubmVjdGlvblRpbWVvdXQsXG4gICAgICAgIGFib3J0Q29udHJvbGxlcixcbiAgICAgICk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgYXdhaXQgdGhpcy5lbmdpbmUuY2xvc2UoKTtcbiAgICAgIHRoaXMucmVjcmVhdGVFbmdpbmUoKTtcbiAgICAgIHRocm93IGU7XG4gICAgfVxuXG4gICAgLy8gYWxzbyBob29rIHVubG9hZCBldmVudFxuICAgIGlmIChpc1dlYigpICYmIHRoaXMub3B0aW9ucy5kaXNjb25uZWN0T25QYWdlTGVhdmUpIHtcbiAgICAgIC8vIGNhcHR1cmluZyBib3RoICdwYWdlaGlkZScgYW5kICdiZWZvcmV1bmxvYWQnIHRvIGNhcHR1cmUgYnJvYWRlc3Qgc2V0IG9mIGJyb3dzZXIgYmVoYXZpb3JzXG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncGFnZWhpZGUnLCB0aGlzLm9uUGFnZUxlYXZlKTtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdiZWZvcmV1bmxvYWQnLCB0aGlzLm9uUGFnZUxlYXZlKTtcbiAgICB9XG4gICAgaWYgKGlzV2ViKCkpIHtcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2ZyZWV6ZScsIHRoaXMub25QYWdlTGVhdmUpO1xuICAgICAgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcz8uYWRkRXZlbnRMaXN0ZW5lcignZGV2aWNlY2hhbmdlJywgdGhpcy5oYW5kbGVEZXZpY2VDaGFuZ2UpO1xuICAgIH1cbiAgICB0aGlzLnNldEFuZEVtaXRDb25uZWN0aW9uU3RhdGUoQ29ubmVjdGlvblN0YXRlLkNvbm5lY3RlZCk7XG4gICAgdGhpcy5lbWl0KFJvb21FdmVudC5Db25uZWN0ZWQpO1xuICAgIHRoaXMucmVnaXN0ZXJDb25uZWN0aW9uUmVjb25jaWxlKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIGRpc2Nvbm5lY3RzIHRoZSByb29tLCBlbWl0cyBbW1Jvb21FdmVudC5EaXNjb25uZWN0ZWRdXVxuICAgKi9cbiAgZGlzY29ubmVjdCA9IGFzeW5jIChzdG9wVHJhY2tzID0gdHJ1ZSkgPT4ge1xuICAgIGNvbnN0IHVubG9jayA9IGF3YWl0IHRoaXMuZGlzY29ubmVjdExvY2subG9jaygpO1xuICAgIHRyeSB7XG4gICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gQ29ubmVjdGlvblN0YXRlLkRpc2Nvbm5lY3RlZCkge1xuICAgICAgICB0aGlzLmxvZy5kZWJ1ZygnYWxyZWFkeSBkaXNjb25uZWN0ZWQnLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLmxvZy5pbmZvKCdkaXNjb25uZWN0IGZyb20gcm9vbScsIHtcbiAgICAgICAgLi4udGhpcy5sb2dDb250ZXh0LFxuICAgICAgfSk7XG4gICAgICBpZiAoXG4gICAgICAgIHRoaXMuc3RhdGUgPT09IENvbm5lY3Rpb25TdGF0ZS5Db25uZWN0aW5nIHx8XG4gICAgICAgIHRoaXMuc3RhdGUgPT09IENvbm5lY3Rpb25TdGF0ZS5SZWNvbm5lY3RpbmdcbiAgICAgICkge1xuICAgICAgICAvLyB0cnkgYWJvcnRpbmcgcGVuZGluZyBjb25uZWN0aW9uIGF0dGVtcHRcbiAgICAgICAgdGhpcy5sb2cud2FybignYWJvcnQgY29ubmVjdGlvbiBhdHRlbXB0JywgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgICAgdGhpcy5hYm9ydENvbnRyb2xsZXI/LmFib3J0KCk7XG4gICAgICAgIC8vIGluIGNhc2UgdGhlIGFib3J0IGNvbnRyb2xsZXIgZGlkbid0IG1hbmFnZSB0byBjYW5jZWwgdGhlIGNvbm5lY3Rpb24gYXR0ZW1wdCwgcmVqZWN0IHRoZSBjb25uZWN0IHByb21pc2UgZXhwbGljaXRseVxuICAgICAgICB0aGlzLmNvbm5lY3RGdXR1cmU/LnJlamVjdD8uKG5ldyBDb25uZWN0aW9uRXJyb3IoJ0NsaWVudCBpbml0aWF0ZWQgZGlzY29ubmVjdCcpKTtcbiAgICAgICAgdGhpcy5jb25uZWN0RnV0dXJlID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgLy8gc2VuZCBsZWF2ZVxuICAgICAgaWYgKCF0aGlzLmVuZ2luZT8uY2xpZW50LmlzRGlzY29ubmVjdGVkKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuZW5naW5lLmNsaWVudC5zZW5kTGVhdmUoKTtcbiAgICAgIH1cbiAgICAgIC8vIGNsb3NlIGVuZ2luZSAoYWxzbyBjbG9zZXMgY2xpZW50KVxuICAgICAgaWYgKHRoaXMuZW5naW5lKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuZW5naW5lLmNsb3NlKCk7XG4gICAgICB9XG4gICAgICB0aGlzLmhhbmRsZURpc2Nvbm5lY3Qoc3RvcFRyYWNrcywgRGlzY29ubmVjdFJlYXNvbi5DTElFTlRfSU5JVElBVEVEKTtcbiAgICAgIC8qIEB0cy1pZ25vcmUgKi9cbiAgICAgIHRoaXMuZW5naW5lID0gdW5kZWZpbmVkO1xuICAgIH0gZmluYWxseSB7XG4gICAgICB1bmxvY2soKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIHJldHJpZXZlcyBhIHBhcnRpY2lwYW50IGJ5IGlkZW50aXR5XG4gICAqIEBwYXJhbSBpZGVudGl0eVxuICAgKiBAcmV0dXJuc1xuICAgKi9cbiAgZ2V0UGFydGljaXBhbnRCeUlkZW50aXR5KGlkZW50aXR5OiBzdHJpbmcpOiBQYXJ0aWNpcGFudCB8IHVuZGVmaW5lZCB7XG4gICAgaWYgKHRoaXMubG9jYWxQYXJ0aWNpcGFudC5pZGVudGl0eSA9PT0gaWRlbnRpdHkpIHtcbiAgICAgIHJldHVybiB0aGlzLmxvY2FsUGFydGljaXBhbnQ7XG4gICAgfVxuICAgIGNvbnN0IHNpZCA9IHRoaXMuaWRlbnRpdHlUb1NpZC5nZXQoaWRlbnRpdHkpO1xuICAgIGlmIChzaWQpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcnRpY2lwYW50cy5nZXQoc2lkKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGNsZWFyQ29ubmVjdGlvbkZ1dHVyZXMoKSB7XG4gICAgdGhpcy5jb25uZWN0RnV0dXJlID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbCBmb3IgdGVzdGluZ1xuICAgKi9cbiAgYXN5bmMgc2ltdWxhdGVTY2VuYXJpbyhzY2VuYXJpbzogU2ltdWxhdGlvblNjZW5hcmlvLCBhcmc/OiBhbnkpIHtcbiAgICBsZXQgcG9zdEFjdGlvbiA9ICgpID0+IHt9O1xuICAgIGxldCByZXE6IFNpbXVsYXRlU2NlbmFyaW8gfCB1bmRlZmluZWQ7XG4gICAgc3dpdGNoIChzY2VuYXJpbykge1xuICAgICAgY2FzZSAnc2lnbmFsLXJlY29ubmVjdCc6XG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgZnVuY3Rpb24gaXMgcHJpdmF0ZVxuICAgICAgICBhd2FpdCB0aGlzLmVuZ2luZS5jbGllbnQuaGFuZGxlT25DbG9zZSgnc2ltdWxhdGUgZGlzY29ubmVjdCcpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3NwZWFrZXInOlxuICAgICAgICByZXEgPSBuZXcgU2ltdWxhdGVTY2VuYXJpbyh7XG4gICAgICAgICAgc2NlbmFyaW86IHtcbiAgICAgICAgICAgIGNhc2U6ICdzcGVha2VyVXBkYXRlJyxcbiAgICAgICAgICAgIHZhbHVlOiAzLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ25vZGUtZmFpbHVyZSc6XG4gICAgICAgIHJlcSA9IG5ldyBTaW11bGF0ZVNjZW5hcmlvKHtcbiAgICAgICAgICBzY2VuYXJpbzoge1xuICAgICAgICAgICAgY2FzZTogJ25vZGVGYWlsdXJlJyxcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3NlcnZlci1sZWF2ZSc6XG4gICAgICAgIHJlcSA9IG5ldyBTaW11bGF0ZVNjZW5hcmlvKHtcbiAgICAgICAgICBzY2VuYXJpbzoge1xuICAgICAgICAgICAgY2FzZTogJ3NlcnZlckxlYXZlJyxcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ21pZ3JhdGlvbic6XG4gICAgICAgIHJlcSA9IG5ldyBTaW11bGF0ZVNjZW5hcmlvKHtcbiAgICAgICAgICBzY2VuYXJpbzoge1xuICAgICAgICAgICAgY2FzZTogJ21pZ3JhdGlvbicsXG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZSxcbiAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdyZXN1bWUtcmVjb25uZWN0JzpcbiAgICAgICAgdGhpcy5lbmdpbmUuZmFpbE5leHQoKTtcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBmdW5jdGlvbiBpcyBwcml2YXRlXG4gICAgICAgIGF3YWl0IHRoaXMuZW5naW5lLmNsaWVudC5oYW5kbGVPbkNsb3NlKCdzaW11bGF0ZSByZXN1bWUtZGlzY29ubmVjdCcpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2Rpc2Nvbm5lY3Qtc2lnbmFsLW9uLXJlc3VtZSc6XG4gICAgICAgIHBvc3RBY3Rpb24gPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBmdW5jdGlvbiBpcyBwcml2YXRlXG4gICAgICAgICAgYXdhaXQgdGhpcy5lbmdpbmUuY2xpZW50LmhhbmRsZU9uQ2xvc2UoJ3NpbXVsYXRlIHJlc3VtZS1kaXNjb25uZWN0Jyk7XG4gICAgICAgIH07XG4gICAgICAgIHJlcSA9IG5ldyBTaW11bGF0ZVNjZW5hcmlvKHtcbiAgICAgICAgICBzY2VuYXJpbzoge1xuICAgICAgICAgICAgY2FzZTogJ2Rpc2Nvbm5lY3RTaWduYWxPblJlc3VtZScsXG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZSxcbiAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdkaXNjb25uZWN0LXNpZ25hbC1vbi1yZXN1bWUtbm8tbWVzc2FnZXMnOlxuICAgICAgICBwb3N0QWN0aW9uID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgZnVuY3Rpb24gaXMgcHJpdmF0ZVxuICAgICAgICAgIGF3YWl0IHRoaXMuZW5naW5lLmNsaWVudC5oYW5kbGVPbkNsb3NlKCdzaW11bGF0ZSByZXN1bWUtZGlzY29ubmVjdCcpO1xuICAgICAgICB9O1xuICAgICAgICByZXEgPSBuZXcgU2ltdWxhdGVTY2VuYXJpbyh7XG4gICAgICAgICAgc2NlbmFyaW86IHtcbiAgICAgICAgICAgIGNhc2U6ICdkaXNjb25uZWN0U2lnbmFsT25SZXN1bWVOb01lc3NhZ2VzJyxcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2Z1bGwtcmVjb25uZWN0JzpcbiAgICAgICAgdGhpcy5lbmdpbmUuZnVsbFJlY29ubmVjdE9uTmV4dCA9IHRydWU7XG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgZnVuY3Rpb24gaXMgcHJpdmF0ZVxuICAgICAgICBhd2FpdCB0aGlzLmVuZ2luZS5jbGllbnQuaGFuZGxlT25DbG9zZSgnc2ltdWxhdGUgZnVsbC1yZWNvbm5lY3QnKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdmb3JjZS10Y3AnOlxuICAgICAgY2FzZSAnZm9yY2UtdGxzJzpcbiAgICAgICAgcmVxID0gbmV3IFNpbXVsYXRlU2NlbmFyaW8oe1xuICAgICAgICAgIHNjZW5hcmlvOiB7XG4gICAgICAgICAgICBjYXNlOiAnc3dpdGNoQ2FuZGlkYXRlUHJvdG9jb2wnLFxuICAgICAgICAgICAgdmFsdWU6IHNjZW5hcmlvID09PSAnZm9yY2UtdGxzJyA/IDIgOiAxLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICBwb3N0QWN0aW9uID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IG9uTGVhdmUgPSB0aGlzLmVuZ2luZS5jbGllbnQub25MZWF2ZTtcbiAgICAgICAgICBpZiAob25MZWF2ZSkge1xuICAgICAgICAgICAgb25MZWF2ZShcbiAgICAgICAgICAgICAgbmV3IExlYXZlUmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcmVhc29uOiBEaXNjb25uZWN0UmVhc29uLkNMSUVOVF9JTklUSUFURUQsXG4gICAgICAgICAgICAgICAgY2FuUmVjb25uZWN0OiB0cnVlLFxuICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3N1YnNjcmliZXItYmFuZHdpZHRoJzpcbiAgICAgICAgaWYgKGFyZyA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiBhcmcgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzdWJzY3JpYmVyLWJhbmR3aWR0aCByZXF1aXJlcyBhIG51bWJlciBhcyBhcmd1bWVudCcpO1xuICAgICAgICB9XG4gICAgICAgIHJlcSA9IG5ldyBTaW11bGF0ZVNjZW5hcmlvKHtcbiAgICAgICAgICBzY2VuYXJpbzoge1xuICAgICAgICAgICAgY2FzZTogJ3N1YnNjcmliZXJCYW5kd2lkdGgnLFxuICAgICAgICAgICAgdmFsdWU6IEJpZ0ludChhcmcpLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICB9XG4gICAgaWYgKHJlcSkge1xuICAgICAgYXdhaXQgdGhpcy5lbmdpbmUuY2xpZW50LnNlbmRTaW11bGF0ZVNjZW5hcmlvKHJlcSk7XG4gICAgICBhd2FpdCBwb3N0QWN0aW9uKCk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBvblBhZ2VMZWF2ZSA9IGFzeW5jICgpID0+IHtcbiAgICBhd2FpdCB0aGlzLmRpc2Nvbm5lY3QoKTtcbiAgfTtcblxuICAvKipcbiAgICogQnJvd3NlcnMgaGF2ZSBkaWZmZXJlbnQgcG9saWNpZXMgcmVnYXJkaW5nIGF1ZGlvIHBsYXliYWNrLiBNb3N0IHJlcXVpcmluZ1xuICAgKiBzb21lIGZvcm0gb2YgdXNlciBpbnRlcmFjdGlvbiAoY2xpY2svdGFwL2V0YykuXG4gICAqIEluIHRob3NlIGNhc2VzLCBhdWRpbyB3aWxsIGJlIHNpbGVudCB1bnRpbCBhIGNsaWNrL3RhcCB0cmlnZ2VyaW5nIG9uZSBvZiB0aGUgZm9sbG93aW5nXG4gICAqIC0gYHN0YXJ0QXVkaW9gXG4gICAqIC0gYGdldFVzZXJNZWRpYWBcbiAgICovXG4gIHN0YXJ0QXVkaW8gPSBhc3luYyAoKSA9PiB7XG4gICAgY29uc3QgZWxlbWVudHM6IEFycmF5PEhUTUxNZWRpYUVsZW1lbnQ+ID0gW107XG4gICAgY29uc3QgYnJvd3NlciA9IGdldEJyb3dzZXIoKTtcbiAgICBpZiAoYnJvd3NlciAmJiBicm93c2VyLm9zID09PSAnaU9TJykge1xuICAgICAgLyoqXG4gICAgICAgKiBpT1MgYmxvY2tzIGF1ZGlvIGVsZW1lbnQgcGxheWJhY2sgaWZcbiAgICAgICAqIC0gdXNlciBpcyBub3QgcHVibGlzaGluZyBhdWRpbyB0aGVtc2VsdmVzIGFuZFxuICAgICAgICogLSBubyBvdGhlciBhdWRpbyBzb3VyY2UgaXMgcGxheWluZ1xuICAgICAgICpcbiAgICAgICAqIGFzIGEgd29ya2Fyb3VuZCwgd2UgY3JlYXRlIGFuIGF1ZGlvIGVsZW1lbnQgd2l0aCBhbiBlbXB0eSB0cmFjaywgc28gdGhhdFxuICAgICAgICogc2lsZW50IGF1ZGlvIGlzIGFsd2F5cyBwbGF5aW5nXG4gICAgICAgKi9cbiAgICAgIGNvbnN0IGF1ZGlvSWQgPSAnbGl2ZWtpdC1kdW1teS1hdWRpby1lbCc7XG4gICAgICBsZXQgZHVtbXlBdWRpb0VsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoYXVkaW9JZCkgYXMgSFRNTEF1ZGlvRWxlbWVudCB8IG51bGw7XG4gICAgICBpZiAoIWR1bW15QXVkaW9FbCkge1xuICAgICAgICBkdW1teUF1ZGlvRWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhdWRpbycpO1xuICAgICAgICBkdW1teUF1ZGlvRWwuaWQgPSBhdWRpb0lkO1xuICAgICAgICBkdW1teUF1ZGlvRWwuYXV0b3BsYXkgPSB0cnVlO1xuICAgICAgICBkdW1teUF1ZGlvRWwuaGlkZGVuID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgdHJhY2sgPSBnZXRFbXB0eUF1ZGlvU3RyZWFtVHJhY2soKTtcbiAgICAgICAgdHJhY2suZW5hYmxlZCA9IHRydWU7XG4gICAgICAgIGNvbnN0IHN0cmVhbSA9IG5ldyBNZWRpYVN0cmVhbShbdHJhY2tdKTtcbiAgICAgICAgZHVtbXlBdWRpb0VsLnNyY09iamVjdCA9IHN0cmVhbTtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndmlzaWJpbGl0eWNoYW5nZScsICgpID0+IHtcbiAgICAgICAgICBpZiAoIWR1bW15QXVkaW9FbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBzZXQgdGhlIHNyY09iamVjdCB0byBudWxsIG9uIHBhZ2UgaGlkZSBpbiBvcmRlciB0byBwcmV2ZW50IGxvY2sgc2NyZWVuIGNvbnRyb2xzIHRvIHNob3cgdXAgZm9yIGl0XG4gICAgICAgICAgZHVtbXlBdWRpb0VsLnNyY09iamVjdCA9IGRvY3VtZW50LmhpZGRlbiA/IG51bGwgOiBzdHJlYW07XG4gICAgICAgICAgaWYgKCFkb2N1bWVudC5oaWRkZW4pIHtcbiAgICAgICAgICAgIHRoaXMubG9nLmRlYnVnKFxuICAgICAgICAgICAgICAncGFnZSB2aXNpYmxlIGFnYWluLCB0cmlnZ2VyaW5nIHN0YXJ0QXVkaW8gdG8gcmVzdW1lIHBsYXliYWNrIGFuZCB1cGRhdGUgcGxheWJhY2sgc3RhdHVzJyxcbiAgICAgICAgICAgICAgdGhpcy5sb2dDb250ZXh0LFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHRoaXMuc3RhcnRBdWRpbygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kKGR1bW15QXVkaW9FbCk7XG4gICAgICAgIHRoaXMub25jZShSb29tRXZlbnQuRGlzY29ubmVjdGVkLCAoKSA9PiB7XG4gICAgICAgICAgZHVtbXlBdWRpb0VsPy5yZW1vdmUoKTtcbiAgICAgICAgICBkdW1teUF1ZGlvRWwgPSBudWxsO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGVsZW1lbnRzLnB1c2goZHVtbXlBdWRpb0VsKTtcbiAgICB9XG5cbiAgICB0aGlzLnBhcnRpY2lwYW50cy5mb3JFYWNoKChwKSA9PiB7XG4gICAgICBwLmF1ZGlvVHJhY2tzLmZvckVhY2goKHQpID0+IHtcbiAgICAgICAgaWYgKHQudHJhY2spIHtcbiAgICAgICAgICB0LnRyYWNrLmF0dGFjaGVkRWxlbWVudHMuZm9yRWFjaCgoZSkgPT4ge1xuICAgICAgICAgICAgZWxlbWVudHMucHVzaChlKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICB0cnkge1xuICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICB0aGlzLmFjcXVpcmVBdWRpb0NvbnRleHQoKSxcbiAgICAgICAgLi4uZWxlbWVudHMubWFwKChlKSA9PiB7XG4gICAgICAgICAgZS5tdXRlZCA9IGZhbHNlO1xuICAgICAgICAgIHJldHVybiBlLnBsYXkoKTtcbiAgICAgICAgfSksXG4gICAgICBdKTtcbiAgICAgIHRoaXMuaGFuZGxlQXVkaW9QbGF5YmFja1N0YXJ0ZWQoKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHRoaXMuaGFuZGxlQXVkaW9QbGF5YmFja0ZhaWxlZChlcnIpO1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH1cbiAgfTtcblxuICBzdGFydFZpZGVvID0gYXN5bmMgKCkgPT4ge1xuICAgIGNvbnN0IGVsZW1lbnRzOiBIVE1MTWVkaWFFbGVtZW50W10gPSBbXTtcbiAgICBmb3IgKGNvbnN0IHAgb2YgdGhpcy5wYXJ0aWNpcGFudHMudmFsdWVzKCkpIHtcbiAgICAgIHAudmlkZW9UcmFja3MuZm9yRWFjaCgodHIpID0+IHtcbiAgICAgICAgdHIudHJhY2s/LmF0dGFjaGVkRWxlbWVudHMuZm9yRWFjaCgoZWwpID0+IHtcbiAgICAgICAgICBpZiAoIWVsZW1lbnRzLmluY2x1ZGVzKGVsKSkge1xuICAgICAgICAgICAgZWxlbWVudHMucHVzaChlbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBhd2FpdCBQcm9taXNlLmFsbChlbGVtZW50cy5tYXAoKGVsKSA9PiBlbC5wbGF5KCkpKVxuICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICB0aGlzLmhhbmRsZVZpZGVvUGxheWJhY2tTdGFydGVkKCk7XG4gICAgICB9KVxuICAgICAgLmNhdGNoKChlKSA9PiB7XG4gICAgICAgIGlmIChlLm5hbWUgPT09ICdOb3RBbGxvd2VkRXJyb3InKSB7XG4gICAgICAgICAgdGhpcy5oYW5kbGVWaWRlb1BsYXliYWNrRmFpbGVkKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5sb2cud2FybihcbiAgICAgICAgICAgICdSZXN1bWluZyB2aWRlbyBwbGF5YmFjayBmYWlsZWQsIG1ha2Ugc3VyZSB5b3UgY2FsbCBgc3RhcnRWaWRlb2AgZGlyZWN0bHkgaW4gYSB1c2VyIGdlc3R1cmUgaGFuZGxlcicsXG4gICAgICAgICAgICB0aGlzLmxvZ0NvbnRleHQsXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBhdWRpbyBwbGF5YmFjayBpcyBlbmFibGVkXG4gICAqL1xuICBnZXQgY2FuUGxheWJhY2tBdWRpbygpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5hdWRpb0VuYWJsZWQ7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHZpZGVvIHBsYXliYWNrIGlzIGVuYWJsZWRcbiAgICovXG4gIGdldCBjYW5QbGF5YmFja1ZpZGVvKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiAhdGhpcy5pc1ZpZGVvUGxheWJhY2tCbG9ja2VkO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGFjdGl2ZSBhdWRpbyBvdXRwdXQgZGV2aWNlIHVzZWQgaW4gdGhpcyByb29tLlxuICAgKiBAcmV0dXJuIHRoZSBwcmV2aW91c2x5IHN1Y2Nlc3NmdWxseSBzZXQgYXVkaW8gb3V0cHV0IGRldmljZSBJRCBvciBhbiBlbXB0eSBzdHJpbmcgaWYgdGhlIGRlZmF1bHQgZGV2aWNlIGlzIHVzZWQuXG4gICAqIEBkZXByZWNhdGVkIHVzZSBgZ2V0QWN0aXZlRGV2aWNlKCdhdWRpb291dHB1dCcpYCBpbnN0ZWFkXG4gICAqL1xuICBnZXRBY3RpdmVBdWRpb091dHB1dERldmljZSgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnMuYXVkaW9PdXRwdXQ/LmRldmljZUlkID8/ICcnO1xuICB9XG5cbiAgZ2V0QWN0aXZlRGV2aWNlKGtpbmQ6IE1lZGlhRGV2aWNlS2luZCk6IHN0cmluZyB8IHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIHRoaXMubG9jYWxQYXJ0aWNpcGFudC5hY3RpdmVEZXZpY2VNYXAuZ2V0KGtpbmQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFN3aXRjaGVzIGFsbCBhY3RpdmUgZGV2aWNlcyB1c2VkIGluIHRoaXMgcm9vbSB0byB0aGUgZ2l2ZW4gZGV2aWNlLlxuICAgKlxuICAgKiBOb3RlOiBzZXR0aW5nIEF1ZGlvT3V0cHV0IGlzIG5vdCBzdXBwb3J0ZWQgb24gc29tZSBicm93c2Vycy4gU2VlIFtzZXRTaW5rSWRdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9IVE1MTWVkaWFFbGVtZW50L3NldFNpbmtJZCNicm93c2VyX2NvbXBhdGliaWxpdHkpXG4gICAqXG4gICAqIEBwYXJhbSBraW5kIHVzZSBgdmlkZW9pbnB1dGAgZm9yIGNhbWVyYSB0cmFjayxcbiAgICogIGBhdWRpb2lucHV0YCBmb3IgbWljcm9waG9uZSB0cmFjayxcbiAgICogIGBhdWRpb291dHB1dGAgdG8gc2V0IHNwZWFrZXIgZm9yIGFsbCBpbmNvbWluZyBhdWRpbyB0cmFja3NcbiAgICogQHBhcmFtIGRldmljZUlkXG4gICAqL1xuICBhc3luYyBzd2l0Y2hBY3RpdmVEZXZpY2Uoa2luZDogTWVkaWFEZXZpY2VLaW5kLCBkZXZpY2VJZDogc3RyaW5nLCBleGFjdDogYm9vbGVhbiA9IGZhbHNlKSB7XG4gICAgbGV0IGRldmljZUhhc0NoYW5nZWQgPSBmYWxzZTtcbiAgICBsZXQgc3VjY2VzcyA9IHRydWU7XG4gICAgY29uc3QgZGV2aWNlQ29uc3RyYWludCA9IGV4YWN0ID8geyBleGFjdDogZGV2aWNlSWQgfSA6IGRldmljZUlkO1xuICAgIGlmIChraW5kID09PSAnYXVkaW9pbnB1dCcpIHtcbiAgICAgIGNvbnN0IHByZXZEZXZpY2VJZCA9IHRoaXMub3B0aW9ucy5hdWRpb0NhcHR1cmVEZWZhdWx0cyEuZGV2aWNlSWQ7XG4gICAgICB0aGlzLm9wdGlvbnMuYXVkaW9DYXB0dXJlRGVmYXVsdHMhLmRldmljZUlkID0gZGV2aWNlQ29uc3RyYWludDtcbiAgICAgIGRldmljZUhhc0NoYW5nZWQgPSBwcmV2RGV2aWNlSWQgIT09IGRldmljZUNvbnN0cmFpbnQ7XG4gICAgICBjb25zdCB0cmFja3MgPSBBcnJheS5mcm9tKHRoaXMubG9jYWxQYXJ0aWNpcGFudC5hdWRpb1RyYWNrcy52YWx1ZXMoKSkuZmlsdGVyKFxuICAgICAgICAodHJhY2spID0+IHRyYWNrLnNvdXJjZSA9PT0gVHJhY2suU291cmNlLk1pY3JvcGhvbmUsXG4gICAgICApO1xuICAgICAgdHJ5IHtcbiAgICAgICAgc3VjY2VzcyA9IChcbiAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbCh0cmFja3MubWFwKCh0KSA9PiB0LmF1ZGlvVHJhY2s/LnNldERldmljZUlkKGRldmljZUNvbnN0cmFpbnQpKSlcbiAgICAgICAgKS5ldmVyeSgodmFsKSA9PiB2YWwgPT09IHRydWUpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0aGlzLm9wdGlvbnMuYXVkaW9DYXB0dXJlRGVmYXVsdHMhLmRldmljZUlkID0gcHJldkRldmljZUlkO1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoa2luZCA9PT0gJ3ZpZGVvaW5wdXQnKSB7XG4gICAgICBjb25zdCBwcmV2RGV2aWNlSWQgPSB0aGlzLm9wdGlvbnMudmlkZW9DYXB0dXJlRGVmYXVsdHMhLmRldmljZUlkO1xuICAgICAgdGhpcy5vcHRpb25zLnZpZGVvQ2FwdHVyZURlZmF1bHRzIS5kZXZpY2VJZCA9IGRldmljZUNvbnN0cmFpbnQ7XG4gICAgICBkZXZpY2VIYXNDaGFuZ2VkID0gcHJldkRldmljZUlkICE9PSBkZXZpY2VDb25zdHJhaW50O1xuICAgICAgY29uc3QgdHJhY2tzID0gQXJyYXkuZnJvbSh0aGlzLmxvY2FsUGFydGljaXBhbnQudmlkZW9UcmFja3MudmFsdWVzKCkpLmZpbHRlcihcbiAgICAgICAgKHRyYWNrKSA9PiB0cmFjay5zb3VyY2UgPT09IFRyYWNrLlNvdXJjZS5DYW1lcmEsXG4gICAgICApO1xuICAgICAgdHJ5IHtcbiAgICAgICAgc3VjY2VzcyA9IChcbiAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbCh0cmFja3MubWFwKCh0KSA9PiB0LnZpZGVvVHJhY2s/LnNldERldmljZUlkKGRldmljZUNvbnN0cmFpbnQpKSlcbiAgICAgICAgKS5ldmVyeSgodmFsKSA9PiB2YWwgPT09IHRydWUpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0aGlzLm9wdGlvbnMudmlkZW9DYXB0dXJlRGVmYXVsdHMhLmRldmljZUlkID0gcHJldkRldmljZUlkO1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoa2luZCA9PT0gJ2F1ZGlvb3V0cHV0Jykge1xuICAgICAgaWYgKFxuICAgICAgICAoIXN1cHBvcnRzU2V0U2lua0lkKCkgJiYgIXRoaXMub3B0aW9ucy5leHBXZWJBdWRpb01peCkgfHxcbiAgICAgICAgKHRoaXMub3B0aW9ucy5leHBXZWJBdWRpb01peCAmJiB0aGlzLmF1ZGlvQ29udGV4dCAmJiAhKCdzZXRTaW5rSWQnIGluIHRoaXMuYXVkaW9Db250ZXh0KSlcbiAgICAgICkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Nhbm5vdCBzd2l0Y2ggYXVkaW8gb3V0cHV0LCBzZXRTaW5rSWQgbm90IHN1cHBvcnRlZCcpO1xuICAgICAgfVxuICAgICAgdGhpcy5vcHRpb25zLmF1ZGlvT3V0cHV0ID8/PSB7fTtcbiAgICAgIGNvbnN0IHByZXZEZXZpY2VJZCA9IHRoaXMub3B0aW9ucy5hdWRpb091dHB1dC5kZXZpY2VJZDtcbiAgICAgIHRoaXMub3B0aW9ucy5hdWRpb091dHB1dC5kZXZpY2VJZCA9IGRldmljZUlkO1xuICAgICAgZGV2aWNlSGFzQ2hhbmdlZCA9IHByZXZEZXZpY2VJZCAhPT0gZGV2aWNlQ29uc3RyYWludDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5leHBXZWJBdWRpb01peCkge1xuICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3Igc2V0U2lua0lkIGlzIG5vdCB5ZXQgaW4gdGhlIHR5cGVzY3JpcHQgdHlwZSBvZiBBdWRpb0NvbnRleHRcbiAgICAgICAgICB0aGlzLmF1ZGlvQ29udGV4dD8uc2V0U2lua0lkKGRldmljZUlkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgICAgICAgIEFycmF5LmZyb20odGhpcy5wYXJ0aWNpcGFudHMudmFsdWVzKCkpLm1hcCgocCkgPT4gcC5zZXRBdWRpb091dHB1dCh7IGRldmljZUlkIH0pKSxcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5hdWRpb091dHB1dC5kZXZpY2VJZCA9IHByZXZEZXZpY2VJZDtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGRldmljZUhhc0NoYW5nZWQgJiYgc3VjY2Vzcykge1xuICAgICAgdGhpcy5sb2NhbFBhcnRpY2lwYW50LmFjdGl2ZURldmljZU1hcC5zZXQoa2luZCwgZGV2aWNlSWQpO1xuICAgICAgdGhpcy5lbWl0KFJvb21FdmVudC5BY3RpdmVEZXZpY2VDaGFuZ2VkLCBraW5kLCBkZXZpY2VJZCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN1Y2Nlc3M7XG4gIH1cblxuICBwcml2YXRlIHNldHVwTG9jYWxQYXJ0aWNpcGFudEV2ZW50cygpIHtcbiAgICB0aGlzLmxvY2FsUGFydGljaXBhbnRcbiAgICAgIC5vbihQYXJ0aWNpcGFudEV2ZW50LlBhcnRpY2lwYW50TWV0YWRhdGFDaGFuZ2VkLCB0aGlzLm9uTG9jYWxQYXJ0aWNpcGFudE1ldGFkYXRhQ2hhbmdlZClcbiAgICAgIC5vbihQYXJ0aWNpcGFudEV2ZW50LlBhcnRpY2lwYW50TmFtZUNoYW5nZWQsIHRoaXMub25Mb2NhbFBhcnRpY2lwYW50TmFtZUNoYW5nZWQpXG4gICAgICAub24oUGFydGljaXBhbnRFdmVudC5UcmFja011dGVkLCB0aGlzLm9uTG9jYWxUcmFja011dGVkKVxuICAgICAgLm9uKFBhcnRpY2lwYW50RXZlbnQuVHJhY2tVbm11dGVkLCB0aGlzLm9uTG9jYWxUcmFja1VubXV0ZWQpXG4gICAgICAub24oUGFydGljaXBhbnRFdmVudC5Mb2NhbFRyYWNrUHVibGlzaGVkLCB0aGlzLm9uTG9jYWxUcmFja1B1Ymxpc2hlZClcbiAgICAgIC5vbihQYXJ0aWNpcGFudEV2ZW50LkxvY2FsVHJhY2tVbnB1Ymxpc2hlZCwgdGhpcy5vbkxvY2FsVHJhY2tVbnB1Ymxpc2hlZClcbiAgICAgIC5vbihQYXJ0aWNpcGFudEV2ZW50LkNvbm5lY3Rpb25RdWFsaXR5Q2hhbmdlZCwgdGhpcy5vbkxvY2FsQ29ubmVjdGlvblF1YWxpdHlDaGFuZ2VkKVxuICAgICAgLm9uKFBhcnRpY2lwYW50RXZlbnQuTWVkaWFEZXZpY2VzRXJyb3IsIHRoaXMub25NZWRpYURldmljZXNFcnJvcilcbiAgICAgIC5vbihQYXJ0aWNpcGFudEV2ZW50LkF1ZGlvU3RyZWFtQWNxdWlyZWQsIHRoaXMuc3RhcnRBdWRpbylcbiAgICAgIC5vbihcbiAgICAgICAgUGFydGljaXBhbnRFdmVudC5QYXJ0aWNpcGFudFBlcm1pc3Npb25zQ2hhbmdlZCxcbiAgICAgICAgdGhpcy5vbkxvY2FsUGFydGljaXBhbnRQZXJtaXNzaW9uc0NoYW5nZWQsXG4gICAgICApO1xuICB9XG5cbiAgcHJpdmF0ZSByZWNyZWF0ZUVuZ2luZSgpIHtcbiAgICB0aGlzLmVuZ2luZT8uY2xvc2UoKTtcbiAgICAvKiBAdHMtaWdub3JlICovXG4gICAgdGhpcy5lbmdpbmUgPSB1bmRlZmluZWQ7XG5cbiAgICAvLyBjbGVhciBvdXQgZXhpc3RpbmcgcmVtb3RlIHBhcnRpY2lwYW50cywgc2luY2UgdGhleSBtYXkgaGF2ZSBhdHRhY2hlZFxuICAgIC8vIHRoZSBvbGQgZW5naW5lXG4gICAgdGhpcy5wYXJ0aWNpcGFudHMuY2xlYXIoKTtcbiAgICB0aGlzLmJ1ZmZlcmVkRXZlbnRzID0gW107XG4gICAgdGhpcy5tYXliZUNyZWF0ZUVuZ2luZSgpO1xuICB9XG5cbiAgcHJpdmF0ZSBvblRyYWNrQWRkZWQoXG4gICAgbWVkaWFUcmFjazogTWVkaWFTdHJlYW1UcmFjayxcbiAgICBzdHJlYW06IE1lZGlhU3RyZWFtLFxuICAgIHJlY2VpdmVyPzogUlRDUnRwUmVjZWl2ZXIsXG4gICkge1xuICAgIC8vIGRvbid0IGZpcmUgb25TdWJzY3JpYmVkIHdoZW4gY29ubmVjdGluZ1xuICAgIC8vIFdlYlJUQyBmaXJlcyBvblRyYWNrIGFzIHNvb24gYXMgc2V0UmVtb3RlRGVzY3JpcHRpb24gaXMgY2FsbGVkIG9uIHRoZSBvZmZlclxuICAgIC8vIGF0IHRoYXQgdGltZSwgSUNFIGNvbm5lY3Rpdml0eSBoYXMgbm90IGJlZW4gZXN0YWJsaXNoZWQgc28gdGhlIHRyYWNrIGlzIG5vdFxuICAgIC8vIHRlY2huaWNhbGx5IHN1YnNjcmliZWQuXG4gICAgLy8gV2UnbGwgZGVmZXIgdGhlc2UgZXZlbnRzIHVudGlsIHdoZW4gdGhlIHJvb20gaXMgY29ubmVjdGVkIG9yIGV2ZW50dWFsbHkgZGlzY29ubmVjdGVkLlxuICAgIGlmICh0aGlzLnN0YXRlID09PSBDb25uZWN0aW9uU3RhdGUuQ29ubmVjdGluZyB8fCB0aGlzLnN0YXRlID09PSBDb25uZWN0aW9uU3RhdGUuUmVjb25uZWN0aW5nKSB7XG4gICAgICBjb25zdCByZWNvbm5lY3RlZEhhbmRsZXIgPSAoKSA9PiB7XG4gICAgICAgIHRoaXMub25UcmFja0FkZGVkKG1lZGlhVHJhY2ssIHN0cmVhbSwgcmVjZWl2ZXIpO1xuICAgICAgICBjbGVhbnVwKCk7XG4gICAgICB9O1xuICAgICAgY29uc3QgY2xlYW51cCA9ICgpID0+IHtcbiAgICAgICAgdGhpcy5vZmYoUm9vbUV2ZW50LlJlY29ubmVjdGVkLCByZWNvbm5lY3RlZEhhbmRsZXIpO1xuICAgICAgICB0aGlzLm9mZihSb29tRXZlbnQuQ29ubmVjdGVkLCByZWNvbm5lY3RlZEhhbmRsZXIpO1xuICAgICAgICB0aGlzLm9mZihSb29tRXZlbnQuRGlzY29ubmVjdGVkLCBjbGVhbnVwKTtcbiAgICAgIH07XG4gICAgICB0aGlzLm9uY2UoUm9vbUV2ZW50LlJlY29ubmVjdGVkLCByZWNvbm5lY3RlZEhhbmRsZXIpO1xuICAgICAgdGhpcy5vbmNlKFJvb21FdmVudC5Db25uZWN0ZWQsIHJlY29ubmVjdGVkSGFuZGxlcik7XG4gICAgICB0aGlzLm9uY2UoUm9vbUV2ZW50LkRpc2Nvbm5lY3RlZCwgY2xlYW51cCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLnN0YXRlID09PSBDb25uZWN0aW9uU3RhdGUuRGlzY29ubmVjdGVkKSB7XG4gICAgICB0aGlzLmxvZy53YXJuKCdza2lwcGluZyBpbmNvbWluZyB0cmFjayBhZnRlciBSb29tIGRpc2Nvbm5lY3RlZCcsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHBhcnRzID0gdW5wYWNrU3RyZWFtSWQoc3RyZWFtLmlkKTtcbiAgICBjb25zdCBwYXJ0aWNpcGFudElkID0gcGFydHNbMF07XG4gICAgbGV0IHN0cmVhbUlkID0gcGFydHNbMV07XG4gICAgbGV0IHRyYWNrSWQgPSBtZWRpYVRyYWNrLmlkO1xuICAgIC8vIGZpcmVmb3ggd2lsbCBnZXQgc3RyZWFtSWQgKHBJRHx0cmFja0lkKSBpbnN0ZWFkIG9mIChwSUR8c3RyZWFtSWQpIGFzIGl0IGRvZXNuJ3Qgc3VwcG9ydCBzeW5jIHRyYWNrcyBieSBzdHJlYW1cbiAgICAvLyBhbmQgZ2VuZXJhdGVzIGl0cyBvd24gdHJhY2sgaWQgaW5zdGVhZCBvZiBpbmZlciBmcm9tIHNkcCB0cmFjayBpZC5cbiAgICBpZiAoc3RyZWFtSWQgJiYgc3RyZWFtSWQuc3RhcnRzV2l0aCgnVFInKSkgdHJhY2tJZCA9IHN0cmVhbUlkO1xuXG4gICAgaWYgKHBhcnRpY2lwYW50SWQgPT09IHRoaXMubG9jYWxQYXJ0aWNpcGFudC5zaWQpIHtcbiAgICAgIHRoaXMubG9nLndhcm4oJ3RyaWVkIHRvIGNyZWF0ZSBSZW1vdGVQYXJ0aWNpcGFudCBmb3IgbG9jYWwgcGFydGljaXBhbnQnLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHBhcnRpY2lwYW50ID0gdGhpcy5wYXJ0aWNpcGFudHMuZ2V0KHBhcnRpY2lwYW50SWQpIGFzIFJlbW90ZVBhcnRpY2lwYW50IHwgdW5kZWZpbmVkO1xuXG4gICAgaWYgKCFwYXJ0aWNpcGFudCkge1xuICAgICAgdGhpcy5sb2cuZXJyb3IoXG4gICAgICAgIGBUcmllZCB0byBhZGQgYSB0cmFjayBmb3IgYSBwYXJ0aWNpcGFudCwgdGhhdCdzIG5vdCBwcmVzZW50LiBTaWQ6ICR7cGFydGljaXBhbnRJZH1gLFxuICAgICAgICB0aGlzLmxvZ0NvbnRleHQsXG4gICAgICApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxldCBhZGFwdGl2ZVN0cmVhbVNldHRpbmdzOiBBZGFwdGl2ZVN0cmVhbVNldHRpbmdzIHwgdW5kZWZpbmVkO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuYWRhcHRpdmVTdHJlYW0pIHtcbiAgICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLmFkYXB0aXZlU3RyZWFtID09PSAnb2JqZWN0Jykge1xuICAgICAgICBhZGFwdGl2ZVN0cmVhbVNldHRpbmdzID0gdGhpcy5vcHRpb25zLmFkYXB0aXZlU3RyZWFtO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWRhcHRpdmVTdHJlYW1TZXR0aW5ncyA9IHt9O1xuICAgICAgfVxuICAgIH1cbiAgICBwYXJ0aWNpcGFudC5hZGRTdWJzY3JpYmVkTWVkaWFUcmFjayhcbiAgICAgIG1lZGlhVHJhY2ssXG4gICAgICB0cmFja0lkLFxuICAgICAgc3RyZWFtLFxuICAgICAgcmVjZWl2ZXIsXG4gICAgICBhZGFwdGl2ZVN0cmVhbVNldHRpbmdzLFxuICAgICk7XG4gIH1cblxuICBwcml2YXRlIGhhbmRsZVJlc3RhcnRpbmcgPSAoKSA9PiB7XG4gICAgdGhpcy5jbGVhckNvbm5lY3Rpb25SZWNvbmNpbGUoKTtcbiAgICAvLyBhbHNvIHVud2luZCBleGlzdGluZyBwYXJ0aWNpcGFudHMgJiBleGlzdGluZyBzdWJzY3JpcHRpb25zXG4gICAgZm9yIChjb25zdCBwIG9mIHRoaXMucGFydGljaXBhbnRzLnZhbHVlcygpKSB7XG4gICAgICB0aGlzLmhhbmRsZVBhcnRpY2lwYW50RGlzY29ubmVjdGVkKHAuc2lkLCBwKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5zZXRBbmRFbWl0Q29ubmVjdGlvblN0YXRlKENvbm5lY3Rpb25TdGF0ZS5SZWNvbm5lY3RpbmcpKSB7XG4gICAgICB0aGlzLmVtaXQoUm9vbUV2ZW50LlJlY29ubmVjdGluZyk7XG4gICAgfVxuICB9O1xuXG4gIHByaXZhdGUgaGFuZGxlU2lnbmFsUmVzdGFydGVkID0gYXN5bmMgKGpvaW5SZXNwb25zZTogSm9pblJlc3BvbnNlKSA9PiB7XG4gICAgdGhpcy5sb2cuZGVidWcoYHNpZ25hbCByZWNvbm5lY3RlZCB0byBzZXJ2ZXIsIHJlZ2lvbiAke2pvaW5SZXNwb25zZS5zZXJ2ZXJSZWdpb259YCwge1xuICAgICAgLi4udGhpcy5sb2dDb250ZXh0LFxuICAgICAgcmVnaW9uOiBqb2luUmVzcG9uc2Uuc2VydmVyUmVnaW9uLFxuICAgIH0pO1xuICAgIHRoaXMuYnVmZmVyZWRFdmVudHMgPSBbXTtcblxuICAgIHRoaXMuYXBwbHlKb2luUmVzcG9uc2Uoam9pblJlc3BvbnNlKTtcblxuICAgIHRyeSB7XG4gICAgICAvLyB1bnB1Ymxpc2ggJiByZXB1Ymxpc2ggdHJhY2tzXG4gICAgICBhd2FpdCB0aGlzLmxvY2FsUGFydGljaXBhbnQucmVwdWJsaXNoQWxsVHJhY2tzKHVuZGVmaW5lZCwgdHJ1ZSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRoaXMubG9nLmVycm9yKCdlcnJvciB0cnlpbmcgdG8gcmUtcHVibGlzaCB0cmFja3MgYWZ0ZXIgcmVjb25uZWN0aW9uJywge1xuICAgICAgICAuLi50aGlzLmxvZ0NvbnRleHQsXG4gICAgICAgIGVycm9yLFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHRoaXMuZW5naW5lLndhaXRGb3JSZXN0YXJ0ZWQoKTtcbiAgICAgIHRoaXMubG9nLmRlYnVnKGBmdWxseSByZWNvbm5lY3RlZCB0byBzZXJ2ZXJgLCB7XG4gICAgICAgIC4uLnRoaXMubG9nQ29udGV4dCxcbiAgICAgICAgcmVnaW9uOiBqb2luUmVzcG9uc2Uuc2VydmVyUmVnaW9uLFxuICAgICAgfSk7XG4gICAgfSBjYXRjaCB7XG4gICAgICAvLyByZWNvbm5lY3Rpb24gZmFpbGVkLCBoYW5kbGVEaXNjb25uZWN0IGlzIGJlaW5nIGludm9rZWQgYWxyZWFkeSwganVzdCByZXR1cm4gaGVyZVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnNldEFuZEVtaXRDb25uZWN0aW9uU3RhdGUoQ29ubmVjdGlvblN0YXRlLkNvbm5lY3RlZCk7XG4gICAgdGhpcy5lbWl0KFJvb21FdmVudC5SZWNvbm5lY3RlZCk7XG4gICAgdGhpcy5yZWdpc3RlckNvbm5lY3Rpb25SZWNvbmNpbGUoKTtcbiAgICB0aGlzLmVtaXRCdWZmZXJlZEV2ZW50cygpO1xuICB9O1xuXG4gIHByaXZhdGUgaGFuZGxlRGlzY29ubmVjdChzaG91bGRTdG9wVHJhY2tzID0gdHJ1ZSwgcmVhc29uPzogRGlzY29ubmVjdFJlYXNvbikge1xuICAgIHRoaXMuY2xlYXJDb25uZWN0aW9uUmVjb25jaWxlKCk7XG4gICAgdGhpcy5idWZmZXJlZEV2ZW50cyA9IFtdO1xuICAgIGlmICh0aGlzLnN0YXRlID09PSBDb25uZWN0aW9uU3RhdGUuRGlzY29ubmVjdGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5yZWdpb25VcmwgPSB1bmRlZmluZWQ7XG5cbiAgICB0cnkge1xuICAgICAgdGhpcy5wYXJ0aWNpcGFudHMuZm9yRWFjaCgocCkgPT4ge1xuICAgICAgICBwLnRyYWNrcy5mb3JFYWNoKChwdWIpID0+IHtcbiAgICAgICAgICBwLnVucHVibGlzaFRyYWNrKHB1Yi50cmFja1NpZCk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIHRoaXMubG9jYWxQYXJ0aWNpcGFudC50cmFja3MuZm9yRWFjaCgocHViKSA9PiB7XG4gICAgICAgIGlmIChwdWIudHJhY2spIHtcbiAgICAgICAgICB0aGlzLmxvY2FsUGFydGljaXBhbnQudW5wdWJsaXNoVHJhY2socHViLnRyYWNrLCBzaG91bGRTdG9wVHJhY2tzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2hvdWxkU3RvcFRyYWNrcykge1xuICAgICAgICAgIHB1Yi50cmFjaz8uZGV0YWNoKCk7XG4gICAgICAgICAgcHViLnRyYWNrPy5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLmxvY2FsUGFydGljaXBhbnRcbiAgICAgICAgLm9mZihQYXJ0aWNpcGFudEV2ZW50LlBhcnRpY2lwYW50TWV0YWRhdGFDaGFuZ2VkLCB0aGlzLm9uTG9jYWxQYXJ0aWNpcGFudE1ldGFkYXRhQ2hhbmdlZClcbiAgICAgICAgLm9mZihQYXJ0aWNpcGFudEV2ZW50LlBhcnRpY2lwYW50TmFtZUNoYW5nZWQsIHRoaXMub25Mb2NhbFBhcnRpY2lwYW50TmFtZUNoYW5nZWQpXG4gICAgICAgIC5vZmYoUGFydGljaXBhbnRFdmVudC5UcmFja011dGVkLCB0aGlzLm9uTG9jYWxUcmFja011dGVkKVxuICAgICAgICAub2ZmKFBhcnRpY2lwYW50RXZlbnQuVHJhY2tVbm11dGVkLCB0aGlzLm9uTG9jYWxUcmFja1VubXV0ZWQpXG4gICAgICAgIC5vZmYoUGFydGljaXBhbnRFdmVudC5Mb2NhbFRyYWNrUHVibGlzaGVkLCB0aGlzLm9uTG9jYWxUcmFja1B1Ymxpc2hlZClcbiAgICAgICAgLm9mZihQYXJ0aWNpcGFudEV2ZW50LkxvY2FsVHJhY2tVbnB1Ymxpc2hlZCwgdGhpcy5vbkxvY2FsVHJhY2tVbnB1Ymxpc2hlZClcbiAgICAgICAgLm9mZihQYXJ0aWNpcGFudEV2ZW50LkNvbm5lY3Rpb25RdWFsaXR5Q2hhbmdlZCwgdGhpcy5vbkxvY2FsQ29ubmVjdGlvblF1YWxpdHlDaGFuZ2VkKVxuICAgICAgICAub2ZmKFBhcnRpY2lwYW50RXZlbnQuTWVkaWFEZXZpY2VzRXJyb3IsIHRoaXMub25NZWRpYURldmljZXNFcnJvcilcbiAgICAgICAgLm9mZihQYXJ0aWNpcGFudEV2ZW50LkF1ZGlvU3RyZWFtQWNxdWlyZWQsIHRoaXMuc3RhcnRBdWRpbylcbiAgICAgICAgLm9mZihcbiAgICAgICAgICBQYXJ0aWNpcGFudEV2ZW50LlBhcnRpY2lwYW50UGVybWlzc2lvbnNDaGFuZ2VkLFxuICAgICAgICAgIHRoaXMub25Mb2NhbFBhcnRpY2lwYW50UGVybWlzc2lvbnNDaGFuZ2VkLFxuICAgICAgICApO1xuXG4gICAgICB0aGlzLmxvY2FsUGFydGljaXBhbnQudHJhY2tzLmNsZWFyKCk7XG4gICAgICB0aGlzLmxvY2FsUGFydGljaXBhbnQudmlkZW9UcmFja3MuY2xlYXIoKTtcbiAgICAgIHRoaXMubG9jYWxQYXJ0aWNpcGFudC5hdWRpb1RyYWNrcy5jbGVhcigpO1xuXG4gICAgICB0aGlzLnBhcnRpY2lwYW50cy5jbGVhcigpO1xuICAgICAgdGhpcy5hY3RpdmVTcGVha2VycyA9IFtdO1xuICAgICAgaWYgKHRoaXMuYXVkaW9Db250ZXh0ICYmIHR5cGVvZiB0aGlzLm9wdGlvbnMuZXhwV2ViQXVkaW9NaXggPT09ICdib29sZWFuJykge1xuICAgICAgICB0aGlzLmF1ZGlvQ29udGV4dC5jbG9zZSgpO1xuICAgICAgICB0aGlzLmF1ZGlvQ29udGV4dCA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIGlmIChpc1dlYigpKSB7XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdiZWZvcmV1bmxvYWQnLCB0aGlzLm9uUGFnZUxlYXZlKTtcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3BhZ2VoaWRlJywgdGhpcy5vblBhZ2VMZWF2ZSk7XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdmcmVlemUnLCB0aGlzLm9uUGFnZUxlYXZlKTtcbiAgICAgICAgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcz8ucmVtb3ZlRXZlbnRMaXN0ZW5lcignZGV2aWNlY2hhbmdlJywgdGhpcy5oYW5kbGVEZXZpY2VDaGFuZ2UpO1xuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICB0aGlzLnNldEFuZEVtaXRDb25uZWN0aW9uU3RhdGUoQ29ubmVjdGlvblN0YXRlLkRpc2Nvbm5lY3RlZCk7XG4gICAgICB0aGlzLmVtaXQoUm9vbUV2ZW50LkRpc2Nvbm5lY3RlZCwgcmVhc29uKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGhhbmRsZVBhcnRpY2lwYW50VXBkYXRlcyA9IChwYXJ0aWNpcGFudEluZm9zOiBQYXJ0aWNpcGFudEluZm9bXSkgPT4ge1xuICAgIC8vIGhhbmRsZSBjaGFuZ2VzIHRvIHBhcnRpY2lwYW50IHN0YXRlLCBhbmQgc2VuZCBldmVudHNcbiAgICBwYXJ0aWNpcGFudEluZm9zLmZvckVhY2goKGluZm8pID0+IHtcbiAgICAgIGlmIChpbmZvLmlkZW50aXR5ID09PSB0aGlzLmxvY2FsUGFydGljaXBhbnQuaWRlbnRpdHkpIHtcbiAgICAgICAgdGhpcy5sb2NhbFBhcnRpY2lwYW50LnVwZGF0ZUluZm8oaW5mbyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gZW5zdXJlIGlkZW50aXR5IDw9PiBzaWQgbWFwcGluZ1xuICAgICAgY29uc3Qgc2lkID0gdGhpcy5pZGVudGl0eVRvU2lkLmdldChpbmZvLmlkZW50aXR5KTtcbiAgICAgIGlmIChzaWQgJiYgc2lkICE9PSBpbmZvLnNpZCkge1xuICAgICAgICAvLyBzaWQgaGFkIGNoYW5nZWQsIG5lZWQgdG8gcmVtb3ZlIHByZXZpb3VzIHBhcnRpY2lwYW50XG4gICAgICAgIHRoaXMuaGFuZGxlUGFydGljaXBhbnREaXNjb25uZWN0ZWQoc2lkLCB0aGlzLnBhcnRpY2lwYW50cy5nZXQoc2lkKSk7XG4gICAgICB9XG5cbiAgICAgIGxldCByZW1vdGVQYXJ0aWNpcGFudCA9IHRoaXMucGFydGljaXBhbnRzLmdldChpbmZvLnNpZCk7XG4gICAgICBjb25zdCBpc05ld1BhcnRpY2lwYW50ID0gIXJlbW90ZVBhcnRpY2lwYW50O1xuXG4gICAgICAvLyB3aGVuIGl0J3MgZGlzY29ubmVjdGVkLCBzZW5kIHVwZGF0ZXNcbiAgICAgIGlmIChpbmZvLnN0YXRlID09PSBQYXJ0aWNpcGFudEluZm9fU3RhdGUuRElTQ09OTkVDVEVEKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlUGFydGljaXBhbnREaXNjb25uZWN0ZWQoaW5mby5zaWQsIHJlbW90ZVBhcnRpY2lwYW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGNyZWF0ZSBwYXJ0aWNpcGFudCBpZiBkb2Vzbid0IGV4aXN0XG4gICAgICAgIHJlbW90ZVBhcnRpY2lwYW50ID0gdGhpcy5nZXRPckNyZWF0ZVBhcnRpY2lwYW50KGluZm8uc2lkLCBpbmZvKTtcbiAgICAgICAgaWYgKCFpc05ld1BhcnRpY2lwYW50KSB7XG4gICAgICAgICAgLy8ganVzdCB1cGRhdGUsIG5vIGV2ZW50c1xuICAgICAgICAgIHJlbW90ZVBhcnRpY2lwYW50LnVwZGF0ZUluZm8oaW5mbyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICBwcml2YXRlIGhhbmRsZVBhcnRpY2lwYW50RGlzY29ubmVjdGVkKHNpZDogc3RyaW5nLCBwYXJ0aWNpcGFudD86IFJlbW90ZVBhcnRpY2lwYW50KSB7XG4gICAgLy8gcmVtb3ZlIGFuZCBzZW5kIGV2ZW50XG4gICAgdGhpcy5wYXJ0aWNpcGFudHMuZGVsZXRlKHNpZCk7XG4gICAgaWYgKCFwYXJ0aWNpcGFudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuaWRlbnRpdHlUb1NpZC5kZWxldGUocGFydGljaXBhbnQuaWRlbnRpdHkpO1xuICAgIHBhcnRpY2lwYW50LnRyYWNrcy5mb3JFYWNoKChwdWJsaWNhdGlvbikgPT4ge1xuICAgICAgcGFydGljaXBhbnQudW5wdWJsaXNoVHJhY2socHVibGljYXRpb24udHJhY2tTaWQsIHRydWUpO1xuICAgIH0pO1xuICAgIHRoaXMuZW1pdChSb29tRXZlbnQuUGFydGljaXBhbnREaXNjb25uZWN0ZWQsIHBhcnRpY2lwYW50KTtcbiAgfVxuXG4gIC8vIHVwZGF0ZXMgYXJlIHNlbnQgb25seSB3aGVuIHRoZXJlJ3MgYSBjaGFuZ2UgdG8gc3BlYWtlciBvcmRlcmluZ1xuICBwcml2YXRlIGhhbmRsZUFjdGl2ZVNwZWFrZXJzVXBkYXRlID0gKHNwZWFrZXJzOiBTcGVha2VySW5mb1tdKSA9PiB7XG4gICAgY29uc3QgYWN0aXZlU3BlYWtlcnM6IFBhcnRpY2lwYW50W10gPSBbXTtcbiAgICBjb25zdCBzZWVuU2lkczogYW55ID0ge307XG4gICAgc3BlYWtlcnMuZm9yRWFjaCgoc3BlYWtlcikgPT4ge1xuICAgICAgc2VlblNpZHNbc3BlYWtlci5zaWRdID0gdHJ1ZTtcbiAgICAgIGlmIChzcGVha2VyLnNpZCA9PT0gdGhpcy5sb2NhbFBhcnRpY2lwYW50LnNpZCkge1xuICAgICAgICB0aGlzLmxvY2FsUGFydGljaXBhbnQuYXVkaW9MZXZlbCA9IHNwZWFrZXIubGV2ZWw7XG4gICAgICAgIHRoaXMubG9jYWxQYXJ0aWNpcGFudC5zZXRJc1NwZWFraW5nKHRydWUpO1xuICAgICAgICBhY3RpdmVTcGVha2Vycy5wdXNoKHRoaXMubG9jYWxQYXJ0aWNpcGFudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBwID0gdGhpcy5wYXJ0aWNpcGFudHMuZ2V0KHNwZWFrZXIuc2lkKTtcbiAgICAgICAgaWYgKHApIHtcbiAgICAgICAgICBwLmF1ZGlvTGV2ZWwgPSBzcGVha2VyLmxldmVsO1xuICAgICAgICAgIHAuc2V0SXNTcGVha2luZyh0cnVlKTtcbiAgICAgICAgICBhY3RpdmVTcGVha2Vycy5wdXNoKHApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAoIXNlZW5TaWRzW3RoaXMubG9jYWxQYXJ0aWNpcGFudC5zaWRdKSB7XG4gICAgICB0aGlzLmxvY2FsUGFydGljaXBhbnQuYXVkaW9MZXZlbCA9IDA7XG4gICAgICB0aGlzLmxvY2FsUGFydGljaXBhbnQuc2V0SXNTcGVha2luZyhmYWxzZSk7XG4gICAgfVxuICAgIHRoaXMucGFydGljaXBhbnRzLmZvckVhY2goKHApID0+IHtcbiAgICAgIGlmICghc2VlblNpZHNbcC5zaWRdKSB7XG4gICAgICAgIHAuYXVkaW9MZXZlbCA9IDA7XG4gICAgICAgIHAuc2V0SXNTcGVha2luZyhmYWxzZSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0aGlzLmFjdGl2ZVNwZWFrZXJzID0gYWN0aXZlU3BlYWtlcnM7XG4gICAgdGhpcy5lbWl0V2hlbkNvbm5lY3RlZChSb29tRXZlbnQuQWN0aXZlU3BlYWtlcnNDaGFuZ2VkLCBhY3RpdmVTcGVha2Vycyk7XG4gIH07XG5cbiAgLy8gcHJvY2VzcyBsaXN0IG9mIGNoYW5nZWQgc3BlYWtlcnNcbiAgcHJpdmF0ZSBoYW5kbGVTcGVha2Vyc0NoYW5nZWQgPSAoc3BlYWtlclVwZGF0ZXM6IFNwZWFrZXJJbmZvW10pID0+IHtcbiAgICBjb25zdCBsYXN0U3BlYWtlcnMgPSBuZXcgTWFwPHN0cmluZywgUGFydGljaXBhbnQ+KCk7XG4gICAgdGhpcy5hY3RpdmVTcGVha2Vycy5mb3JFYWNoKChwKSA9PiB7XG4gICAgICBsYXN0U3BlYWtlcnMuc2V0KHAuc2lkLCBwKTtcbiAgICB9KTtcbiAgICBzcGVha2VyVXBkYXRlcy5mb3JFYWNoKChzcGVha2VyKSA9PiB7XG4gICAgICBsZXQgcDogUGFydGljaXBhbnQgfCB1bmRlZmluZWQgPSB0aGlzLnBhcnRpY2lwYW50cy5nZXQoc3BlYWtlci5zaWQpO1xuICAgICAgaWYgKHNwZWFrZXIuc2lkID09PSB0aGlzLmxvY2FsUGFydGljaXBhbnQuc2lkKSB7XG4gICAgICAgIHAgPSB0aGlzLmxvY2FsUGFydGljaXBhbnQ7XG4gICAgICB9XG4gICAgICBpZiAoIXApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcC5hdWRpb0xldmVsID0gc3BlYWtlci5sZXZlbDtcbiAgICAgIHAuc2V0SXNTcGVha2luZyhzcGVha2VyLmFjdGl2ZSk7XG5cbiAgICAgIGlmIChzcGVha2VyLmFjdGl2ZSkge1xuICAgICAgICBsYXN0U3BlYWtlcnMuc2V0KHNwZWFrZXIuc2lkLCBwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxhc3RTcGVha2Vycy5kZWxldGUoc3BlYWtlci5zaWQpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IGFjdGl2ZVNwZWFrZXJzID0gQXJyYXkuZnJvbShsYXN0U3BlYWtlcnMudmFsdWVzKCkpO1xuICAgIGFjdGl2ZVNwZWFrZXJzLnNvcnQoKGEsIGIpID0+IGIuYXVkaW9MZXZlbCAtIGEuYXVkaW9MZXZlbCk7XG4gICAgdGhpcy5hY3RpdmVTcGVha2VycyA9IGFjdGl2ZVNwZWFrZXJzO1xuICAgIHRoaXMuZW1pdFdoZW5Db25uZWN0ZWQoUm9vbUV2ZW50LkFjdGl2ZVNwZWFrZXJzQ2hhbmdlZCwgYWN0aXZlU3BlYWtlcnMpO1xuICB9O1xuXG4gIHByaXZhdGUgaGFuZGxlU3RyZWFtU3RhdGVVcGRhdGUgPSAoc3RyZWFtU3RhdGVVcGRhdGU6IFN0cmVhbVN0YXRlVXBkYXRlKSA9PiB7XG4gICAgc3RyZWFtU3RhdGVVcGRhdGUuc3RyZWFtU3RhdGVzLmZvckVhY2goKHN0cmVhbVN0YXRlKSA9PiB7XG4gICAgICBjb25zdCBwYXJ0aWNpcGFudCA9IHRoaXMucGFydGljaXBhbnRzLmdldChzdHJlYW1TdGF0ZS5wYXJ0aWNpcGFudFNpZCk7XG4gICAgICBpZiAoIXBhcnRpY2lwYW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHB1YiA9IHBhcnRpY2lwYW50LmdldFRyYWNrUHVibGljYXRpb24oc3RyZWFtU3RhdGUudHJhY2tTaWQpO1xuICAgICAgaWYgKCFwdWIgfHwgIXB1Yi50cmFjaykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBwdWIudHJhY2suc3RyZWFtU3RhdGUgPSBUcmFjay5zdHJlYW1TdGF0ZUZyb21Qcm90byhzdHJlYW1TdGF0ZS5zdGF0ZSk7XG4gICAgICBwYXJ0aWNpcGFudC5lbWl0KFBhcnRpY2lwYW50RXZlbnQuVHJhY2tTdHJlYW1TdGF0ZUNoYW5nZWQsIHB1YiwgcHViLnRyYWNrLnN0cmVhbVN0YXRlKTtcbiAgICAgIHRoaXMuZW1pdFdoZW5Db25uZWN0ZWQoXG4gICAgICAgIFJvb21FdmVudC5UcmFja1N0cmVhbVN0YXRlQ2hhbmdlZCxcbiAgICAgICAgcHViLFxuICAgICAgICBwdWIudHJhY2suc3RyZWFtU3RhdGUsXG4gICAgICAgIHBhcnRpY2lwYW50LFxuICAgICAgKTtcbiAgICB9KTtcbiAgfTtcblxuICBwcml2YXRlIGhhbmRsZVN1YnNjcmlwdGlvblBlcm1pc3Npb25VcGRhdGUgPSAodXBkYXRlOiBTdWJzY3JpcHRpb25QZXJtaXNzaW9uVXBkYXRlKSA9PiB7XG4gICAgY29uc3QgcGFydGljaXBhbnQgPSB0aGlzLnBhcnRpY2lwYW50cy5nZXQodXBkYXRlLnBhcnRpY2lwYW50U2lkKTtcbiAgICBpZiAoIXBhcnRpY2lwYW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHB1YiA9IHBhcnRpY2lwYW50LmdldFRyYWNrUHVibGljYXRpb24odXBkYXRlLnRyYWNrU2lkKTtcbiAgICBpZiAoIXB1Yikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHB1Yi5zZXRBbGxvd2VkKHVwZGF0ZS5hbGxvd2VkKTtcbiAgfTtcblxuICBwcml2YXRlIGhhbmRsZVN1YnNjcmlwdGlvbkVycm9yID0gKHVwZGF0ZTogU3Vic2NyaXB0aW9uUmVzcG9uc2UpID0+IHtcbiAgICBjb25zdCBwYXJ0aWNpcGFudCA9IEFycmF5LmZyb20odGhpcy5wYXJ0aWNpcGFudHMudmFsdWVzKCkpLmZpbmQoKHApID0+XG4gICAgICBwLnRyYWNrcy5oYXModXBkYXRlLnRyYWNrU2lkKSxcbiAgICApO1xuICAgIGlmICghcGFydGljaXBhbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgcHViID0gcGFydGljaXBhbnQuZ2V0VHJhY2tQdWJsaWNhdGlvbih1cGRhdGUudHJhY2tTaWQpO1xuICAgIGlmICghcHViKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcHViLnNldFN1YnNjcmlwdGlvbkVycm9yKHVwZGF0ZS5lcnIpO1xuICB9O1xuXG4gIHByaXZhdGUgaGFuZGxlRGF0YVBhY2tldCA9ICh1c2VyUGFja2V0OiBVc2VyUGFja2V0LCBraW5kOiBEYXRhUGFja2V0X0tpbmQpID0+IHtcbiAgICAvLyBmaW5kIHRoZSBwYXJ0aWNpcGFudFxuICAgIGNvbnN0IHBhcnRpY2lwYW50ID0gdGhpcy5wYXJ0aWNpcGFudHMuZ2V0KHVzZXJQYWNrZXQucGFydGljaXBhbnRTaWQpO1xuXG4gICAgdGhpcy5lbWl0KFJvb21FdmVudC5EYXRhUmVjZWl2ZWQsIHVzZXJQYWNrZXQucGF5bG9hZCwgcGFydGljaXBhbnQsIGtpbmQsIHVzZXJQYWNrZXQudG9waWMpO1xuXG4gICAgLy8gYWxzbyBlbWl0IG9uIHRoZSBwYXJ0aWNpcGFudFxuICAgIHBhcnRpY2lwYW50Py5lbWl0KFBhcnRpY2lwYW50RXZlbnQuRGF0YVJlY2VpdmVkLCB1c2VyUGFja2V0LnBheWxvYWQsIGtpbmQpO1xuICB9O1xuXG4gIHByaXZhdGUgaGFuZGxlQXVkaW9QbGF5YmFja1N0YXJ0ZWQgPSAoKSA9PiB7XG4gICAgaWYgKHRoaXMuY2FuUGxheWJhY2tBdWRpbykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmF1ZGlvRW5hYmxlZCA9IHRydWU7XG4gICAgdGhpcy5lbWl0KFJvb21FdmVudC5BdWRpb1BsYXliYWNrU3RhdHVzQ2hhbmdlZCwgdHJ1ZSk7XG4gIH07XG5cbiAgcHJpdmF0ZSBoYW5kbGVBdWRpb1BsYXliYWNrRmFpbGVkID0gKGU6IGFueSkgPT4ge1xuICAgIHRoaXMubG9nLndhcm4oJ2NvdWxkIG5vdCBwbGF5YmFjayBhdWRpbycsIHsgLi4udGhpcy5sb2dDb250ZXh0LCBlcnJvcjogZSB9KTtcbiAgICBpZiAoIXRoaXMuY2FuUGxheWJhY2tBdWRpbykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmF1ZGlvRW5hYmxlZCA9IGZhbHNlO1xuICAgIHRoaXMuZW1pdChSb29tRXZlbnQuQXVkaW9QbGF5YmFja1N0YXR1c0NoYW5nZWQsIGZhbHNlKTtcbiAgfTtcblxuICBwcml2YXRlIGhhbmRsZVZpZGVvUGxheWJhY2tTdGFydGVkID0gKCkgPT4ge1xuICAgIGlmICh0aGlzLmlzVmlkZW9QbGF5YmFja0Jsb2NrZWQpIHtcbiAgICAgIHRoaXMuaXNWaWRlb1BsYXliYWNrQmxvY2tlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5lbWl0KFJvb21FdmVudC5WaWRlb1BsYXliYWNrU3RhdHVzQ2hhbmdlZCwgdHJ1ZSk7XG4gICAgfVxuICB9O1xuXG4gIHByaXZhdGUgaGFuZGxlVmlkZW9QbGF5YmFja0ZhaWxlZCA9ICgpID0+IHtcbiAgICBpZiAoIXRoaXMuaXNWaWRlb1BsYXliYWNrQmxvY2tlZCkge1xuICAgICAgdGhpcy5pc1ZpZGVvUGxheWJhY2tCbG9ja2VkID0gdHJ1ZTtcbiAgICAgIHRoaXMuZW1pdChSb29tRXZlbnQuVmlkZW9QbGF5YmFja1N0YXR1c0NoYW5nZWQsIGZhbHNlKTtcbiAgICB9XG4gIH07XG5cbiAgcHJpdmF0ZSBoYW5kbGVEZXZpY2VDaGFuZ2UgPSBhc3luYyAoKSA9PiB7XG4gICAgdGhpcy5lbWl0KFJvb21FdmVudC5NZWRpYURldmljZXNDaGFuZ2VkKTtcbiAgfTtcblxuICBwcml2YXRlIGhhbmRsZVJvb21VcGRhdGUgPSAocm9vbTogUm9vbU1vZGVsKSA9PiB7XG4gICAgY29uc3Qgb2xkUm9vbSA9IHRoaXMucm9vbUluZm87XG4gICAgdGhpcy5yb29tSW5mbyA9IHJvb207XG4gICAgaWYgKG9sZFJvb20gJiYgb2xkUm9vbS5tZXRhZGF0YSAhPT0gcm9vbS5tZXRhZGF0YSkge1xuICAgICAgdGhpcy5lbWl0V2hlbkNvbm5lY3RlZChSb29tRXZlbnQuUm9vbU1ldGFkYXRhQ2hhbmdlZCwgcm9vbS5tZXRhZGF0YSk7XG4gICAgfVxuICAgIGlmIChvbGRSb29tPy5hY3RpdmVSZWNvcmRpbmcgIT09IHJvb20uYWN0aXZlUmVjb3JkaW5nKSB7XG4gICAgICB0aGlzLmVtaXRXaGVuQ29ubmVjdGVkKFJvb21FdmVudC5SZWNvcmRpbmdTdGF0dXNDaGFuZ2VkLCByb29tLmFjdGl2ZVJlY29yZGluZyk7XG4gICAgfVxuICB9O1xuXG4gIHByaXZhdGUgaGFuZGxlQ29ubmVjdGlvblF1YWxpdHlVcGRhdGUgPSAodXBkYXRlOiBDb25uZWN0aW9uUXVhbGl0eVVwZGF0ZSkgPT4ge1xuICAgIHVwZGF0ZS51cGRhdGVzLmZvckVhY2goKGluZm8pID0+IHtcbiAgICAgIGlmIChpbmZvLnBhcnRpY2lwYW50U2lkID09PSB0aGlzLmxvY2FsUGFydGljaXBhbnQuc2lkKSB7XG4gICAgICAgIHRoaXMubG9jYWxQYXJ0aWNpcGFudC5zZXRDb25uZWN0aW9uUXVhbGl0eShpbmZvLnF1YWxpdHkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBwYXJ0aWNpcGFudCA9IHRoaXMucGFydGljaXBhbnRzLmdldChpbmZvLnBhcnRpY2lwYW50U2lkKTtcbiAgICAgIGlmIChwYXJ0aWNpcGFudCkge1xuICAgICAgICBwYXJ0aWNpcGFudC5zZXRDb25uZWN0aW9uUXVhbGl0eShpbmZvLnF1YWxpdHkpO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIHByaXZhdGUgYXN5bmMgYWNxdWlyZUF1ZGlvQ29udGV4dCgpIHtcbiAgICBpZiAoXG4gICAgICB0eXBlb2YgdGhpcy5vcHRpb25zLmV4cFdlYkF1ZGlvTWl4ICE9PSAnYm9vbGVhbicgJiZcbiAgICAgIHRoaXMub3B0aW9ucy5leHBXZWJBdWRpb01peC5hdWRpb0NvbnRleHRcbiAgICApIHtcbiAgICAgIC8vIG92ZXJyaWRlIGF1ZGlvIGNvbnRleHQgd2l0aCBjdXN0b20gYXVkaW8gY29udGV4dCBpZiBzdXBwbGllZCBieSB1c2VyXG4gICAgICB0aGlzLmF1ZGlvQ29udGV4dCA9IHRoaXMub3B0aW9ucy5leHBXZWJBdWRpb01peC5hdWRpb0NvbnRleHQ7XG4gICAgfSBlbHNlIGlmICghdGhpcy5hdWRpb0NvbnRleHQgfHwgdGhpcy5hdWRpb0NvbnRleHQuc3RhdGUgPT09ICdjbG9zZWQnKSB7XG4gICAgICAvLyBieSB1c2luZyBhbiBBdWRpb0NvbnRleHQsIGl0IHJlZHVjZXMgbGFnIG9uIGF1ZGlvIGVsZW1lbnRzXG4gICAgICAvLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy85ODExNDI5L2h0bWw1LWF1ZGlvLXRhZy1vbi1zYWZhcmktaGFzLWEtZGVsYXkvNTQxMTk4NTQjNTQxMTk4NTRcbiAgICAgIHRoaXMuYXVkaW9Db250ZXh0ID0gZ2V0TmV3QXVkaW9Db250ZXh0KCkgPz8gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmF1ZGlvQ29udGV4dCAmJiB0aGlzLmF1ZGlvQ29udGV4dC5zdGF0ZSA9PT0gJ3N1c3BlbmRlZCcpIHtcbiAgICAgIC8vIGZvciBpT1MgYSBuZXdseSBjcmVhdGVkIEF1ZGlvQ29udGV4dCBpcyBhbHdheXMgaW4gYHN1c3BlbmRlZGAgc3RhdGUuXG4gICAgICAvLyB3ZSB0cnkgb3VyIGJlc3QgdG8gcmVzdW1lIHRoZSBjb250ZXh0IGhlcmUsIGlmIHRoYXQgZG9lc24ndCB3b3JrLCB3ZSBqdXN0IGNvbnRpbnVlIHdpdGggcmVndWxhciBwcm9jZXNzaW5nXG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCB0aGlzLmF1ZGlvQ29udGV4dC5yZXN1bWUoKTtcbiAgICAgIH0gY2F0Y2ggKGU6IGFueSkge1xuICAgICAgICB0aGlzLmxvZy53YXJuKCdDb3VsZCBub3QgcmVzdW1lIGF1ZGlvIGNvbnRleHQnLCB7IC4uLnRoaXMubG9nQ29udGV4dCwgZXJyb3I6IGUgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5leHBXZWJBdWRpb01peCkge1xuICAgICAgdGhpcy5wYXJ0aWNpcGFudHMuZm9yRWFjaCgocGFydGljaXBhbnQpID0+IHBhcnRpY2lwYW50LnNldEF1ZGlvQ29udGV4dCh0aGlzLmF1ZGlvQ29udGV4dCkpO1xuICAgIH1cblxuICAgIHRoaXMubG9jYWxQYXJ0aWNpcGFudC5zZXRBdWRpb0NvbnRleHQodGhpcy5hdWRpb0NvbnRleHQpO1xuXG4gICAgY29uc3QgbmV3Q29udGV4dElzUnVubmluZyA9IHRoaXMuYXVkaW9Db250ZXh0Py5zdGF0ZSA9PT0gJ3J1bm5pbmcnO1xuICAgIGlmIChuZXdDb250ZXh0SXNSdW5uaW5nICE9PSB0aGlzLmNhblBsYXliYWNrQXVkaW8pIHtcbiAgICAgIHRoaXMuYXVkaW9FbmFibGVkID0gbmV3Q29udGV4dElzUnVubmluZztcbiAgICAgIHRoaXMuZW1pdChSb29tRXZlbnQuQXVkaW9QbGF5YmFja1N0YXR1c0NoYW5nZWQsIG5ld0NvbnRleHRJc1J1bm5pbmcpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgY3JlYXRlUGFydGljaXBhbnQoaWQ6IHN0cmluZywgaW5mbz86IFBhcnRpY2lwYW50SW5mbyk6IFJlbW90ZVBhcnRpY2lwYW50IHtcbiAgICBsZXQgcGFydGljaXBhbnQ6IFJlbW90ZVBhcnRpY2lwYW50O1xuICAgIGlmIChpbmZvKSB7XG4gICAgICBwYXJ0aWNpcGFudCA9IFJlbW90ZVBhcnRpY2lwYW50LmZyb21QYXJ0aWNpcGFudEluZm8odGhpcy5lbmdpbmUuY2xpZW50LCBpbmZvKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGFydGljaXBhbnQgPSBuZXcgUmVtb3RlUGFydGljaXBhbnQodGhpcy5lbmdpbmUuY2xpZW50LCBpZCwgJycsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB7XG4gICAgICAgIGxvZ2dlckNvbnRleHRDYjogKCkgPT4gdGhpcy5sb2dDb250ZXh0LFxuICAgICAgICBsb2dnZXJOYW1lOiB0aGlzLm9wdGlvbnMubG9nZ2VyTmFtZSxcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLmV4cFdlYkF1ZGlvTWl4KSB7XG4gICAgICBwYXJ0aWNpcGFudC5zZXRBdWRpb0NvbnRleHQodGhpcy5hdWRpb0NvbnRleHQpO1xuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLmF1ZGlvT3V0cHV0Py5kZXZpY2VJZCkge1xuICAgICAgcGFydGljaXBhbnRcbiAgICAgICAgLnNldEF1ZGlvT3V0cHV0KHRoaXMub3B0aW9ucy5hdWRpb091dHB1dClcbiAgICAgICAgLmNhdGNoKChlKSA9PiB0aGlzLmxvZy53YXJuKGBDb3VsZCBub3Qgc2V0IGF1ZGlvIG91dHB1dDogJHtlLm1lc3NhZ2V9YCwgdGhpcy5sb2dDb250ZXh0KSk7XG4gICAgfVxuICAgIHJldHVybiBwYXJ0aWNpcGFudDtcbiAgfVxuXG4gIHByaXZhdGUgZ2V0T3JDcmVhdGVQYXJ0aWNpcGFudChpZDogc3RyaW5nLCBpbmZvOiBQYXJ0aWNpcGFudEluZm8pOiBSZW1vdGVQYXJ0aWNpcGFudCB7XG4gICAgaWYgKHRoaXMucGFydGljaXBhbnRzLmhhcyhpZCkpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcnRpY2lwYW50cy5nZXQoaWQpIGFzIFJlbW90ZVBhcnRpY2lwYW50O1xuICAgIH1cbiAgICBjb25zdCBwYXJ0aWNpcGFudCA9IHRoaXMuY3JlYXRlUGFydGljaXBhbnQoaWQsIGluZm8pO1xuICAgIHRoaXMucGFydGljaXBhbnRzLnNldChpZCwgcGFydGljaXBhbnQpO1xuXG4gICAgdGhpcy5pZGVudGl0eVRvU2lkLnNldChpbmZvLmlkZW50aXR5LCBpbmZvLnNpZCk7XG4gICAgLy8gaWYgd2UgaGF2ZSB2YWxpZCBpbmZvIGFuZCB0aGUgcGFydGljaXBhbnQgd2Fzbid0IGluIHRoZSBtYXAgYmVmb3JlLCB3ZSBjYW4gYXNzdW1lIHRoZSBwYXJ0aWNpcGFudCBpcyBuZXdcbiAgICAvLyBmaXJpbmcgaGVyZSB0byBtYWtlIHN1cmUgdGhhdCBgUGFydGljaXBhbnRDb25uZWN0ZWRgIGZpcmVzIGJlZm9yZSB0aGUgaW5pdGlhbCB0cmFjayBldmVudHNcbiAgICB0aGlzLmVtaXRXaGVuQ29ubmVjdGVkKFJvb21FdmVudC5QYXJ0aWNpcGFudENvbm5lY3RlZCwgcGFydGljaXBhbnQpO1xuXG4gICAgLy8gYWxzbyBmb3J3YXJkIGV2ZW50c1xuICAgIC8vIHRyYWNrUHVibGlzaGVkIGlzIG9ubHkgZmlyZWQgZm9yIHRyYWNrcyBhZGRlZCBhZnRlciBib3RoIGxvY2FsIHBhcnRpY2lwYW50XG4gICAgLy8gYW5kIHJlbW90ZSBwYXJ0aWNpcGFudCBqb2luZWQgdGhlIHJvb21cbiAgICBwYXJ0aWNpcGFudFxuICAgICAgLm9uKFBhcnRpY2lwYW50RXZlbnQuVHJhY2tQdWJsaXNoZWQsICh0cmFja1B1YmxpY2F0aW9uOiBSZW1vdGVUcmFja1B1YmxpY2F0aW9uKSA9PiB7XG4gICAgICAgIHRoaXMuZW1pdFdoZW5Db25uZWN0ZWQoUm9vbUV2ZW50LlRyYWNrUHVibGlzaGVkLCB0cmFja1B1YmxpY2F0aW9uLCBwYXJ0aWNpcGFudCk7XG4gICAgICB9KVxuICAgICAgLm9uKFxuICAgICAgICBQYXJ0aWNpcGFudEV2ZW50LlRyYWNrU3Vic2NyaWJlZCxcbiAgICAgICAgKHRyYWNrOiBSZW1vdGVUcmFjaywgcHVibGljYXRpb246IFJlbW90ZVRyYWNrUHVibGljYXRpb24pID0+IHtcbiAgICAgICAgICAvLyBtb25pdG9yIHBsYXliYWNrIHN0YXR1c1xuICAgICAgICAgIGlmICh0cmFjay5raW5kID09PSBUcmFjay5LaW5kLkF1ZGlvKSB7XG4gICAgICAgICAgICB0cmFjay5vbihUcmFja0V2ZW50LkF1ZGlvUGxheWJhY2tTdGFydGVkLCB0aGlzLmhhbmRsZUF1ZGlvUGxheWJhY2tTdGFydGVkKTtcbiAgICAgICAgICAgIHRyYWNrLm9uKFRyYWNrRXZlbnQuQXVkaW9QbGF5YmFja0ZhaWxlZCwgdGhpcy5oYW5kbGVBdWRpb1BsYXliYWNrRmFpbGVkKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRyYWNrLmtpbmQgPT09IFRyYWNrLktpbmQuVmlkZW8pIHtcbiAgICAgICAgICAgIHRyYWNrLm9uKFRyYWNrRXZlbnQuVmlkZW9QbGF5YmFja0ZhaWxlZCwgdGhpcy5oYW5kbGVWaWRlb1BsYXliYWNrRmFpbGVkKTtcbiAgICAgICAgICAgIHRyYWNrLm9uKFRyYWNrRXZlbnQuVmlkZW9QbGF5YmFja1N0YXJ0ZWQsIHRoaXMuaGFuZGxlVmlkZW9QbGF5YmFja1N0YXJ0ZWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmVtaXQoUm9vbUV2ZW50LlRyYWNrU3Vic2NyaWJlZCwgdHJhY2ssIHB1YmxpY2F0aW9uLCBwYXJ0aWNpcGFudCk7XG4gICAgICAgIH0sXG4gICAgICApXG4gICAgICAub24oUGFydGljaXBhbnRFdmVudC5UcmFja1VucHVibGlzaGVkLCAocHVibGljYXRpb246IFJlbW90ZVRyYWNrUHVibGljYXRpb24pID0+IHtcbiAgICAgICAgdGhpcy5lbWl0KFJvb21FdmVudC5UcmFja1VucHVibGlzaGVkLCBwdWJsaWNhdGlvbiwgcGFydGljaXBhbnQpO1xuICAgICAgfSlcbiAgICAgIC5vbihcbiAgICAgICAgUGFydGljaXBhbnRFdmVudC5UcmFja1Vuc3Vic2NyaWJlZCxcbiAgICAgICAgKHRyYWNrOiBSZW1vdGVUcmFjaywgcHVibGljYXRpb246IFJlbW90ZVRyYWNrUHVibGljYXRpb24pID0+IHtcbiAgICAgICAgICB0aGlzLmVtaXQoUm9vbUV2ZW50LlRyYWNrVW5zdWJzY3JpYmVkLCB0cmFjaywgcHVibGljYXRpb24sIHBhcnRpY2lwYW50KTtcbiAgICAgICAgfSxcbiAgICAgIClcbiAgICAgIC5vbihQYXJ0aWNpcGFudEV2ZW50LlRyYWNrU3Vic2NyaXB0aW9uRmFpbGVkLCAoc2lkOiBzdHJpbmcpID0+IHtcbiAgICAgICAgdGhpcy5lbWl0KFJvb21FdmVudC5UcmFja1N1YnNjcmlwdGlvbkZhaWxlZCwgc2lkLCBwYXJ0aWNpcGFudCk7XG4gICAgICB9KVxuICAgICAgLm9uKFBhcnRpY2lwYW50RXZlbnQuVHJhY2tNdXRlZCwgKHB1YjogVHJhY2tQdWJsaWNhdGlvbikgPT4ge1xuICAgICAgICB0aGlzLmVtaXRXaGVuQ29ubmVjdGVkKFJvb21FdmVudC5UcmFja011dGVkLCBwdWIsIHBhcnRpY2lwYW50KTtcbiAgICAgIH0pXG4gICAgICAub24oUGFydGljaXBhbnRFdmVudC5UcmFja1VubXV0ZWQsIChwdWI6IFRyYWNrUHVibGljYXRpb24pID0+IHtcbiAgICAgICAgdGhpcy5lbWl0V2hlbkNvbm5lY3RlZChSb29tRXZlbnQuVHJhY2tVbm11dGVkLCBwdWIsIHBhcnRpY2lwYW50KTtcbiAgICAgIH0pXG4gICAgICAub24oUGFydGljaXBhbnRFdmVudC5QYXJ0aWNpcGFudE1ldGFkYXRhQ2hhbmdlZCwgKG1ldGFkYXRhOiBzdHJpbmcgfCB1bmRlZmluZWQpID0+IHtcbiAgICAgICAgdGhpcy5lbWl0V2hlbkNvbm5lY3RlZChSb29tRXZlbnQuUGFydGljaXBhbnRNZXRhZGF0YUNoYW5nZWQsIG1ldGFkYXRhLCBwYXJ0aWNpcGFudCk7XG4gICAgICB9KVxuICAgICAgLm9uKFBhcnRpY2lwYW50RXZlbnQuUGFydGljaXBhbnROYW1lQ2hhbmdlZCwgKG5hbWUpID0+IHtcbiAgICAgICAgdGhpcy5lbWl0V2hlbkNvbm5lY3RlZChSb29tRXZlbnQuUGFydGljaXBhbnROYW1lQ2hhbmdlZCwgbmFtZSwgcGFydGljaXBhbnQpO1xuICAgICAgfSlcbiAgICAgIC5vbihQYXJ0aWNpcGFudEV2ZW50LkNvbm5lY3Rpb25RdWFsaXR5Q2hhbmdlZCwgKHF1YWxpdHk6IENvbm5lY3Rpb25RdWFsaXR5KSA9PiB7XG4gICAgICAgIHRoaXMuZW1pdFdoZW5Db25uZWN0ZWQoUm9vbUV2ZW50LkNvbm5lY3Rpb25RdWFsaXR5Q2hhbmdlZCwgcXVhbGl0eSwgcGFydGljaXBhbnQpO1xuICAgICAgfSlcbiAgICAgIC5vbihcbiAgICAgICAgUGFydGljaXBhbnRFdmVudC5QYXJ0aWNpcGFudFBlcm1pc3Npb25zQ2hhbmdlZCxcbiAgICAgICAgKHByZXZQZXJtaXNzaW9ucz86IFBhcnRpY2lwYW50UGVybWlzc2lvbikgPT4ge1xuICAgICAgICAgIHRoaXMuZW1pdFdoZW5Db25uZWN0ZWQoXG4gICAgICAgICAgICBSb29tRXZlbnQuUGFydGljaXBhbnRQZXJtaXNzaW9uc0NoYW5nZWQsXG4gICAgICAgICAgICBwcmV2UGVybWlzc2lvbnMsXG4gICAgICAgICAgICBwYXJ0aWNpcGFudCxcbiAgICAgICAgICApO1xuICAgICAgICB9LFxuICAgICAgKVxuICAgICAgLm9uKFBhcnRpY2lwYW50RXZlbnQuVHJhY2tTdWJzY3JpcHRpb25TdGF0dXNDaGFuZ2VkLCAocHViLCBzdGF0dXMpID0+IHtcbiAgICAgICAgdGhpcy5lbWl0V2hlbkNvbm5lY3RlZChSb29tRXZlbnQuVHJhY2tTdWJzY3JpcHRpb25TdGF0dXNDaGFuZ2VkLCBwdWIsIHN0YXR1cywgcGFydGljaXBhbnQpO1xuICAgICAgfSlcbiAgICAgIC5vbihQYXJ0aWNpcGFudEV2ZW50LlRyYWNrU3Vic2NyaXB0aW9uRmFpbGVkLCAodHJhY2tTaWQsIGVycm9yKSA9PiB7XG4gICAgICAgIHRoaXMuZW1pdChSb29tRXZlbnQuVHJhY2tTdWJzY3JpcHRpb25GYWlsZWQsIHRyYWNrU2lkLCBwYXJ0aWNpcGFudCwgZXJyb3IpO1xuICAgICAgfSlcbiAgICAgIC5vbihQYXJ0aWNpcGFudEV2ZW50LlRyYWNrU3Vic2NyaXB0aW9uUGVybWlzc2lvbkNoYW5nZWQsIChwdWIsIHN0YXR1cykgPT4ge1xuICAgICAgICB0aGlzLmVtaXRXaGVuQ29ubmVjdGVkKFxuICAgICAgICAgIFJvb21FdmVudC5UcmFja1N1YnNjcmlwdGlvblBlcm1pc3Npb25DaGFuZ2VkLFxuICAgICAgICAgIHB1YixcbiAgICAgICAgICBzdGF0dXMsXG4gICAgICAgICAgcGFydGljaXBhbnQsXG4gICAgICAgICk7XG4gICAgICB9KTtcblxuICAgIC8vIHVwZGF0ZSBpbmZvIGF0IHRoZSBlbmQgYWZ0ZXIgY2FsbGJhY2tzIGhhdmUgYmVlbiBzZXQgdXBcbiAgICBpZiAoaW5mbykge1xuICAgICAgcGFydGljaXBhbnQudXBkYXRlSW5mbyhpbmZvKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnRpY2lwYW50O1xuICB9XG5cbiAgcHJpdmF0ZSBzZW5kU3luY1N0YXRlKCkge1xuICAgIGNvbnN0IHJlbW90ZVRyYWNrcyA9IEFycmF5LmZyb20odGhpcy5wYXJ0aWNpcGFudHMudmFsdWVzKCkpLnJlZHVjZSgoYWNjLCBwYXJ0aWNpcGFudCkgPT4ge1xuICAgICAgYWNjLnB1c2goLi4uKHBhcnRpY2lwYW50LmdldFRyYWNrcygpIGFzIFJlbW90ZVRyYWNrUHVibGljYXRpb25bXSkpOyAvLyBGSVhNRSB3b3VsZCBiZSBuaWNlIHRvIGhhdmUgdGhpcyByZXR1cm4gUmVtb3RlVHJhY2tQdWJsaWNhdGlvbnMgZGlyZWN0bHkgaW5zdGVhZCBvZiB0aGUgdHlwZSBjYXN0XG4gICAgICByZXR1cm4gYWNjO1xuICAgIH0sIFtdIGFzIFJlbW90ZVRyYWNrUHVibGljYXRpb25bXSk7XG4gICAgY29uc3QgbG9jYWxUcmFja3MgPSB0aGlzLmxvY2FsUGFydGljaXBhbnQuZ2V0VHJhY2tzKCkgYXMgTG9jYWxUcmFja1B1YmxpY2F0aW9uW107IC8vIEZJWE1FIHdvdWxkIGJlIG5pY2UgdG8gaGF2ZSB0aGlzIHJldHVybiBMb2NhbFRyYWNrUHVibGljYXRpb25zIGRpcmVjdGx5IGluc3RlYWQgb2YgdGhlIHR5cGUgY2FzdFxuICAgIHRoaXMuZW5naW5lLnNlbmRTeW5jU3RhdGUocmVtb3RlVHJhY2tzLCBsb2NhbFRyYWNrcyk7XG4gIH1cblxuICAvKipcbiAgICogQWZ0ZXIgcmVzdW1pbmcsIHdlJ2xsIG5lZWQgdG8gbm90aWZ5IHRoZSBzZXJ2ZXIgb2YgdGhlIGN1cnJlbnRcbiAgICogc3Vic2NyaXB0aW9uIHNldHRpbmdzLlxuICAgKi9cbiAgcHJpdmF0ZSB1cGRhdGVTdWJzY3JpcHRpb25zKCkge1xuICAgIGZvciAoY29uc3QgcCBvZiB0aGlzLnBhcnRpY2lwYW50cy52YWx1ZXMoKSkge1xuICAgICAgZm9yIChjb25zdCBwdWIgb2YgcC52aWRlb1RyYWNrcy52YWx1ZXMoKSkge1xuICAgICAgICBpZiAocHViLmlzU3Vic2NyaWJlZCAmJiBwdWIgaW5zdGFuY2VvZiBSZW1vdGVUcmFja1B1YmxpY2F0aW9uKSB7XG4gICAgICAgICAgcHViLmVtaXRUcmFja1VwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSByZWdpc3RlckNvbm5lY3Rpb25SZWNvbmNpbGUoKSB7XG4gICAgdGhpcy5jbGVhckNvbm5lY3Rpb25SZWNvbmNpbGUoKTtcbiAgICBsZXQgY29uc2VjdXRpdmVGYWlsdXJlcyA9IDA7XG4gICAgdGhpcy5jb25uZWN0aW9uUmVjb25jaWxlSW50ZXJ2YWwgPSBDcml0aWNhbFRpbWVycy5zZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICBpZiAoXG4gICAgICAgIC8vIGVuc3VyZSB3ZSBkaWRuJ3QgdGVhciBpdCBkb3duXG4gICAgICAgICF0aGlzLmVuZ2luZSB8fFxuICAgICAgICAvLyBlbmdpbmUgZGV0ZWN0ZWQgY2xvc2UsIGJ1dCBSb29tIG1pc3NlZCBpdFxuICAgICAgICB0aGlzLmVuZ2luZS5pc0Nsb3NlZCB8fFxuICAgICAgICAvLyB0cmFuc3BvcnRzIGZhaWxlZCB3aXRob3V0IG5vdGlmeWluZyBlbmdpbmVcbiAgICAgICAgIXRoaXMuZW5naW5lLnZlcmlmeVRyYW5zcG9ydCgpXG4gICAgICApIHtcbiAgICAgICAgY29uc2VjdXRpdmVGYWlsdXJlcysrO1xuICAgICAgICB0aGlzLmxvZy53YXJuKCdkZXRlY3RlZCBjb25uZWN0aW9uIHN0YXRlIG1pc21hdGNoJywge1xuICAgICAgICAgIC4uLnRoaXMubG9nQ29udGV4dCxcbiAgICAgICAgICBudW1GYWlsdXJlczogY29uc2VjdXRpdmVGYWlsdXJlcyxcbiAgICAgICAgICBlbmdpbmU6IHtcbiAgICAgICAgICAgIGNsb3NlZDogdGhpcy5lbmdpbmUuaXNDbG9zZWQsXG4gICAgICAgICAgICB0cmFuc3BvcnRzQ29ubmVjdGVkOiB0aGlzLmVuZ2luZS52ZXJpZnlUcmFuc3BvcnQoKSxcbiAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGNvbnNlY3V0aXZlRmFpbHVyZXMgPj0gMykge1xuICAgICAgICAgIHRoaXMucmVjcmVhdGVFbmdpbmUoKTtcbiAgICAgICAgICB0aGlzLmhhbmRsZURpc2Nvbm5lY3QoXG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMuc3RvcExvY2FsVHJhY2tPblVucHVibGlzaCxcbiAgICAgICAgICAgIERpc2Nvbm5lY3RSZWFzb24uU1RBVEVfTUlTTUFUQ0gsXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc2VjdXRpdmVGYWlsdXJlcyA9IDA7XG4gICAgICB9XG4gICAgfSwgY29ubmVjdGlvblJlY29uY2lsZUZyZXF1ZW5jeSk7XG4gIH1cblxuICBwcml2YXRlIGNsZWFyQ29ubmVjdGlvblJlY29uY2lsZSgpIHtcbiAgICBpZiAodGhpcy5jb25uZWN0aW9uUmVjb25jaWxlSW50ZXJ2YWwpIHtcbiAgICAgIENyaXRpY2FsVGltZXJzLmNsZWFySW50ZXJ2YWwodGhpcy5jb25uZWN0aW9uUmVjb25jaWxlSW50ZXJ2YWwpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgc2V0QW5kRW1pdENvbm5lY3Rpb25TdGF0ZShzdGF0ZTogQ29ubmVjdGlvblN0YXRlKTogYm9vbGVhbiB7XG4gICAgaWYgKHN0YXRlID09PSB0aGlzLnN0YXRlKSB7XG4gICAgICAvLyB1bmNoYW5nZWRcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgIHRoaXMuZW1pdChSb29tRXZlbnQuQ29ubmVjdGlvblN0YXRlQ2hhbmdlZCwgdGhpcy5zdGF0ZSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBwcml2YXRlIGVtaXRCdWZmZXJlZEV2ZW50cygpIHtcbiAgICB0aGlzLmJ1ZmZlcmVkRXZlbnRzLmZvckVhY2goKFtldiwgYXJnc10pID0+IHtcbiAgICAgIHRoaXMuZW1pdChldiwgLi4uYXJncyk7XG4gICAgfSk7XG4gICAgdGhpcy5idWZmZXJlZEV2ZW50cyA9IFtdO1xuICB9XG5cbiAgcHJpdmF0ZSBlbWl0V2hlbkNvbm5lY3RlZDxFIGV4dGVuZHMga2V5b2YgUm9vbUV2ZW50Q2FsbGJhY2tzPihcbiAgICBldmVudDogRSxcbiAgICAuLi5hcmdzOiBQYXJhbWV0ZXJzPFJvb21FdmVudENhbGxiYWNrc1tFXT5cbiAgKTogYm9vbGVhbiB7XG4gICAgaWYgKHRoaXMuc3RhdGUgPT09IENvbm5lY3Rpb25TdGF0ZS5Db25uZWN0ZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLmVtaXQoZXZlbnQsIC4uLmFyZ3MpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5zdGF0ZSA9PT0gQ29ubmVjdGlvblN0YXRlLlJlY29ubmVjdGluZykge1xuICAgICAgLy8gaW4gY2FzZSB0aGUgcm9vbSBpcyByZWNvbm5lY3RpbmcsIGJ1ZmZlciB0aGUgZXZlbnRzIGJ5IGZpcmluZyB0aGVtIGxhdGVyIGFmdGVyIGVtaXR0aW5nIFJvb21FdmVudC5SZWNvbm5lY3RlZFxuICAgICAgdGhpcy5idWZmZXJlZEV2ZW50cy5wdXNoKFtldmVudCwgYXJnc10pO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBwcml2YXRlIG9uTG9jYWxQYXJ0aWNpcGFudE1ldGFkYXRhQ2hhbmdlZCA9IChtZXRhZGF0YTogc3RyaW5nIHwgdW5kZWZpbmVkKSA9PiB7XG4gICAgdGhpcy5lbWl0KFJvb21FdmVudC5QYXJ0aWNpcGFudE1ldGFkYXRhQ2hhbmdlZCwgbWV0YWRhdGEsIHRoaXMubG9jYWxQYXJ0aWNpcGFudCk7XG4gIH07XG5cbiAgcHJpdmF0ZSBvbkxvY2FsUGFydGljaXBhbnROYW1lQ2hhbmdlZCA9IChuYW1lOiBzdHJpbmcpID0+IHtcbiAgICB0aGlzLmVtaXQoUm9vbUV2ZW50LlBhcnRpY2lwYW50TmFtZUNoYW5nZWQsIG5hbWUsIHRoaXMubG9jYWxQYXJ0aWNpcGFudCk7XG4gIH07XG5cbiAgcHJpdmF0ZSBvbkxvY2FsVHJhY2tNdXRlZCA9IChwdWI6IFRyYWNrUHVibGljYXRpb24pID0+IHtcbiAgICB0aGlzLmVtaXQoUm9vbUV2ZW50LlRyYWNrTXV0ZWQsIHB1YiwgdGhpcy5sb2NhbFBhcnRpY2lwYW50KTtcbiAgfTtcblxuICBwcml2YXRlIG9uTG9jYWxUcmFja1VubXV0ZWQgPSAocHViOiBUcmFja1B1YmxpY2F0aW9uKSA9PiB7XG4gICAgdGhpcy5lbWl0KFJvb21FdmVudC5UcmFja1VubXV0ZWQsIHB1YiwgdGhpcy5sb2NhbFBhcnRpY2lwYW50KTtcbiAgfTtcblxuICBwcml2YXRlIG9uTG9jYWxUcmFja1B1Ymxpc2hlZCA9IGFzeW5jIChwdWI6IExvY2FsVHJhY2tQdWJsaWNhdGlvbikgPT4ge1xuICAgIHRoaXMuZW1pdChSb29tRXZlbnQuTG9jYWxUcmFja1B1Ymxpc2hlZCwgcHViLCB0aGlzLmxvY2FsUGFydGljaXBhbnQpO1xuICAgIGlmIChwdWIudHJhY2sgaW5zdGFuY2VvZiBMb2NhbEF1ZGlvVHJhY2spIHtcbiAgICAgIGNvbnN0IHRyYWNrSXNTaWxlbnQgPSBhd2FpdCBwdWIudHJhY2suY2hlY2tGb3JTaWxlbmNlKCk7XG4gICAgICBpZiAodHJhY2tJc1NpbGVudCkge1xuICAgICAgICB0aGlzLmVtaXQoUm9vbUV2ZW50LkxvY2FsQXVkaW9TaWxlbmNlRGV0ZWN0ZWQsIHB1Yik7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGRldmljZUlkID0gYXdhaXQgcHViLnRyYWNrPy5nZXREZXZpY2VJZCgpO1xuICAgIGNvbnN0IGRldmljZUtpbmQgPSBzb3VyY2VUb0tpbmQocHViLnNvdXJjZSk7XG4gICAgaWYgKFxuICAgICAgZGV2aWNlS2luZCAmJlxuICAgICAgZGV2aWNlSWQgJiZcbiAgICAgIGRldmljZUlkICE9PSB0aGlzLmxvY2FsUGFydGljaXBhbnQuYWN0aXZlRGV2aWNlTWFwLmdldChkZXZpY2VLaW5kKVxuICAgICkge1xuICAgICAgdGhpcy5sb2NhbFBhcnRpY2lwYW50LmFjdGl2ZURldmljZU1hcC5zZXQoZGV2aWNlS2luZCwgZGV2aWNlSWQpO1xuICAgICAgdGhpcy5lbWl0KFJvb21FdmVudC5BY3RpdmVEZXZpY2VDaGFuZ2VkLCBkZXZpY2VLaW5kLCBkZXZpY2VJZCk7XG4gICAgfVxuICB9O1xuXG4gIHByaXZhdGUgb25Mb2NhbFRyYWNrVW5wdWJsaXNoZWQgPSAocHViOiBMb2NhbFRyYWNrUHVibGljYXRpb24pID0+IHtcbiAgICB0aGlzLmVtaXQoUm9vbUV2ZW50LkxvY2FsVHJhY2tVbnB1Ymxpc2hlZCwgcHViLCB0aGlzLmxvY2FsUGFydGljaXBhbnQpO1xuICB9O1xuXG4gIHByaXZhdGUgb25Mb2NhbENvbm5lY3Rpb25RdWFsaXR5Q2hhbmdlZCA9IChxdWFsaXR5OiBDb25uZWN0aW9uUXVhbGl0eSkgPT4ge1xuICAgIHRoaXMuZW1pdChSb29tRXZlbnQuQ29ubmVjdGlvblF1YWxpdHlDaGFuZ2VkLCBxdWFsaXR5LCB0aGlzLmxvY2FsUGFydGljaXBhbnQpO1xuICB9O1xuXG4gIHByaXZhdGUgb25NZWRpYURldmljZXNFcnJvciA9IChlOiBFcnJvcikgPT4ge1xuICAgIHRoaXMuZW1pdChSb29tRXZlbnQuTWVkaWFEZXZpY2VzRXJyb3IsIGUpO1xuICB9O1xuXG4gIHByaXZhdGUgb25Mb2NhbFBhcnRpY2lwYW50UGVybWlzc2lvbnNDaGFuZ2VkID0gKHByZXZQZXJtaXNzaW9ucz86IFBhcnRpY2lwYW50UGVybWlzc2lvbikgPT4ge1xuICAgIHRoaXMuZW1pdChSb29tRXZlbnQuUGFydGljaXBhbnRQZXJtaXNzaW9uc0NoYW5nZWQsIHByZXZQZXJtaXNzaW9ucywgdGhpcy5sb2NhbFBhcnRpY2lwYW50KTtcbiAgfTtcblxuICAvKipcbiAgICogQWxsb3dzIHRvIHBvcHVsYXRlIGEgcm9vbSB3aXRoIHNpbXVsYXRlZCBwYXJ0aWNpcGFudHMuXG4gICAqIE5vIGFjdHVhbCBjb25uZWN0aW9uIHRvIGEgc2VydmVyIHdpbGwgYmUgZXN0YWJsaXNoZWQsIGFsbCBzdGF0ZSBpc1xuICAgKiBAZXhwZXJpbWVudGFsXG4gICAqL1xuICBhc3luYyBzaW11bGF0ZVBhcnRpY2lwYW50cyhvcHRpb25zOiBTaW11bGF0aW9uT3B0aW9ucykge1xuICAgIGNvbnN0IHB1Ymxpc2hPcHRpb25zID0ge1xuICAgICAgYXVkaW86IHRydWUsXG4gICAgICB2aWRlbzogdHJ1ZSxcbiAgICAgIHVzZVJlYWxUcmFja3M6IGZhbHNlLFxuICAgICAgLi4ub3B0aW9ucy5wdWJsaXNoLFxuICAgIH07XG4gICAgY29uc3QgcGFydGljaXBhbnRPcHRpb25zID0ge1xuICAgICAgY291bnQ6IDksXG4gICAgICBhdWRpbzogZmFsc2UsXG4gICAgICB2aWRlbzogdHJ1ZSxcbiAgICAgIGFzcGVjdFJhdGlvczogWzEuNjYsIDEuNywgMS4zXSxcbiAgICAgIC4uLm9wdGlvbnMucGFydGljaXBhbnRzLFxuICAgIH07XG4gICAgdGhpcy5oYW5kbGVEaXNjb25uZWN0KCk7XG4gICAgdGhpcy5yb29tSW5mbyA9IG5ldyBSb29tTW9kZWwoe1xuICAgICAgc2lkOiAnUk1fU0lNVUxBVEVEJyxcbiAgICAgIG5hbWU6ICdzaW11bGF0ZWQtcm9vbScsXG4gICAgICBlbXB0eVRpbWVvdXQ6IDAsXG4gICAgICBtYXhQYXJ0aWNpcGFudHM6IDAsXG4gICAgICBjcmVhdGlvblRpbWU6IHByb3RvSW50NjQucGFyc2UobmV3IERhdGUoKS5nZXRUaW1lKCkpLFxuICAgICAgbWV0YWRhdGE6ICcnLFxuICAgICAgbnVtUGFydGljaXBhbnRzOiAxLFxuICAgICAgbnVtUHVibGlzaGVyczogMSxcbiAgICAgIHR1cm5QYXNzd29yZDogJycsXG4gICAgICBlbmFibGVkQ29kZWNzOiBbXSxcbiAgICAgIGFjdGl2ZVJlY29yZGluZzogZmFsc2UsXG4gICAgfSk7XG5cbiAgICB0aGlzLmxvY2FsUGFydGljaXBhbnQudXBkYXRlSW5mbyhcbiAgICAgIG5ldyBQYXJ0aWNpcGFudEluZm8oe1xuICAgICAgICBpZGVudGl0eTogJ3NpbXVsYXRlZC1sb2NhbCcsXG4gICAgICAgIG5hbWU6ICdsb2NhbC1uYW1lJyxcbiAgICAgIH0pLFxuICAgICk7XG4gICAgdGhpcy5zZXR1cExvY2FsUGFydGljaXBhbnRFdmVudHMoKTtcbiAgICB0aGlzLmVtaXQoUm9vbUV2ZW50LlNpZ25hbENvbm5lY3RlZCk7XG4gICAgdGhpcy5lbWl0KFJvb21FdmVudC5Db25uZWN0ZWQpO1xuICAgIHRoaXMuc2V0QW5kRW1pdENvbm5lY3Rpb25TdGF0ZShDb25uZWN0aW9uU3RhdGUuQ29ubmVjdGVkKTtcbiAgICBpZiAocHVibGlzaE9wdGlvbnMudmlkZW8pIHtcbiAgICAgIGNvbnN0IGNhbVB1YiA9IG5ldyBMb2NhbFRyYWNrUHVibGljYXRpb24oXG4gICAgICAgIFRyYWNrLktpbmQuVmlkZW8sXG4gICAgICAgIG5ldyBUcmFja0luZm8oe1xuICAgICAgICAgIHNvdXJjZTogVHJhY2tTb3VyY2UuQ0FNRVJBLFxuICAgICAgICAgIHNpZDogTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTBfMDAwKS50b1N0cmluZygpLFxuICAgICAgICAgIHR5cGU6IFRyYWNrVHlwZS5BVURJTyxcbiAgICAgICAgICBuYW1lOiAndmlkZW8tZHVtbXknLFxuICAgICAgICB9KSxcbiAgICAgICAgbmV3IExvY2FsVmlkZW9UcmFjayhcbiAgICAgICAgICBwdWJsaXNoT3B0aW9ucy51c2VSZWFsVHJhY2tzXG4gICAgICAgICAgICA/IChcbiAgICAgICAgICAgICAgICBhd2FpdCB3aW5kb3cubmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEoeyB2aWRlbzogdHJ1ZSB9KVxuICAgICAgICAgICAgICApLmdldFZpZGVvVHJhY2tzKClbMF1cbiAgICAgICAgICAgIDogY3JlYXRlRHVtbXlWaWRlb1N0cmVhbVRyYWNrKFxuICAgICAgICAgICAgICAgIDE2MCAqIChwYXJ0aWNpcGFudE9wdGlvbnMuYXNwZWN0UmF0aW9zWzBdID8/IDEpLFxuICAgICAgICAgICAgICAgIDE2MCxcbiAgICAgICAgICAgICAgICB0cnVlLFxuICAgICAgICAgICAgICAgIHRydWUsXG4gICAgICAgICAgICAgICksXG4gICAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgIHsgbG9nZ2VyTmFtZTogdGhpcy5vcHRpb25zLmxvZ2dlck5hbWUsIGxvZ2dlckNvbnRleHRDYjogKCkgPT4gdGhpcy5sb2dDb250ZXh0IH0sXG4gICAgICAgICksXG4gICAgICAgIHsgbG9nZ2VyTmFtZTogdGhpcy5vcHRpb25zLmxvZ2dlck5hbWUsIGxvZ2dlckNvbnRleHRDYjogKCkgPT4gdGhpcy5sb2dDb250ZXh0IH0sXG4gICAgICApO1xuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgdGhpcy5sb2NhbFBhcnRpY2lwYW50LmFkZFRyYWNrUHVibGljYXRpb24oY2FtUHViKTtcbiAgICAgIHRoaXMubG9jYWxQYXJ0aWNpcGFudC5lbWl0KFBhcnRpY2lwYW50RXZlbnQuTG9jYWxUcmFja1B1Ymxpc2hlZCwgY2FtUHViKTtcbiAgICB9XG4gICAgaWYgKHB1Ymxpc2hPcHRpb25zLmF1ZGlvKSB7XG4gICAgICBjb25zdCBhdWRpb1B1YiA9IG5ldyBMb2NhbFRyYWNrUHVibGljYXRpb24oXG4gICAgICAgIFRyYWNrLktpbmQuQXVkaW8sXG4gICAgICAgIG5ldyBUcmFja0luZm8oe1xuICAgICAgICAgIHNvdXJjZTogVHJhY2tTb3VyY2UuTUlDUk9QSE9ORSxcbiAgICAgICAgICBzaWQ6IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwXzAwMCkudG9TdHJpbmcoKSxcbiAgICAgICAgICB0eXBlOiBUcmFja1R5cGUuQVVESU8sXG4gICAgICAgIH0pLFxuICAgICAgICBuZXcgTG9jYWxBdWRpb1RyYWNrKFxuICAgICAgICAgIHB1Ymxpc2hPcHRpb25zLnVzZVJlYWxUcmFja3NcbiAgICAgICAgICAgID8gKGF3YWl0IG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKHsgYXVkaW86IHRydWUgfSkpLmdldEF1ZGlvVHJhY2tzKClbMF1cbiAgICAgICAgICAgIDogZ2V0RW1wdHlBdWRpb1N0cmVhbVRyYWNrKCksXG4gICAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgIHRoaXMuYXVkaW9Db250ZXh0LFxuICAgICAgICAgIHsgbG9nZ2VyTmFtZTogdGhpcy5vcHRpb25zLmxvZ2dlck5hbWUsIGxvZ2dlckNvbnRleHRDYjogKCkgPT4gdGhpcy5sb2dDb250ZXh0IH0sXG4gICAgICAgICksXG4gICAgICAgIHsgbG9nZ2VyTmFtZTogdGhpcy5vcHRpb25zLmxvZ2dlck5hbWUsIGxvZ2dlckNvbnRleHRDYjogKCkgPT4gdGhpcy5sb2dDb250ZXh0IH0sXG4gICAgICApO1xuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgdGhpcy5sb2NhbFBhcnRpY2lwYW50LmFkZFRyYWNrUHVibGljYXRpb24oYXVkaW9QdWIpO1xuICAgICAgdGhpcy5sb2NhbFBhcnRpY2lwYW50LmVtaXQoUGFydGljaXBhbnRFdmVudC5Mb2NhbFRyYWNrUHVibGlzaGVkLCBhdWRpb1B1Yik7XG4gICAgfVxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJ0aWNpcGFudE9wdGlvbnMuY291bnQgLSAxOyBpICs9IDEpIHtcbiAgICAgIGxldCBpbmZvOiBQYXJ0aWNpcGFudEluZm8gPSBuZXcgUGFydGljaXBhbnRJbmZvKHtcbiAgICAgICAgc2lkOiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxMF8wMDApLnRvU3RyaW5nKCksXG4gICAgICAgIGlkZW50aXR5OiBgc2ltdWxhdGVkLSR7aX1gLFxuICAgICAgICBzdGF0ZTogUGFydGljaXBhbnRJbmZvX1N0YXRlLkFDVElWRSxcbiAgICAgICAgdHJhY2tzOiBbXSxcbiAgICAgICAgam9pbmVkQXQ6IHByb3RvSW50NjQucGFyc2UoRGF0ZS5ub3coKSksXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHAgPSB0aGlzLmdldE9yQ3JlYXRlUGFydGljaXBhbnQoaW5mby5pZGVudGl0eSwgaW5mbyk7XG4gICAgICBpZiAocGFydGljaXBhbnRPcHRpb25zLnZpZGVvKSB7XG4gICAgICAgIGNvbnN0IGR1bW15VmlkZW8gPSBjcmVhdGVEdW1teVZpZGVvU3RyZWFtVHJhY2soXG4gICAgICAgICAgMTYwICogKHBhcnRpY2lwYW50T3B0aW9ucy5hc3BlY3RSYXRpb3NbaSAlIHBhcnRpY2lwYW50T3B0aW9ucy5hc3BlY3RSYXRpb3MubGVuZ3RoXSA/PyAxKSxcbiAgICAgICAgICAxNjAsXG4gICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgdHJ1ZSxcbiAgICAgICAgKTtcbiAgICAgICAgY29uc3QgdmlkZW9UcmFjayA9IG5ldyBUcmFja0luZm8oe1xuICAgICAgICAgIHNvdXJjZTogVHJhY2tTb3VyY2UuQ0FNRVJBLFxuICAgICAgICAgIHNpZDogTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTBfMDAwKS50b1N0cmluZygpLFxuICAgICAgICAgIHR5cGU6IFRyYWNrVHlwZS5BVURJTyxcbiAgICAgICAgfSk7XG4gICAgICAgIHAuYWRkU3Vic2NyaWJlZE1lZGlhVHJhY2soZHVtbXlWaWRlbywgdmlkZW9UcmFjay5zaWQsIG5ldyBNZWRpYVN0cmVhbShbZHVtbXlWaWRlb10pKTtcbiAgICAgICAgaW5mby50cmFja3MgPSBbLi4uaW5mby50cmFja3MsIHZpZGVvVHJhY2tdO1xuICAgICAgfVxuICAgICAgaWYgKHBhcnRpY2lwYW50T3B0aW9ucy5hdWRpbykge1xuICAgICAgICBjb25zdCBkdW1teVRyYWNrID0gZ2V0RW1wdHlBdWRpb1N0cmVhbVRyYWNrKCk7XG4gICAgICAgIGNvbnN0IGF1ZGlvVHJhY2sgPSBuZXcgVHJhY2tJbmZvKHtcbiAgICAgICAgICBzb3VyY2U6IFRyYWNrU291cmNlLk1JQ1JPUEhPTkUsXG4gICAgICAgICAgc2lkOiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxMF8wMDApLnRvU3RyaW5nKCksXG4gICAgICAgICAgdHlwZTogVHJhY2tUeXBlLkFVRElPLFxuICAgICAgICB9KTtcbiAgICAgICAgcC5hZGRTdWJzY3JpYmVkTWVkaWFUcmFjayhkdW1teVRyYWNrLCBhdWRpb1RyYWNrLnNpZCwgbmV3IE1lZGlhU3RyZWFtKFtkdW1teVRyYWNrXSkpO1xuICAgICAgICBpbmZvLnRyYWNrcyA9IFsuLi5pbmZvLnRyYWNrcywgYXVkaW9UcmFja107XG4gICAgICB9XG5cbiAgICAgIHAudXBkYXRlSW5mbyhpbmZvKTtcbiAgICB9XG4gIH1cblxuICAvLyAvKiogQGludGVybmFsICovXG4gIGVtaXQ8RSBleHRlbmRzIGtleW9mIFJvb21FdmVudENhbGxiYWNrcz4oXG4gICAgZXZlbnQ6IEUsXG4gICAgLi4uYXJnczogUGFyYW1ldGVyczxSb29tRXZlbnRDYWxsYmFja3NbRV0+XG4gICk6IGJvb2xlYW4ge1xuICAgIC8vIGFjdGl2ZSBzcGVha2VyIHVwZGF0ZXMgYXJlIHRvbyBzcGFtbXlcbiAgICBpZiAoZXZlbnQgIT09IFJvb21FdmVudC5BY3RpdmVTcGVha2Vyc0NoYW5nZWQpIHtcbiAgICAgIC8vIG9ubHkgZXh0cmFjdCBsb2dDb250ZXh0IGZyb20gYXJndW1lbnRzIGluIG9yZGVyIHRvIGF2b2lkIGxvZ2dpbmcgdGhlIHdob2xlIG9iamVjdCB0cmVlXG4gICAgICBjb25zdCBtaW5pbWl6ZWRBcmdzID0gbWFwQXJncyhhcmdzKS5maWx0ZXIoKGFyZzogdW5rbm93bikgPT4gYXJnICE9PSB1bmRlZmluZWQpO1xuICAgICAgdGhpcy5sb2cuZGVidWcoYHJvb20gZXZlbnQgJHtldmVudH1gLCB7IC4uLnRoaXMubG9nQ29udGV4dCwgZXZlbnQsIGFyZ3M6IG1pbmltaXplZEFyZ3MgfSk7XG4gICAgfVxuICAgIHJldHVybiBzdXBlci5lbWl0KGV2ZW50LCAuLi5hcmdzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXBBcmdzKGFyZ3M6IHVua25vd25bXSk6IGFueSB7XG4gIHJldHVybiBhcmdzLm1hcCgoYXJnOiB1bmtub3duKSA9PiB7XG4gICAgaWYgKCFhcmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYXJnKSkge1xuICAgICAgcmV0dXJuIG1hcEFyZ3MoYXJnKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBhcmcgPT09ICdvYmplY3QnKSB7XG4gICAgICByZXR1cm4gJ2xvZ0NvbnRleHQnIGluIGFyZyAmJiBhcmcubG9nQ29udGV4dDtcbiAgICB9XG4gICAgcmV0dXJuIGFyZztcbiAgfSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IFJvb207XG5cbmV4cG9ydCB0eXBlIFJvb21FdmVudENhbGxiYWNrcyA9IHtcbiAgY29ubmVjdGVkOiAoKSA9PiB2b2lkO1xuICByZWNvbm5lY3Rpbmc6ICgpID0+IHZvaWQ7XG4gIHJlY29ubmVjdGVkOiAoKSA9PiB2b2lkO1xuICBkaXNjb25uZWN0ZWQ6IChyZWFzb24/OiBEaXNjb25uZWN0UmVhc29uKSA9PiB2b2lkO1xuICAvKiogQGRlcHJlY2F0ZWQgc3RhdGVDaGFuZ2VkIGhhcyBiZWVuIHJlbmFtZWQgdG8gY29ubmVjdGlvblN0YXRlQ2hhbmdlZCAqL1xuICBzdGF0ZUNoYW5nZWQ6IChzdGF0ZTogQ29ubmVjdGlvblN0YXRlKSA9PiB2b2lkO1xuICBjb25uZWN0aW9uU3RhdGVDaGFuZ2VkOiAoc3RhdGU6IENvbm5lY3Rpb25TdGF0ZSkgPT4gdm9pZDtcbiAgbWVkaWFEZXZpY2VzQ2hhbmdlZDogKCkgPT4gdm9pZDtcbiAgcGFydGljaXBhbnRDb25uZWN0ZWQ6IChwYXJ0aWNpcGFudDogUmVtb3RlUGFydGljaXBhbnQpID0+IHZvaWQ7XG4gIHBhcnRpY2lwYW50RGlzY29ubmVjdGVkOiAocGFydGljaXBhbnQ6IFJlbW90ZVBhcnRpY2lwYW50KSA9PiB2b2lkO1xuICB0cmFja1B1Ymxpc2hlZDogKHB1YmxpY2F0aW9uOiBSZW1vdGVUcmFja1B1YmxpY2F0aW9uLCBwYXJ0aWNpcGFudDogUmVtb3RlUGFydGljaXBhbnQpID0+IHZvaWQ7XG4gIHRyYWNrU3Vic2NyaWJlZDogKFxuICAgIHRyYWNrOiBSZW1vdGVUcmFjayxcbiAgICBwdWJsaWNhdGlvbjogUmVtb3RlVHJhY2tQdWJsaWNhdGlvbixcbiAgICBwYXJ0aWNpcGFudDogUmVtb3RlUGFydGljaXBhbnQsXG4gICkgPT4gdm9pZDtcbiAgdHJhY2tTdWJzY3JpcHRpb25GYWlsZWQ6IChcbiAgICB0cmFja1NpZDogc3RyaW5nLFxuICAgIHBhcnRpY2lwYW50OiBSZW1vdGVQYXJ0aWNpcGFudCxcbiAgICByZWFzb24/OiBTdWJzY3JpcHRpb25FcnJvcixcbiAgKSA9PiB2b2lkO1xuICB0cmFja1VucHVibGlzaGVkOiAocHVibGljYXRpb246IFJlbW90ZVRyYWNrUHVibGljYXRpb24sIHBhcnRpY2lwYW50OiBSZW1vdGVQYXJ0aWNpcGFudCkgPT4gdm9pZDtcbiAgdHJhY2tVbnN1YnNjcmliZWQ6IChcbiAgICB0cmFjazogUmVtb3RlVHJhY2ssXG4gICAgcHVibGljYXRpb246IFJlbW90ZVRyYWNrUHVibGljYXRpb24sXG4gICAgcGFydGljaXBhbnQ6IFJlbW90ZVBhcnRpY2lwYW50LFxuICApID0+IHZvaWQ7XG4gIHRyYWNrTXV0ZWQ6IChwdWJsaWNhdGlvbjogVHJhY2tQdWJsaWNhdGlvbiwgcGFydGljaXBhbnQ6IFBhcnRpY2lwYW50KSA9PiB2b2lkO1xuICB0cmFja1VubXV0ZWQ6IChwdWJsaWNhdGlvbjogVHJhY2tQdWJsaWNhdGlvbiwgcGFydGljaXBhbnQ6IFBhcnRpY2lwYW50KSA9PiB2b2lkO1xuICBsb2NhbFRyYWNrUHVibGlzaGVkOiAocHVibGljYXRpb246IExvY2FsVHJhY2tQdWJsaWNhdGlvbiwgcGFydGljaXBhbnQ6IExvY2FsUGFydGljaXBhbnQpID0+IHZvaWQ7XG4gIGxvY2FsVHJhY2tVbnB1Ymxpc2hlZDogKFxuICAgIHB1YmxpY2F0aW9uOiBMb2NhbFRyYWNrUHVibGljYXRpb24sXG4gICAgcGFydGljaXBhbnQ6IExvY2FsUGFydGljaXBhbnQsXG4gICkgPT4gdm9pZDtcbiAgbG9jYWxBdWRpb1NpbGVuY2VEZXRlY3RlZDogKHB1YmxpY2F0aW9uOiBMb2NhbFRyYWNrUHVibGljYXRpb24pID0+IHZvaWQ7XG4gIHBhcnRpY2lwYW50TWV0YWRhdGFDaGFuZ2VkOiAoXG4gICAgbWV0YWRhdGE6IHN0cmluZyB8IHVuZGVmaW5lZCxcbiAgICBwYXJ0aWNpcGFudDogUmVtb3RlUGFydGljaXBhbnQgfCBMb2NhbFBhcnRpY2lwYW50LFxuICApID0+IHZvaWQ7XG4gIHBhcnRpY2lwYW50TmFtZUNoYW5nZWQ6IChuYW1lOiBzdHJpbmcsIHBhcnRpY2lwYW50OiBSZW1vdGVQYXJ0aWNpcGFudCB8IExvY2FsUGFydGljaXBhbnQpID0+IHZvaWQ7XG4gIHBhcnRpY2lwYW50UGVybWlzc2lvbnNDaGFuZ2VkOiAoXG4gICAgcHJldlBlcm1pc3Npb25zOiBQYXJ0aWNpcGFudFBlcm1pc3Npb24gfCB1bmRlZmluZWQsXG4gICAgcGFydGljaXBhbnQ6IFJlbW90ZVBhcnRpY2lwYW50IHwgTG9jYWxQYXJ0aWNpcGFudCxcbiAgKSA9PiB2b2lkO1xuICBhY3RpdmVTcGVha2Vyc0NoYW5nZWQ6IChzcGVha2VyczogQXJyYXk8UGFydGljaXBhbnQ+KSA9PiB2b2lkO1xuICByb29tTWV0YWRhdGFDaGFuZ2VkOiAobWV0YWRhdGE6IHN0cmluZykgPT4gdm9pZDtcbiAgZGF0YVJlY2VpdmVkOiAoXG4gICAgcGF5bG9hZDogVWludDhBcnJheSxcbiAgICBwYXJ0aWNpcGFudD86IFJlbW90ZVBhcnRpY2lwYW50LFxuICAgIGtpbmQ/OiBEYXRhUGFja2V0X0tpbmQsXG4gICAgdG9waWM/OiBzdHJpbmcsXG4gICkgPT4gdm9pZDtcbiAgY29ubmVjdGlvblF1YWxpdHlDaGFuZ2VkOiAocXVhbGl0eTogQ29ubmVjdGlvblF1YWxpdHksIHBhcnRpY2lwYW50OiBQYXJ0aWNpcGFudCkgPT4gdm9pZDtcbiAgbWVkaWFEZXZpY2VzRXJyb3I6IChlcnJvcjogRXJyb3IpID0+IHZvaWQ7XG4gIHRyYWNrU3RyZWFtU3RhdGVDaGFuZ2VkOiAoXG4gICAgcHVibGljYXRpb246IFJlbW90ZVRyYWNrUHVibGljYXRpb24sXG4gICAgc3RyZWFtU3RhdGU6IFRyYWNrLlN0cmVhbVN0YXRlLFxuICAgIHBhcnRpY2lwYW50OiBSZW1vdGVQYXJ0aWNpcGFudCxcbiAgKSA9PiB2b2lkO1xuICB0cmFja1N1YnNjcmlwdGlvblBlcm1pc3Npb25DaGFuZ2VkOiAoXG4gICAgcHVibGljYXRpb246IFJlbW90ZVRyYWNrUHVibGljYXRpb24sXG4gICAgc3RhdHVzOiBUcmFja1B1YmxpY2F0aW9uLlBlcm1pc3Npb25TdGF0dXMsXG4gICAgcGFydGljaXBhbnQ6IFJlbW90ZVBhcnRpY2lwYW50LFxuICApID0+IHZvaWQ7XG4gIHRyYWNrU3Vic2NyaXB0aW9uU3RhdHVzQ2hhbmdlZDogKFxuICAgIHB1YmxpY2F0aW9uOiBSZW1vdGVUcmFja1B1YmxpY2F0aW9uLFxuICAgIHN0YXR1czogVHJhY2tQdWJsaWNhdGlvbi5TdWJzY3JpcHRpb25TdGF0dXMsXG4gICAgcGFydGljaXBhbnQ6IFJlbW90ZVBhcnRpY2lwYW50LFxuICApID0+IHZvaWQ7XG4gIGF1ZGlvUGxheWJhY2tDaGFuZ2VkOiAocGxheWluZzogYm9vbGVhbikgPT4gdm9pZDtcbiAgdmlkZW9QbGF5YmFja0NoYW5nZWQ6IChwbGF5aW5nOiBib29sZWFuKSA9PiB2b2lkO1xuICBzaWduYWxDb25uZWN0ZWQ6ICgpID0+IHZvaWQ7XG4gIHJlY29yZGluZ1N0YXR1c0NoYW5nZWQ6IChyZWNvcmRpbmc6IGJvb2xlYW4pID0+IHZvaWQ7XG4gIHBhcnRpY2lwYW50RW5jcnlwdGlvblN0YXR1c0NoYW5nZWQ6IChlbmNyeXB0ZWQ6IGJvb2xlYW4sIHBhcnRpY2lwYW50PzogUGFydGljaXBhbnQpID0+IHZvaWQ7XG4gIGVuY3J5cHRpb25FcnJvcjogKGVycm9yOiBFcnJvcikgPT4gdm9pZDtcbiAgZGNCdWZmZXJTdGF0dXNDaGFuZ2VkOiAoaXNMb3c6IGJvb2xlYW4sIGtpbmQ6IERhdGFQYWNrZXRfS2luZCkgPT4gdm9pZDtcbiAgYWN0aXZlRGV2aWNlQ2hhbmdlZDogKGtpbmQ6IE1lZGlhRGV2aWNlS2luZCwgZGV2aWNlSWQ6IHN0cmluZykgPT4gdm9pZDtcbn07XG4iLCJpbXBvcnQgeyBFdmVudEVtaXR0ZXIgfSBmcm9tICdldmVudHMnO1xuaW1wb3J0IHR5cGUgVHlwZWRFbWl0dGVyIGZyb20gJ3R5cGVkLWVtaXR0ZXInO1xuaW1wb3J0IHR5cGUgeyBSb29tQ29ubmVjdE9wdGlvbnMsIFJvb21PcHRpb25zIH0gZnJvbSAnLi4vLi4vb3B0aW9ucyc7XG5pbXBvcnQgdHlwZSBSVENFbmdpbmUgZnJvbSAnLi4vLi4vcm9vbS9SVENFbmdpbmUnO1xuaW1wb3J0IFJvb20sIHsgQ29ubmVjdGlvblN0YXRlIH0gZnJvbSAnLi4vLi4vcm9vbS9Sb29tJztcblxudHlwZSBMb2dNZXNzYWdlID0ge1xuICBsZXZlbDogJ2luZm8nIHwgJ3dhcm5pbmcnIHwgJ2Vycm9yJztcbiAgbWVzc2FnZTogc3RyaW5nO1xufTtcblxuZXhwb3J0IGVudW0gQ2hlY2tTdGF0dXMge1xuICBJRExFLFxuICBSVU5OSU5HLFxuICBTS0lQUEVELFxuICBTVUNDRVNTLFxuICBGQUlMRUQsXG59XG5cbmV4cG9ydCB0eXBlIENoZWNrSW5mbyA9IHtcbiAgbmFtZTogc3RyaW5nO1xuICBsb2dzOiBBcnJheTxMb2dNZXNzYWdlPjtcbiAgc3RhdHVzOiBDaGVja1N0YXR1cztcbiAgZGVzY3JpcHRpb246IHN0cmluZztcbn07XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ2hlY2tlck9wdGlvbnMge1xuICBlcnJvcnNBc1dhcm5pbmdzPzogYm9vbGVhbjtcbiAgcm9vbU9wdGlvbnM/OiBSb29tT3B0aW9ucztcbiAgY29ubmVjdE9wdGlvbnM/OiBSb29tQ29ubmVjdE9wdGlvbnM7XG59XG5cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBDaGVja2VyIGV4dGVuZHMgKEV2ZW50RW1pdHRlciBhcyBuZXcgKCkgPT4gVHlwZWRFbWl0dGVyPENoZWNrZXJDYWxsYmFja3M+KSB7XG4gIHByb3RlY3RlZCB1cmw6IHN0cmluZztcblxuICBwcm90ZWN0ZWQgdG9rZW46IHN0cmluZztcblxuICByb29tOiBSb29tO1xuXG4gIGNvbm5lY3RPcHRpb25zPzogUm9vbUNvbm5lY3RPcHRpb25zO1xuXG4gIHN0YXR1czogQ2hlY2tTdGF0dXMgPSBDaGVja1N0YXR1cy5JRExFO1xuXG4gIGxvZ3M6IEFycmF5PExvZ01lc3NhZ2U+ID0gW107XG5cbiAgZXJyb3JzQXNXYXJuaW5nczogYm9vbGVhbiA9IGZhbHNlO1xuXG4gIG5hbWU6IHN0cmluZztcblxuICBjb25zdHJ1Y3Rvcih1cmw6IHN0cmluZywgdG9rZW46IHN0cmluZywgb3B0aW9uczogQ2hlY2tlck9wdGlvbnMgPSB7fSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy51cmwgPSB1cmw7XG4gICAgdGhpcy50b2tlbiA9IHRva2VuO1xuICAgIHRoaXMubmFtZSA9IHRoaXMuY29uc3RydWN0b3IubmFtZTtcbiAgICB0aGlzLnJvb20gPSBuZXcgUm9vbShvcHRpb25zLnJvb21PcHRpb25zKTtcbiAgICB0aGlzLmNvbm5lY3RPcHRpb25zID0gb3B0aW9ucy5jb25uZWN0T3B0aW9ucztcbiAgICBpZiAob3B0aW9ucy5lcnJvcnNBc1dhcm5pbmdzKSB7XG4gICAgICB0aGlzLmVycm9yc0FzV2FybmluZ3MgPSBvcHRpb25zLmVycm9yc0FzV2FybmluZ3M7XG4gICAgfVxuICB9XG5cbiAgYWJzdHJhY3QgZ2V0IGRlc2NyaXB0aW9uKCk6IHN0cmluZztcblxuICBwcm90ZWN0ZWQgYWJzdHJhY3QgcGVyZm9ybSgpOiBQcm9taXNlPHZvaWQ+O1xuXG4gIGFzeW5jIHJ1bihvbkNvbXBsZXRlPzogKCkgPT4gdm9pZCkge1xuICAgIGlmICh0aGlzLnN0YXR1cyAhPT0gQ2hlY2tTdGF0dXMuSURMRSkge1xuICAgICAgdGhyb3cgRXJyb3IoJ2NoZWNrIGlzIHJ1bm5pbmcgYWxyZWFkeScpO1xuICAgIH1cbiAgICB0aGlzLnNldFN0YXR1cyhDaGVja1N0YXR1cy5SVU5OSU5HKTtcblxuICAgIHRyeSB7XG4gICAgICBhd2FpdCB0aGlzLnBlcmZvcm0oKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICBpZiAodGhpcy5lcnJvcnNBc1dhcm5pbmdzKSB7XG4gICAgICAgICAgdGhpcy5hcHBlbmRXYXJuaW5nKGVyci5tZXNzYWdlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmFwcGVuZEVycm9yKGVyci5tZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGF3YWl0IHRoaXMuZGlzY29ubmVjdCgpO1xuXG4gICAgLy8gc2xlZXAgZm9yIGEgYml0IHRvIGVuc3VyZSBkaXNjb25uZWN0XG4gICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgNTAwKSk7XG5cbiAgICAvLyBAdHMtaWdub3JlXG4gICAgaWYgKHRoaXMuc3RhdHVzICE9PSBDaGVja1N0YXR1cy5TS0lQUEVEKSB7XG4gICAgICB0aGlzLnNldFN0YXR1cyh0aGlzLmlzU3VjY2VzcygpID8gQ2hlY2tTdGF0dXMuU1VDQ0VTUyA6IENoZWNrU3RhdHVzLkZBSUxFRCk7XG4gICAgfVxuXG4gICAgaWYgKG9uQ29tcGxldGUpIHtcbiAgICAgIG9uQ29tcGxldGUoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZ2V0SW5mbygpO1xuICB9XG5cbiAgcHJvdGVjdGVkIGlzU3VjY2VzcygpOiBib29sZWFuIHtcbiAgICByZXR1cm4gIXRoaXMubG9ncy5zb21lKChsKSA9PiBsLmxldmVsID09PSAnZXJyb3InKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBhc3luYyBjb25uZWN0KCk6IFByb21pc2U8Um9vbT4ge1xuICAgIGlmICh0aGlzLnJvb20uc3RhdGUgPT09IENvbm5lY3Rpb25TdGF0ZS5Db25uZWN0ZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLnJvb207XG4gICAgfVxuICAgIGF3YWl0IHRoaXMucm9vbS5jb25uZWN0KHRoaXMudXJsLCB0aGlzLnRva2VuKTtcbiAgICByZXR1cm4gdGhpcy5yb29tO1xuICB9XG5cbiAgcHJvdGVjdGVkIGFzeW5jIGRpc2Nvbm5lY3QoKSB7XG4gICAgaWYgKHRoaXMucm9vbSAmJiB0aGlzLnJvb20uc3RhdGUgIT09IENvbm5lY3Rpb25TdGF0ZS5EaXNjb25uZWN0ZWQpIHtcbiAgICAgIGF3YWl0IHRoaXMucm9vbS5kaXNjb25uZWN0KCk7XG4gICAgICAvLyB3YWl0IGZvciBpdCB0byBnbyB0aHJvdWdoXG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCA1MDApKTtcbiAgICB9XG4gIH1cblxuICBwcm90ZWN0ZWQgc2tpcCgpIHtcbiAgICB0aGlzLnNldFN0YXR1cyhDaGVja1N0YXR1cy5TS0lQUEVEKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBhcHBlbmRNZXNzYWdlKG1lc3NhZ2U6IHN0cmluZykge1xuICAgIHRoaXMubG9ncy5wdXNoKHsgbGV2ZWw6ICdpbmZvJywgbWVzc2FnZSB9KTtcbiAgICB0aGlzLmVtaXQoJ3VwZGF0ZScsIHRoaXMuZ2V0SW5mbygpKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBhcHBlbmRXYXJuaW5nKG1lc3NhZ2U6IHN0cmluZykge1xuICAgIHRoaXMubG9ncy5wdXNoKHsgbGV2ZWw6ICd3YXJuaW5nJywgbWVzc2FnZSB9KTtcbiAgICB0aGlzLmVtaXQoJ3VwZGF0ZScsIHRoaXMuZ2V0SW5mbygpKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBhcHBlbmRFcnJvcihtZXNzYWdlOiBzdHJpbmcpIHtcbiAgICB0aGlzLmxvZ3MucHVzaCh7IGxldmVsOiAnZXJyb3InLCBtZXNzYWdlIH0pO1xuICAgIHRoaXMuZW1pdCgndXBkYXRlJywgdGhpcy5nZXRJbmZvKCkpO1xuICB9XG5cbiAgcHJvdGVjdGVkIHNldFN0YXR1cyhzdGF0dXM6IENoZWNrU3RhdHVzKSB7XG4gICAgdGhpcy5zdGF0dXMgPSBzdGF0dXM7XG4gICAgdGhpcy5lbWl0KCd1cGRhdGUnLCB0aGlzLmdldEluZm8oKSk7XG4gIH1cblxuICBwcm90ZWN0ZWQgZ2V0IGVuZ2luZSgpOiBSVENFbmdpbmUgfCB1bmRlZmluZWQge1xuICAgIHJldHVybiB0aGlzLnJvb20/LmVuZ2luZTtcbiAgfVxuXG4gIGdldEluZm8oKTogQ2hlY2tJbmZvIHtcbiAgICByZXR1cm4ge1xuICAgICAgbG9nczogdGhpcy5sb2dzLFxuICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgc3RhdHVzOiB0aGlzLnN0YXR1cyxcbiAgICAgIGRlc2NyaXB0aW9uOiB0aGlzLmRlc2NyaXB0aW9uLFxuICAgIH07XG4gIH1cbn1cbmV4cG9ydCB0eXBlIEluc3RhbnRpYWJsZUNoZWNrPFQgZXh0ZW5kcyBDaGVja2VyPiA9IHtcbiAgbmV3ICh1cmw6IHN0cmluZywgdG9rZW46IHN0cmluZywgb3B0aW9ucz86IENoZWNrZXJPcHRpb25zKTogVDtcbn07XG5cbnR5cGUgQ2hlY2tlckNhbGxiYWNrcyA9IHtcbiAgdXBkYXRlOiAoaW5mbzogQ2hlY2tJbmZvKSA9PiB2b2lkO1xufTtcbiIsImltcG9ydCBEZXZpY2VNYW5hZ2VyIGZyb20gJy4uL0RldmljZU1hbmFnZXInO1xuaW1wb3J0IHsgYXVkaW9EZWZhdWx0cywgdmlkZW9EZWZhdWx0cyB9IGZyb20gJy4uL2RlZmF1bHRzJztcbmltcG9ydCB7IERldmljZVVuc3VwcG9ydGVkRXJyb3IsIFRyYWNrSW52YWxpZEVycm9yIH0gZnJvbSAnLi4vZXJyb3JzJztcbmltcG9ydCB7IG1lZGlhVHJhY2tUb0xvY2FsVHJhY2sgfSBmcm9tICcuLi9wYXJ0aWNpcGFudC9wdWJsaXNoVXRpbHMnO1xuaW1wb3J0IHsgaXNTYWZhcmkxNyB9IGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCBMb2NhbEF1ZGlvVHJhY2sgZnJvbSAnLi9Mb2NhbEF1ZGlvVHJhY2snO1xuaW1wb3J0IHR5cGUgTG9jYWxUcmFjayBmcm9tICcuL0xvY2FsVHJhY2snO1xuaW1wb3J0IExvY2FsVmlkZW9UcmFjayBmcm9tICcuL0xvY2FsVmlkZW9UcmFjayc7XG5pbXBvcnQgeyBUcmFjayB9IGZyb20gJy4vVHJhY2snO1xuaW1wb3J0IHR5cGUge1xuICBBdWRpb0NhcHR1cmVPcHRpb25zLFxuICBDcmVhdGVMb2NhbFRyYWNrc09wdGlvbnMsXG4gIFNjcmVlblNoYXJlQ2FwdHVyZU9wdGlvbnMsXG4gIFZpZGVvQ2FwdHVyZU9wdGlvbnMsXG59IGZyb20gJy4vb3B0aW9ucyc7XG5pbXBvcnQgeyBTY3JlZW5TaGFyZVByZXNldHMgfSBmcm9tICcuL29wdGlvbnMnO1xuaW1wb3J0IHtcbiAgY29uc3RyYWludHNGb3JPcHRpb25zLFxuICBtZXJnZURlZmF1bHRPcHRpb25zLFxuICBzY3JlZW5DYXB0dXJlVG9EaXNwbGF5TWVkaWFTdHJlYW1PcHRpb25zLFxufSBmcm9tICcuL3V0aWxzJztcblxuLyoqXG4gKiBDcmVhdGVzIGEgbG9jYWwgdmlkZW8gYW5kIGF1ZGlvIHRyYWNrIGF0IHRoZSBzYW1lIHRpbWUuIFdoZW4gYWNxdWlyaW5nIGJvdGhcbiAqIGF1ZGlvIGFuZCB2aWRlbyB0cmFja3MgdG9nZXRoZXIsIGl0J2xsIGRpc3BsYXkgYSBzaW5nbGUgcGVybWlzc2lvbiBwcm9tcHQgdG9cbiAqIHRoZSB1c2VyIGluc3RlYWQgb2YgdHdvIHNlcGFyYXRlIG9uZXMuXG4gKiBAcGFyYW0gb3B0aW9uc1xuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY3JlYXRlTG9jYWxUcmFja3MoXG4gIG9wdGlvbnM/OiBDcmVhdGVMb2NhbFRyYWNrc09wdGlvbnMsXG4pOiBQcm9taXNlPEFycmF5PExvY2FsVHJhY2s+PiB7XG4gIC8vIHNldCBkZWZhdWx0IG9wdGlvbnMgdG8gdHJ1ZVxuICBvcHRpb25zID8/PSB7fTtcbiAgb3B0aW9ucy5hdWRpbyA/Pz0gdHJ1ZTtcbiAgb3B0aW9ucy52aWRlbyA/Pz0gdHJ1ZTtcblxuICBjb25zdCBvcHRzID0gbWVyZ2VEZWZhdWx0T3B0aW9ucyhvcHRpb25zLCBhdWRpb0RlZmF1bHRzLCB2aWRlb0RlZmF1bHRzKTtcbiAgY29uc3QgY29uc3RyYWludHMgPSBjb25zdHJhaW50c0Zvck9wdGlvbnMob3B0cyk7XG5cbiAgLy8gS2VlcCBhIHJlZmVyZW5jZSB0byB0aGUgcHJvbWlzZSBvbiBEZXZpY2VNYW5hZ2VyIGFuZCBhd2FpdCBpdCBpbiBnZXRMb2NhbERldmljZXMoKVxuICAvLyB3b3JrcyBhcm91bmQgaU9TIFNhZmFyaSBCdWcgaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTE3OTM2M1xuICBjb25zdCBtZWRpYVByb21pc2UgPSBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYShjb25zdHJhaW50cyk7XG5cbiAgaWYgKG9wdGlvbnMuYXVkaW8pIHtcbiAgICBEZXZpY2VNYW5hZ2VyLnVzZXJNZWRpYVByb21pc2VNYXAuc2V0KCdhdWRpb2lucHV0JywgbWVkaWFQcm9taXNlKTtcbiAgICBtZWRpYVByb21pc2UuY2F0Y2goKCkgPT4gRGV2aWNlTWFuYWdlci51c2VyTWVkaWFQcm9taXNlTWFwLmRlbGV0ZSgnYXVkaW9pbnB1dCcpKTtcbiAgfVxuICBpZiAob3B0aW9ucy52aWRlbykge1xuICAgIERldmljZU1hbmFnZXIudXNlck1lZGlhUHJvbWlzZU1hcC5zZXQoJ3ZpZGVvaW5wdXQnLCBtZWRpYVByb21pc2UpO1xuICAgIG1lZGlhUHJvbWlzZS5jYXRjaCgoKSA9PiBEZXZpY2VNYW5hZ2VyLnVzZXJNZWRpYVByb21pc2VNYXAuZGVsZXRlKCd2aWRlb2lucHV0JykpO1xuICB9XG5cbiAgY29uc3Qgc3RyZWFtID0gYXdhaXQgbWVkaWFQcm9taXNlO1xuICByZXR1cm4gc3RyZWFtLmdldFRyYWNrcygpLm1hcCgobWVkaWFTdHJlYW1UcmFjaykgPT4ge1xuICAgIGNvbnN0IGlzQXVkaW8gPSBtZWRpYVN0cmVhbVRyYWNrLmtpbmQgPT09ICdhdWRpbyc7XG4gICAgbGV0IHRyYWNrT3B0aW9ucyA9IGlzQXVkaW8gPyBvcHRpb25zIS5hdWRpbyA6IG9wdGlvbnMhLnZpZGVvO1xuICAgIGlmICh0eXBlb2YgdHJhY2tPcHRpb25zID09PSAnYm9vbGVhbicgfHwgIXRyYWNrT3B0aW9ucykge1xuICAgICAgdHJhY2tPcHRpb25zID0ge307XG4gICAgfVxuICAgIGxldCB0cmFja0NvbnN0cmFpbnRzOiBNZWRpYVRyYWNrQ29uc3RyYWludHMgfCB1bmRlZmluZWQ7XG4gICAgY29uc3QgY29uT3JCb29sID0gaXNBdWRpbyA/IGNvbnN0cmFpbnRzLmF1ZGlvIDogY29uc3RyYWludHMudmlkZW87XG4gICAgaWYgKHR5cGVvZiBjb25PckJvb2wgIT09ICdib29sZWFuJykge1xuICAgICAgdHJhY2tDb25zdHJhaW50cyA9IGNvbk9yQm9vbDtcbiAgICB9XG5cbiAgICAvLyB1cGRhdGUgdGhlIGNvbnN0cmFpbnRzIHdpdGggdGhlIGRldmljZSBpZCB0aGUgdXNlciBnYXZlIHBlcm1pc3Npb25zIHRvIGluIHRoZSBwZXJtaXNzaW9uIHByb21wdFxuICAgIC8vIG90aGVyd2lzZSBlYWNoIHRyYWNrIHJlc3RhcnQgKGUuZy4gbXV0ZSAtIHVubXV0ZSkgd2lsbCB0cnkgdG8gaW5pdGlhbGl6ZSB0aGUgZGV2aWNlIGFnYWluIC0+IGNhdXNpbmcgYWRkaXRpb25hbCBwZXJtaXNzaW9uIHByb21wdHNcbiAgICBpZiAodHJhY2tDb25zdHJhaW50cykge1xuICAgICAgdHJhY2tDb25zdHJhaW50cy5kZXZpY2VJZCA9IG1lZGlhU3RyZWFtVHJhY2suZ2V0U2V0dGluZ3MoKS5kZXZpY2VJZDtcbiAgICB9IGVsc2Uge1xuICAgICAgdHJhY2tDb25zdHJhaW50cyA9IHsgZGV2aWNlSWQ6IG1lZGlhU3RyZWFtVHJhY2suZ2V0U2V0dGluZ3MoKS5kZXZpY2VJZCB9O1xuICAgIH1cblxuICAgIGNvbnN0IHRyYWNrID0gbWVkaWFUcmFja1RvTG9jYWxUcmFjayhtZWRpYVN0cmVhbVRyYWNrLCB0cmFja0NvbnN0cmFpbnRzKTtcbiAgICBpZiAodHJhY2sua2luZCA9PT0gVHJhY2suS2luZC5WaWRlbykge1xuICAgICAgdHJhY2suc291cmNlID0gVHJhY2suU291cmNlLkNhbWVyYTtcbiAgICB9IGVsc2UgaWYgKHRyYWNrLmtpbmQgPT09IFRyYWNrLktpbmQuQXVkaW8pIHtcbiAgICAgIHRyYWNrLnNvdXJjZSA9IFRyYWNrLlNvdXJjZS5NaWNyb3Bob25lO1xuICAgIH1cbiAgICB0cmFjay5tZWRpYVN0cmVhbSA9IHN0cmVhbTtcbiAgICByZXR1cm4gdHJhY2s7XG4gIH0pO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBbW0xvY2FsVmlkZW9UcmFja11dIHdpdGggZ2V0VXNlck1lZGlhKClcbiAqIEBwYXJhbSBvcHRpb25zXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjcmVhdGVMb2NhbFZpZGVvVHJhY2soXG4gIG9wdGlvbnM/OiBWaWRlb0NhcHR1cmVPcHRpb25zLFxuKTogUHJvbWlzZTxMb2NhbFZpZGVvVHJhY2s+IHtcbiAgY29uc3QgdHJhY2tzID0gYXdhaXQgY3JlYXRlTG9jYWxUcmFja3Moe1xuICAgIGF1ZGlvOiBmYWxzZSxcbiAgICB2aWRlbzogb3B0aW9ucyxcbiAgfSk7XG4gIHJldHVybiA8TG9jYWxWaWRlb1RyYWNrPnRyYWNrc1swXTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNyZWF0ZUxvY2FsQXVkaW9UcmFjayhcbiAgb3B0aW9ucz86IEF1ZGlvQ2FwdHVyZU9wdGlvbnMsXG4pOiBQcm9taXNlPExvY2FsQXVkaW9UcmFjaz4ge1xuICBjb25zdCB0cmFja3MgPSBhd2FpdCBjcmVhdGVMb2NhbFRyYWNrcyh7XG4gICAgYXVkaW86IG9wdGlvbnMsXG4gICAgdmlkZW86IGZhbHNlLFxuICB9KTtcbiAgcmV0dXJuIDxMb2NhbEF1ZGlvVHJhY2s+dHJhY2tzWzBdO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBzY3JlZW4gY2FwdHVyZSB0cmFja3Mgd2l0aCBnZXREaXNwbGF5TWVkaWEoKS5cbiAqIEEgTG9jYWxWaWRlb1RyYWNrIGlzIGFsd2F5cyBjcmVhdGVkIGFuZCByZXR1cm5lZC5cbiAqIElmIHsgYXVkaW86IHRydWUgfSwgYW5kIHRoZSBicm93c2VyIHN1cHBvcnRzIGF1ZGlvIGNhcHR1cmUsIGEgTG9jYWxBdWRpb1RyYWNrIGlzIGFsc28gY3JlYXRlZC5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNyZWF0ZUxvY2FsU2NyZWVuVHJhY2tzKFxuICBvcHRpb25zPzogU2NyZWVuU2hhcmVDYXB0dXJlT3B0aW9ucyxcbik6IFByb21pc2U8QXJyYXk8TG9jYWxUcmFjaz4+IHtcbiAgaWYgKG9wdGlvbnMgPT09IHVuZGVmaW5lZCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuICBpZiAob3B0aW9ucy5yZXNvbHV0aW9uID09PSB1bmRlZmluZWQgJiYgIWlzU2FmYXJpMTcoKSkge1xuICAgIG9wdGlvbnMucmVzb2x1dGlvbiA9IFNjcmVlblNoYXJlUHJlc2V0cy5oMTA4MGZwczMwLnJlc29sdXRpb247XG4gIH1cblxuICBpZiAobmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXREaXNwbGF5TWVkaWEgPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBEZXZpY2VVbnN1cHBvcnRlZEVycm9yKCdnZXREaXNwbGF5TWVkaWEgbm90IHN1cHBvcnRlZCcpO1xuICB9XG5cbiAgY29uc3QgY29uc3RyYWludHMgPSBzY3JlZW5DYXB0dXJlVG9EaXNwbGF5TWVkaWFTdHJlYW1PcHRpb25zKG9wdGlvbnMpO1xuICBjb25zdCBzdHJlYW06IE1lZGlhU3RyZWFtID0gYXdhaXQgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXREaXNwbGF5TWVkaWEoY29uc3RyYWludHMpO1xuXG4gIGNvbnN0IHRyYWNrcyA9IHN0cmVhbS5nZXRWaWRlb1RyYWNrcygpO1xuICBpZiAodHJhY2tzLmxlbmd0aCA9PT0gMCkge1xuICAgIHRocm93IG5ldyBUcmFja0ludmFsaWRFcnJvcignbm8gdmlkZW8gdHJhY2sgZm91bmQnKTtcbiAgfVxuICBjb25zdCBzY3JlZW5WaWRlbyA9IG5ldyBMb2NhbFZpZGVvVHJhY2sodHJhY2tzWzBdLCB1bmRlZmluZWQsIGZhbHNlKTtcbiAgc2NyZWVuVmlkZW8uc291cmNlID0gVHJhY2suU291cmNlLlNjcmVlblNoYXJlO1xuICBjb25zdCBsb2NhbFRyYWNrczogQXJyYXk8TG9jYWxUcmFjaz4gPSBbc2NyZWVuVmlkZW9dO1xuICBpZiAoc3RyZWFtLmdldEF1ZGlvVHJhY2tzKCkubGVuZ3RoID4gMCkge1xuICAgIGNvbnN0IHNjcmVlbkF1ZGlvID0gbmV3IExvY2FsQXVkaW9UcmFjayhzdHJlYW0uZ2V0QXVkaW9UcmFja3MoKVswXSwgdW5kZWZpbmVkLCBmYWxzZSk7XG4gICAgc2NyZWVuQXVkaW8uc291cmNlID0gVHJhY2suU291cmNlLlNjcmVlblNoYXJlQXVkaW87XG4gICAgbG9jYWxUcmFja3MucHVzaChzY3JlZW5BdWRpbyk7XG4gIH1cbiAgcmV0dXJuIGxvY2FsVHJhY2tzO1xufVxuIiwiaW1wb3J0IHsgY3JlYXRlTG9jYWxBdWRpb1RyYWNrIH0gZnJvbSAnLi4vLi4vcm9vbS90cmFjay9jcmVhdGUnO1xuaW1wb3J0IHsgQ2hlY2tlciB9IGZyb20gJy4vQ2hlY2tlcic7XG5cbmV4cG9ydCBjbGFzcyBQdWJsaXNoQXVkaW9DaGVjayBleHRlbmRzIENoZWNrZXIge1xuICBnZXQgZGVzY3JpcHRpb24oKTogc3RyaW5nIHtcbiAgICByZXR1cm4gJ0NhbiBwdWJsaXNoIGF1ZGlvJztcbiAgfVxuXG4gIGFzeW5jIHBlcmZvcm0oKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3Qgcm9vbSA9IGF3YWl0IHRoaXMuY29ubmVjdCgpO1xuXG4gICAgY29uc3QgdHJhY2sgPSBhd2FpdCBjcmVhdGVMb2NhbEF1ZGlvVHJhY2soKTtcbiAgICByb29tLmxvY2FsUGFydGljaXBhbnQucHVibGlzaFRyYWNrKHRyYWNrKTtcbiAgICAvLyB3YWl0IGZvciBhIGZldyBzZWNvbmRzIHRvIHB1Ymxpc2hcbiAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCAzMDAwKSk7XG5cbiAgICAvLyB2ZXJpZnkgUlRDIHN0YXRzIHRoYXQgaXQncyBwdWJsaXNoaW5nXG4gICAgY29uc3Qgc3RhdHMgPSBhd2FpdCB0cmFjay5zZW5kZXI/LmdldFN0YXRzKCk7XG4gICAgaWYgKCFzdGF0cykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgZ2V0IFJUQ1N0YXRzJyk7XG4gICAgfVxuICAgIGxldCBudW1QYWNrZXRzID0gMDtcbiAgICBzdGF0cy5mb3JFYWNoKChzdGF0KSA9PiB7XG4gICAgICBpZiAoc3RhdC50eXBlID09PSAnb3V0Ym91bmQtcnRwJyAmJiBzdGF0Lm1lZGlhVHlwZSA9PT0gJ2F1ZGlvJykge1xuICAgICAgICBudW1QYWNrZXRzID0gc3RhdC5wYWNrZXRzU2VudDtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAobnVtUGFja2V0cyA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgZGV0ZXJtaW5lIHBhY2tldHMgYXJlIHNlbnQnKTtcbiAgICB9XG4gICAgdGhpcy5hcHBlbmRNZXNzYWdlKGBwdWJsaXNoZWQgJHtudW1QYWNrZXRzfSBhdWRpbyBwYWNrZXRzYCk7XG4gIH1cbn1cbiIsImltcG9ydCB7IGNyZWF0ZUxvY2FsVmlkZW9UcmFjayB9IGZyb20gJy4uLy4uL3Jvb20vdHJhY2svY3JlYXRlJztcbmltcG9ydCB7IENoZWNrZXIgfSBmcm9tICcuL0NoZWNrZXInO1xuXG5leHBvcnQgY2xhc3MgUHVibGlzaFZpZGVvQ2hlY2sgZXh0ZW5kcyBDaGVja2VyIHtcbiAgZ2V0IGRlc2NyaXB0aW9uKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuICdDYW4gcHVibGlzaCB2aWRlbyc7XG4gIH1cblxuICBhc3luYyBwZXJmb3JtKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnN0IHJvb20gPSBhd2FpdCB0aGlzLmNvbm5lY3QoKTtcblxuICAgIGNvbnN0IHRyYWNrID0gYXdhaXQgY3JlYXRlTG9jYWxWaWRlb1RyYWNrKCk7XG4gICAgcm9vbS5sb2NhbFBhcnRpY2lwYW50LnB1Ymxpc2hUcmFjayh0cmFjayk7XG4gICAgLy8gd2FpdCBmb3IgYSBmZXcgc2Vjb25kcyB0byBwdWJsaXNoXG4gICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMzAwMCkpO1xuXG4gICAgLy8gdmVyaWZ5IFJUQyBzdGF0cyB0aGF0IGl0J3MgcHVibGlzaGluZ1xuICAgIGNvbnN0IHN0YXRzID0gYXdhaXQgdHJhY2suc2VuZGVyPy5nZXRTdGF0cygpO1xuICAgIGlmICghc3RhdHMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGdldCBSVENTdGF0cycpO1xuICAgIH1cbiAgICBsZXQgbnVtUGFja2V0cyA9IDA7XG4gICAgc3RhdHMuZm9yRWFjaCgoc3RhdCkgPT4ge1xuICAgICAgaWYgKHN0YXQudHlwZSA9PT0gJ291dGJvdW5kLXJ0cCcgJiYgc3RhdC5tZWRpYVR5cGUgPT09ICd2aWRlbycpIHtcbiAgICAgICAgbnVtUGFja2V0cyA9IHN0YXQucGFja2V0c1NlbnQ7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKG51bVBhY2tldHMgPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGRldGVybWluZSBwYWNrZXRzIGFyZSBzZW50Jyk7XG4gICAgfVxuICAgIHRoaXMuYXBwZW5kTWVzc2FnZShgcHVibGlzaGVkICR7bnVtUGFja2V0c30gdmlkZW8gcGFja2V0c2ApO1xuICB9XG59XG4iLCJpbXBvcnQgeyBDb25uZWN0aW9uU3RhdGUgfSBmcm9tICcuLi8uLi9yb29tL1Jvb20nO1xuaW1wb3J0IHsgUm9vbUV2ZW50IH0gZnJvbSAnLi4vLi4vcm9vbS9ldmVudHMnO1xuaW1wb3J0IHsgQ2hlY2tlciB9IGZyb20gJy4vQ2hlY2tlcic7XG5cbmV4cG9ydCBjbGFzcyBSZWNvbm5lY3RDaGVjayBleHRlbmRzIENoZWNrZXIge1xuICBnZXQgZGVzY3JpcHRpb24oKTogc3RyaW5nIHtcbiAgICByZXR1cm4gJ1Jlc3VtaW5nIGNvbm5lY3Rpb24gYWZ0ZXIgaW50ZXJydXB0aW9uJztcbiAgfVxuXG4gIGFzeW5jIHBlcmZvcm0oKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3Qgcm9vbSA9IGF3YWl0IHRoaXMuY29ubmVjdCgpO1xuICAgIGxldCByZWNvbm5lY3RpbmdUcmlnZ2VyZWQgPSBmYWxzZTtcbiAgICBsZXQgcmVjb25uZWN0ZWQgPSBmYWxzZTtcblxuICAgIGxldCByZWNvbm5lY3RSZXNvbHZlcjogKHZhbHVlOiB1bmtub3duKSA9PiB2b2lkO1xuICAgIGNvbnN0IHJlY29ubmVjdFRpbWVvdXQgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgc2V0VGltZW91dChyZXNvbHZlLCA1MDAwKTtcbiAgICAgIHJlY29ubmVjdFJlc29sdmVyID0gcmVzb2x2ZTtcbiAgICB9KTtcblxuICAgIHJvb21cbiAgICAgIC5vbihSb29tRXZlbnQuUmVjb25uZWN0aW5nLCAoKSA9PiB7XG4gICAgICAgIHJlY29ubmVjdGluZ1RyaWdnZXJlZCA9IHRydWU7XG4gICAgICB9KVxuICAgICAgLm9uKFJvb21FdmVudC5SZWNvbm5lY3RlZCwgKCkgPT4ge1xuICAgICAgICByZWNvbm5lY3RlZCA9IHRydWU7XG4gICAgICAgIHJlY29ubmVjdFJlc29sdmVyKHRydWUpO1xuICAgICAgfSk7XG5cbiAgICByb29tLmVuZ2luZS5jbGllbnQud3M/LmNsb3NlKCk7XG4gICAgY29uc3Qgb25DbG9zZSA9IHJvb20uZW5naW5lLmNsaWVudC5vbkNsb3NlO1xuICAgIGlmIChvbkNsb3NlKSB7XG4gICAgICBvbkNsb3NlKCcnKTtcbiAgICB9XG5cbiAgICBhd2FpdCByZWNvbm5lY3RUaW1lb3V0O1xuXG4gICAgaWYgKCFyZWNvbm5lY3RpbmdUcmlnZ2VyZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRGlkIG5vdCBhdHRlbXB0IHRvIHJlY29ubmVjdCcpO1xuICAgIH0gZWxzZSBpZiAoIXJlY29ubmVjdGVkIHx8IHJvb20uc3RhdGUgIT09IENvbm5lY3Rpb25TdGF0ZS5Db25uZWN0ZWQpIHtcbiAgICAgIHRoaXMuYXBwZW5kV2FybmluZygncmVjb25uZWN0aW9uIGlzIG9ubHkgcG9zc2libGUgaW4gUmVkaXMtYmFzZWQgY29uZmlndXJhdGlvbnMnKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm90IGFibGUgdG8gcmVjb25uZWN0Jyk7XG4gICAgfVxuICB9XG59XG4iLCJpbXBvcnQgeyBTaWduYWxDbGllbnQgfSBmcm9tICcuLi8uLi9hcGkvU2lnbmFsQ2xpZW50JztcbmltcG9ydCB7IENoZWNrZXIgfSBmcm9tICcuL0NoZWNrZXInO1xuXG5leHBvcnQgY2xhc3MgVFVSTkNoZWNrIGV4dGVuZHMgQ2hlY2tlciB7XG4gIGdldCBkZXNjcmlwdGlvbigpOiBzdHJpbmcge1xuICAgIHJldHVybiAnQ2FuIGNvbm5lY3QgdmlhIFRVUk4nO1xuICB9XG5cbiAgYXN5bmMgcGVyZm9ybSgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCBzaWduYWxDbGllbnQgPSBuZXcgU2lnbmFsQ2xpZW50KCk7XG4gICAgY29uc3Qgam9pblJlcyA9IGF3YWl0IHNpZ25hbENsaWVudC5qb2luKHRoaXMudXJsLCB0aGlzLnRva2VuLCB7XG4gICAgICBhdXRvU3Vic2NyaWJlOiB0cnVlLFxuICAgICAgbWF4UmV0cmllczogMCxcbiAgICAgIGUyZWVFbmFibGVkOiBmYWxzZSxcbiAgICAgIHdlYnNvY2tldFRpbWVvdXQ6IDE1XzAwMCxcbiAgICB9KTtcblxuICAgIGxldCBoYXNUTFMgPSBmYWxzZTtcbiAgICBsZXQgaGFzVFVSTiA9IGZhbHNlO1xuICAgIGxldCBoYXNTVFVOID0gZmFsc2U7XG5cbiAgICBmb3IgKGxldCBpY2VTZXJ2ZXIgb2Ygam9pblJlcy5pY2VTZXJ2ZXJzKSB7XG4gICAgICBmb3IgKGxldCB1cmwgb2YgaWNlU2VydmVyLnVybHMpIHtcbiAgICAgICAgaWYgKHVybC5zdGFydHNXaXRoKCd0dXJuOicpKSB7XG4gICAgICAgICAgaGFzVFVSTiA9IHRydWU7XG4gICAgICAgICAgaGFzU1RVTiA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAodXJsLnN0YXJ0c1dpdGgoJ3R1cm5zOicpKSB7XG4gICAgICAgICAgaGFzVFVSTiA9IHRydWU7XG4gICAgICAgICAgaGFzU1RVTiA9IHRydWU7XG4gICAgICAgICAgaGFzVExTID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodXJsLnN0YXJ0c1dpdGgoJ3N0dW46JykpIHtcbiAgICAgICAgICBoYXNTVFVOID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWhhc1NUVU4pIHtcbiAgICAgIHRoaXMuYXBwZW5kV2FybmluZygnTm8gU1RVTiBzZXJ2ZXJzIGNvbmZpZ3VyZWQgb24gc2VydmVyIHNpZGUuJyk7XG4gICAgfSBlbHNlIGlmIChoYXNUVVJOICYmICFoYXNUTFMpIHtcbiAgICAgIHRoaXMuYXBwZW5kV2FybmluZygnVFVSTiBpcyBjb25maWd1cmVkIHNlcnZlciBzaWRlLCBidXQgVFVSTi9UTFMgaXMgdW5hdmFpbGFibGUuJyk7XG4gICAgfVxuICAgIGF3YWl0IHNpZ25hbENsaWVudC5jbG9zZSgpO1xuICAgIGlmICh0aGlzLmNvbm5lY3RPcHRpb25zPy5ydGNDb25maWc/LmljZVNlcnZlcnMgfHwgaGFzVFVSTikge1xuICAgICAgYXdhaXQgdGhpcy5yb29tIS5jb25uZWN0KHRoaXMudXJsLCB0aGlzLnRva2VuLCB7XG4gICAgICAgIHJ0Y0NvbmZpZzoge1xuICAgICAgICAgIGljZVRyYW5zcG9ydFBvbGljeTogJ3JlbGF5JyxcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFwcGVuZFdhcm5pbmcoJ05vIFRVUk4gc2VydmVycyBjb25maWd1cmVkLicpO1xuICAgICAgdGhpcy5za2lwKCk7XG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCAwKSk7XG4gICAgfVxuICB9XG59XG4iLCJpbXBvcnQgbG9nIGZyb20gJy4uLy4uL2xvZ2dlcic7XG5pbXBvcnQgeyBSb29tRXZlbnQgfSBmcm9tICcuLi8uLi9yb29tL2V2ZW50cyc7XG5pbXBvcnQgeyBDaGVja2VyIH0gZnJvbSAnLi9DaGVja2VyJztcblxuZXhwb3J0IGNsYXNzIFdlYlJUQ0NoZWNrIGV4dGVuZHMgQ2hlY2tlciB7XG4gIGdldCBkZXNjcmlwdGlvbigpOiBzdHJpbmcge1xuICAgIHJldHVybiAnRXN0YWJsaXNoaW5nIFdlYlJUQyBjb25uZWN0aW9uJztcbiAgfVxuXG4gIHByb3RlY3RlZCBhc3luYyBwZXJmb3JtKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIGxldCBoYXNUY3AgPSBmYWxzZTtcbiAgICBsZXQgaGFzSXB2NFVkcCA9IGZhbHNlO1xuICAgIHRoaXMucm9vbS5vbihSb29tRXZlbnQuU2lnbmFsQ29ubmVjdGVkLCAoKSA9PiB7XG4gICAgICBjb25zdCBwcmV2VHJpY2tsZSA9IHRoaXMucm9vbS5lbmdpbmUuY2xpZW50Lm9uVHJpY2tsZTtcblxuICAgICAgY29uc3QgY2FuZGlkYXRlczogUlRDSWNlQ2FuZGlkYXRlW10gPSBbXTtcbiAgICAgIHRoaXMucm9vbS5lbmdpbmUuY2xpZW50Lm9uVHJpY2tsZSA9IChzZCwgdGFyZ2V0KSA9PiB7XG4gICAgICAgIGlmIChzZC5jYW5kaWRhdGUpIHtcbiAgICAgICAgICBjb25zdCBjYW5kaWRhdGUgPSBuZXcgUlRDSWNlQ2FuZGlkYXRlKHNkKTtcbiAgICAgICAgICBjYW5kaWRhdGVzLnB1c2goY2FuZGlkYXRlKTtcbiAgICAgICAgICBsZXQgc3RyID0gYCR7Y2FuZGlkYXRlLnByb3RvY29sfSAke2NhbmRpZGF0ZS5hZGRyZXNzfToke2NhbmRpZGF0ZS5wb3J0fSAke2NhbmRpZGF0ZS50eXBlfWA7XG4gICAgICAgICAgaWYgKGNhbmRpZGF0ZS5hZGRyZXNzKSB7XG4gICAgICAgICAgICBpZiAoaXNJUFByaXZhdGUoY2FuZGlkYXRlLmFkZHJlc3MpKSB7XG4gICAgICAgICAgICAgIHN0ciArPSAnIChwcml2YXRlKSc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAoY2FuZGlkYXRlLnByb3RvY29sID09PSAndGNwJyAmJiBjYW5kaWRhdGUudGNwVHlwZSA9PT0gJ3Bhc3NpdmUnKSB7XG4gICAgICAgICAgICAgICAgaGFzVGNwID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBzdHIgKz0gJyAocGFzc2l2ZSknO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNhbmRpZGF0ZS5wcm90b2NvbCA9PT0gJ3VkcCcpIHtcbiAgICAgICAgICAgICAgICBoYXNJcHY0VWRwID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmFwcGVuZE1lc3NhZ2Uoc3RyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJldlRyaWNrbGUpIHtcbiAgICAgICAgICBwcmV2VHJpY2tsZShzZCwgdGFyZ2V0KTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgaWYgKHRoaXMucm9vbS5lbmdpbmUucGNNYW5hZ2VyKSB7XG4gICAgICAgIHRoaXMucm9vbS5lbmdpbmUucGNNYW5hZ2VyLnN1YnNjcmliZXIub25JY2VDYW5kaWRhdGVFcnJvciA9IChldikgPT4ge1xuICAgICAgICAgIGlmIChldiBpbnN0YW5jZW9mIFJUQ1BlZXJDb25uZWN0aW9uSWNlRXJyb3JFdmVudCkge1xuICAgICAgICAgICAgdGhpcy5hcHBlbmRXYXJuaW5nKFxuICAgICAgICAgICAgICBgZXJyb3Igd2l0aCBJQ0UgY2FuZGlkYXRlOiAke2V2LmVycm9yQ29kZX0gJHtldi5lcnJvclRleHR9ICR7ZXYudXJsfWAsXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgdGhpcy5jb25uZWN0KCk7XG4gICAgICBsb2cuaW5mbygnbm93IHRoZSByb29tIGlzIGNvbm5lY3RlZCcpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdGhpcy5hcHBlbmRXYXJuaW5nKCdwb3J0cyBuZWVkIHRvIGJlIG9wZW4gb24gZmlyZXdhbGwgaW4gb3JkZXIgdG8gY29ubmVjdC4nKTtcbiAgICAgIHRocm93IGVycjtcbiAgICB9XG4gICAgaWYgKCFoYXNUY3ApIHtcbiAgICAgIHRoaXMuYXBwZW5kV2FybmluZygnU2VydmVyIGlzIG5vdCBjb25maWd1cmVkIGZvciBJQ0UvVENQJyk7XG4gICAgfVxuICAgIGlmICghaGFzSXB2NFVkcCkge1xuICAgICAgdGhpcy5hcHBlbmRXYXJuaW5nKFxuICAgICAgICAnTm8gcHVibGljIElQdjQgVURQIGNhbmRpZGF0ZXMgd2VyZSBmb3VuZC4gWW91ciBzZXJ2ZXIgaXMgbGlrZWx5IG5vdCBjb25maWd1cmVkIGNvcnJlY3RseScsXG4gICAgICApO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBpc0lQUHJpdmF0ZShhZGRyZXNzOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgY29uc3QgcGFydHMgPSBhZGRyZXNzLnNwbGl0KCcuJyk7XG4gIGlmIChwYXJ0cy5sZW5ndGggPT09IDQpIHtcbiAgICBpZiAocGFydHNbMF0gPT09ICcxMCcpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAocGFydHNbMF0gPT09ICcxOTInICYmIHBhcnRzWzFdID09PSAnMTY4Jykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmIChwYXJ0c1swXSA9PT0gJzE3MicpIHtcbiAgICAgIGNvbnN0IHNlY29uZCA9IHBhcnNlSW50KHBhcnRzWzFdLCAxMCk7XG4gICAgICBpZiAoc2Vjb25kID49IDE2ICYmIHNlY29uZCA8PSAzMSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuIiwiaW1wb3J0IHsgU2lnbmFsQ2xpZW50IH0gZnJvbSAnLi4vLi4vYXBpL1NpZ25hbENsaWVudCc7XG5pbXBvcnQgeyBTZXJ2ZXJJbmZvX0VkaXRpb24gfSBmcm9tICcuLi8uLi9wcm90by9saXZla2l0X21vZGVsc19wYic7XG5pbXBvcnQgeyBDaGVja2VyIH0gZnJvbSAnLi9DaGVja2VyJztcblxuZXhwb3J0IGNsYXNzIFdlYlNvY2tldENoZWNrIGV4dGVuZHMgQ2hlY2tlciB7XG4gIGdldCBkZXNjcmlwdGlvbigpOiBzdHJpbmcge1xuICAgIHJldHVybiAnQ29ubmVjdGluZyB0byBzaWduYWwgY29ubmVjdGlvbiB2aWEgV2ViU29ja2V0JztcbiAgfVxuXG4gIHByb3RlY3RlZCBhc3luYyBwZXJmb3JtKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIGlmICh0aGlzLnVybC5zdGFydHNXaXRoKCd3czonKSB8fCB0aGlzLnVybC5zdGFydHNXaXRoKCdodHRwOicpKSB7XG4gICAgICB0aGlzLmFwcGVuZFdhcm5pbmcoJ1NlcnZlciBpcyBpbnNlY3VyZSwgY2xpZW50cyBtYXkgYmxvY2sgY29ubmVjdGlvbnMgdG8gaXQnKTtcbiAgICB9XG5cbiAgICBsZXQgc2lnbmFsQ2xpZW50ID0gbmV3IFNpZ25hbENsaWVudCgpO1xuICAgIGNvbnN0IGpvaW5SZXMgPSBhd2FpdCBzaWduYWxDbGllbnQuam9pbih0aGlzLnVybCwgdGhpcy50b2tlbiwge1xuICAgICAgYXV0b1N1YnNjcmliZTogdHJ1ZSxcbiAgICAgIG1heFJldHJpZXM6IDAsXG4gICAgICBlMmVlRW5hYmxlZDogZmFsc2UsXG4gICAgICB3ZWJzb2NrZXRUaW1lb3V0OiAxNV8wMDAsXG4gICAgfSk7XG4gICAgdGhpcy5hcHBlbmRNZXNzYWdlKGBDb25uZWN0ZWQgdG8gc2VydmVyLCB2ZXJzaW9uICR7am9pblJlcy5zZXJ2ZXJWZXJzaW9ufS5gKTtcbiAgICBpZiAoam9pblJlcy5zZXJ2ZXJJbmZvPy5lZGl0aW9uID09PSBTZXJ2ZXJJbmZvX0VkaXRpb24uQ2xvdWQgJiYgam9pblJlcy5zZXJ2ZXJJbmZvPy5yZWdpb24pIHtcbiAgICAgIHRoaXMuYXBwZW5kTWVzc2FnZShgTGl2ZUtpdCBDbG91ZDogJHtqb2luUmVzLnNlcnZlckluZm8/LnJlZ2lvbn1gKTtcbiAgICB9XG4gICAgYXdhaXQgc2lnbmFsQ2xpZW50LmNsb3NlKCk7XG4gIH1cbn1cbiIsImltcG9ydCB7IEV2ZW50RW1pdHRlciB9IGZyb20gJ2V2ZW50cyc7XG5pbXBvcnQgdHlwZSBUeXBlZEVtaXR0ZXIgZnJvbSAndHlwZWQtZW1pdHRlcic7XG5pbXBvcnQgeyBDaGVja1N0YXR1cywgQ2hlY2tlciB9IGZyb20gJy4vY2hlY2tzL0NoZWNrZXInO1xuaW1wb3J0IHR5cGUgeyBDaGVja0luZm8sIEluc3RhbnRpYWJsZUNoZWNrIH0gZnJvbSAnLi9jaGVja3MvQ2hlY2tlcic7XG5pbXBvcnQgeyBQdWJsaXNoQXVkaW9DaGVjayB9IGZyb20gJy4vY2hlY2tzL3B1Ymxpc2hBdWRpbyc7XG5pbXBvcnQgeyBQdWJsaXNoVmlkZW9DaGVjayB9IGZyb20gJy4vY2hlY2tzL3B1Ymxpc2hWaWRlbyc7XG5pbXBvcnQgeyBSZWNvbm5lY3RDaGVjayB9IGZyb20gJy4vY2hlY2tzL3JlY29ubmVjdCc7XG5pbXBvcnQgeyBUVVJOQ2hlY2sgfSBmcm9tICcuL2NoZWNrcy90dXJuJztcbmltcG9ydCB7IFdlYlJUQ0NoZWNrIH0gZnJvbSAnLi9jaGVja3Mvd2VicnRjJztcbmltcG9ydCB7IFdlYlNvY2tldENoZWNrIH0gZnJvbSAnLi9jaGVja3Mvd2Vic29ja2V0JztcblxuZXhwb3J0IHR5cGUgeyBDaGVja0luZm8sIENoZWNrU3RhdHVzIH07XG5cbmV4cG9ydCBjbGFzcyBDb25uZWN0aW9uQ2hlY2sgZXh0ZW5kcyAoRXZlbnRFbWl0dGVyIGFzIG5ldyAoKSA9PiBUeXBlZEVtaXR0ZXI8Q29ubmVjdGlvbkNoZWNrQ2FsbGJhY2tzPikge1xuICB0b2tlbjogc3RyaW5nO1xuXG4gIHVybDogc3RyaW5nO1xuXG4gIHByaXZhdGUgY2hlY2tSZXN1bHRzOiBNYXA8bnVtYmVyLCBDaGVja0luZm8+ID0gbmV3IE1hcCgpO1xuXG4gIGNvbnN0cnVjdG9yKHVybDogc3RyaW5nLCB0b2tlbjogc3RyaW5nKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnVybCA9IHVybDtcbiAgICB0aGlzLnRva2VuID0gdG9rZW47XG4gIH1cblxuICBwcml2YXRlIGdldE5leHRDaGVja0lkKCkge1xuICAgIGNvbnN0IG5leHRJZCA9IHRoaXMuY2hlY2tSZXN1bHRzLnNpemU7XG4gICAgdGhpcy5jaGVja1Jlc3VsdHMuc2V0KG5leHRJZCwge1xuICAgICAgbG9nczogW10sXG4gICAgICBzdGF0dXM6IENoZWNrU3RhdHVzLklETEUsXG4gICAgICBuYW1lOiAnJyxcbiAgICAgIGRlc2NyaXB0aW9uOiAnJyxcbiAgICB9KTtcbiAgICByZXR1cm4gbmV4dElkO1xuICB9XG5cbiAgcHJpdmF0ZSB1cGRhdGVDaGVjayhjaGVja0lkOiBudW1iZXIsIGluZm86IENoZWNrSW5mbykge1xuICAgIHRoaXMuY2hlY2tSZXN1bHRzLnNldChjaGVja0lkLCBpbmZvKTtcbiAgICB0aGlzLmVtaXQoJ2NoZWNrVXBkYXRlJywgY2hlY2tJZCwgaW5mbyk7XG4gIH1cblxuICBpc1N1Y2Nlc3MoKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5jaGVja1Jlc3VsdHMudmFsdWVzKCkpLmV2ZXJ5KChyKSA9PiByLnN0YXR1cyAhPT0gQ2hlY2tTdGF0dXMuRkFJTEVEKTtcbiAgfVxuXG4gIGdldFJlc3VsdHMoKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5jaGVja1Jlc3VsdHMudmFsdWVzKCkpO1xuICB9XG5cbiAgYXN5bmMgY3JlYXRlQW5kUnVuQ2hlY2s8VCBleHRlbmRzIENoZWNrZXI+KGNoZWNrOiBJbnN0YW50aWFibGVDaGVjazxUPikge1xuICAgIGNvbnN0IGNoZWNrSWQgPSB0aGlzLmdldE5leHRDaGVja0lkKCk7XG4gICAgY29uc3QgdGVzdCA9IG5ldyBjaGVjayh0aGlzLnVybCwgdGhpcy50b2tlbik7XG4gICAgY29uc3QgaGFuZGxlVXBkYXRlID0gKGluZm86IENoZWNrSW5mbykgPT4ge1xuICAgICAgdGhpcy51cGRhdGVDaGVjayhjaGVja0lkLCBpbmZvKTtcbiAgICB9O1xuICAgIHRlc3Qub24oJ3VwZGF0ZScsIGhhbmRsZVVwZGF0ZSk7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGVzdC5ydW4oKTtcbiAgICB0ZXN0Lm9mZigndXBkYXRlJywgaGFuZGxlVXBkYXRlKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgYXN5bmMgY2hlY2tXZWJzb2NrZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuY3JlYXRlQW5kUnVuQ2hlY2soV2ViU29ja2V0Q2hlY2spO1xuICB9XG5cbiAgYXN5bmMgY2hlY2tXZWJSVEMoKSB7XG4gICAgcmV0dXJuIHRoaXMuY3JlYXRlQW5kUnVuQ2hlY2soV2ViUlRDQ2hlY2spO1xuICB9XG5cbiAgYXN5bmMgY2hlY2tUVVJOKCkge1xuICAgIHJldHVybiB0aGlzLmNyZWF0ZUFuZFJ1bkNoZWNrKFRVUk5DaGVjayk7XG4gIH1cblxuICBhc3luYyBjaGVja1JlY29ubmVjdCgpIHtcbiAgICByZXR1cm4gdGhpcy5jcmVhdGVBbmRSdW5DaGVjayhSZWNvbm5lY3RDaGVjayk7XG4gIH1cblxuICBhc3luYyBjaGVja1B1Ymxpc2hBdWRpbygpIHtcbiAgICByZXR1cm4gdGhpcy5jcmVhdGVBbmRSdW5DaGVjayhQdWJsaXNoQXVkaW9DaGVjayk7XG4gIH1cblxuICBhc3luYyBjaGVja1B1Ymxpc2hWaWRlbygpIHtcbiAgICByZXR1cm4gdGhpcy5jcmVhdGVBbmRSdW5DaGVjayhQdWJsaXNoVmlkZW9DaGVjayk7XG4gIH1cbn1cblxudHlwZSBDb25uZWN0aW9uQ2hlY2tDYWxsYmFja3MgPSB7XG4gIGNoZWNrVXBkYXRlOiAoaWQ6IG51bWJlciwgaW5mbzogQ2hlY2tJbmZvKSA9PiB2b2lkO1xufTtcbiIsImltcG9ydCBsb2cgZnJvbSAnLi4vLi4vbG9nZ2VyJztcbmltcG9ydCBMb2NhbFRyYWNrIGZyb20gJy4vTG9jYWxUcmFjayc7XG5pbXBvcnQgdHlwZSB7IFZpZGVvQ2FwdHVyZU9wdGlvbnMgfSBmcm9tICcuL29wdGlvbnMnO1xuXG50eXBlIEZhY2luZ01vZGUgPSBOb25OdWxsYWJsZTxWaWRlb0NhcHR1cmVPcHRpb25zWydmYWNpbmdNb2RlJ10+O1xudHlwZSBGYWNpbmdNb2RlRnJvbUxvY2FsVHJhY2tPcHRpb25zID0ge1xuICAvKipcbiAgICogSWYgbm8gZmFjaW5nIG1vZGUgY2FuIGJlIGRldGVybWluZWQsIHRoaXMgdmFsdWUgd2lsbCBiZSB1c2VkLlxuICAgKiBAZGVmYXVsdFZhbHVlICd1c2VyJ1xuICAgKi9cbiAgZGVmYXVsdEZhY2luZ01vZGU/OiBGYWNpbmdNb2RlO1xufTtcbnR5cGUgRmFjaW5nTW9kZUZyb21Mb2NhbFRyYWNrUmV0dXJuVmFsdWUgPSB7XG4gIC8qKlxuICAgKiBUaGUgKHByb2JhYmxlKSBmYWNpbmdNb2RlIG9mIHRoZSB0cmFjay5cbiAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL01lZGlhVHJhY2tDb25zdHJhaW50cy9mYWNpbmdNb2RlIHwgTUROIGRvY3Mgb24gZmFjaW5nTW9kZX1cbiAgICovXG4gIGZhY2luZ01vZGU6IEZhY2luZ01vZGU7XG4gIC8qKlxuICAgKiBUaGUgY29uZmlkZW5jZSB0aGF0IHRoZSByZXR1cm5lZCBmYWNpbmdNb2RlIGlzIGNvcnJlY3QuXG4gICAqL1xuICBjb25maWRlbmNlOiAnaGlnaCcgfCAnbWVkaXVtJyB8ICdsb3cnO1xufTtcblxuLyoqXG4gKiBUcnkgdG8gYW5hbHl6ZSB0aGUgbG9jYWwgdHJhY2sgdG8gZGV0ZXJtaW5lIHRoZSBmYWNpbmcgbW9kZSBvZiBhIHRyYWNrLlxuICpcbiAqIEByZW1hcmtzXG4gKiBUaGVyZSBpcyBubyBwcm9wZXJ0eSBzdXBwb3J0ZWQgYnkgYWxsIGJyb3dzZXJzIHRvIGRldGVjdCB3aGV0aGVyIGEgdmlkZW8gdHJhY2sgb3JpZ2luYXRlZCBmcm9tIGEgdXNlci0gb3IgZW52aXJvbm1lbnQtZmFjaW5nIGNhbWVyYSBkZXZpY2UuXG4gKiBGb3IgdGhpcyByZWFzb24sIHdlIHVzZSB0aGUgYGZhY2luZ01vZGVgIHByb3BlcnR5IHdoZW4gYXZhaWxhYmxlLCBidXQgd2lsbCBmYWxsIGJhY2sgb24gYSBzdHJpbmctYmFzZWQgYW5hbHlzaXMgb2YgdGhlIGRldmljZSBsYWJlbCB0byBkZXRlcm1pbmUgdGhlIGZhY2luZyBtb2RlLlxuICogSWYgYm90aCBtZXRob2RzIGZhaWwsIHRoZSBkZWZhdWx0IGZhY2luZyBtb2RlIHdpbGwgYmUgdXNlZC5cbiAqXG4gKiBAc2VlIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvTWVkaWFUcmFja0NvbnN0cmFpbnRzL2ZhY2luZ01vZGUgfCBNRE4gZG9jcyBvbiBmYWNpbmdNb2RlfVxuICogQGV4cGVyaW1lbnRhbFxuICovXG5leHBvcnQgZnVuY3Rpb24gZmFjaW5nTW9kZUZyb21Mb2NhbFRyYWNrKFxuICBsb2NhbFRyYWNrOiBMb2NhbFRyYWNrIHwgTWVkaWFTdHJlYW1UcmFjayxcbiAgb3B0aW9uczogRmFjaW5nTW9kZUZyb21Mb2NhbFRyYWNrT3B0aW9ucyA9IHt9LFxuKTogRmFjaW5nTW9kZUZyb21Mb2NhbFRyYWNrUmV0dXJuVmFsdWUge1xuICBjb25zdCB0cmFjayA9IGxvY2FsVHJhY2sgaW5zdGFuY2VvZiBMb2NhbFRyYWNrID8gbG9jYWxUcmFjay5tZWRpYVN0cmVhbVRyYWNrIDogbG9jYWxUcmFjaztcbiAgY29uc3QgdHJhY2tTZXR0aW5ncyA9IHRyYWNrLmdldFNldHRpbmdzKCk7XG4gIGxldCByZXN1bHQ6IEZhY2luZ01vZGVGcm9tTG9jYWxUcmFja1JldHVyblZhbHVlID0ge1xuICAgIGZhY2luZ01vZGU6IG9wdGlvbnMuZGVmYXVsdEZhY2luZ01vZGUgPz8gJ3VzZXInLFxuICAgIGNvbmZpZGVuY2U6ICdsb3cnLFxuICB9O1xuXG4gIC8vIDEuIFRyeSB0byBnZXQgZmFjaW5nTW9kZSBmcm9tIHRyYWNrIHNldHRpbmdzLlxuICBpZiAoJ2ZhY2luZ01vZGUnIGluIHRyYWNrU2V0dGluZ3MpIHtcbiAgICBjb25zdCByYXdGYWNpbmdNb2RlID0gdHJhY2tTZXR0aW5ncy5mYWNpbmdNb2RlO1xuICAgIGxvZy5kZWJ1ZygncmF3RmFjaW5nTW9kZScsIHsgcmF3RmFjaW5nTW9kZSB9KTtcbiAgICBpZiAocmF3RmFjaW5nTW9kZSAmJiB0eXBlb2YgcmF3RmFjaW5nTW9kZSA9PT0gJ3N0cmluZycgJiYgaXNGYWNpbmdNb2RlVmFsdWUocmF3RmFjaW5nTW9kZSkpIHtcbiAgICAgIHJlc3VsdCA9IHsgZmFjaW5nTW9kZTogcmF3RmFjaW5nTW9kZSwgY29uZmlkZW5jZTogJ2hpZ2gnIH07XG4gICAgfVxuICB9XG5cbiAgLy8gMi4gSWYgd2UgZG9uJ3QgaGF2ZSBhIGhpZ2ggY29uZmlkZW5jZSB3ZSB0cnkgdG8gZ2V0IHRoZSBmYWNpbmcgbW9kZSBmcm9tIHRoZSBkZXZpY2UgbGFiZWwuXG4gIGlmIChbJ2xvdycsICdtZWRpdW0nXS5pbmNsdWRlcyhyZXN1bHQuY29uZmlkZW5jZSkpIHtcbiAgICBsb2cuZGVidWcoYFRyeSB0byBnZXQgZmFjaW5nIG1vZGUgZnJvbSBkZXZpY2UgbGFiZWw6ICgke3RyYWNrLmxhYmVsfSlgKTtcbiAgICBjb25zdCBsYWJlbEFuYWx5c2lzUmVzdWx0ID0gZmFjaW5nTW9kZUZyb21EZXZpY2VMYWJlbCh0cmFjay5sYWJlbCk7XG4gICAgaWYgKGxhYmVsQW5hbHlzaXNSZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmVzdWx0ID0gbGFiZWxBbmFseXNpc1Jlc3VsdDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5jb25zdCBrbm93bkRldmljZUxhYmVscyA9IG5ldyBNYXA8c3RyaW5nLCBGYWNpbmdNb2RlRnJvbUxvY2FsVHJhY2tSZXR1cm5WYWx1ZT4oW1xuICBbJ29icyB2aXJ0dWFsIGNhbWVyYScsIHsgZmFjaW5nTW9kZTogJ2Vudmlyb25tZW50JywgY29uZmlkZW5jZTogJ21lZGl1bScgfV0sXG5dKTtcbmNvbnN0IGtub3duRGV2aWNlTGFiZWxTZWN0aW9ucyA9IG5ldyBNYXA8c3RyaW5nLCBGYWNpbmdNb2RlRnJvbUxvY2FsVHJhY2tSZXR1cm5WYWx1ZT4oW1xuICBbJ2lwaG9uZScsIHsgZmFjaW5nTW9kZTogJ2Vudmlyb25tZW50JywgY29uZmlkZW5jZTogJ21lZGl1bScgfV0sXG4gIFsnaXBhZCcsIHsgZmFjaW5nTW9kZTogJ2Vudmlyb25tZW50JywgY29uZmlkZW5jZTogJ21lZGl1bScgfV0sXG5dKTtcbi8qKlxuICogQXR0ZW1wdCB0byBhbmFseXplIHRoZSBkZXZpY2UgbGFiZWwgdG8gZGV0ZXJtaW5lIHRoZSBmYWNpbmcgbW9kZS5cbiAqXG4gKiBAZXhwZXJpbWVudGFsXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmYWNpbmdNb2RlRnJvbURldmljZUxhYmVsKFxuICBkZXZpY2VMYWJlbDogc3RyaW5nLFxuKTogRmFjaW5nTW9kZUZyb21Mb2NhbFRyYWNrUmV0dXJuVmFsdWUgfCB1bmRlZmluZWQge1xuICBjb25zdCBsYWJlbCA9IGRldmljZUxhYmVsLnRyaW0oKS50b0xvd2VyQ2FzZSgpO1xuICAvLyBFbXB0eSBzdHJpbmcgaXMgYSB2YWxpZCBkZXZpY2UgbGFiZWwgYnV0IHdlIGNhbid0IGluZmVyIGFueXRoaW5nIGZyb20gaXQuXG4gIGlmIChsYWJlbCA9PT0gJycpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgLy8gQ2FuIHdlIG1hdGNoIGFnYWluc3Qgd2lkZWx5IGtub3duIGRldmljZSBsYWJlbHMuXG4gIGlmIChrbm93bkRldmljZUxhYmVscy5oYXMobGFiZWwpKSB7XG4gICAgcmV0dXJuIGtub3duRGV2aWNlTGFiZWxzLmdldChsYWJlbCk7XG4gIH1cblxuICAvLyBDYW4gd2UgbWF0Y2ggYWdhaW5zdCBzZWN0aW9ucyBvZiB0aGUgZGV2aWNlIGxhYmVsLlxuICByZXR1cm4gQXJyYXkuZnJvbShrbm93bkRldmljZUxhYmVsU2VjdGlvbnMuZW50cmllcygpKS5maW5kKChbc2VjdGlvbl0pID0+XG4gICAgbGFiZWwuaW5jbHVkZXMoc2VjdGlvbiksXG4gICk/LlsxXTtcbn1cblxuZnVuY3Rpb24gaXNGYWNpbmdNb2RlVmFsdWUoaXRlbTogc3RyaW5nKTogaXRlbSBpcyBGYWNpbmdNb2RlIHtcbiAgY29uc3QgYWxsb3dlZFZhbHVlczogRmFjaW5nTW9kZVtdID0gWyd1c2VyJywgJ2Vudmlyb25tZW50JywgJ2xlZnQnLCAncmlnaHQnXTtcbiAgcmV0dXJuIGl0ZW0gPT09IHVuZGVmaW5lZCB8fCBhbGxvd2VkVmFsdWVzLmluY2x1ZGVzKGl0ZW0gYXMgRmFjaW5nTW9kZSk7XG59XG4iXSwibmFtZXMiOlsicm9vdCIsImRlZmluaXRpb24iLCJtb2R1bGUiLCJleHBvcnRzIiwibG9nIiwidGhpcyIsIm5vb3AiLCJ1bmRlZmluZWRUeXBlIiwiaXNJRSIsIndpbmRvdyIsIm5hdmlnYXRvciIsInRlc3QiLCJ1c2VyQWdlbnQiLCJsb2dNZXRob2RzIiwiYmluZE1ldGhvZCIsIm9iaiIsIm1ldGhvZE5hbWUiLCJtZXRob2QiLCJiaW5kIiwiRnVuY3Rpb24iLCJwcm90b3R5cGUiLCJjYWxsIiwiZSIsImFwcGx5IiwiYXJndW1lbnRzIiwidHJhY2VGb3JJRSIsImNvbnNvbGUiLCJ0cmFjZSIsInJlYWxNZXRob2QiLCJ1bmRlZmluZWQiLCJyZXBsYWNlTG9nZ2luZ01ldGhvZHMiLCJsZXZlbCIsImxvZ2dlck5hbWUiLCJpIiwibGVuZ3RoIiwibWV0aG9kRmFjdG9yeSIsImRlYnVnIiwiZW5hYmxlTG9nZ2luZ1doZW5Db25zb2xlQXJyaXZlcyIsImRlZmF1bHRNZXRob2RGYWN0b3J5IiwiTG9nZ2VyIiwibmFtZSIsImRlZmF1bHRMZXZlbCIsImZhY3RvcnkiLCJzZWxmIiwiY3VycmVudExldmVsIiwic3RvcmFnZUtleSIsInBlcnNpc3RMZXZlbElmUG9zc2libGUiLCJsZXZlbE51bSIsImxldmVsTmFtZSIsInRvVXBwZXJDYXNlIiwibG9jYWxTdG9yYWdlIiwiaWdub3JlIiwiZG9jdW1lbnQiLCJjb29raWUiLCJlbmNvZGVVUklDb21wb25lbnQiLCJnZXRQZXJzaXN0ZWRMZXZlbCIsInN0b3JlZExldmVsIiwibG9jYXRpb24iLCJpbmRleE9mIiwiZXhlYyIsInNsaWNlIiwibGV2ZWxzIiwiY2xlYXJQZXJzaXN0ZWRMZXZlbCIsInJlbW92ZUl0ZW0iLCJnZXRMZXZlbCIsInNldExldmVsIiwicGVyc2lzdCIsIlNJTEVOVCIsInNldERlZmF1bHRMZXZlbCIsInJlc2V0TGV2ZWwiLCJlbmFibGVBbGwiLCJUUkFDRSIsImRpc2FibGVBbGwiLCJpbml0aWFsTGV2ZWwiLCJkZWZhdWx0TG9nZ2VyIiwiX2xvZ2dlcnNCeU5hbWUiLCJnZXRMb2dnZXIiLCJUeXBlRXJyb3IiLCJsb2dnZXIiLCJfbG9nIiwibm9Db25mbGljdCIsImdldExvZ2dlcnMiLCJMb2dMZXZlbCIsIkxvZ2dlck5hbWVzIiwibGl2ZWtpdExvZ2dlciIsImluZm8iLCJzZXRMb2dMZXZlbCIsIk9iamVjdCIsImVudHJpZXMiLCJmaWx0ZXIiLCJfcmVmIiwibG9nck5hbWUiLCJzdGFydHNXaXRoIiwibWFwIiwiX3JlZjIiLCJsb2dyIiwic2V0TG9nRXh0ZW5zaW9uIiwiZXh0ZW5zaW9uIiwib3JpZ2luYWxGYWN0b3J5IiwiY29uZmlnTGV2ZWwiLCJyYXdNZXRob2QiLCJsb2dMZXZlbCIsIm5lZWRMb2ciLCJzaWxlbnQiLCJtc2ciLCJjb250ZXh0IiwiYXNzZXJ0IiwiY29uZGl0aW9uIiwiRXJyb3IiLCJGTE9BVDMyX01BWCIsIkZMT0FUMzJfTUlOIiwiVUlOVDMyX01BWCIsIklOVDMyX01BWCIsIklOVDMyX01JTiIsImFzc2VydEludDMyIiwiYXJnIiwiTnVtYmVyIiwiaXNJbnRlZ2VyIiwiYXNzZXJ0VUludDMyIiwiYXNzZXJ0RmxvYXQzMiIsImlzRmluaXRlIiwiZW51bVR5cGVTeW1ib2wiLCJTeW1ib2wiLCJnZXRFbnVtVHlwZSIsImVudW1PYmplY3QiLCJ0Iiwic2V0RW51bVR5cGUiLCJ0eXBlTmFtZSIsInZhbHVlcyIsIm9wdCIsIm1ha2VFbnVtVHlwZSIsInYiLCJubyIsImxvY2FsTmFtZSIsIl9vcHQiLCJuYW1lcyIsImNyZWF0ZSIsIm51bWJlcnMiLCJub3JtYWxWYWx1ZXMiLCJ2YWx1ZSIsIm4iLCJub3JtYWxpemVFbnVtVmFsdWUiLCJwdXNoIiwiZmluZE5hbWUiLCJmaW5kTnVtYmVyIiwibWFrZUVudW0iLCJhc3NpZ24iLCJNZXNzYWdlIiwiZXF1YWxzIiwib3RoZXIiLCJnZXRUeXBlIiwicnVudGltZSIsInV0aWwiLCJjbG9uZSIsImZyb21CaW5hcnkiLCJieXRlcyIsIm9wdGlvbnMiLCJ0eXBlIiwiZm9ybWF0IiwiYmluIiwibWFrZVJlYWRPcHRpb25zIiwicmVhZE1lc3NhZ2UiLCJyZWFkZXJGYWN0b3J5IiwiYnl0ZUxlbmd0aCIsImZyb21Kc29uIiwianNvblZhbHVlIiwianNvbiIsImZyb21Kc29uU3RyaW5nIiwianNvblN0cmluZyIsIkpTT04iLCJwYXJzZSIsImNvbmNhdCIsIm1lc3NhZ2UiLCJTdHJpbmciLCJ0b0JpbmFyeSIsIm1ha2VXcml0ZU9wdGlvbnMiLCJ3cml0ZXIiLCJ3cml0ZXJGYWN0b3J5Iiwid3JpdGVNZXNzYWdlIiwiZmluaXNoIiwidG9Kc29uIiwidG9Kc29uU3RyaW5nIiwiX2EiLCJzdHJpbmdpZnkiLCJwcmV0dHlTcGFjZXMiLCJ0b0pTT04iLCJlbWl0RGVmYXVsdFZhbHVlcyIsImdldFByb3RvdHlwZU9mIiwiY29uc3RydWN0b3IiLCJtYWtlTWVzc2FnZVR5cGUiLCJmaWVsZHMiLCJzdWJzdHJpbmciLCJsYXN0SW5kZXhPZiIsImRhdGEiLCJpbml0RmllbGRzIiwiaW5pdFBhcnRpYWwiLCJzZXRQcm90b3R5cGVPZiIsIm5ld0ZpZWxkTGlzdCIsImEiLCJiIiwibWFrZVByb3RvUnVudGltZSIsInN5bnRheCIsIlNjYWxhclR5cGUiLCJMb25nVHlwZSIsInZhcmludDY0cmVhZCIsImxvd0JpdHMiLCJoaWdoQml0cyIsInNoaWZ0IiwiYnVmIiwicG9zIiwiYXNzZXJ0Qm91bmRzIiwibWlkZGxlQnl0ZSIsInZhcmludDY0d3JpdGUiLCJsbyIsImhpIiwiaGFzTmV4dCIsImJ5dGUiLCJzcGxpdEJpdHMiLCJoYXNNb3JlQml0cyIsIlRXT19QV1JfMzJfREJMIiwiaW50NjRGcm9tU3RyaW5nIiwiZGVjIiwibWludXMiLCJiYXNlIiwiYWRkMWU2ZGlnaXQiLCJiZWdpbiIsImVuZCIsImRpZ2l0MWU2IiwibmVnYXRlIiwibmV3Qml0cyIsImludDY0VG9TdHJpbmciLCJiaXRzIiwibmVnYXRpdmUiLCJyZXN1bHQiLCJ1SW50NjRUb1N0cmluZyIsInRvVW5zaWduZWQiLCJsb3ciLCJtaWQiLCJoaWdoIiwiZGlnaXRBIiwiZGlnaXRCIiwiZGlnaXRDIiwiTWF0aCIsImZsb29yIiwidG9TdHJpbmciLCJkZWNpbWFsRnJvbTFlN1dpdGhMZWFkaW5nWmVyb3MiLCJkaWdpdDFlNyIsInBhcnRpYWwiLCJ2YXJpbnQzMndyaXRlIiwidmFyaW50MzJyZWFkIiwicmVhZEJ5dGVzIiwibWFrZUludDY0U3VwcG9ydCIsImR2IiwiRGF0YVZpZXciLCJBcnJheUJ1ZmZlciIsIm9rIiwiQmlnSW50IiwiZ2V0QmlnSW50NjQiLCJnZXRCaWdVaW50NjQiLCJzZXRCaWdJbnQ2NCIsInNldEJpZ1VpbnQ2NCIsInByb2Nlc3MiLCJlbnYiLCJCVUZfQklHSU5UX0RJU0FCTEUiLCJNSU4iLCJNQVgiLCJVTUlOIiwiVU1BWCIsInplcm8iLCJzdXBwb3J0ZWQiLCJiaSIsInVQYXJzZSIsImVuYyIsImdldEludDMyIiwidUVuYyIsInNldEludDMyIiwidURlYyIsImFzc2VydEludDY0U3RyaW5nIiwiYXNzZXJ0VUludDY0U3RyaW5nIiwicHJvdG9JbnQ2NCIsIldpcmVUeXBlIiwiQmluYXJ5V3JpdGVyIiwidGV4dEVuY29kZXIiLCJzdGFjayIsIlRleHRFbmNvZGVyIiwiY2h1bmtzIiwiVWludDhBcnJheSIsImxlbiIsIm9mZnNldCIsInNldCIsImZvcmsiLCJqb2luIiwiY2h1bmsiLCJwcmV2IiwicG9wIiwidWludDMyIiwicmF3IiwidGFnIiwiZmllbGRObyIsImludDMyIiwiYm9vbCIsInN0cmluZyIsImVuY29kZSIsImZsb2F0IiwiYnVmZmVyIiwic2V0RmxvYXQzMiIsImRvdWJsZSIsInNldEZsb2F0NjQiLCJmaXhlZDMyIiwic2V0VWludDMyIiwic2ZpeGVkMzIiLCJzaW50MzIiLCJzZml4ZWQ2NCIsInZpZXciLCJ0YyIsImZpeGVkNjQiLCJpbnQ2NCIsInNpbnQ2NCIsInNpZ24iLCJ1aW50NjQiLCJCaW5hcnlSZWFkZXIiLCJ0ZXh0RGVjb2RlciIsInZhcmludDY0IiwiYnl0ZU9mZnNldCIsIlRleHREZWNvZGVyIiwid2lyZVR5cGUiLCJza2lwIiwic3RhcnQiLCJWYXJpbnQiLCJCaXQ2NCIsIkJpdDMyIiwiTGVuZ3RoRGVsaW1pdGVkIiwiU3RhcnRHcm91cCIsIkVuZEdyb3VwIiwic3ViYXJyYXkiLCJSYW5nZUVycm9yIiwienplIiwicyIsImdldFVpbnQzMiIsImdldEZsb2F0MzIiLCJnZXRGbG9hdDY0IiwiZGVjb2RlIiwid3JhcEZpZWxkIiwiZmllbGRXcmFwcGVyIiwiRE9VQkxFIiwiRkxPQVQiLCJJTlQ2NCIsIlVJTlQ2NCIsIklOVDMyIiwiVUlOVDMyIiwiQk9PTCIsIlNUUklORyIsIkJZVEVTIiwic2NhbGFyRXF1YWxzIiwiRklYRUQ2NCIsIlNGSVhFRDY0IiwiU0lOVDY0Iiwic2NhbGFyRGVmYXVsdFZhbHVlIiwibG9uZ1R5cGUiLCJzY2FsYXJUeXBlSW5mbyIsImlzVW5kZWZpbmVkIiwiaXNJbnRyaW5zaWNEZWZhdWx0IiwiRklYRUQzMiIsIlNGSVhFRDMyIiwidG9Mb3dlckNhc2UiLCJ1bmtub3duRmllbGRzU3ltYm9sIiwicmVhZERlZmF1bHRzIiwicmVhZFVua25vd25GaWVsZHMiLCJ3cml0ZURlZmF1bHRzIiwid3JpdGVVbmtub3duRmllbGRzIiwibWFrZUJpbmFyeUZvcm1hdENvbW1vbiIsImxpc3RVbmtub3duRmllbGRzIiwiZGlzY2FyZFVua25vd25GaWVsZHMiLCJtIiwiYyIsImYiLCJvblVua25vd25GaWVsZCIsIkFycmF5IiwiaXNBcnJheSIsInJlYWRlciIsImZpZWxkIiwiZmluZCIsInRhcmdldCIsInJlcGVhdGVkIiwib25lb2YiLCJjYXNlIiwia2luZCIsInNjYWxhclR5cGUiLCJUIiwicmVhZCIsInJlYWRTY2FsYXIiLCJMIiwicmVhZFNjYWxhckxUU3RyaW5nIiwiYXJyIiwibWVzc2FnZVR5cGUiLCJyZWFkTWVzc2FnZUZpZWxkIiwidW53cmFwRmllbGQiLCJtYXBLZXkiLCJtYXBWYWwiLCJyZWFkTWFwRW50cnkiLCJrZXkiLCJ2YWwiLCJLIiwiViIsImtleVJhdyIsIkJJR0lOVCIsIlNJTlQzMiIsIndyaXRlTWFwRW50cnkiLCJrZXlWYWx1ZSIsInBhcnNlSW50Iiwid3JpdGVTY2FsYXIiLCJ3cml0ZU1lc3NhZ2VGaWVsZCIsImVtaXRJbnRyaW5zaWNEZWZhdWx0Iiwid3JpdGVQYWNrZWQiLCJtYWtlQmluYXJ5Rm9ybWF0UHJvdG8zIiwiYnlOdW1iZXIiLCJwYWNrZWQiLCJpdGVtIiwiZW5jVGFibGUiLCJzcGxpdCIsImRlY1RhYmxlIiwiY2hhckNvZGVBdCIsInByb3RvQmFzZTY0IiwiYmFzZTY0U3RyIiwiZXMiLCJieXRlUG9zIiwiZ3JvdXBQb3MiLCJwIiwiYmFzZTY0IiwianNvblJlYWREZWZhdWx0cyIsImlnbm9yZVVua25vd25GaWVsZHMiLCJqc29uV3JpdGVEZWZhdWx0cyIsImVudW1Bc0ludGVnZXIiLCJ1c2VQcm90b0ZpZWxkTmFtZSIsIm1ha2VKc29uRm9ybWF0Q29tbW9uIiwibWFrZVdyaXRlRmllbGQiLCJ3cml0ZUZpZWxkIiwid3JpdGVFbnVtIiwib25lb2ZTZWVuIiwianNvbktleSIsImZpbmRKc29uTmFtZSIsInNlZW4iLCJ0YXJnZXRBcnJheSIsImpzb25JdGVtIiwicmVhZEVudW0iLCJ0YXJnZXRNYXAiLCJqc29uTWFwS2V5IiwianNvbk1hcFZhbHVlIiwiZW51bVZhbHVlIiwibWVtYmVyIiwiYnlNZW1iZXIiLCJmaW5kRmllbGQiLCJqc29uTmFtZSIsInIiLCJkZWJ1Z0pzb25WYWx1ZSIsIk5hTiIsIlBPU0lUSVZFX0lORklOSVRZIiwiTkVHQVRJVkVfSU5GSU5JVFkiLCJ0cmltIiwiaXNOYU4iLCJsb25nIiwidUxvbmciLCJtYWtlSnNvbkZvcm1hdFByb3RvMyIsImpzb25PYmoiLCJlbnRyeUtleSIsImVudHJ5VmFsdWUiLCJlbnVtVHlwZSIsImtleXMiLCJqc29uQXJyIiwibWFrZVV0aWxDb21tb24iLCJzb3VyY2UiLCJzayIsInNvdXJjZUZpZWxkIiwidG9VOEFyciIsImNvcHkiLCJrIiwibXQiLCJldmVyeSIsInZhIiwidmIiLCJhbnkiLCJjbG9uZVNpbmd1bGFyRmllbGQiLCJpbnB1dCIsIkludGVybmFsRmllbGRMaXN0Iiwibm9ybWFsaXplciIsIl9maWVsZHMiLCJfbm9ybWFsaXplciIsImpzb25OYW1lcyIsImxpc3QiLCJhbGwiLCJudW1iZXJzQXNjIiwic29ydCIsIm1lbWJlcnMiLCJvIiwibG9jYWxGaWVsZE5hbWUiLCJwcm90b05hbWUiLCJpbk9uZW9mIiwicHJvdG9DYW1lbENhc2UiLCJzYWZlT2JqZWN0UHJvcGVydHkiLCJzYWZlTWVzc2FnZVByb3BlcnR5IiwibG9jYWxPbmVvZk5hbWUiLCJmaWVsZEpzb25OYW1lIiwic25ha2VDYXNlIiwiY2FwTmV4dCIsImNoYXJBdCIsInJlc2VydmVkT2JqZWN0UHJvcGVydGllcyIsIlNldCIsInJlc2VydmVkTWVzc2FnZVByb3BlcnRpZXMiLCJmYWxsYmFjayIsImhhcyIsIkludGVybmFsT25lb2ZJbmZvIiwiZGVmYXVsdCIsImFkZEZpZWxkIiwiX2xvb2t1cCIsInByb3RvMyIsIm5vcm1hbGl6ZUZpZWxkSW5mb3NQcm90bzMiLCJmaWVsZEluZm9zIiwiX2IiLCJfYyIsIl9kIiwib29uYW1lIiwiVGltZXN0YW1wIiwic2Vjb25kcyIsIm5hbm9zIiwibWF0Y2hlcyIsIm1hdGNoIiwibXMiLCJEYXRlIiwicmVwZWF0IiwieiIsIm5hbm9zU3RyIiwidG9JU09TdHJpbmciLCJyZXBsYWNlIiwidG9EYXRlIiwiY2VpbCIsIm5vdyIsImZyb21EYXRlIiwiZGF0ZSIsImdldFRpbWUiLCJBdWRpb0NvZGVjIiwiVmlkZW9Db2RlYyIsIkltYWdlQ29kZWMiLCJUcmFja1R5cGUiLCJUcmFja1NvdXJjZSIsIlZpZGVvUXVhbGl0eSIsIkNvbm5lY3Rpb25RdWFsaXR5IiwiQ2xpZW50Q29uZmlnU2V0dGluZyIsIkRpc2Nvbm5lY3RSZWFzb24iLCJSZWNvbm5lY3RSZWFzb24iLCJTdWJzY3JpcHRpb25FcnJvciIsIlJvb20iLCJzaWQiLCJlbXB0eVRpbWVvdXQiLCJtYXhQYXJ0aWNpcGFudHMiLCJjcmVhdGlvblRpbWUiLCJ0dXJuUGFzc3dvcmQiLCJlbmFibGVkQ29kZWNzIiwibWV0YWRhdGEiLCJudW1QYXJ0aWNpcGFudHMiLCJudW1QdWJsaXNoZXJzIiwiYWN0aXZlUmVjb3JkaW5nIiwiQ29kZWMiLCJtaW1lIiwiZm10cExpbmUiLCJQbGF5b3V0RGVsYXkiLCJlbmFibGVkIiwibWluIiwibWF4IiwiUGFydGljaXBhbnRQZXJtaXNzaW9uIiwiY2FuU3Vic2NyaWJlIiwiY2FuUHVibGlzaCIsImNhblB1Ymxpc2hEYXRhIiwiY2FuUHVibGlzaFNvdXJjZXMiLCJoaWRkZW4iLCJyZWNvcmRlciIsImNhblVwZGF0ZU1ldGFkYXRhIiwiYWdlbnQiLCJQYXJ0aWNpcGFudEluZm8iLCJpZGVudGl0eSIsInN0YXRlIiwiUGFydGljaXBhbnRJbmZvX1N0YXRlIiwiSk9JTklORyIsInRyYWNrcyIsImpvaW5lZEF0IiwidmVyc2lvbiIsInJlZ2lvbiIsImlzUHVibGlzaGVyIiwiVHJhY2tJbmZvIiwiRW5jcnlwdGlvbiIsIkVuY3J5cHRpb25fVHlwZSIsIlNpbXVsY2FzdENvZGVjSW5mbyIsIm1pbWVUeXBlIiwiY2lkIiwibGF5ZXJzIiwiVmlkZW9MYXllciIsIkFVRElPIiwibXV0ZWQiLCJ3aWR0aCIsImhlaWdodCIsInNpbXVsY2FzdCIsImRpc2FibGVEdHgiLCJVTktOT1dOIiwiY29kZWNzIiwic3RlcmVvIiwiZGlzYWJsZVJlZCIsImVuY3J5cHRpb24iLCJOT05FIiwic3RyZWFtIiwicXVhbGl0eSIsIkxPVyIsImJpdHJhdGUiLCJzc3JjIiwiRGF0YVBhY2tldCIsIkRhdGFQYWNrZXRfS2luZCIsIlJFTElBQkxFIiwiVXNlclBhY2tldCIsIkFjdGl2ZVNwZWFrZXJVcGRhdGUiLCJzcGVha2VycyIsIlNwZWFrZXJJbmZvIiwiYWN0aXZlIiwicGFydGljaXBhbnRTaWQiLCJwYXJ0aWNpcGFudElkZW50aXR5IiwicGF5bG9hZCIsImRlc3RpbmF0aW9uU2lkcyIsImRlc3RpbmF0aW9uSWRlbnRpdGllcyIsIlBhcnRpY2lwYW50VHJhY2tzIiwidHJhY2tTaWRzIiwiU2VydmVySW5mbyIsImVkaXRpb24iLCJTZXJ2ZXJJbmZvX0VkaXRpb24iLCJTdGFuZGFyZCIsInByb3RvY29sIiwibm9kZUlkIiwiZGVidWdJbmZvIiwiQ2xpZW50SW5mbyIsInNkayIsIkNsaWVudEluZm9fU0RLIiwib3MiLCJvc1ZlcnNpb24iLCJkZXZpY2VNb2RlbCIsImJyb3dzZXIiLCJicm93c2VyVmVyc2lvbiIsImFkZHJlc3MiLCJuZXR3b3JrIiwiQ2xpZW50Q29uZmlndXJhdGlvbiIsInJlc3VtZUNvbm5lY3Rpb24iLCJVTlNFVCIsImZvcmNlUmVsYXkiLCJWaWRlb0NvbmZpZ3VyYXRpb24iLCJEaXNhYmxlZENvZGVjcyIsImhhcmR3YXJlRW5jb2RlciIsInB1Ymxpc2giLCJSVFBEcmlmdCIsImR1cmF0aW9uIiwic3RhcnRUaW1lc3RhbXAiLCJlbmRUaW1lc3RhbXAiLCJydHBDbG9ja1RpY2tzIiwiZHJpZnRTYW1wbGVzIiwiZHJpZnRNcyIsImNsb2NrUmF0ZSIsIlJUUFN0YXRzIiwicGFja2V0cyIsInBhY2tldFJhdGUiLCJoZWFkZXJCeXRlcyIsInBhY2tldHNMb3N0IiwicGFja2V0TG9zc1JhdGUiLCJwYWNrZXRMb3NzUGVyY2VudGFnZSIsInBhY2tldHNEdXBsaWNhdGUiLCJwYWNrZXREdXBsaWNhdGVSYXRlIiwiYnl0ZXNEdXBsaWNhdGUiLCJoZWFkZXJCeXRlc0R1cGxpY2F0ZSIsImJpdHJhdGVEdXBsaWNhdGUiLCJwYWNrZXRzUGFkZGluZyIsInBhY2tldFBhZGRpbmdSYXRlIiwiYnl0ZXNQYWRkaW5nIiwiaGVhZGVyQnl0ZXNQYWRkaW5nIiwiYml0cmF0ZVBhZGRpbmciLCJwYWNrZXRzT3V0T2ZPcmRlciIsImZyYW1lcyIsImZyYW1lUmF0ZSIsImppdHRlckN1cnJlbnQiLCJqaXR0ZXJNYXgiLCJnYXBIaXN0b2dyYW0iLCJuYWNrcyIsIm5hY2tBY2tzIiwibmFja01pc3NlcyIsIm5hY2tSZXBlYXRlZCIsInBsaXMiLCJmaXJzIiwicnR0Q3VycmVudCIsInJ0dE1heCIsImtleUZyYW1lcyIsImxheWVyTG9ja1BsaXMiLCJUaW1lZFZlcnNpb24iLCJ1bml4TWljcm8iLCJ0aWNrcyIsIm1heFJldHJ5RGVsYXkiLCJERUZBVUxUX1JFVFJZX0RFTEFZU19JTl9NUyIsIkRlZmF1bHRSZWNvbm5lY3RQb2xpY3kiLCJyZXRyeURlbGF5cyIsIl9yZXRyeURlbGF5cyIsIm5leHRSZXRyeURlbGF5SW5NcyIsInJldHJ5Q291bnQiLCJyZXRyeURlbGF5IiwicmFuZG9tIiwiUiIsIlJlZmxlY3QiLCJSZWZsZWN0QXBwbHkiLCJyZWNlaXZlciIsImFyZ3MiLCJSZWZsZWN0T3duS2V5cyIsIm93bktleXMiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJnZXRPd25Qcm9wZXJ0eU5hbWVzIiwiUHJvY2Vzc0VtaXRXYXJuaW5nIiwid2FybmluZyIsIndhcm4iLCJOdW1iZXJJc05hTiIsIkV2ZW50RW1pdHRlciIsImluaXQiLCJldmVudHNNb2R1bGUiLCJvbmNlIiwiX2V2ZW50cyIsIl9ldmVudHNDb3VudCIsIl9tYXhMaXN0ZW5lcnMiLCJkZWZhdWx0TWF4TGlzdGVuZXJzIiwiY2hlY2tMaXN0ZW5lciIsImxpc3RlbmVyIiwiZGVmaW5lUHJvcGVydHkiLCJlbnVtZXJhYmxlIiwiZ2V0Iiwic2V0TWF4TGlzdGVuZXJzIiwiX2dldE1heExpc3RlbmVycyIsInRoYXQiLCJnZXRNYXhMaXN0ZW5lcnMiLCJlbWl0IiwiZG9FcnJvciIsImV2ZW50cyIsImVycm9yIiwiZXIiLCJlcnIiLCJoYW5kbGVyIiwibGlzdGVuZXJzIiwiYXJyYXlDbG9uZSIsIl9hZGRMaXN0ZW5lciIsInByZXBlbmQiLCJleGlzdGluZyIsIm5ld0xpc3RlbmVyIiwidW5zaGlmdCIsIndhcm5lZCIsInciLCJlbWl0dGVyIiwiY291bnQiLCJhZGRMaXN0ZW5lciIsIm9uIiwicHJlcGVuZExpc3RlbmVyIiwib25jZVdyYXBwZXIiLCJmaXJlZCIsInJlbW92ZUxpc3RlbmVyIiwid3JhcEZuIiwiX29uY2VXcmFwIiwid3JhcHBlZCIsInByZXBlbmRPbmNlTGlzdGVuZXIiLCJwb3NpdGlvbiIsIm9yaWdpbmFsTGlzdGVuZXIiLCJzcGxpY2VPbmUiLCJvZmYiLCJyZW1vdmVBbGxMaXN0ZW5lcnMiLCJfbGlzdGVuZXJzIiwidW53cmFwIiwiZXZsaXN0ZW5lciIsInVud3JhcExpc3RlbmVycyIsInJhd0xpc3RlbmVycyIsImxpc3RlbmVyQ291bnQiLCJldmVudE5hbWVzIiwiaW5kZXgiLCJyZXQiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsImVycm9yTGlzdGVuZXIiLCJyZXNvbHZlciIsImV2ZW50VGFyZ2V0QWdub3N0aWNBZGRMaXN0ZW5lciIsImFkZEVycm9ySGFuZGxlcklmRXZlbnRFbWl0dGVyIiwiZmxhZ3MiLCJhZGRFdmVudExpc3RlbmVyIiwid3JhcExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImxvZ0Rpc2FibGVkXyIsImRlcHJlY2F0aW9uV2FybmluZ3NfIiwiZXh0cmFjdFZlcnNpb24iLCJ1YXN0cmluZyIsImV4cHIiLCJ3cmFwUGVlckNvbm5lY3Rpb25FdmVudCIsImV2ZW50TmFtZVRvV3JhcCIsIndyYXBwZXIiLCJSVENQZWVyQ29ubmVjdGlvbiIsInByb3RvIiwibmF0aXZlQWRkRXZlbnRMaXN0ZW5lciIsIm5hdGl2ZUV2ZW50TmFtZSIsImNiIiwid3JhcHBlZENhbGxiYWNrIiwibW9kaWZpZWRFdmVudCIsImhhbmRsZUV2ZW50IiwiX2V2ZW50TWFwIiwiTWFwIiwibmF0aXZlUmVtb3ZlRXZlbnRMaXN0ZW5lciIsInVud3JhcHBlZENiIiwiZGVsZXRlIiwic2l6ZSIsImNvbmZpZ3VyYWJsZSIsImRpc2FibGVMb2ciLCJkaXNhYmxlV2FybmluZ3MiLCJkZXByZWNhdGVkIiwib2xkTWV0aG9kIiwibmV3TWV0aG9kIiwiZGV0ZWN0QnJvd3NlciIsIm1vekdldFVzZXJNZWRpYSIsIndlYmtpdEdldFVzZXJNZWRpYSIsImlzU2VjdXJlQ29udGV4dCIsIndlYmtpdFJUQ1BlZXJDb25uZWN0aW9uIiwic3VwcG9ydHNVbmlmaWVkUGxhbiIsIlJUQ1J0cFRyYW5zY2VpdmVyIiwiaXNPYmplY3QiLCJjb21wYWN0T2JqZWN0IiwicmVkdWNlIiwiYWNjdW11bGF0b3IiLCJpc09iaiIsImlzRW1wdHlPYmplY3QiLCJ3YWxrU3RhdHMiLCJzdGF0cyIsInJlc3VsdFNldCIsImlkIiwiZm9yRWFjaCIsImVuZHNXaXRoIiwiZmlsdGVyU3RhdHMiLCJ0cmFjayIsIm91dGJvdW5kIiwic3RyZWFtU3RhdHNUeXBlIiwiZmlsdGVyZWRSZXN1bHQiLCJ0cmFja1N0YXRzIiwidHJhY2tJZGVudGlmaWVyIiwidHJhY2tTdGF0IiwidHJhY2tJZCIsImxvZ2dpbmciLCJ1dGlscyIsInNoaW1HZXRVc2VyTWVkaWEiLCJicm93c2VyRGV0YWlscyIsIm1lZGlhRGV2aWNlcyIsImNvbnN0cmFpbnRzVG9DaHJvbWVfIiwibWFuZGF0b3J5Iiwib3B0aW9uYWwiLCJjYyIsImlkZWFsIiwiZXhhY3QiLCJvbGRuYW1lXyIsInByZWZpeCIsIm9jIiwibWl4IiwiYWR2YW5jZWQiLCJzaGltQ29uc3RyYWludHNfIiwiY29uc3RyYWludHMiLCJmdW5jIiwiYXVkaW8iLCJyZW1hcCIsInZpZGVvIiwiZmFjZSIsImZhY2luZ01vZGUiLCJnZXRTdXBwb3J0ZWRGYWNpbmdNb2RlTGllcyIsImdldFN1cHBvcnRlZENvbnN0cmFpbnRzIiwiZW51bWVyYXRlRGV2aWNlcyIsInRoZW4iLCJkZXZpY2VzIiwiZCIsImRldiIsInNvbWUiLCJsYWJlbCIsImluY2x1ZGVzIiwiZGV2aWNlSWQiLCJzaGltRXJyb3JfIiwiUGVybWlzc2lvbkRlbmllZEVycm9yIiwiUGVybWlzc2lvbkRpc21pc3NlZEVycm9yIiwiSW52YWxpZFN0YXRlRXJyb3IiLCJEZXZpY2VzTm90Rm91bmRFcnJvciIsIkNvbnN0cmFpbnROb3RTYXRpc2ZpZWRFcnJvciIsIlRyYWNrU3RhcnRFcnJvciIsIk1lZGlhRGV2aWNlRmFpbGVkRHVlVG9TaHV0ZG93biIsIk1lZGlhRGV2aWNlS2lsbFN3aXRjaE9uIiwiVGFiQ2FwdHVyZUVycm9yIiwiU2NyZWVuQ2FwdHVyZUVycm9yIiwiRGV2aWNlQ2FwdHVyZUVycm9yIiwiY29uc3RyYWludCIsImNvbnN0cmFpbnROYW1lIiwiZ2V0VXNlck1lZGlhXyIsIm9uU3VjY2VzcyIsIm9uRXJyb3IiLCJnZXRVc2VyTWVkaWEiLCJvcmlnR2V0VXNlck1lZGlhIiwiY3MiLCJnZXRBdWRpb1RyYWNrcyIsImdldFZpZGVvVHJhY2tzIiwiZ2V0VHJhY2tzIiwic3RvcCIsIkRPTUV4Y2VwdGlvbiIsInNoaW1HZXREaXNwbGF5TWVkaWEiLCJnZXRTb3VyY2VJZCIsImdldERpc3BsYXlNZWRpYSIsInNvdXJjZUlkIiwid2lkdGhTcGVjaWZpZWQiLCJoZWlnaHRTcGVjaWZpZWQiLCJmcmFtZVJhdGVTcGVjaWZpZWQiLCJjaHJvbWVNZWRpYVNvdXJjZSIsImNocm9tZU1lZGlhU291cmNlSWQiLCJtYXhGcmFtZVJhdGUiLCJtYXhXaWR0aCIsIm1heEhlaWdodCIsInNoaW1NZWRpYVN0cmVhbSIsIk1lZGlhU3RyZWFtIiwid2Via2l0TWVkaWFTdHJlYW0iLCJzaGltT25UcmFjayIsIl9vbnRyYWNrIiwib3JpZ1NldFJlbW90ZURlc2NyaXB0aW9uIiwic2V0UmVtb3RlRGVzY3JpcHRpb24iLCJfb250cmFja3BvbHkiLCJ0ZSIsImdldFJlY2VpdmVycyIsImV2ZW50IiwiRXZlbnQiLCJ0cmFuc2NlaXZlciIsInN0cmVhbXMiLCJkaXNwYXRjaEV2ZW50Iiwic2hpbUdldFNlbmRlcnNXaXRoRHRtZiIsInNoaW1TZW5kZXJXaXRoRHRtZiIsInBjIiwiZHRtZiIsIl9kdG1mIiwiY3JlYXRlRFRNRlNlbmRlciIsIl9wYyIsImdldFNlbmRlcnMiLCJfc2VuZGVycyIsIm9yaWdBZGRUcmFjayIsImFkZFRyYWNrIiwic2VuZGVyIiwib3JpZ1JlbW92ZVRyYWNrIiwicmVtb3ZlVHJhY2siLCJpZHgiLCJzcGxpY2UiLCJvcmlnQWRkU3RyZWFtIiwiYWRkU3RyZWFtIiwib3JpZ1JlbW92ZVN0cmVhbSIsInJlbW92ZVN0cmVhbSIsIlJUQ1J0cFNlbmRlciIsIm9yaWdHZXRTZW5kZXJzIiwic2VuZGVycyIsInNoaW1HZXRTdGF0cyIsIm9yaWdHZXRTdGF0cyIsImdldFN0YXRzIiwic2VsZWN0b3IiLCJvblN1Y2MiLCJvbkVyciIsImZpeENocm9tZVN0YXRzXyIsInJlc3BvbnNlIiwic3RhbmRhcmRSZXBvcnQiLCJyZXBvcnRzIiwicmVwb3J0Iiwic3RhbmRhcmRTdGF0cyIsInRpbWVzdGFtcCIsImxvY2FsY2FuZGlkYXRlIiwicmVtb3RlY2FuZGlkYXRlIiwic3RhdCIsIm1ha2VNYXBTdGF0cyIsInN1Y2Nlc3NDYWxsYmFja1dyYXBwZXJfIiwic2hpbVNlbmRlclJlY2VpdmVyR2V0U3RhdHMiLCJSVENSdHBSZWNlaXZlciIsIm9yaWdHZXRSZWNlaXZlcnMiLCJyZWNlaXZlcnMiLCJzcmNFbGVtZW50IiwiTWVkaWFTdHJlYW1UcmFjayIsInNoaW1BZGRUcmFja1JlbW92ZVRyYWNrV2l0aE5hdGl2ZSIsImdldExvY2FsU3RyZWFtcyIsIl9zaGltbWVkTG9jYWxTdHJlYW1zIiwic3RyZWFtSWQiLCJhbHJlYWR5RXhpc3RzIiwiZXhpc3RpbmdTZW5kZXJzIiwibmV3U2VuZGVycyIsIm5ld1NlbmRlciIsInNoaW1BZGRUcmFja1JlbW92ZVRyYWNrIiwib3JpZ0dldExvY2FsU3RyZWFtcyIsIm5hdGl2ZVN0cmVhbXMiLCJfcmV2ZXJzZVN0cmVhbXMiLCJfc3RyZWFtcyIsIm5ld1N0cmVhbSIsInNpZ25hbGluZ1N0YXRlIiwib2xkU3RyZWFtIiwicmVwbGFjZUludGVybmFsU3RyZWFtSWQiLCJkZXNjcmlwdGlvbiIsInNkcCIsImludGVybmFsSWQiLCJleHRlcm5hbFN0cmVhbSIsImludGVybmFsU3RyZWFtIiwiUmVnRXhwIiwiUlRDU2Vzc2lvbkRlc2NyaXB0aW9uIiwicmVwbGFjZUV4dGVybmFsU3RyZWFtSWQiLCJuYXRpdmVNZXRob2QiLCJtZXRob2RPYmoiLCJpc0xlZ2FjeUNhbGwiLCJkZXNjIiwib3JpZ1NldExvY2FsRGVzY3JpcHRpb24iLCJzZXRMb2NhbERlc2NyaXB0aW9uIiwib3JpZ0xvY2FsRGVzY3JpcHRpb24iLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJpc0xvY2FsIiwic3RyZWFtaWQiLCJoYXNUcmFjayIsInNoaW1QZWVyQ29ubmVjdGlvbiIsIlJUQ0ljZUNhbmRpZGF0ZSIsImZpeE5lZ290aWF0aW9uTmVlZGVkIiwiZ2V0Q29uZmlndXJhdGlvbiIsInNkcFNlbWFudGljcyIsIm5hdGl2ZUdldFVzZXJNZWRpYSIsImdldFNldHRpbmdzIiwibmF0aXZlR2V0U2V0dGluZ3MiLCJhcHBseUNvbnN0cmFpbnRzIiwibmF0aXZlQXBwbHlDb25zdHJhaW50cyIsInByZWZlcnJlZE1lZGlhU291cmNlIiwiY29kZSIsIm1lZGlhU291cmNlIiwiUlRDVHJhY2tFdmVudCIsIm1velJUQ1BlZXJDb25uZWN0aW9uIiwibW9kZXJuU3RhdHNUeXBlcyIsImluYm91bmRydHAiLCJvdXRib3VuZHJ0cCIsImNhbmRpZGF0ZXBhaXIiLCJuYXRpdmVHZXRTdGF0cyIsInNoaW1TZW5kZXJHZXRTdGF0cyIsInNoaW1SZWNlaXZlckdldFN0YXRzIiwic2hpbVJlbW92ZVN0cmVhbSIsInNoaW1SVENEYXRhQ2hhbm5lbCIsIkRhdGFDaGFubmVsIiwiUlRDRGF0YUNoYW5uZWwiLCJzaGltQWRkVHJhbnNjZWl2ZXIiLCJvcmlnQWRkVHJhbnNjZWl2ZXIiLCJhZGRUcmFuc2NlaXZlciIsInNldFBhcmFtZXRlcnNQcm9taXNlcyIsInNlbmRFbmNvZGluZ3MiLCJzaG91bGRQZXJmb3JtQ2hlY2siLCJlbmNvZGluZ1BhcmFtIiwicmlkUmVnZXgiLCJyaWQiLCJwYXJzZUZsb2F0Iiwic2NhbGVSZXNvbHV0aW9uRG93bkJ5IiwibWF4RnJhbWVyYXRlIiwicGFyYW1zIiwiZ2V0UGFyYW1ldGVycyIsImVuY29kaW5ncyIsInNldFBhcmFtZXRlcnMiLCJjYXRjaCIsInNoaW1HZXRQYXJhbWV0ZXJzIiwib3JpZ0dldFBhcmFtZXRlcnMiLCJzaGltQ3JlYXRlT2ZmZXIiLCJvcmlnQ3JlYXRlT2ZmZXIiLCJjcmVhdGVPZmZlciIsImZpbmFsbHkiLCJzaGltQ3JlYXRlQW5zd2VyIiwib3JpZ0NyZWF0ZUFuc3dlciIsImNyZWF0ZUFuc3dlciIsInNoaW1Mb2NhbFN0cmVhbXNBUEkiLCJfbG9jYWxTdHJlYW1zIiwiX2FkZFRyYWNrIiwiX2xlbiIsIl9rZXkiLCJzaGltUmVtb3RlU3RyZWFtc0FQSSIsImdldFJlbW90ZVN0cmVhbXMiLCJfcmVtb3RlU3RyZWFtcyIsIl9vbmFkZHN0cmVhbSIsIl9vbmFkZHN0cmVhbXBvbHkiLCJzaGltQ2FsbGJhY2tzQVBJIiwiYWRkSWNlQ2FuZGlkYXRlIiwic3VjY2Vzc0NhbGxiYWNrIiwiZmFpbHVyZUNhbGxiYWNrIiwicHJvbWlzZSIsIndpdGhDYWxsYmFjayIsImNhbmRpZGF0ZSIsIl9nZXRVc2VyTWVkaWEiLCJzaGltQ29uc3RyYWludHMiLCJlcnJjYiIsInNoaW1SVENJY2VTZXJ2ZXJVcmxzIiwiT3JpZ1BlZXJDb25uZWN0aW9uIiwicGNDb25maWciLCJwY0NvbnN0cmFpbnRzIiwiaWNlU2VydmVycyIsIm5ld0ljZVNlcnZlcnMiLCJzZXJ2ZXIiLCJ1cmxzIiwidXJsIiwiZ2VuZXJhdGVDZXJ0aWZpY2F0ZSIsInNoaW1UcmFja0V2ZW50VHJhbnNjZWl2ZXIiLCJzaGltQ3JlYXRlT2ZmZXJMZWdhY3kiLCJvZmZlck9wdGlvbnMiLCJvZmZlclRvUmVjZWl2ZUF1ZGlvIiwiYXVkaW9UcmFuc2NlaXZlciIsImdldFRyYW5zY2VpdmVycyIsImRpcmVjdGlvbiIsInNldERpcmVjdGlvbiIsIm9mZmVyVG9SZWNlaXZlVmlkZW8iLCJ2aWRlb1RyYW5zY2VpdmVyIiwic2hpbUF1ZGlvQ29udGV4dCIsIkF1ZGlvQ29udGV4dCIsIndlYmtpdEF1ZGlvQ29udGV4dCIsIlNEUFV0aWxzIiwiZ2VuZXJhdGVJZGVudGlmaWVyIiwibG9jYWxDTmFtZSIsInNwbGl0TGluZXMiLCJibG9iIiwibGluZSIsInNwbGl0U2VjdGlvbnMiLCJwYXJ0cyIsInBhcnQiLCJnZXREZXNjcmlwdGlvbiIsInNlY3Rpb25zIiwiZ2V0TWVkaWFTZWN0aW9ucyIsIm1hdGNoUHJlZml4IiwicGFyc2VDYW5kaWRhdGUiLCJmb3VuZGF0aW9uIiwiY29tcG9uZW50IiwicHJpb3JpdHkiLCJpcCIsInBvcnQiLCJyZWxhdGVkQWRkcmVzcyIsInJlbGF0ZWRQb3J0IiwidGNwVHlwZSIsInVmcmFnIiwidXNlcm5hbWVGcmFnbWVudCIsIndyaXRlQ2FuZGlkYXRlIiwicGFyc2VJY2VPcHRpb25zIiwicGFyc2VSdHBNYXAiLCJwYXJzZWQiLCJwYXlsb2FkVHlwZSIsImNoYW5uZWxzIiwibnVtQ2hhbm5lbHMiLCJ3cml0ZVJ0cE1hcCIsImNvZGVjIiwicHQiLCJwcmVmZXJyZWRQYXlsb2FkVHlwZSIsInBhcnNlRXh0bWFwIiwidXJpIiwiYXR0cmlidXRlcyIsIndyaXRlRXh0bWFwIiwiaGVhZGVyRXh0ZW5zaW9uIiwicHJlZmVycmVkSWQiLCJwYXJzZUZtdHAiLCJrdiIsImoiLCJ3cml0ZUZtdHAiLCJwYXJhbWV0ZXJzIiwicGFyYW0iLCJwYXJzZVJ0Y3BGYiIsInBhcmFtZXRlciIsIndyaXRlUnRjcEZiIiwibGluZXMiLCJydGNwRmVlZGJhY2siLCJmYiIsInBhcnNlU3NyY01lZGlhIiwic3AiLCJjb2xvbiIsImF0dHJpYnV0ZSIsInBhcnNlU3NyY0dyb3VwIiwic2VtYW50aWNzIiwic3NyY3MiLCJnZXRNaWQiLCJtZWRpYVNlY3Rpb24iLCJwYXJzZUZpbmdlcnByaW50IiwiYWxnb3JpdGhtIiwiZ2V0RHRsc1BhcmFtZXRlcnMiLCJzZXNzaW9ucGFydCIsInJvbGUiLCJmaW5nZXJwcmludHMiLCJ3cml0ZUR0bHNQYXJhbWV0ZXJzIiwic2V0dXBUeXBlIiwiZnAiLCJwYXJzZUNyeXB0b0xpbmUiLCJjcnlwdG9TdWl0ZSIsImtleVBhcmFtcyIsInNlc3Npb25QYXJhbXMiLCJ3cml0ZUNyeXB0b0xpbmUiLCJ3cml0ZUNyeXB0b0tleVBhcmFtcyIsInBhcnNlQ3J5cHRvS2V5UGFyYW1zIiwia2V5TWV0aG9kIiwia2V5U2FsdCIsImxpZmVUaW1lIiwibWtpVmFsdWUiLCJta2lMZW5ndGgiLCJnZXRDcnlwdG9QYXJhbWV0ZXJzIiwiZ2V0SWNlUGFyYW1ldGVycyIsInB3ZCIsInBhc3N3b3JkIiwid3JpdGVJY2VQYXJhbWV0ZXJzIiwiaWNlTGl0ZSIsInBhcnNlUnRwUGFyYW1ldGVycyIsImhlYWRlckV4dGVuc2lvbnMiLCJmZWNNZWNoYW5pc21zIiwicnRjcCIsIm1saW5lIiwicHJvZmlsZSIsInJ0cG1hcGxpbmUiLCJmbXRwcyIsIndpbGRjYXJkUnRjcEZiIiwiZHVwbGljYXRlIiwiZXhpc3RpbmdGZWVkYmFjayIsIndyaXRlUnRwRGVzY3JpcHRpb24iLCJjYXBzIiwibWF4cHRpbWUiLCJwYXJzZVJ0cEVuY29kaW5nUGFyYW1ldGVycyIsImVuY29kaW5nUGFyYW1ldGVycyIsImhhc1JlZCIsImhhc1VscGZlYyIsInByaW1hcnlTc3JjIiwic2Vjb25kYXJ5U3NyYyIsImZsb3dzIiwiYXB0IiwiZW5jUGFyYW0iLCJjb2RlY1BheWxvYWRUeXBlIiwicnR4IiwiZmVjIiwibWVjaGFuaXNtIiwiYmFuZHdpZHRoIiwibWF4Qml0cmF0ZSIsInBhcnNlUnRjcFBhcmFtZXRlcnMiLCJydGNwUGFyYW1ldGVycyIsInJlbW90ZVNzcmMiLCJjbmFtZSIsInJzaXplIiwicmVkdWNlZFNpemUiLCJjb21wb3VuZCIsIm11eCIsIndyaXRlUnRjcFBhcmFtZXRlcnMiLCJwYXJzZU1zaWQiLCJzcGVjIiwicGxhbkIiLCJtc2lkUGFydHMiLCJwYXJzZVNjdHBEZXNjcmlwdGlvbiIsInBhcnNlTUxpbmUiLCJtYXhTaXplTGluZSIsIm1heE1lc3NhZ2VTaXplIiwic2N0cFBvcnQiLCJmbXQiLCJzY3RwTWFwTGluZXMiLCJ3cml0ZVNjdHBEZXNjcmlwdGlvbiIsIm1lZGlhIiwic2N0cCIsIm91dHB1dCIsImdlbmVyYXRlU2Vzc2lvbklkIiwic3Vic3RyIiwid3JpdGVTZXNzaW9uQm9pbGVycGxhdGUiLCJzZXNzSWQiLCJzZXNzVmVyIiwic2Vzc1VzZXIiLCJzZXNzaW9uSWQiLCJ1c2VyIiwiZ2V0RGlyZWN0aW9uIiwiZ2V0S2luZCIsImlzUmVqZWN0ZWQiLCJwYXJzZU9MaW5lIiwidXNlcm5hbWUiLCJzZXNzaW9uVmVyc2lvbiIsIm5ldFR5cGUiLCJhZGRyZXNzVHlwZSIsImlzVmFsaWRTRFAiLCJzaGltUlRDSWNlQ2FuZGlkYXRlIiwiTmF0aXZlUlRDSWNlQ2FuZGlkYXRlIiwibmF0aXZlQ2FuZGlkYXRlIiwicGFyc2VkQ2FuZGlkYXRlIiwic2RwTWlkIiwic2RwTUxpbmVJbmRleCIsIndyaXRhYmxlIiwic2hpbVJUQ0ljZUNhbmRpZGF0ZVJlbGF5UHJvdG9jb2wiLCJyZWxheVByb3RvY29sIiwic2hpbU1heE1lc3NhZ2VTaXplIiwiX3NjdHAiLCJzY3RwSW5EZXNjcmlwdGlvbiIsIm1MaW5lIiwiZ2V0UmVtb3RlRmlyZWZveFZlcnNpb24iLCJnZXRDYW5TZW5kTWF4TWVzc2FnZVNpemUiLCJyZW1vdGVJc0ZpcmVmb3giLCJjYW5TZW5kTWF4TWVzc2FnZVNpemUiLCJnZXRNYXhNZXNzYWdlU2l6ZSIsImlzRmlyZWZveCIsImNhblNlbmRNTVMiLCJyZW1vdGVNTVMiLCJzaGltU2VuZFRocm93VHlwZUVycm9yIiwid3JhcERjU2VuZCIsImRjIiwib3JpZ0RhdGFDaGFubmVsU2VuZCIsInNlbmQiLCJyZWFkeVN0YXRlIiwib3JpZ0NyZWF0ZURhdGFDaGFubmVsIiwiY3JlYXRlRGF0YUNoYW5uZWwiLCJkYXRhQ2hhbm5lbCIsImNoYW5uZWwiLCJzaGltQ29ubmVjdGlvblN0YXRlIiwiY29tcGxldGVkIiwiY2hlY2tpbmciLCJpY2VDb25uZWN0aW9uU3RhdGUiLCJfb25jb25uZWN0aW9uc3RhdGVjaGFuZ2UiLCJvcmlnTWV0aG9kIiwiX2Nvbm5lY3Rpb25zdGF0ZWNoYW5nZXBvbHkiLCJfbGFzdENvbm5lY3Rpb25TdGF0ZSIsImNvbm5lY3Rpb25TdGF0ZSIsIm5ld0V2ZW50IiwicmVtb3ZlRXh0bWFwQWxsb3dNaXhlZCIsIm5hdGl2ZVNSRCIsInNoaW1BZGRJY2VDYW5kaWRhdGVOdWxsT3JFbXB0eSIsIm5hdGl2ZUFkZEljZUNhbmRpZGF0ZSIsInNoaW1QYXJhbWV0ZXJsZXNzU2V0TG9jYWxEZXNjcmlwdGlvbiIsIm5hdGl2ZVNldExvY2FsRGVzY3JpcHRpb24iLCJhZGFwdGVyRmFjdG9yeSIsInNoaW1DaHJvbWUiLCJzaGltRmlyZWZveCIsInNoaW1TYWZhcmkiLCJhZGFwdGVyIiwiY29tbW9uU2hpbSIsImNocm9tZVNoaW0iLCJicm93c2VyU2hpbSIsImZpcmVmb3hTaGltIiwic2FmYXJpU2hpbSIsIkVOQ1JZUFRJT05fQUxHT1JJVEhNIiwiREVDUllQVElPTl9GQUlMVVJFX1RPTEVSQU5DRSIsIkUyRUVfRkxBRyIsIlNBTFQiLCJLRVlfUFJPVklERVJfREVGQVVMVFMiLCJzaGFyZWRLZXkiLCJyYXRjaGV0U2FsdCIsInJhdGNoZXRXaW5kb3dTaXplIiwiZmFpbHVyZVRvbGVyYW5jZSIsIktleVByb3ZpZGVyRXZlbnQiLCJLZXlIYW5kbGVyRXZlbnQiLCJFbmNyeXB0aW9uRXZlbnQiLCJDcnlwdG9yRXZlbnQiLCJpc0UyRUVTdXBwb3J0ZWQiLCJpc0luc2VydGFibGVTdHJlYW1TdXBwb3J0ZWQiLCJpc1NjcmlwdFRyYW5zZm9ybVN1cHBvcnRlZCIsIlJUQ1J0cFNjcmlwdFRyYW5zZm9ybSIsImNyZWF0ZUVuY29kZWRTdHJlYW1zIiwiaXNWaWRlb0ZyYW1lIiwiZnJhbWUiLCJpbXBvcnRLZXkiLCJrZXlCeXRlcyIsInVzYWdlIiwiY3J5cHRvIiwic3VidGxlIiwiY3JlYXRlS2V5TWF0ZXJpYWxGcm9tU3RyaW5nIiwia2V5TWF0ZXJpYWwiLCJjcmVhdGVLZXlNYXRlcmlhbEZyb21CdWZmZXIiLCJjcnlwdG9CdWZmZXIiLCJnZXRBbGdvT3B0aW9ucyIsImFsZ29yaXRobU5hbWUiLCJzYWx0IiwiZW5jb2RlZFNhbHQiLCJoYXNoIiwiaXRlcmF0aW9ucyIsImRlcml2ZUtleXMiLCJtYXRlcmlhbCIsImFsZ29yaXRobU9wdGlvbnMiLCJlbmNyeXB0aW9uS2V5IiwiZGVyaXZlS2V5IiwiY3JlYXRlRTJFRUtleSIsImdldFJhbmRvbVZhbHVlcyIsInJhdGNoZXQiLCJkZXJpdmVCaXRzIiwibmVlZHNSYnNwVW5lc2NhcGluZyIsImZyYW1lRGF0YSIsInBhcnNlUmJzcCIsImRhdGFPdXQiLCJrWmVyb3NJblN0YXJ0U2VxdWVuY2UiLCJrRW11bGF0aW9uQnl0ZSIsIndyaXRlUmJzcCIsImRhdGFfaW4iLCJudW1Db25zZWN1dGl2ZVplcm9zIiwiQmFzZUtleVByb3ZpZGVyIiwib25LZXlSYXRjaGV0ZWQiLCJrZXlJbmRleCIsImtleUluZm9NYXAiLCJLZXlSYXRjaGV0ZWQiLCJvblNldEVuY3J5cHRpb25LZXkiLCJrZXlJbmZvIiwiU2V0S2V5IiwiZ2V0S2V5cyIsImZyb20iLCJnZXRPcHRpb25zIiwicmF0Y2hldEtleSIsIlJhdGNoZXRSZXF1ZXN0IiwiRXh0ZXJuYWxFMkVFS2V5UHJvdmlkZXIiLCJvcHRzIiwic2V0S2V5IiwiZGVyaXZlZEtleSIsIkxpdmVraXRFcnJvciIsIkNvbm5lY3Rpb25FcnJvciIsInJlYXNvbiIsInN0YXR1cyIsIkRldmljZVVuc3VwcG9ydGVkRXJyb3IiLCJUcmFja0ludmFsaWRFcnJvciIsIlVuc3VwcG9ydGVkU2VydmVyIiwiVW5leHBlY3RlZENvbm5lY3Rpb25TdGF0ZSIsIk5lZ290aWF0aW9uRXJyb3IiLCJQdWJsaXNoRGF0YUVycm9yIiwiTWVkaWFEZXZpY2VGYWlsdXJlIiwiZ2V0RmFpbHVyZSIsIk5vdEZvdW5kIiwiUGVybWlzc2lvbkRlbmllZCIsIkRldmljZUluVXNlIiwiT3RoZXIiLCJSb29tRXZlbnQiLCJQYXJ0aWNpcGFudEV2ZW50IiwiRW5naW5lRXZlbnQiLCJUcmFja0V2ZW50IiwiaXNJbW1lZGlhdGUiLCJ1IiwiY2FsbGJhY2siLCJtYXhXYWl0IiwibCIsImNsZWFyVGltZW91dCIsInNldFRpbWVvdXQiLCJjYW5jZWwiLCJjb21tb25WZXJzaW9uSWRlbnRpZmllciIsImdldEJyb3dzZXIiLCJmb3JjZSIsInVhIiwiYnJvd3NlcnNMaXN0IiwiZGVzY3JpYmUiLCJnZXRNYXRjaCIsImV4cCIsInByb3RvY29sVmVyc2lvbiIsIkNyaXRpY2FsVGltZXJzIiwic2V0SW50ZXJ2YWwiLCJjbGVhckludGVydmFsIiwiVmlkZW9QcmVzZXQiLCJlbmNvZGluZyIsInJlc29sdXRpb24iLCJhc3BlY3RSYXRpbyIsImJhY2t1cENvZGVjcyIsInZpZGVvQ29kZWNzIiwiaXNCYWNrdXBDb2RlYyIsImJhY2t1cCIsIkF1ZGlvUHJlc2V0cyIsInRlbGVwaG9uZSIsInNwZWVjaCIsIm11c2ljIiwibXVzaWNTdGVyZW8iLCJtdXNpY0hpZ2hRdWFsaXR5IiwibXVzaWNIaWdoUXVhbGl0eVN0ZXJlbyIsIlZpZGVvUHJlc2V0cyIsImg5MCIsImgxODAiLCJoMjE2IiwiaDM2MCIsImg1NDAiLCJoNzIwIiwiaDEwODAiLCJoMTQ0MCIsImgyMTYwIiwiVmlkZW9QcmVzZXRzNDMiLCJoMTIwIiwiaDI0MCIsImg0ODAiLCJTY3JlZW5TaGFyZVByZXNldHMiLCJoMzYwZnBzMyIsImgzNjBmcHMxNSIsImg3MjBmcHM1IiwiaDcyMGZwczE1IiwiaDcyMGZwczMwIiwiaDEwODBmcHMxNSIsImgxMDgwZnBzMzAiLCJvcmlnaW5hbCIsIlNpZ25hbFRhcmdldCIsIlN0cmVhbVN0YXRlIiwiQ2FuZGlkYXRlUHJvdG9jb2wiLCJTaWduYWxSZXF1ZXN0IiwiU2Vzc2lvbkRlc2NyaXB0aW9uIiwiVHJpY2tsZVJlcXVlc3QiLCJBZGRUcmFja1JlcXVlc3QiLCJNdXRlVHJhY2tSZXF1ZXN0IiwiVXBkYXRlU3Vic2NyaXB0aW9uIiwiVXBkYXRlVHJhY2tTZXR0aW5ncyIsIkxlYXZlUmVxdWVzdCIsIlVwZGF0ZVZpZGVvTGF5ZXJzIiwiU3Vic2NyaXB0aW9uUGVybWlzc2lvbiIsIlN5bmNTdGF0ZSIsIlNpbXVsYXRlU2NlbmFyaW8iLCJVcGRhdGVQYXJ0aWNpcGFudE1ldGFkYXRhIiwiUGluZyIsIlNpZ25hbFJlc3BvbnNlIiwiSm9pblJlc3BvbnNlIiwiUGFydGljaXBhbnRVcGRhdGUiLCJUcmFja1B1Ymxpc2hlZFJlc3BvbnNlIiwiU3BlYWtlcnNDaGFuZ2VkIiwiUm9vbVVwZGF0ZSIsIkNvbm5lY3Rpb25RdWFsaXR5VXBkYXRlIiwiU3RyZWFtU3RhdGVVcGRhdGUiLCJTdWJzY3JpYmVkUXVhbGl0eVVwZGF0ZSIsIlN1YnNjcmlwdGlvblBlcm1pc3Npb25VcGRhdGUiLCJUcmFja1VucHVibGlzaGVkUmVzcG9uc2UiLCJSZWNvbm5lY3RSZXNwb25zZSIsIlBvbmciLCJTdWJzY3JpcHRpb25SZXNwb25zZSIsIlNpbXVsY2FzdENvZGVjIiwic2ltdWxjYXN0Q29kZWNzIiwiY2FuZGlkYXRlSW5pdCIsIlBVQkxJU0hFUiIsIm90aGVyUGFydGljaXBhbnRzIiwic2VydmVyVmVyc2lvbiIsInN1YnNjcmliZXJQcmltYXJ5IiwiYWx0ZXJuYXRpdmVVcmwiLCJzZXJ2ZXJSZWdpb24iLCJwaW5nVGltZW91dCIsInBpbmdJbnRlcnZhbCIsInNpZlRyYWlsZXIiLCJJQ0VTZXJ2ZXIiLCJ0cmFja1NpZCIsInBhcnRpY2lwYW50cyIsInN1YnNjcmliZSIsInBhcnRpY2lwYW50VHJhY2tzIiwiZGlzYWJsZWQiLCJmcHMiLCJjYW5SZWNvbm5lY3QiLCJVTktOT1dOX1JFQVNPTiIsImNyZWRlbnRpYWwiLCJDb25uZWN0aW9uUXVhbGl0eUluZm8iLCJQT09SIiwic2NvcmUiLCJ1cGRhdGVzIiwiU3RyZWFtU3RhdGVJbmZvIiwiQUNUSVZFIiwic3RyZWFtU3RhdGVzIiwiU3Vic2NyaWJlZFF1YWxpdHkiLCJTdWJzY3JpYmVkQ29kZWMiLCJxdWFsaXRpZXMiLCJzdWJzY3JpYmVkUXVhbGl0aWVzIiwic3Vic2NyaWJlZENvZGVjcyIsIlRyYWNrUGVybWlzc2lvbiIsImFsbFRyYWNrcyIsImFsbFBhcnRpY2lwYW50cyIsInRyYWNrUGVybWlzc2lvbnMiLCJhbGxvd2VkIiwicHVibGlzaFRyYWNrcyIsImRhdGFDaGFubmVscyIsIkRhdGFDaGFubmVsSW5mbyIsInNjZW5hcmlvIiwicnR0IiwibGFzdFBpbmdUaW1lc3RhbXAiLCJSZWdpb25TZXR0aW5ncyIsInJlZ2lvbnMiLCJSZWdpb25JbmZvIiwiZGlzdGFuY2UiLCJTRV9VTktOT1dOIiwiY2xvbmVEZWVwIiwic3RydWN0dXJlZENsb25lIiwiQkFDS0dST1VORF9SRUFDVElPTl9ERUxBWSIsInJlY3ljbGVkRWxlbWVudHMiLCJUcmFjayIsIm1lZGlhVHJhY2siLCJsb2dnZXJPcHRpb25zIiwiYXR0YWNoZWRFbGVtZW50cyIsImlzTXV0ZWQiLCJzdHJlYW1TdGF0ZSIsIkFjdGl2ZSIsImlzSW5CYWNrZ3JvdW5kIiwiX2N1cnJlbnRCaXRyYXRlIiwiYXBwVmlzaWJpbGl0eUNoYW5nZWRMaXN0ZW5lciIsImJhY2tncm91bmRUaW1lb3V0IiwidmlzaWJpbGl0eVN0YXRlIiwiaGFuZGxlQXBwVmlzaWJpbGl0eUNoYW5nZWQiLCJsb2dnZXJDb250ZXh0Q2IiLCJfbWVkaWFTdHJlYW1UcmFjayIsIl9tZWRpYVN0cmVhbUlEIiwiU291cmNlIiwiVW5rbm93biIsImxvZ0NvbnRleHQiLCJnZXRMb2dDb250ZXh0RnJvbVRyYWNrIiwiY3VycmVudEJpdHJhdGUiLCJtZWRpYVN0cmVhbVRyYWNrIiwibWVkaWFTdHJlYW1JRCIsImF0dGFjaCIsImVsZW1lbnQiLCJlbGVtZW50VHlwZSIsIktpbmQiLCJWaWRlbyIsImFkZEFwcFZpc2liaWxpdHlMaXN0ZW5lciIsInBhcmVudEVsZW1lbnQiLCJjcmVhdGVFbGVtZW50IiwiYXR0YWNoVG9FbGVtZW50IiwiYWxsTWVkaWFTdHJlYW1UcmFja3MiLCJzcmNPYmplY3QiLCJoYXNBdWRpbyIsInRyIiwicGxheSIsIkF1ZGlvUGxheWJhY2tTdGFydGVkIiwiVmlkZW9QbGF5YmFja1N0YXJ0ZWQiLCJBdWRpb1BsYXliYWNrRmFpbGVkIiwiVmlkZW9QbGF5YmFja0ZhaWxlZCIsIkVsZW1lbnRBdHRhY2hlZCIsImRldGFjaCIsImRldGFjaFRyYWNrIiwicmVjeWNsZUVsZW1lbnQiLCJFbGVtZW50RGV0YWNoZWQiLCJkZXRhY2hlZCIsImVsbSIsInJlbW92ZUFwcFZpc2liaWxpdHlMaXN0ZW5lciIsInN0b3BNb25pdG9yIiwiZW5hYmxlIiwiZGlzYWJsZSIsIm1vbml0b3JJbnRlcnZhbCIsInVwZGF0ZUxvZ2dlck9wdGlvbnMiLCJIVE1MQXVkaW9FbGVtZW50Iiwic2hvdWxkQ2FjaGUiLCJwYXVzZSIsImlzV2ViIiwibWVkaWFTdHJlYW0iLCJleGlzdGluZ1RyYWNrcyIsImV0IiwiaXNTYWZhcmkiLCJIVE1MVmlkZW9FbGVtZW50IiwiYXV0b3BsYXkiLCJwbGF5c0lubGluZSIsImlzRmlyZUZveCIsImtpbmRUb1Byb3RvIiwiQXVkaW8iLCJWSURFTyIsIkRBVEEiLCJraW5kRnJvbVByb3RvIiwic291cmNlVG9Qcm90byIsIkNhbWVyYSIsIkNBTUVSQSIsIk1pY3JvcGhvbmUiLCJNSUNST1BIT05FIiwiU2NyZWVuU2hhcmUiLCJTQ1JFRU5fU0hBUkUiLCJTY3JlZW5TaGFyZUF1ZGlvIiwiU0NSRUVOX1NIQVJFX0FVRElPIiwic291cmNlRnJvbVByb3RvIiwic3RyZWFtU3RhdGVGcm9tUHJvdG8iLCJQcm90b1N0cmVhbVN0YXRlIiwiUEFVU0VEIiwiUGF1c2VkIiwibWVyZ2VEZWZhdWx0T3B0aW9ucyIsImF1ZGlvRGVmYXVsdHMiLCJ2aWRlb0RlZmF1bHRzIiwibWVyZ2VPYmplY3RXaXRob3V0T3ZlcndyaXRpbmciLCJtYWluT2JqZWN0Iiwib2JqZWN0VG9NZXJnZSIsImNvbnN0cmFpbnRzRm9yT3B0aW9ucyIsInZpZGVvT3B0aW9ucyIsImRldGVjdFNpbGVuY2UiLCJ0aW1lT2Zmc2V0IiwiY3R4IiwiZ2V0TmV3QXVkaW9Db250ZXh0IiwiYW5hbHlzZXIiLCJjcmVhdGVBbmFseXNlciIsImZmdFNpemUiLCJidWZmZXJMZW5ndGgiLCJmcmVxdWVuY3lCaW5Db3VudCIsImRhdGFBcnJheSIsImNyZWF0ZU1lZGlhU3RyZWFtU291cmNlIiwiY29ubmVjdCIsInNsZWVwIiwiZ2V0Qnl0ZVRpbWVEb21haW5EYXRhIiwic29tZU5vaXNlIiwic2FtcGxlIiwiY2xvc2UiLCJsYXRlbmN5SGludCIsInNvdXJjZVRvS2luZCIsInNjcmVlbkNhcHR1cmVUb0Rpc3BsYXlNZWRpYVN0cmVhbU9wdGlvbnMiLCJ2aWRlb0NvbnN0cmFpbnRzIiwiY29udHJvbGxlciIsInNlbGZCcm93c2VyU3VyZmFjZSIsInN1cmZhY2VTd2l0Y2hpbmciLCJzeXN0ZW1BdWRpbyIsIm1pbWVUeXBlVG9WaWRlb0NvZGVjU3RyaW5nIiwiZ2V0VHJhY2tQdWJsaWNhdGlvbkluZm8iLCJpbmZvcyIsInRyYWNrSW5mbyIsInRyYWNrU291cmNlIiwidHJhY2tNdXRlZCIsInRyYWNrRW5hYmxlZCIsInRyYWNrS2luZCIsInRyYWNrTmFtZSIsImlzRW5hYmxlZCIsInRyYWNrRW5jcnlwdGVkIiwiaXNFbmNyeXB0ZWQiLCJ0cmFja01pbWVUeXBlIiwic2VwYXJhdG9yIiwiZGRFeHRlbnNpb25VUkkiLCJ1bnBhY2tTdHJlYW1JZCIsInN1cHBvcnRzVHJhbnNjZWl2ZXIiLCJzdXBwb3J0c0FkZFRyYWNrIiwic3VwcG9ydHNBZGFwdGl2ZVN0cmVhbSIsIlJlc2l6ZU9ic2VydmVyIiwiSW50ZXJzZWN0aW9uT2JzZXJ2ZXIiLCJzdXBwb3J0c0R5bmFjYXN0Iiwic3VwcG9ydHNBVjEiLCJjYXBhYmlsaXRpZXMiLCJnZXRDYXBhYmlsaXRpZXMiLCJoYXNBVjEiLCJzdXBwb3J0c1ZQOSIsImNvbXBhcmVWZXJzaW9ucyIsImhhc1ZQOSIsImlzU1ZDQ29kZWMiLCJzdXBwb3J0c1NldFNpbmtJZCIsInNldENvZGVjUHJlZmVyZW5jZXNWZXJzaW9ucyIsIkNocm9tZSIsIlNhZmFyaSIsIkZpcmVmb3giLCJzdXBwb3J0c1NldENvZGVjUHJlZmVyZW5jZXMiLCJpc0Jyb3dzZXJTdXBwb3J0ZWQiLCJpc0Nocm9taXVtQmFzZWQiLCJpc1NhZmFyaTE3IiwiaXNNb2JpbGUiLCJpc1JlYWN0TmF0aXZlIiwicHJvZHVjdCIsImlzQ2xvdWQiLCJzZXJ2ZXJVcmwiLCJob3N0bmFtZSIsImdldExLUmVhY3ROYXRpdmVJbmZvIiwiZ2xvYmFsIiwiTGl2ZUtpdFJlYWN0TmF0aXZlR2xvYmFsIiwiZ2V0UmVhY3ROYXRpdmVPcyIsInBsYXRmb3JtIiwiZ2V0RGV2aWNlUGl4ZWxSYXRpbyIsImRldmljZVBpeGVsUmF0aW8iLCJ2MSIsInYyIiwicGFydHMxIiwicGFydHMyIiwicDEiLCJwMiIsInJvRGlzcGF0Y2hDYWxsYmFjayIsImVudHJ5IiwiaGFuZGxlUmVzaXplIiwiaW9EaXNwYXRjaENhbGxiYWNrIiwiaGFuZGxlVmlzaWJpbGl0eUNoYW5nZWQiLCJyZXNpemVPYnNlcnZlciIsImdldFJlc2l6ZU9ic2VydmVyIiwiaW50ZXJzZWN0aW9uT2JzZXJ2ZXIiLCJnZXRJbnRlcnNlY3Rpb25PYnNlcnZlciIsInJvb3RNYXJnaW4iLCJnZXRDbGllbnRJbmZvIiwiSlMiLCJlbXB0eVZpZGVvU3RyZWFtVHJhY2siLCJnZXRFbXB0eVZpZGVvU3RyZWFtVHJhY2siLCJjcmVhdGVEdW1teVZpZGVvU3RyZWFtVHJhY2siLCJwYWludENvbnRlbnQiLCJjYW52YXMiLCJnZXRDb250ZXh0IiwiZmlsbFJlY3QiLCJiZWdpblBhdGgiLCJhcmMiLCJQSSIsImNsb3NlUGF0aCIsImZpbGxTdHlsZSIsImZpbGwiLCJkdW1teVN0cmVhbSIsImNhcHR1cmVTdHJlYW0iLCJkdW1teVRyYWNrIiwiZW1wdHlBdWRpb1N0cmVhbVRyYWNrIiwiZ2V0RW1wdHlBdWRpb1N0cmVhbVRyYWNrIiwib3NjaWxsYXRvciIsImNyZWF0ZU9zY2lsbGF0b3IiLCJnYWluIiwiY3JlYXRlR2FpbiIsInNldFZhbHVlQXRUaW1lIiwiZHN0IiwiY3JlYXRlTWVkaWFTdHJlYW1EZXN0aW5hdGlvbiIsIkZ1dHVyZSIsImZ1dHVyZUJhc2UiLCJvbkZpbmFsbHkiLCJfX2F3YWl0ZXIiLCJjcmVhdGVBdWRpb0FuYWx5c2VyIiwiY2xvbmVUcmFjayIsInNtb290aGluZ1RpbWVDb25zdGFudCIsIm1pbkRlY2liZWxzIiwibWF4RGVjaWJlbHMiLCJhdWRpb0NvbnRleHQiLCJzdHJlYW1UcmFjayIsIm1lZGlhU3RyZWFtU291cmNlIiwiY2FsY3VsYXRlVm9sdW1lIiwiZ2V0Qnl0ZUZyZXF1ZW5jeURhdGEiLCJzdW0iLCJhbXBsaXR1ZGUiLCJwb3ciLCJ2b2x1bWUiLCJzcXJ0IiwiY2xlYW51cCIsIk11dGV4IiwiX2xvY2tpbmciLCJfbG9ja3MiLCJpc0xvY2tlZCIsImxvY2siLCJ1bmxvY2tOZXh0Iiwid2lsbExvY2siLCJ3aWxsVW5sb2NrIiwiaXNWaWRlb0NvZGVjIiwibWF5YmVDb2RlYyIsInVud3JhcENvbnN0cmFpbnQiLCJ0b1dlYnNvY2tldFVybCIsInRvSHR0cFVybCIsImRlZmF1bHRJZCIsIkRldmljZU1hbmFnZXIiLCJnZXRJbnN0YW5jZSIsImluc3RhbmNlIiwiZ2V0RGV2aWNlcyIsInJlcXVlc3RQZXJtaXNzaW9ucyIsInVzZXJNZWRpYVByb21pc2VNYXAiLCJoYXNEZXZpY2VJblVzZSIsImlzRHVtbXlEZXZpY2VPckVtcHR5IiwiZGV2aWNlIiwibm9MYWJlbCIsImlzUmVsZXZhbnQiLCJwZXJtaXNzaW9uc1RvQWNxdWlyZSIsIm5vcm1hbGl6ZURldmljZUlkIiwiZ3JvdXBJZCIsIm1lZGlhRGV2aWNlS2luZHMiLCJkZWZhdWx0RGltZW5zaW9uc1RpbWVvdXQiLCJMb2NhbFRyYWNrIiwiX2NvbnN0cmFpbnRzIiwidXNlclByb3ZpZGVkVHJhY2siLCJfaXNVcHN0cmVhbVBhdXNlZCIsImhhbmRsZVRyYWNrTXV0ZUV2ZW50IiwiZGVib3VuY2VkVHJhY2tNdXRlSGFuZGxlciIsImRlYm91bmNlIiwicGF1c2VVcHN0cmVhbSIsImhhbmRsZVRyYWNrVW5tdXRlRXZlbnQiLCJyZXN1bWVVcHN0cmVhbSIsImhhbmRsZUVuZGVkIiwicmVhY3F1aXJlVHJhY2siLCJFbmRlZCIsInByb3ZpZGVkQnlVc2VyIiwibXV0ZUxvY2siLCJwYXVzZVVwc3RyZWFtTG9jayIsInByb2Nlc3NvckxvY2siLCJzZXRNZWRpYVN0cmVhbVRyYWNrIiwiZ2V0Q29uc3RyYWludHMiLCJkaW1lbnNpb25zIiwiaXNVcHN0cmVhbVBhdXNlZCIsImlzVXNlclByb3ZpZGVkIiwicHJvY2Vzc29yIiwicHJvY2Vzc2VkVHJhY2siLCJuZXdUcmFjayIsImVsIiwicHJvY2Vzc29yRWxlbWVudCIsInJlc3RhcnQiLCJyZXBsYWNlVHJhY2siLCJ3YWl0Rm9yRGltZW5zaW9ucyIsInRpbWVvdXQiLCJzdGFydGVkIiwiZGltcyIsImdldERldmljZUlkIiwibXV0ZSIsInNldFRyYWNrTXV0ZWQiLCJ1bm11dGUiLCJzdG9wUHJvY2Vzc29yIiwic3RyZWFtQ29uc3RyYWludHMiLCJSZXN0YXJ0ZWQiLCJNdXRlZCIsIlVubXV0ZWQiLCJuZWVkc1JlQWNxdWlzaXRpb24iLCJfc3VwZXIiLCJkZXN0cm95IiwidW5sb2NrIiwiVXBzdHJlYW1QYXVzZWQiLCJVcHN0cmVhbVJlc3VtZWQiLCJnZXRSVENTdGF0c1JlcG9ydCIsInN0YXRzUmVwb3J0Iiwic2V0UHJvY2Vzc29yIiwic2hvd1Byb2Nlc3NlZFN0cmVhbUxvY2FsbHkiLCJwcm9jZXNzb3JPcHRpb25zIiwiZ2V0UHJvY2Vzc29yIiwicmVtb3ZlIiwiRTJFRU1hbmFnZXIiLCJvbldvcmtlck1lc3NhZ2UiLCJldiIsIkVuY3J5cHRpb25FcnJvciIsImtleVByb3ZpZGVyIiwicG9zdEtleSIsImVuY3J5cHRpb25FbmFibGVkIiwicm9vbSIsImxvY2FsUGFydGljaXBhbnQiLCJQYXJ0aWNpcGFudEVuY3J5cHRpb25TdGF0dXNDaGFuZ2VkIiwicGFydGljaXBhbnQiLCJnZXRQYXJ0aWNpcGFudEJ5SWRlbnRpdHkiLCJvbldvcmtlckVycm9yIiwid29ya2VyIiwic2V0dXAiLCJzZXR1cEV2ZW50TGlzdGVuZXJzIiwia2V5UHJvdmlkZXJPcHRpb25zIiwib25tZXNzYWdlIiwib25lcnJvciIsInBvc3RNZXNzYWdlIiwic2V0UGFydGljaXBhbnRDcnlwdG9yRW5hYmxlZCIsInBvc3RFbmFibGUiLCJzZXRTaWZUcmFpbGVyIiwidHJhaWxlciIsInBvc3RTaWZUcmFpbGVyIiwic2V0dXBFbmdpbmUiLCJlbmdpbmUiLCJSVFBWaWRlb01hcFVwZGF0ZSIsInJ0cE1hcCIsInBvc3RSVFBNYXAiLCJUcmFja1B1Ymxpc2hlZCIsInB1YiIsIkNvbm5lY3Rpb25TdGF0ZUNoYW5nZWQiLCJDb25uZWN0aW9uU3RhdGUiLCJDb25uZWN0ZWQiLCJUcmFja1Vuc3Vic2NyaWJlZCIsIl8iLCJUcmFja1N1YnNjcmliZWQiLCJzZXR1cEUyRUVSZWNlaXZlciIsIlNpZ25hbENvbm5lY3RlZCIsImlzRTJFRUVuYWJsZWQiLCJMb2NhbFRyYWNrUHVibGlzaGVkIiwicHVibGljYXRpb24iLCJzZXR1cEUyRUVTZW5kZXIiLCJwYXJ0aWNpcGFudElkIiwicG9zdFJhdGNoZXRSZXF1ZXN0IiwiZW5hYmxlTXNnIiwiUmVmZXJlbmNlRXJyb3IiLCJyZW1vdGVJZCIsImhhbmRsZVJlY2VpdmVyIiwiaGFuZGxlU2VuZGVyIiwidHJhbnNmb3JtIiwid3JpdGFibGVTdHJlYW0iLCJyZWFkYWJsZSIsInJlYWRhYmxlU3RyZWFtIiwicmVjZWl2ZXJTdHJlYW1zIiwic2VuZGVyU3RyZWFtcyIsIlF1ZXVlVGFza1N0YXR1cyIsIkFzeW5jUXVldWUiLCJwZW5kaW5nVGFza3MiLCJ0YXNrTXV0ZXgiLCJuZXh0VGFza0luZGV4IiwicnVuIiwidGFzayIsInRhc2tJbmZvIiwiZW5xdWV1ZWRBdCIsIldBSVRJTkciLCJleGVjdXRlZEF0IiwiUlVOTklORyIsIkNPTVBMRVRFRCIsImZsdXNoIiwic25hcHNob3QiLCJwYXNzVGhyb3VnaFF1ZXVlU2lnbmFscyIsImNhblBhc3NUaHJvdWdoUXVldWUiLCJyZXEiLCJjYW5QYXNzIiwiU2lnbmFsQ29ubmVjdGlvblN0YXRlIiwiU2lnbmFsQ2xpZW50IiwiY3VycmVudFN0YXRlIiwiaXNEaXNjb25uZWN0ZWQiLCJESVNDT05ORUNUSU5HIiwiRElTQ09OTkVDVEVEIiwiaXNFc3RhYmxpc2hpbmdDb25uZWN0aW9uIiwiQ09OTkVDVElORyIsIlJFQ09OTkVDVElORyIsInVzZUpTT04iLCJyZXNldENhbGxiYWNrcyIsIm9uQW5zd2VyIiwib25MZWF2ZSIsIm9uTG9jYWxUcmFja1B1Ymxpc2hlZCIsIm9uTG9jYWxUcmFja1VucHVibGlzaGVkIiwib25OZWdvdGlhdGVSZXF1ZXN0ZWQiLCJvbk9mZmVyIiwib25SZW1vdGVNdXRlQ2hhbmdlZCIsIm9uU3Vic2NyaWJlZFF1YWxpdHlVcGRhdGUiLCJvblRva2VuUmVmcmVzaCIsIm9uVHJpY2tsZSIsIm9uQ2xvc2UiLCJTaWduYWwiLCJyZXF1ZXN0UXVldWUiLCJxdWV1ZWRSZXF1ZXN0cyIsImNsb3NpbmdMb2NrIiwiY29ubmVjdGlvbkxvY2siLCJ0b2tlbiIsImFib3J0U2lnbmFsIiwicmVzIiwicmVjb25uZWN0IiwiY2xlYXJQaW5nSW50ZXJ2YWwiLCJyZWNvbm5lY3RSZWFzb24iLCJjb25uZWN0T3B0aW9ucyIsImNsaWVudEluZm8iLCJjcmVhdGVDb25uZWN0aW9uUGFyYW1zIiwiYWJvcnRIYW5kbGVyIiwid3NUaW1lb3V0Iiwid2Vic29ja2V0VGltZW91dCIsImFib3J0ZWQiLCJ3cyIsIldlYlNvY2tldCIsImJpbmFyeVR5cGUiLCJvbm9wZW4iLCJDT05ORUNURUQiLCJyZXNwIiwiZmV0Y2giLCJ0b0ZpeGVkIiwidGV4dCIsImhhbmRsZVdTRXJyb3IiLCJzaG91bGRQcm9jZXNzTWVzc2FnZSIsInBpbmdUaW1lb3V0RHVyYXRpb24iLCJwaW5nSW50ZXJ2YWxEdXJhdGlvbiIsImludGVydmFsIiwic3RhcnRQaW5nSW50ZXJ2YWwiLCJzaWduYWxMYXRlbmN5IiwiaGFuZGxlU2lnbmFsUmVzcG9uc2UiLCJvbmNsb3NlIiwiaGFuZGxlT25DbG9zZSIsInVwZGF0ZVN0YXRlIiwiY2xvc2VQcm9taXNlIiwiQ0xPU0lORyIsInJhY2UiLCJzZW5kT2ZmZXIiLCJvZmZlciIsIm9mZmVyU2RwIiwic2VuZFJlcXVlc3QiLCJ0b1Byb3RvU2Vzc2lvbkRlc2NyaXB0aW9uIiwic2VuZEFuc3dlciIsImFuc3dlciIsImFuc3dlclNkcCIsInNlbmRJY2VDYW5kaWRhdGUiLCJzZW5kTXV0ZVRyYWNrIiwic2VuZEFkZFRyYWNrIiwic2VuZFVwZGF0ZUxvY2FsTWV0YWRhdGEiLCJzZW5kVXBkYXRlVHJhY2tTZXR0aW5ncyIsInNldHRpbmdzIiwic2VuZFVwZGF0ZVN1YnNjcmlwdGlvbiIsInN1YiIsInNlbmRTeW5jU3RhdGUiLCJzeW5jIiwic2VuZFVwZGF0ZVZpZGVvTGF5ZXJzIiwic2VuZFVwZGF0ZVN1YnNjcmlwdGlvblBlcm1pc3Npb25zIiwic2VuZFNpbXVsYXRlU2NlbmFyaW8iLCJzZW5kUGluZyIsInNlbmRMZWF2ZSIsIkNMSUVOVF9JTklUSUFURUQiLCJmcm9tUXVldWUiLCJjYW5RdWV1ZSIsIk9QRU4iLCJwaW5nSGFuZGxlZCIsInNkIiwiZnJvbVByb3RvU2Vzc2lvbkRlc2NyaXB0aW9uIiwib25QYXJ0aWNpcGFudFVwZGF0ZSIsIm9uU3BlYWtlcnNDaGFuZ2VkIiwib25Sb29tVXBkYXRlIiwib25Db25uZWN0aW9uUXVhbGl0eSIsIm9uU3RyZWFtU3RhdGVVcGRhdGUiLCJvblN1YnNjcmlwdGlvblBlcm1pc3Npb25VcGRhdGUiLCJvblN1YnNjcmlwdGlvbkVycm9yIiwicmVzZXRQaW5nVGltZW91dCIsIm1zZ0Nhc2UiLCJzZXRSZWNvbm5lY3RlZCIsIm9uQ2xvc2VDYWxsYmFjayIsImNsZWFyUGluZ1RpbWVvdXQiLCJ0b1VUQ1N0cmluZyIsInJzZCIsIlVSTFNlYXJjaFBhcmFtcyIsImF1dG9TdWJzY3JpYmUiLCJwdWJsaXNoT25seSIsImFkYXB0aXZlU3RyZWFtIiwiY29ubmVjdGlvbiIsImdyYW1tYXIiLCJncmFtbWFyTW9kdWxlIiwicmVnIiwicmF0ZSIsInN1YnR5cGUiLCJjb25maWciLCJzZXNzaW9uQ29uZmlnIiwic3RyIiwicmFkZHIiLCJ0Y3B0eXBlIiwiZ2VuZXJhdGlvbiIsImRpcjIiLCJjbGtzcmNFeHQiLCJtZWRpYUNsb2NrVmFsdWUiLCJyYXRlTnVtZXJhdG9yIiwicmF0ZURlbm9taW5hdG9yIiwib2JqcyIsInRvSW50SWZJbnQiLCJhdHRhY2hQcm9wZXJ0aWVzIiwicmF3TmFtZSIsInBhcnNlUmVnIiwiY29udGVudCIsIm5lZWRzQmxhbmsiLCJrZXlMb2NhdGlvbiIsInJlcXVpcmUkJDAiLCJ2YWxpZExpbmUiLCJzZXNzaW9uIiwicnRwIiwiZm10cCIsInBhcmFtUmVkdWNlciIsImFjYyIsInBhcnNlUGFyYW1zIiwicGFyc2VGbXRwQ29uZmlnIiwicGFyc2VQYXlsb2FkcyIsInBhcnNlUmVtb3RlQ2FuZGlkYXRlcyIsImNhbmRpZGF0ZXMiLCJwYXJzZUltYWdlQXR0cmlidXRlcyIsInBhcnNlU2ltdWxjYXN0U3RyZWFtTGlzdCIsInNjaWQiLCJwYXVzZWQiLCJmb3JtYXRSZWdFeHAiLCJmb3JtYXRTdHIiLCJ4IiwibWFrZUxpbmUiLCJkZWZhdWx0T3V0ZXJPcmRlciIsImRlZmF1bHRJbm5lck9yZGVyIiwicGF5bG9hZHMiLCJvdXRlck9yZGVyIiwiaW5uZXJPcmRlciIsInBhcnNlciIsInJlcXVpcmUkJDEiLCJ3cml0ZSIsInN0YXJ0Qml0cmF0ZUZvclNWQyIsIlBDRXZlbnRzIiwiTmVnb3RpYXRpb25TdGFydGVkIiwiTmVnb3RpYXRpb25Db21wbGV0ZSIsIlJUUFZpZGVvUGF5bG9hZFR5cGVzIiwiUENUcmFuc3BvcnQiLCJjcmVhdGVQQyIsIm1lZGlhQ29uc3RyYWludHMiLCJwZW5kaW5nQ2FuZGlkYXRlcyIsInJlc3RhcnRpbmdJY2UiLCJyZW5lZ290aWF0ZSIsInRyYWNrQml0cmF0ZXMiLCJyZW1vdGVTdGVyZW9NaWRzIiwicmVtb3RlTmFja01pZHMiLCJuZWdvdGlhdGUiLCJjcmVhdGVBbmRTZW5kT2ZmZXIiLCJvbmNvbm5lY3Rpb25zdGF0ZWNoYW5nZSIsIm9uaWNlY29ubmVjdGlvbnN0YXRlY2hhbmdlIiwib25pY2VnYXRoZXJpbmdzdGF0ZWNoYW5nZSIsIm9uZGF0YWNoYW5uZWwiLCJvbm5lZ290aWF0aW9ubmVlZGVkIiwib25zaWduYWxpbmdzdGF0ZWNoYW5nZSIsIm9uaWNlY2FuZGlkYXRlIiwib250cmFjayIsIm9uSWNlQ2FuZGlkYXRlIiwib25pY2VjYW5kaWRhdGVlcnJvciIsIm9uSWNlQ2FuZGlkYXRlRXJyb3IiLCJvbkljZUNvbm5lY3Rpb25TdGF0ZUNoYW5nZSIsIm9uU2lnbmFsaW5nU3RhdGVjaGFuZ2UiLCJvbkNvbm5lY3Rpb25TdGF0ZUNoYW5nZSIsIm9uRGF0YUNoYW5uZWwiLCJvblRyYWNrIiwiaXNJQ0VDb25uZWN0ZWQiLCJyZW1vdGVEZXNjcmlwdGlvbiIsIm11bmdlZFNEUCIsInN0ZXJlb01pZHMiLCJuYWNrTWlkcyIsImV4dHJhY3RTdGVyZW9BbmROYWNrQXVkaW9Gcm9tT2ZmZXIiLCJzZHBQYXJzZWQiLCJ0cmFja2JyIiwiY29kZWNQYXlsb2FkIiwiZm10cEZvdW5kIiwiYXR0ciIsIm1heGJyIiwic2V0TXVuZ2VkU0RQIiwiaWNlUmVzdGFydCIsImN1cnJlbnRTRCIsImVuc3VyZUF1ZGlvTmFja0FuZFN0ZXJlbyIsImVuc3VyZVZpZGVvRERFeHRlbnNpb25Gb3JTVkMiLCJtc2lkIiwicm91bmQiLCJjcmVhdGVBbmRTZXRBbnN3ZXIiLCJkYXRhQ2hhbm5lbERpY3QiLCJ0cmFuc2NlaXZlckluaXQiLCJzZXRUcmFja0NvZGVjQml0cmF0ZSIsInNldENvbmZpZ3VyYXRpb24iLCJydGNDb25maWciLCJjYW5SZW1vdmVUcmFjayIsImdldENvbm5lY3Rpb25TdGF0ZSIsImdldElDRUNvbm5lY3Rpb25TdGF0ZSIsImdldFNpZ25hbGxpbmdTdGF0ZSIsImdldExvY2FsRGVzY3JpcHRpb24iLCJsb2NhbERlc2NyaXB0aW9uIiwiZ2V0UmVtb3RlRGVzY3JpcHRpb24iLCJnZXRDb25uZWN0ZWRBZGRyZXNzIiwic2VsZWN0ZWRDYW5kaWRhdGVQYWlySWQiLCJjYW5kaWRhdGVQYWlycyIsInNlbGVjdGVkIiwic2VsZWN0ZWRJRCIsInJlbW90ZUNhbmRpZGF0ZUlkIiwibXVuZ2VkIiwicmVtb3RlIiwib3JpZ2luYWxTZHAiLCJyZW1vdGVTZHAiLCJvcHVzUGF5bG9hZCIsInJ0Y3BGYiIsIm1heElEIiwiZGRGb3VuZCIsImV4dCIsImRlZmF1bHRWaWRlb0NvZGVjIiwicHVibGlzaERlZmF1bHRzIiwiYXVkaW9CaXRyYXRlIiwiYXVkaW9QcmVzZXQiLCJkdHgiLCJyZWQiLCJmb3JjZVN0ZXJlbyIsInNjcmVlblNoYXJlRW5jb2RpbmciLCJzdG9wTWljVHJhY2tPbk11dGUiLCJ2aWRlb0NvZGVjIiwiYmFja3VwQ29kZWMiLCJhdXRvR2FpbkNvbnRyb2wiLCJlY2hvQ2FuY2VsbGF0aW9uIiwibm9pc2VTdXBwcmVzc2lvbiIsInJvb21PcHRpb25EZWZhdWx0cyIsImR5bmFjYXN0Iiwic3RvcExvY2FsVHJhY2tPblVucHVibGlzaCIsInJlY29ubmVjdFBvbGljeSIsImRpc2Nvbm5lY3RPblBhZ2VMZWF2ZSIsImV4cFdlYkF1ZGlvTWl4Iiwicm9vbUNvbm5lY3RPcHRpb25EZWZhdWx0cyIsIm1heFJldHJpZXMiLCJwZWVyQ29ubmVjdGlvblRpbWVvdXQiLCJQQ1RyYW5zcG9ydFN0YXRlIiwiUENUcmFuc3BvcnRNYW5hZ2VyIiwibmVlZHNQdWJsaXNoZXIiLCJpc1B1Ymxpc2hlckNvbm5lY3Rpb25SZXF1aXJlZCIsIm5lZWRzU3Vic2NyaWJlciIsImlzU3Vic2NyaWJlckNvbm5lY3Rpb25SZXF1aXJlZCIsInByZXZpb3VzU3RhdGUiLCJjb25uZWN0aW9uU3RhdGVzIiwicmVxdWlyZWRUcmFuc3BvcnRzIiwic3QiLCJGQUlMRUQiLCJDTE9TRUQiLCJORVciLCJvblN0YXRlQ2hhbmdlIiwicHVibGlzaGVyIiwic3Vic2NyaWJlciIsIlBDTWFuYWdlciIsImdvb2dDb25zdHJhaW50cyIsImdvb2dEc2NwIiwiU1VCU0NSSUJFUiIsIm9uUHVibGlzaGVyT2ZmZXIiLCJyZXF1aXJlUHVibGlzaGVyIiwicmVxdWlyZSIsInJlcXVpcmVTdWJzY3JpYmVyIiwiY3JlYXRlQW5kU2VuZFB1Ymxpc2hlck9mZmVyIiwic2V0UHVibGlzaGVyQW5zd2VyIiwidHJpZ2dlckljZVJlc3RhcnQiLCJjcmVhdGVTdWJzY3JpYmVyQW5zd2VyRnJvbU9mZmVyIiwiUlRDU2RwVHlwZSIsInVwZGF0ZUNvbmZpZ3VyYXRpb24iLCJlbnN1cmVQQ1RyYW5zcG9ydENvbm5lY3Rpb24iLCJhYm9ydENvbnRyb2xsZXIiLCJ0cmFuc3BvcnQiLCJlbnN1cmVUcmFuc3BvcnRDb25uZWN0ZWQiLCJuZWdvdGlhdGlvblRpbWVvdXQiLCJzaWduYWwiLCJhZGRQdWJsaXNoZXJUcmFuc2NlaXZlciIsImFkZFB1Ymxpc2hlclRyYWNrIiwiY3JlYXRlUHVibGlzaGVyRGF0YUNoYW5uZWwiLCJ0cmFuc3BvcnRzIiwicGNUcmFuc3BvcnQiLCJjb25uZWN0VGltZW91dCIsImxvc3N5RGF0YUNoYW5uZWwiLCJyZWxpYWJsZURhdGFDaGFubmVsIiwibWluUmVjb25uZWN0V2FpdCIsImxlYXZlUmVjb25uZWN0IiwiUENTdGF0ZSIsIlJUQ0VuZ2luZSIsImlzQ2xvc2VkIiwiX2lzQ2xvc2VkIiwiZnVsbFJlY29ubmVjdE9uTmV4dCIsInBjU3RhdGUiLCJOZXciLCJwZW5kaW5nVHJhY2tSZXNvbHZlcnMiLCJyZWNvbm5lY3RBdHRlbXB0cyIsInJlY29ubmVjdFN0YXJ0IiwiYXR0ZW1wdGluZ1JlY29ubmVjdCIsImpvaW5BdHRlbXB0cyIsIm1heEpvaW5BdHRlbXB0cyIsInNob3VsZEZhaWxOZXh0IiwiaGFuZGxlRGF0YUNoYW5uZWwiLCJyZWxpYWJsZURDU3ViIiwibG9zc3lEQ1N1YiIsImhhbmRsZURhdGFNZXNzYWdlIiwiZGF0YVByb2Nlc3NMb2NrIiwiQmxvYiIsImFycmF5QnVmZmVyIiwiZHAiLCJBY3RpdmVTcGVha2Vyc1VwZGF0ZSIsIkRhdGFQYWNrZXRSZWNlaXZlZCIsImhhbmRsZURhdGFFcnJvciIsImN1cnJlbnRUYXJnZXQiLCJjaGFubmVsS2luZCIsIm1heFJldHJhbnNtaXRzIiwiRXJyb3JFdmVudCIsImhhbmRsZUJ1ZmZlcmVkQW1vdW50TG93IiwiTE9TU1kiLCJ1cGRhdGVBbmRFbWl0RENCdWZmZXJTdGF0dXMiLCJoYW5kbGVEaXNjb25uZWN0IiwiZGlzY29ubmVjdFJlYXNvbiIsImRpc2Nvbm5lY3QiLCJEaXNjb25uZWN0ZWQiLCJkZWxheSIsImdldE5leHRSZXRyeURlbGF5IiwiZWxhcHNlZE1zIiwiY2xlYXJSZWNvbm5lY3RUaW1lb3V0IiwicmVnaW9uVXJsUHJvdmlkZXIiLCJ1cGRhdGVUb2tlbiIsInJlY29ubmVjdFRpbWVvdXQiLCJhdHRlbXB0UmVjb25uZWN0Iiwid2FpdEZvclJlc3RhcnRlZCIsIm9uUmVzdGFydGVkIiwib25EaXNjb25uZWN0ZWQiLCJpc0J1ZmZlclN0YXR1c0xvdyIsImRjQnVmZmVyU3RhdHVzIiwiRENCdWZmZXJTdGF0dXNDaGFuZ2VkIiwiZGF0YUNoYW5uZWxGb3JLaW5kIiwiYnVmZmVyZWRBbW91bnQiLCJidWZmZXJlZEFtb3VudExvd1RocmVzaG9sZCIsImhhbmRsZUJyb3dzZXJPbkxpbmUiLCJjbGllbnQiLCJSUl9TSUdOQUxfRElTQ09OTkVDVEVEIiwiRW5naW5lIiwiZXhwU2lnbmFsTGF0ZW5jeSIsInJlZ2lzdGVyT25MaW5lTGlzdGVuZXIiLCJ1cGRhdGUiLCJTdHJlYW1TdGF0ZUNoYW5nZWQiLCJsYXRlc3RKb2luUmVzcG9uc2UiLCJyb29tU2lkIiwiX2UiLCJfZiIsInNpZ25hbE9wdHMiLCJzZXR1cFNpZ25hbENsaWVudENhbGxiYWNrcyIsImpvaW5SZXNwb25zZSIsInBjTWFuYWdlciIsImNvbmZpZ3VyZSIsImNsaWVudENvbmZpZ3VyYXRpb24iLCJDbG9zaW5nIiwiZGVyZWdpc3Rlck9uTGluZUxpc3RlbmVyIiwiY2xlYXJQZW5kaW5nUmVjb25uZWN0IiwiY2xlYW51cFBlZXJDb25uZWN0aW9ucyIsImNsZWFudXBDbGllbnQiLCJkY0NsZWFudXAiLCJvbmJ1ZmZlcmVkYW1vdW50bG93Iiwib25jbG9zaW5nIiwibG9zc3lEQyIsInJlbGlhYmxlREMiLCJwdWJsaWNhdGlvblRpbWVvdXQiLCJ1cGRhdGVNdXRlU3RhdHVzIiwiZGF0YVN1YnNjcmliZXJSZWFkeVN0YXRlIiwiZ2V0Q29ubmVjdGVkU2VydmVyQWRkcmVzcyIsInNldFJlZ2lvblVybFByb3ZpZGVyIiwicHJvdmlkZXIiLCJtYWtlUlRDQ29uZmlndXJhdGlvbiIsIlRyYW5zcG9ydHNDcmVhdGVkIiwicHVibGlzaGVyU3RhdGUiLCJzdWJzY3JpYmVyU3RhdGUiLCJzaG91bGRFbWl0IiwiUlJfU1VCU0NSSUJFUl9GQUlMRUQiLCJSUl9QVUJMSVNIRVJfRkFJTEVEIiwiTWVkaWFUcmFja0FkZGVkIiwiY3JlYXRlRGF0YUNoYW5uZWxzIiwiTG9jYWxUcmFja1VucHVibGlzaGVkIiwiUmVtb3RlTXV0ZSIsImxlYXZlIiwic2VydmVyUmVzcG9uc2UiLCJlMmVlRW5hYmxlZCIsImVuY29kZWRJbnNlcnRhYmxlU3RyZWFtcyIsInJ0Y0ljZVNlcnZlcnMiLCJpY2VTZXJ2ZXIiLCJydGNJY2VTZXJ2ZXIiLCJFTkFCTEVEIiwiaWNlVHJhbnNwb3J0UG9saWN5IiwiY29udGludWFsR2F0aGVyaW5nUG9saWN5Iiwib3JkZXJlZCIsInNldFByZWZlcnJlZENvZGVjIiwiY2FwIiwibWF0Y2hlZCIsInBhcnRpYWxNYXRjaGVkIiwidW5tYXRjaGVkIiwibWF0Y2hlc1ZpZGVvQ29kZWMiLCJzZHBGbXRwTGluZSIsInNldENvZGVjUHJlZmVyZW5jZXMiLCJjcmVhdGVTZW5kZXIiLCJjcmVhdGVUcmFuc2NlaXZlclJUQ1J0cFNlbmRlciIsImNyZWF0ZVJUQ1J0cFNlbmRlciIsImNyZWF0ZVNpbXVsY2FzdFNlbmRlciIsInNpbXVsY2FzdFRyYWNrIiwiY3JlYXRlU2ltdWxjYXN0VHJhbnNjZWl2ZXJTZW5kZXIiLCJzZXRTaW11bGNhc3RUcmFja1NlbmRlciIsIkRJU0FCTEVEIiwicmVzdGFydENvbm5lY3Rpb24iLCJyZWNvdmVyYWJsZSIsIlNpZ25hbFJlY29ubmVjdEVycm9yIiwiUlJfVU5LTk9XTiIsInJlZ2lvblVybCIsIlJlc3RhcnRpbmciLCJTaWduYWxSZXN0YXJ0ZWQiLCJ3YWl0Rm9yUENSZWNvbm5lY3RlZCIsInJlc2V0QXR0ZW1wdHMiLCJuZXh0UmVnaW9uVXJsIiwiZ2V0TmV4dEJlc3RSZWdpb25VcmwiLCJSZXN1bWluZyIsIlNpZ25hbFJlc3VtZWQiLCJSZXN1bWVkIiwid2FpdEZvclBDSW5pdGlhbENvbm5lY3Rpb24iLCJSZWNvbm5lY3RpbmciLCJzZW5kRGF0YVBhY2tldCIsInBhY2tldCIsImVuc3VyZVB1Ymxpc2hlckNvbm5lY3RlZCIsImVuc3VyZURhdGFUcmFuc3BvcnRDb25uZWN0ZWQiLCJ0cmFuc3BvcnROYW1lIiwidGFyZ2V0Q2hhbm5lbCIsImVuZFRpbWUiLCJ2ZXJpZnlUcmFuc3BvcnQiLCJBYm9ydENvbnRyb2xsZXIiLCJoYW5kbGVDbG9zZWQiLCJhYm9ydCIsInJ0cFR5cGVzIiwicmVtb3RlVHJhY2tzIiwibG9jYWxUcmFja3MiLCJwcmV2aW91c0Fuc3dlciIsInByZXZpb3VzT2ZmZXIiLCJpc0Rlc2lyZWQiLCJzdWJzY3JpcHRpb24iLCJkYXRhQ2hhbm5lbHNJbmZvIiwiZmFpbE5leHQiLCJnZXRJbmZvIiwiUmVnaW9uVXJsUHJvdmlkZXIiLCJsYXN0VXBkYXRlQXQiLCJzZXR0aW5nc0NhY2hlVGltZSIsImF0dGVtcHRlZFJlZ2lvbnMiLCJVUkwiLCJnZXRTZXJ2ZXJVcmwiLCJyZWdpb25TZXR0aW5ncyIsImZldGNoUmVnaW9uU2V0dGluZ3MiLCJyZWdpb25zTGVmdCIsImF0dGVtcHRlZCIsIm5leHRSZWdpb24iLCJyZWdpb25TZXR0aW5nc1Jlc3BvbnNlIiwiZ2V0Q2xvdWRDb25maWdVcmwiLCJoZWFkZXJzIiwiYXV0aG9yaXphdGlvbiIsInN0YXR1c1RleHQiLCJob3N0IiwibW9uaXRvckZyZXF1ZW5jeSIsImNvbXB1dGVCaXRyYXRlIiwiY3VycmVudFN0YXRzIiwicHJldlN0YXRzIiwiYnl0ZXNOb3ciLCJieXRlc1ByZXYiLCJieXRlc1JlY2VpdmVkIiwiYnl0ZXNTZW50IiwiTG9jYWxBdWRpb1RyYWNrIiwic3RvcE9uTXV0ZSIsIm1vbml0b3JTZW5kZXIiLCJnZXRTZW5kZXJTdGF0cyIsImNoZWNrRm9yU2lsZW5jZSIsInNldERldmljZUlkIiwicmVzdGFydFRyYWNrIiwiZGV2aWNlSGFzQ2hhbmdlZCIsInN0YXJ0TW9uaXRvciIsInNldEF1ZGlvQ29udGV4dCIsImF1ZGlvU3RhdHMiLCJwYWNrZXRzU2VudCIsInJvdW5kVHJpcFRpbWUiLCJqaXR0ZXIiLCJ0cmFja0lzU2lsZW50IiwiQXVkaW9TaWxlbmNlRGV0ZWN0ZWQiLCJtZWRpYVRyYWNrVG9Mb2NhbFRyYWNrIiwiTG9jYWxWaWRlb1RyYWNrIiwicHJlc2V0czE2OSIsInByZXNldHM0MyIsInByZXNldHNTY3JlZW5TaGFyZSIsImRlZmF1bHRTaW11bGNhc3RQcmVzZXRzMTY5IiwiZGVmYXVsdFNpbXVsY2FzdFByZXNldHM0MyIsImNvbXB1dGVEZWZhdWx0U2NyZWVuU2hhcmVTaW11bGNhc3RQcmVzZXRzIiwiZnJvbVByZXNldCIsInZpZGVvUmlkcyIsImNvbXB1dGVWaWRlb0VuY29kaW5ncyIsImlzU2NyZWVuU2hhcmUiLCJ2aWRlb0VuY29kaW5nIiwidXNlU2ltdWxjYXN0Iiwic2NhbGFiaWxpdHlNb2RlIiwiZGV0ZXJtaW5lQXBwcm9wcmlhdGVFbmNvZGluZyIsInNtIiwiU2NhbGFiaWxpdHlNb2RlIiwic3BhdGlhbCIsInByZXNldHMiLCJzb3J0UHJlc2V0cyIsInNjcmVlblNoYXJlU2ltdWxjYXN0TGF5ZXJzIiwiZGVmYXVsdFNpbXVsY2FzdExheWVycyIsInZpZGVvU2ltdWxjYXN0TGF5ZXJzIiwibWlkUHJlc2V0IiwibG93UHJlc2V0IiwiZW5jb2RpbmdzRnJvbVByZXNldHMiLCJjb21wdXRlVHJhY2tCYWNrdXBFbmNvZGluZ3MiLCJzZXJ2ZXJSZXF1ZXN0ZWQiLCJwcmVzZXRzRm9yUmVzb2x1dGlvbiIsInByZXNldCIsImFzcGVjdCIsImFicyIsImNhblNldFByaW9yaXR5IiwibmV0d29ya1ByaW9yaXR5IiwidG9wRnJhbWVyYXRlIiwibm90aWZ5T25jZSIsImFFbmMiLCJiRW5jIiwicmVzdWx0cyIsInRlbXBvcmFsIiwic3VmZml4IiwicmVmcmVzaFN1YnNjcmliZWRDb2RlY0FmdGVyTmV3Q29kZWMiLCJzdGF0c01hcCIsInRvdGFsQml0cmF0ZSIsInNlbmRlckxvY2siLCJpc1NpbXVsY2FzdCIsInNpZ25hbENsaWVudCIsIl9fYXN5bmNWYWx1ZXMiLCJfZyIsIm5leHQiLCJkb25lIiwic2MiLCJpdGVtcyIsInZzIiwiZnJhbWVIZWlnaHQiLCJmcmFtZVdpZHRoIiwiZmlyQ291bnQiLCJwbGlDb3VudCIsIm5hY2tDb3VudCIsImZyYW1lc1NlbnQiLCJyZXRyYW5zbWl0dGVkUGFja2V0c1NlbnQiLCJxdWFsaXR5TGltaXRhdGlvblJlYXNvbiIsInF1YWxpdHlMaW1pdGF0aW9uUmVzb2x1dGlvbkNoYW5nZXMiLCJzZXRQdWJsaXNoaW5nUXVhbGl0eSIsIm1heFF1YWxpdHkiLCJxIiwiSElHSCIsInNldFB1Ymxpc2hpbmdMYXllcnMiLCJfaCIsImFkZFNpbXVsY2FzdFRyYWNrIiwic2ltdWxjYXN0Q29kZWNJbmZvIiwic2V0UHVibGlzaGluZ0NvZGVjcyIsImN1cnJlbnRDb2RlYyIsIm5ld0NvZGVjcyIsImNvZGVjc18xIiwiY29kZWNzXzFfMSIsInNldFB1Ymxpc2hpbmdMYXllcnNGb3JTZW5kZXIiLCJzZW5kZXJFbmNvZGluZ3MiLCJoYXNDaGFuZ2VkIiwiY2xvc2FibGVTcGF0aWFsIiwidmlkZW9RdWFsaXR5Rm9yUmlkIiwic3Vic2NyaWJlZFF1YWxpdHkiLCJNRURJVU0iLCJ2aWRlb0xheWVyc0Zyb21FbmNvZGluZ3MiLCJzdmMiLCJlbmNvZGluZ1NNIiwic2NhbGUiLCJSZW1vdGVUcmFjayIsInNldE11dGVkIiwic2V0TWVkaWFTdHJlYW0iLCJvblJlbW92ZVRyYWNrIiwibW9uaXRvclJlY2VpdmVyIiwiUmVtb3RlQXVkaW9UcmFjayIsImF1ZGlvT3V0cHV0IiwiZ2V0UmVjZWl2ZXJTdGF0cyIsIndlYkF1ZGlvUGx1Z2luTm9kZXMiLCJzaW5rSWQiLCJzZXRWb2x1bWUiLCJnYWluTm9kZSIsInNldFRhcmdldEF0VGltZSIsIl9zZXRWb2x1bWUiLCJlbGVtZW50Vm9sdW1lIiwiZ2V0Vm9sdW1lIiwiaGlnaGVzdFZvbHVtZSIsInNldFNpbmtJZCIsIm5lZWRzTmV3V2ViQXVkaW9Db25uZWN0aW9uIiwiY29ubmVjdFdlYkF1ZGlvIiwiZGlzY29ubmVjdFdlYkF1ZGlvIiwic2V0V2ViQXVkaW9QbHVnaW5zIiwibm9kZXMiLCJzb3VyY2VOb2RlIiwibGFzdE5vZGUiLCJub2RlIiwiZGVzdGluYXRpb24iLCJyZXN1bWUiLCJyZWNlaXZlclN0YXRzIiwiY29uY2VhbGVkU2FtcGxlcyIsImNvbmNlYWxtZW50RXZlbnRzIiwic2lsZW50Q29uY2VhbGVkU2FtcGxlcyIsInNpbGVudENvbmNlYWxtZW50RXZlbnRzIiwidG90YWxBdWRpb0VuZXJneSIsInRvdGFsU2FtcGxlc0R1cmF0aW9uIiwiUkVBQ1RJT05fREVMQVkiLCJSZW1vdGVWaWRlb1RyYWNrIiwiYWRhcHRpdmVTdHJlYW1TZXR0aW5ncyIsImVsZW1lbnRJbmZvcyIsImRlYm91bmNlZEhhbmRsZVJlc2l6ZSIsInVwZGF0ZURpbWVuc2lvbnMiLCJpc0FkYXB0aXZlU3RyZWFtIiwiZWxlbWVudEluZm8iLCJIVE1MRWxlbWVudEluZm8iLCJvYnNlcnZlRWxlbWVudEluZm8iLCJ1cGRhdGVWaXNpYmlsaXR5Iiwib2JzZXJ2ZSIsInN0b3BPYnNlcnZpbmdFbGVtZW50SW5mbyIsInN0b3BFbGVtZW50SW5mb3MiLCJzdG9wT2JzZXJ2aW5nIiwiZGV0YWNoZWRFbGVtZW50cyIsInN0b3BPYnNlcnZpbmdFbGVtZW50IiwiZ2V0RGVjb2RlckltcGxlbWVudGF0aW9uIiwiZGVjb2RlckltcGxlbWVudGF0aW9uIiwiY29kZWNJRCIsImNvZGVjSWQiLCJmcmFtZXNEZWNvZGVkIiwiZnJhbWVzRHJvcHBlZCIsImZyYW1lc1JlY2VpdmVkIiwicGFja2V0c1JlY2VpdmVkIiwibGFzdFZpc2liaWxpdHlDaGFuZ2UiLCJ2aXNpYmlsaXR5Q2hhbmdlZEF0IiwiYmFja2dyb3VuZFBhdXNlIiwicGF1c2VWaWRlb0luQmFja2dyb3VuZCIsImlzUGlQTW9kZSIsInBpY3R1cmVJblBpY3R1cmUiLCJpc1Zpc2libGUiLCJ2aXNpYmxlIiwibGFzdFZpc2libGUiLCJWaXNpYmlsaXR5Q2hhbmdlZCIsInBpeGVsRGVuc2l0eSIsImdldFBpeGVsRGVuc2l0eSIsImN1cnJlbnRFbGVtZW50V2lkdGgiLCJjdXJyZW50RWxlbWVudEhlaWdodCIsImxhc3REaW1lbnNpb25zIiwiVmlkZW9EaW1lbnNpb25zQ2hhbmdlZCIsImlzUGlQIiwiaXNJbnRlcnNlY3RpbmciLCJvblZpc2liaWxpdHlDaGFuZ2VkIiwib25FbnRlclBpUCIsIm9uTGVhdmVQaVAiLCJpc0VsZW1lbnRJblZpZXdwb3J0IiwicGljdHVyZUluUGljdHVyZUVsZW1lbnQiLCJjbGllbnRXaWR0aCIsImNsaWVudEhlaWdodCIsInVub2JzZXJ2ZSIsInRvcCIsIm9mZnNldFRvcCIsImxlZnQiLCJvZmZzZXRMZWZ0Iiwib2Zmc2V0V2lkdGgiLCJvZmZzZXRIZWlnaHQiLCJvcGFjaXR5IiwiZGlzcGxheSIsImdldENvbXB1dGVkU3R5bGUiLCJvZmZzZXRQYXJlbnQiLCJwYWdlWU9mZnNldCIsImlubmVySGVpZ2h0IiwicGFnZVhPZmZzZXQiLCJpbm5lcldpZHRoIiwiVHJhY2tQdWJsaWNhdGlvbiIsIm1ldGFkYXRhTXV0ZWQiLCJoYW5kbGVNdXRlZCIsImhhbmRsZVVubXV0ZWQiLCJQdWJsaWNhdGlvbiIsInNldFRyYWNrIiwiaXNTdWJzY3JpYmVkIiwiYXVkaW9UcmFjayIsInZpZGVvVHJhY2siLCJ1cGRhdGVJbmZvIiwic2ltdWxjYXN0ZWQiLCJTdWJzY3JpcHRpb25TdGF0dXMiLCJQZXJtaXNzaW9uU3RhdHVzIiwiTG9jYWxUcmFja1B1YmxpY2F0aW9uIiwidGkiLCJoYW5kbGVUcmFja0VuZGVkIiwicXVhbGl0eUZyb21Qcm90byIsIlByb3RvUXVhbGl0eSIsIkVYQ0VMTEVOVCIsIkV4Y2VsbGVudCIsIkdPT0QiLCJHb29kIiwiUG9vciIsIkxPU1QiLCJMb3N0IiwiUGFydGljaXBhbnQiLCJpc0FnZW50IiwicGVybWlzc2lvbnMiLCJhdWRpb0xldmVsIiwiaXNTcGVha2luZyIsIl9jb25uZWN0aW9uUXVhbGl0eSIsImF1ZGlvVHJhY2tzIiwidmlkZW9UcmFja3MiLCJnZXRUcmFjayIsImdldFRyYWNrQnlOYW1lIiwiY29ubmVjdGlvblF1YWxpdHkiLCJpc0NhbWVyYUVuYWJsZWQiLCJpc01pY3JvcGhvbmVFbmFibGVkIiwiaXNTY3JlZW5TaGFyZUVuYWJsZWQiLCJwYXJ0aWNpcGFudEluZm8iLCJfc2V0TmFtZSIsIl9zZXRNZXRhZGF0YSIsInBlcm1pc3Npb24iLCJzZXRQZXJtaXNzaW9ucyIsIm1kIiwiY2hhbmdlZCIsInByZXZNZXRhZGF0YSIsIlBhcnRpY2lwYW50TWV0YWRhdGFDaGFuZ2VkIiwiUGFydGljaXBhbnROYW1lQ2hhbmdlZCIsInByZXZQZXJtaXNzaW9ucyIsIlBhcnRpY2lwYW50UGVybWlzc2lvbnNDaGFuZ2VkIiwic2V0SXNTcGVha2luZyIsInNwZWFraW5nIiwibGFzdFNwb2tlQXQiLCJJc1NwZWFraW5nQ2hhbmdlZCIsInNldENvbm5lY3Rpb25RdWFsaXR5IiwicHJldlF1YWxpdHkiLCJDb25uZWN0aW9uUXVhbGl0eUNoYW5nZWQiLCJhZGRUcmFja1B1YmxpY2F0aW9uIiwiVHJhY2tNdXRlZCIsIlRyYWNrVW5tdXRlZCIsInRyYWNrUGVybWlzc2lvblRvUHJvdG8iLCJwZXJtcyIsImFsbG93QWxsIiwiYWxsb3dlZFRyYWNrU2lkcyIsIlJlbW90ZVRyYWNrUHVibGljYXRpb24iLCJjdXJyZW50VmlkZW9RdWFsaXR5IiwiaGFuZGxlVmlzaWJpbGl0eUNoYW5nZSIsImVtaXRUcmFja1VwZGF0ZSIsImhhbmRsZVZpZGVvRGltZW5zaW9uc0NoYW5nZSIsInZpZGVvRGltZW5zaW9ucyIsInN1YnNjcmliZWQiLCJzZXRTdWJzY3JpYmVkIiwicHJldlN0YXR1cyIsInN1YnNjcmlwdGlvblN0YXR1cyIsInByZXZQZXJtaXNzaW9uIiwicGVybWlzc2lvblN0YXR1cyIsImVtaXRTdWJzY3JpcHRpb25VcGRhdGVJZkNoYW5nZWQiLCJlbWl0UGVybWlzc2lvblVwZGF0ZUlmQ2hhbmdlZCIsIlVuc3Vic2NyaWJlZCIsIkRlc2lyZWQiLCJTdWJzY3JpYmVkIiwiQWxsb3dlZCIsIk5vdEFsbG93ZWQiLCJzZXRFbmFibGVkIiwiaXNNYW51YWxPcGVyYXRpb25BbGxvd2VkIiwic2V0VmlkZW9RdWFsaXR5Iiwic2V0VmlkZW9EaW1lbnNpb25zIiwic2V0VmlkZW9GUFMiLCJ2aWRlb1F1YWxpdHkiLCJwcmV2VHJhY2siLCJzZXRBbGxvd2VkIiwic2V0U3Vic2NyaXB0aW9uRXJyb3IiLCJTdWJzY3JpcHRpb25GYWlsZWQiLCJwcmV2TWV0YWRhdGFNdXRlZCIsInByZXZpb3VzU3RhdHVzIiwiY3VycmVudFN0YXR1cyIsIlN1YnNjcmlwdGlvblN0YXR1c0NoYW5nZWQiLCJwcmV2aW91c1Blcm1pc3Npb25TdGF0dXMiLCJjdXJyZW50UGVybWlzc2lvblN0YXR1cyIsIlN1YnNjcmlwdGlvblBlcm1pc3Npb25DaGFuZ2VkIiwiVXBkYXRlU2V0dGluZ3MiLCJSZW1vdGVQYXJ0aWNpcGFudCIsImZyb21QYXJ0aWNpcGFudEluZm8iLCJwaSIsInZvbHVtZU1hcCIsIlRyYWNrU3Vic2NyaXB0aW9uUGVybWlzc2lvbkNoYW5nZWQiLCJUcmFja1N1YnNjcmlwdGlvblN0YXR1c0NoYW5nZWQiLCJwcmV2aW91c1RyYWNrIiwiVHJhY2tTdWJzY3JpcHRpb25GYWlsZWQiLCJhdWRpb1B1YmxpY2F0aW9uIiwiYWRkU3Vic2NyaWJlZE1lZGlhVHJhY2siLCJ0cmllc0xlZnQiLCJnZXRUcmFja1B1YmxpY2F0aW9uIiwiaXNWaWRlbyIsImhhc01ldGFkYXRhIiwidmFsaWRUcmFja3MiLCJuZXdUcmFja3MiLCJleGlzdGluZ1RyYWNrT2ZTb3VyY2UiLCJwdWJsaXNoZWRUcmFjayIsIm9sZFRyYWNrIiwidW5wdWJsaXNoVHJhY2siLCJzZW5kVW5wdWJsaXNoIiwiVHJhY2tVbnB1Ymxpc2hlZCIsInNldEF1ZGlvT3V0cHV0IiwicHJvbWlzZXMiLCJMb2NhbFBhcnRpY2lwYW50IiwicGVuZGluZ1B1Ymxpc2hpbmciLCJwZW5kaW5nUHVibGlzaFByb21pc2VzIiwicGFydGljaXBhbnRUcmFja1Blcm1pc3Npb25zIiwiYWxsUGFydGljaXBhbnRzQWxsb3dlZFRvU3Vic2NyaWJlIiwiZW5jcnlwdGlvblR5cGUiLCJoYW5kbGVSZWNvbm5lY3RpbmciLCJyZWNvbm5lY3RGdXR1cmUiLCJoYW5kbGVSZWNvbm5lY3RlZCIsInVwZGF0ZVRyYWNrU3Vic2NyaXB0aW9uUGVybWlzc2lvbnMiLCJoYW5kbGVEaXNjb25uZWN0ZWQiLCJhbGxQYXJ0aWNpcGFudHNBbGxvd2VkIiwib25UcmFja1VubXV0ZWQiLCJvblRyYWNrTXV0ZWQiLCJvblRyYWNrVXBzdHJlYW1QYXVzZWQiLCJvblRyYWNrVXBzdHJlYW1SZXN1bWVkIiwiaGFuZGxlU3Vic2NyaWJlZFF1YWxpdHlVcGRhdGUiLCJyb29tT3B0aW9ucyIsIm5ld0NvZGVjc18xIiwibmV3Q29kZWNzXzFfMSIsInB1Ymxpc2hBZGRpdGlvbmFsQ29kZWNGb3JUcmFjayIsImhhbmRsZUxvY2FsVHJhY2tVbnB1Ymxpc2hlZCIsInVucHVibGlzaGVkIiwiY3VycmVudFBlcm1pc3Npb25zIiwicXVlcnkiLCJvbmNoYW5nZSIsImFjdGl2ZURldmljZU1hcCIsImxhc3RDYW1lcmFFcnJvciIsImNhbWVyYUVycm9yIiwibGFzdE1pY3JvcGhvbmVFcnJvciIsIm1pY3JvcGhvbmVFcnJvciIsInNldE1ldGFkYXRhIiwic2V0TmFtZSIsInNldENhbWVyYUVuYWJsZWQiLCJwdWJsaXNoT3B0aW9ucyIsInNldFRyYWNrRW5hYmxlZCIsInNldE1pY3JvcGhvbmVFbmFibGVkIiwic2V0U2NyZWVuU2hhcmVFbmFibGVkIiwic2V0RTJFRUVuYWJsZWQiLCJHQ00iLCJyZXB1Ymxpc2hBbGxUcmFja3MiLCJhZGQiLCJjcmVhdGVUcmFja3MiLCJjcmVhdGVTY3JlZW5UcmFja3MiLCJwdWJsaXNoUHJvbWlzZXMiLCJsb2NhbFRyYWNrIiwicHVibGlzaFRyYWNrIiwicHVibGlzaGVkVHJhY2tzIiwiTWVkaWFEZXZpY2VzRXJyb3IiLCJzY3JlZW5BdWRpb1RyYWNrIiwiZW5hYmxlQ2FtZXJhQW5kTWljcm9waG9uZSIsImF1ZGlvQ2FwdHVyZURlZmF1bHRzIiwidmlkZW9DYXB0dXJlRGVmYXVsdHMiLCJBdWRpb1N0cmVhbUFjcXVpcmVkIiwiaXNBdWRpbyIsInRyYWNrQ29uc3RyYWludHMiLCJjb25PckJvb2wiLCJzY3JlZW5WaWRlbyIsImNvbnRlbnRIaW50Iiwic2NyZWVuQXVkaW8iLCJkZWZhdWx0Q29uc3RyYWludHMiLCJkZXZpY2VLaW5kIiwiZXhpc3RpbmdQdWJsaWNhdGlvbiIsImlzU3RlcmVvSW5wdXQiLCJjaGFubmVsQ291bnQiLCJpc1N0ZXJlbyIsImUyZWUiLCJwdWJsaXNoUHJvbWlzZSIsImRlZmF1bHRSZXMiLCJfaiIsIl9rIiwiX2wiLCJwcmltYXJ5Q29kZWNNaW1lIiwidXBkYXRlZENvZGVjIiwidHJhY2tUcmFuc2NlaXZlciIsIl9tIiwiX28iLCJzdG9wT25VbnB1Ymxpc2giLCJnZXRQdWJsaWNhdGlvbkZvclRyYWNrIiwicHViTG9nQ29udGV4dCIsIm5lZ290aWF0aW9uTmVlZGVkIiwidHJhY2tTZW5kZXIiLCJjbGVhciIsInVucHVibGlzaFRyYWNrcyIsInJlc3RhcnRUcmFja3MiLCJsb2NhbFB1YnMiLCJwdWJsaXNoRGF0YSIsInRvcGljIiwic2V0VHJhY2tTdWJzY3JpcHRpb25QZXJtaXNzaW9ucyIsIm11dGVkT25TZXJ2ZXIiLCJjb25uZWN0aW9uUmVjb25jaWxlRnJlcXVlbmN5IiwiUm9vbVN0YXRlIiwiX3RoaXMiLCJhY3RpdmVTcGVha2VycyIsImF1ZGlvRW5hYmxlZCIsImlzVmlkZW9QbGF5YmFja0Jsb2NrZWQiLCJidWZmZXJlZEV2ZW50cyIsInVubG9ja0Rpc2Nvbm5lY3QiLCJkaXNjb25uZWN0TG9jayIsImNvbm5lY3RGdXR1cmUiLCJzZXRBbmRFbWl0Q29ubmVjdGlvblN0YXRlIiwiQ29ubmVjdGluZyIsImNvbm5lY3RGbiIsImF0dGVtcHRDb25uZWN0aW9uIiwibmV4dFVybCIsImNsZWFyQ29ubmVjdGlvbkZ1dHVyZXMiLCJjb25uZWN0U2lnbmFsIiwiZTJlZU1hbmFnZXIiLCJzZXJ2ZXJJbmZvIiwiYXBwbHlKb2luUmVzcG9uc2UiLCJoYW5kbGVQYXJ0aWNpcGFudFVwZGF0ZXMiLCJoYW5kbGVSb29tVXBkYXRlIiwicmVjcmVhdGVFbmdpbmUiLCJtYXliZUNyZWF0ZUVuZ2luZSIsImFjcXVpcmVBdWRpb0NvbnRleHQiLCJjb25uT3B0aW9ucyIsInNldHVwTG9jYWxQYXJ0aWNpcGFudEV2ZW50cyIsInJlc3VsdGluZ0Vycm9yIiwib25QYWdlTGVhdmUiLCJoYW5kbGVEZXZpY2VDaGFuZ2UiLCJyZWdpc3RlckNvbm5lY3Rpb25SZWNvbmNpbGUiLCJzdG9wVHJhY2tzIiwic3RhcnRBdWRpbyIsImVsZW1lbnRzIiwiYXVkaW9JZCIsImR1bW15QXVkaW9FbCIsImdldEVsZW1lbnRCeUlkIiwiYm9keSIsImFwcGVuZCIsImhhbmRsZUF1ZGlvUGxheWJhY2tTdGFydGVkIiwiaGFuZGxlQXVkaW9QbGF5YmFja0ZhaWxlZCIsInN0YXJ0VmlkZW8iLCJoYW5kbGVWaWRlb1BsYXliYWNrU3RhcnRlZCIsImhhbmRsZVZpZGVvUGxheWJhY2tGYWlsZWQiLCJoYW5kbGVSZXN0YXJ0aW5nIiwiY2xlYXJDb25uZWN0aW9uUmVjb25jaWxlIiwiaGFuZGxlUGFydGljaXBhbnREaXNjb25uZWN0ZWQiLCJoYW5kbGVTaWduYWxSZXN0YXJ0ZWQiLCJfcCIsIlJlY29ubmVjdGVkIiwiZW1pdEJ1ZmZlcmVkRXZlbnRzIiwicGFydGljaXBhbnRJbmZvcyIsImlkZW50aXR5VG9TaWQiLCJyZW1vdGVQYXJ0aWNpcGFudCIsImlzTmV3UGFydGljaXBhbnQiLCJnZXRPckNyZWF0ZVBhcnRpY2lwYW50IiwiaGFuZGxlQWN0aXZlU3BlYWtlcnNVcGRhdGUiLCJzZWVuU2lkcyIsInNwZWFrZXIiLCJlbWl0V2hlbkNvbm5lY3RlZCIsIkFjdGl2ZVNwZWFrZXJzQ2hhbmdlZCIsImhhbmRsZVNwZWFrZXJzQ2hhbmdlZCIsInNwZWFrZXJVcGRhdGVzIiwibGFzdFNwZWFrZXJzIiwiaGFuZGxlU3RyZWFtU3RhdGVVcGRhdGUiLCJzdHJlYW1TdGF0ZVVwZGF0ZSIsIlRyYWNrU3RyZWFtU3RhdGVDaGFuZ2VkIiwiaGFuZGxlU3Vic2NyaXB0aW9uUGVybWlzc2lvblVwZGF0ZSIsImhhbmRsZVN1YnNjcmlwdGlvbkVycm9yIiwiaGFuZGxlRGF0YVBhY2tldCIsInVzZXJQYWNrZXQiLCJEYXRhUmVjZWl2ZWQiLCJjYW5QbGF5YmFja0F1ZGlvIiwiQXVkaW9QbGF5YmFja1N0YXR1c0NoYW5nZWQiLCJWaWRlb1BsYXliYWNrU3RhdHVzQ2hhbmdlZCIsIk1lZGlhRGV2aWNlc0NoYW5nZWQiLCJvbGRSb29tIiwicm9vbUluZm8iLCJSb29tTWV0YWRhdGFDaGFuZ2VkIiwiUmVjb3JkaW5nU3RhdHVzQ2hhbmdlZCIsImhhbmRsZUNvbm5lY3Rpb25RdWFsaXR5VXBkYXRlIiwib25Mb2NhbFBhcnRpY2lwYW50TWV0YWRhdGFDaGFuZ2VkIiwib25Mb2NhbFBhcnRpY2lwYW50TmFtZUNoYW5nZWQiLCJvbkxvY2FsVHJhY2tNdXRlZCIsIm9uTG9jYWxUcmFja1VubXV0ZWQiLCJMb2NhbEF1ZGlvU2lsZW5jZURldGVjdGVkIiwiX3EiLCJBY3RpdmVEZXZpY2VDaGFuZ2VkIiwib25Mb2NhbENvbm5lY3Rpb25RdWFsaXR5Q2hhbmdlZCIsIm9uTWVkaWFEZXZpY2VzRXJyb3IiLCJvbkxvY2FsUGFydGljaXBhbnRQZXJtaXNzaW9uc0NoYW5nZWQiLCJzd2l0Y2hBY3RpdmVEZXZpY2UiLCJzZXR1cEUyRUUiLCJpc1JlY29yZGluZyIsIm9uVHJhY2tBZGRlZCIsInVwZGF0ZVN1YnNjcmlwdGlvbnMiLCJnZXRMb2NhbERldmljZXMiLCJwcmVwYXJlQ29ubmVjdGlvbiIsInNpbXVsYXRlU2NlbmFyaW8iLCJwb3N0QWN0aW9uIiwiY2FuUGxheWJhY2tWaWRlbyIsImdldEFjdGl2ZUF1ZGlvT3V0cHV0RGV2aWNlIiwiZ2V0QWN0aXZlRGV2aWNlIiwic3VjY2VzcyIsImRldmljZUNvbnN0cmFpbnQiLCJwcmV2RGV2aWNlSWQiLCJyZWNvbm5lY3RlZEhhbmRsZXIiLCJzaG91bGRTdG9wVHJhY2tzIiwiUGFydGljaXBhbnREaXNjb25uZWN0ZWQiLCJuZXdDb250ZXh0SXNSdW5uaW5nIiwiY3JlYXRlUGFydGljaXBhbnQiLCJQYXJ0aWNpcGFudENvbm5lY3RlZCIsInRyYWNrUHVibGljYXRpb24iLCJjb25zZWN1dGl2ZUZhaWx1cmVzIiwiY29ubmVjdGlvblJlY29uY2lsZUludGVydmFsIiwibnVtRmFpbHVyZXMiLCJjbG9zZWQiLCJ0cmFuc3BvcnRzQ29ubmVjdGVkIiwiU1RBVEVfTUlTTUFUQ0giLCJzaW11bGF0ZVBhcnRpY2lwYW50cyIsInVzZVJlYWxUcmFja3MiLCJwYXJ0aWNpcGFudE9wdGlvbnMiLCJhc3BlY3RSYXRpb3MiLCJSb29tTW9kZWwiLCJjYW1QdWIiLCJhdWRpb1B1YiIsImR1bW15VmlkZW8iLCJfbGVuMiIsIl9rZXkyIiwibWluaW1pemVkQXJncyIsIm1hcEFyZ3MiLCJDaGVja1N0YXR1cyIsIkNoZWNrZXIiLCJJRExFIiwibG9ncyIsImVycm9yc0FzV2FybmluZ3MiLCJvbkNvbXBsZXRlIiwic2V0U3RhdHVzIiwicGVyZm9ybSIsImFwcGVuZFdhcm5pbmciLCJhcHBlbmRFcnJvciIsIlNLSVBQRUQiLCJpc1N1Y2Nlc3MiLCJTVUNDRVNTIiwiYXBwZW5kTWVzc2FnZSIsImNyZWF0ZUxvY2FsVHJhY2tzIiwibWVkaWFQcm9taXNlIiwiY3JlYXRlTG9jYWxWaWRlb1RyYWNrIiwiY3JlYXRlTG9jYWxBdWRpb1RyYWNrIiwiY3JlYXRlTG9jYWxTY3JlZW5UcmFja3MiLCJQdWJsaXNoQXVkaW9DaGVjayIsIm51bVBhY2tldHMiLCJtZWRpYVR5cGUiLCJQdWJsaXNoVmlkZW9DaGVjayIsIlJlY29ubmVjdENoZWNrIiwicmVjb25uZWN0aW5nVHJpZ2dlcmVkIiwicmVjb25uZWN0ZWQiLCJyZWNvbm5lY3RSZXNvbHZlciIsIlRVUk5DaGVjayIsImpvaW5SZXMiLCJoYXNUTFMiLCJoYXNUVVJOIiwiaGFzU1RVTiIsIldlYlJUQ0NoZWNrIiwiaGFzVGNwIiwiaGFzSXB2NFVkcCIsInByZXZUcmlja2xlIiwiaXNJUFByaXZhdGUiLCJSVENQZWVyQ29ubmVjdGlvbkljZUVycm9yRXZlbnQiLCJlcnJvckNvZGUiLCJlcnJvclRleHQiLCJzZWNvbmQiLCJXZWJTb2NrZXRDaGVjayIsIkNsb3VkIiwiQ29ubmVjdGlvbkNoZWNrIiwiY2hlY2tSZXN1bHRzIiwiZ2V0TmV4dENoZWNrSWQiLCJuZXh0SWQiLCJ1cGRhdGVDaGVjayIsImNoZWNrSWQiLCJnZXRSZXN1bHRzIiwiY3JlYXRlQW5kUnVuQ2hlY2siLCJjaGVjayIsImhhbmRsZVVwZGF0ZSIsImNoZWNrV2Vic29ja2V0IiwiY2hlY2tXZWJSVEMiLCJjaGVja1RVUk4iLCJjaGVja1JlY29ubmVjdCIsImNoZWNrUHVibGlzaEF1ZGlvIiwiY2hlY2tQdWJsaXNoVmlkZW8iLCJmYWNpbmdNb2RlRnJvbUxvY2FsVHJhY2siLCJ0cmFja1NldHRpbmdzIiwiZGVmYXVsdEZhY2luZ01vZGUiLCJjb25maWRlbmNlIiwicmF3RmFjaW5nTW9kZSIsImlzRmFjaW5nTW9kZVZhbHVlIiwibGFiZWxBbmFseXNpc1Jlc3VsdCIsImZhY2luZ01vZGVGcm9tRGV2aWNlTGFiZWwiLCJrbm93bkRldmljZUxhYmVscyIsImtub3duRGV2aWNlTGFiZWxTZWN0aW9ucyIsImRldmljZUxhYmVsIiwic2VjdGlvbiIsImFsbG93ZWRWYWx1ZXMiXSwiaWdub3JlTGlzdCI6WzAsMiwzLDQsNSw2LDcsOCw5LDEwLDExLDEyLDEzLDE0LDE1LDE2LDE3LDE4LDE5LDIwLDIxLDIyLDIzLDI2LDI3LDI4LDI5LDMwLDMxLDMyLDMzLDM0LDM1LDM2LDM3LDM4LDQ1LDYwLDYxLDYyLDYzXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/livekit-client/dist/livekit-client.esm.mjs\n");

/***/ })

};
;